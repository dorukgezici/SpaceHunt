/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 76);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/*! excalibur - v0.14.0 - 2017-12-02
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2017 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>; Licensed BSD-2-Clause
* @preserve */
(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function (b) {
            return (root.ex = factory(b));
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals
        root.ex = factory();
    }
}(this, function () {
    //almond, and your modules will be inlined here
/**
 * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/almond/LICENSE
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name) {
            name = name.split('/');
            lastIndex = name.length - 1;

            // If wanting node ID compatibility, strip .js from end
            // of IDs. Have to do this here, and not in nameToUrl
            // because node allows either .js or non .js to map
            // to same file.
            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
            }

            // Starts with a '.' so need the baseName
            if (name[0].charAt(0) === '.' && baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that 'directory' and not name of the baseName's
                //module. For instance, baseName of 'one/two/three', maps to
                //'one/two/three.js', but we want the directory, 'one/two' for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
            }

            //start trimDots
            for (i = 0; i < name.length; i++) {
                part = name[i];
                if (part === '.') {
                    name.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        name.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
            //end trimDots

            name = name.join('/');
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    //Creates a parts array for a relName where first part is plugin ID,
    //second part is resource ID. Assumes relName has already been normalized.
    function makeRelParts(relName) {
        return relName ? splitPrefix(relName) : [];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relParts) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0],
            relResourceName = relParts[1];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relResourceName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relResourceName));
            } else {
                name = normalize(name, relResourceName);
            }
        } else {
            name = normalize(name, relResourceName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i, relParts,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;
        relParts = makeRelParts(relName);

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relParts);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, makeRelParts(callback)).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
/*! excalibur - v0.14.0 - 2017-12-02
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2017 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>; Licensed BSD-2-Clause
* @preserve */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("Actions/RotationType", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that describes the strategies that rotation actions can use
     */
    var RotationType;
    (function (RotationType) {
        /**
         * Rotation via `ShortestPath` will use the smallest angle
         * between the starting and ending points. This strategy is the default behavior.
         */
        RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";
        /**
         * Rotation via `LongestPath` will use the largest angle
         * between the starting and ending points.
         */
        RotationType[RotationType["LongestPath"] = 1] = "LongestPath";
        /**
         * Rotation via `Clockwise` will travel in a clockwise direction,
         * regardless of the starting and ending points.
         */
        RotationType[RotationType["Clockwise"] = 2] = "Clockwise";
        /**
         * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
         * regardless of the starting and ending points.
         */
        RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";
    })(RotationType = exports.RotationType || (exports.RotationType = {}));
});
define("Algebra", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A 2D vector on a plane.
     */
    var Vector = (function () {
        /**
         * @param x  X component of the Vector
         * @param y  Y component of the Vector
         */
        function Vector(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * Returns a vector of unit length in the direction of the specified angle in Radians.
         * @param angle The angle to generate the vector
         */
        Vector.fromAngle = function (angle) {
            return new Vector(Math.cos(angle), Math.sin(angle));
        };
        /**
         * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
         */
        Vector.isValid = function (vec) {
            if (vec === null || vec === undefined) {
                return false;
            }
            if (isNaN(vec.x) || isNaN(vec.y)) {
                return false;
            }
            if (vec.x === Infinity ||
                vec.y === Infinity ||
                vec.x === -Infinity ||
                vec.y === Infinity) {
                return false;
            }
            return true;
        };
        /**
         * Calculates distance between two Vectors
         * @param vec1
         * @param vec2
         */
        Vector.distance = function (vec1, vec2) {
            return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
        };
        /**
         * Sets the x and y components at once
         */
        Vector.prototype.setTo = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Compares this point against another and tests for equality
         * @param point  The other point to compare to
         */
        Vector.prototype.equals = function (vector, tolerance) {
            if (tolerance === void 0) { tolerance = .001; }
            return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
        };
        /**
         * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
         * @param v  The other vector. Leave blank to use origin vector.
         */
        Vector.prototype.distance = function (v) {
            if (!v) {
                v = Vector.Zero;
            }
            return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
        };
        /**
         * The magnitude (size) of the Vector
         */
        Vector.prototype.magnitude = function () {
            return this.distance();
        };
        /**
         * Normalizes a vector to have a magnitude of 1.
         */
        Vector.prototype.normalize = function () {
            var d = this.distance();
            if (d > 0) {
                return new Vector(this.x / d, this.y / d);
            }
            else {
                return new Vector(0, 1);
            }
        };
        /**
         * Returns the average (midpoint) between the current point and the specified
         */
        Vector.prototype.average = function (vec) {
            return this.add(vec).scale(.5);
        };
        /**
         * Scales a vector's by a factor of size
         * @param size  The factor to scale the magnitude by
         */
        Vector.prototype.scale = function (size) {
            return new Vector(this.x * size, this.y * size);
        };
        /**
         * Adds one vector to another
         * @param v The vector to add
         */
        Vector.prototype.add = function (v) {
            return new Vector(this.x + v.x, this.y + v.y);
        };
        /**
         * Subtracts a vector from another, if you subract vector `B.sub(A)` the resulting vector points from A -> B
         * @param v The vector to subtract
         */
        Vector.prototype.sub = function (v) {
            return new Vector(this.x - v.x, this.y - v.y);
        };
        /**
         * Adds one vector to this one modifying the original
         * @param v The vector to add
         */
        Vector.prototype.addEqual = function (v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        };
        /**
         * Subtracts a vector from this one modifying the original
         * @parallel v The vector to subtract
         */
        Vector.prototype.subEqual = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        };
        /**
         * Scales this vector by a factor of size and modifies the original
         */
        Vector.prototype.scaleEqual = function (size) {
            this.x *= size;
            this.y *= size;
            return this;
        };
        /**
         * Performs a dot product with another vector
         * @param v  The vector to dot
         */
        Vector.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };
        Vector.prototype.cross = function (v) {
            if (v instanceof Vector) {
                return this.x * v.y - this.y * v.x;
            }
            else if (typeof v === 'number') {
                return new Vector(v * this.y, -v * this.x);
            }
        };
        /**
         * Returns the perpendicular vector to this one
         */
        Vector.prototype.perpendicular = function () {
            return new Vector(this.y, -this.x);
        };
        /**
         * Returns the normal vector to this one, same as the perpendicular of length 1
         */
        Vector.prototype.normal = function () {
            return this.perpendicular().normalize();
        };
        /**
         * Negate the current vector
         */
        Vector.prototype.negate = function () {
            return this.scale(-1);
        };
        /**
         * Returns the angle of this vector.
         */
        Vector.prototype.toAngle = function () {
            return Math.atan2(this.y, this.x);
        };
        /**
         * Rotates the current vector around a point by a certain number of
         * degrees in radians
         */
        Vector.prototype.rotate = function (angle, anchor) {
            if (!anchor) {
                anchor = new Vector(0, 0);
            }
            var sinAngle = Math.sin(angle);
            var cosAngle = Math.cos(angle);
            var x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
            var y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
            return new Vector(x, y);
        };
        /**
         * Creates new vector that has the same values as the previous.
         */
        Vector.prototype.clone = function () {
            return new Vector(this.x, this.y);
        };
        /**
         * Returns a string repesentation of the vector.
         */
        Vector.prototype.toString = function () {
            return "(" + this.x + ", " + this.y + ")";
        };
        return Vector;
    }());
    /**
     * A (0, 0) vector
     */
    Vector.Zero = new Vector(0, 0);
    /**
     * A (1, 1) vector
     */
    Vector.One = new Vector(1, 1);
    /**
     * A (0.5, 0.5) vector
     */
    Vector.Half = new Vector(0.5, 0.5);
    /**
     * A unit vector pointing up (0, -1)
     */
    Vector.Up = new Vector(0, -1);
    /**
     * A unit vector pointing down (0, 1)
     */
    Vector.Down = new Vector(0, 1);
    /**
     * A unit vector pointing left (-1, 0)
     */
    Vector.Left = new Vector(-1, 0);
    /**
     * A unit vector pointing right (1, 0)
     */
    Vector.Right = new Vector(1, 0);
    exports.Vector = Vector;
    /**
     * A 2D ray that can be cast into the scene to do collision detection
     */
    var Ray = (function () {
        /**
         * @param pos The starting position for the ray
         * @param dir The vector indicating the direction of the ray
         */
        function Ray(pos, dir) {
            this.pos = pos;
            this.dir = dir.normalize();
        }
        /**
         * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
         * This number indicates the mathematical intersection time.
         * @param line  The line to test
         */
        Ray.prototype.intersect = function (line) {
            var numerator = line.begin.sub(this.pos);
            // Test is line and ray are parallel and non intersecting
            if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
                return -1;
            }
            // Lines are parallel
            var divisor = (this.dir.cross(line.getSlope()));
            if (divisor === 0) {
                return -1;
            }
            var t = numerator.cross(line.getSlope()) / divisor;
            if (t >= 0) {
                var u = (numerator.cross(this.dir) / divisor) / line.getLength();
                if (u >= 0 && u <= 1) {
                    return t;
                }
            }
            return -1;
        };
        /**
         * Returns the point of intersection given the intersection time
         */
        Ray.prototype.getPoint = function (time) {
            return this.pos.add(this.dir.scale(time));
        };
        return Ray;
    }());
    exports.Ray = Ray;
    /**
     * A 2D line segment
     */
    var Line = (function () {
        /**
         * @param begin  The starting point of the line segment
         * @param end  The ending point of the line segment
         */
        function Line(begin, end) {
            this.begin = begin;
            this.end = end;
        }
        Object.defineProperty(Line.prototype, "slope", {
            /**
             * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
             */
            get: function () {
                return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Line.prototype, "intercept", {
            /**
             * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
             */
            get: function () {
                return this.begin.y - (this.slope * this.begin.x);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the normal of the line
         */
        Line.prototype.normal = function () {
            return this.end.sub(this.begin).normal();
        };
        /**
         * Returns the slope of the line in the form of a vector
         */
        Line.prototype.getSlope = function () {
            var begin = this.begin;
            var end = this.end;
            var distance = begin.distance(end);
            return end.sub(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         */
        Line.prototype.getLength = function () {
            var begin = this.begin;
            var end = this.end;
            var distance = begin.distance(end);
            return distance;
        };
        /**
         * Find the perpendicular distance from the line to a point
         * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
         * @param point
         */
        Line.prototype.distanceToPoint = function (point) {
            var x0 = point.x;
            var y0 = point.y;
            var l = this.getLength();
            var dy = this.end.y - this.begin.y;
            var dx = this.end.x - this.begin.x;
            var distance = Math.abs(dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
            return distance;
        };
        /**
         * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
         * a new point with the calculated Y value and vice-versa.
         *
         * @param x The known X value of the target point
         * @param y The known Y value of the target point
         * @returns A new point with the other calculated axis value
         */
        Line.prototype.findPoint = function (x, y) {
            if (x === void 0) { x = null; }
            if (y === void 0) { y = null; }
            var m = this.slope;
            var b = this.intercept;
            if (x !== null) {
                return new Vector(x, (m * x) + b);
            }
            else if (y !== null) {
                return new Vector((y - b) / m, y);
            }
            else {
                throw new Error('You must provide an X or a Y value');
            }
        };
        /**
         * @see http://stackoverflow.com/a/11908158/109458
         */
        Line.prototype.hasPoint = function () {
            var currPoint;
            var threshold = 0;
            if (typeof arguments[0] === 'number' &&
                typeof arguments[1] === 'number') {
                currPoint = new Vector(arguments[0], arguments[1]);
                threshold = arguments[2] || 0;
            }
            else if (arguments[0] instanceof Vector) {
                currPoint = arguments[0];
                threshold = arguments[1] || 0;
            }
            else {
                throw 'Could not determine the arguments for Vector.hasPoint';
            }
            var dxc = currPoint.x - this.begin.x;
            var dyc = currPoint.y - this.begin.y;
            var dx1 = this.end.x - this.begin.x;
            var dy1 = this.end.y - this.begin.y;
            var cross = dxc * dy1 - dyc * dx1;
            // check whether point lines on the line
            if (Math.abs(cross) > threshold) {
                return false;
            }
            // check whether point lies in-between start and end
            if (Math.abs(dx1) >= Math.abs(dy1)) {
                return dx1 > 0
                    ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x
                    : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
            }
            else {
                return dy1 > 0
                    ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y
                    : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
            }
        };
        return Line;
    }());
    exports.Line = Line;
    /**
     * A 1 dimensional projection on an axis, used to test overlaps
     */
    var Projection = (function () {
        function Projection(min, max) {
            this.min = min;
            this.max = max;
        }
        Projection.prototype.overlaps = function (projection) {
            return this.max > projection.min && projection.max > this.min;
        };
        Projection.prototype.getOverlap = function (projection) {
            if (this.overlaps(projection)) {
                if (this.max > projection.max) {
                    return projection.max - this.min;
                }
                else {
                    return this.max - projection.min;
                }
            }
            return 0;
        };
        return Projection;
    }());
    exports.Projection = Projection;
});
define("Physics", ["require", "exports", "Algebra"], function (require, exports, Algebra_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Possible collision resolution strategies
     *
     * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.
     *
     * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated
     * simulated physical interactions.
     */
    var CollisionResolutionStrategy;
    (function (CollisionResolutionStrategy) {
        CollisionResolutionStrategy[CollisionResolutionStrategy["Box"] = 0] = "Box";
        CollisionResolutionStrategy[CollisionResolutionStrategy["RigidBody"] = 1] = "RigidBody";
    })(CollisionResolutionStrategy = exports.CollisionResolutionStrategy || (exports.CollisionResolutionStrategy = {}));
    /**
     * Possible broadphase collision pair identification strategies
     *
     * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
     * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy
     * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.
     */
    var BroadphaseStrategy;
    (function (BroadphaseStrategy) {
        BroadphaseStrategy[BroadphaseStrategy["Naive"] = 0] = "Naive";
        BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 1] = "DynamicAABBTree";
    })(BroadphaseStrategy = exports.BroadphaseStrategy || (exports.BroadphaseStrategy = {}));
    /**
     * Possible numerical integrators for position and velocity
     */
    var Integrator;
    (function (Integrator) {
        Integrator[Integrator["Euler"] = 0] = "Euler";
    })(Integrator = exports.Integrator || (exports.Integrator = {}));
    /**
     * The [[Physics]] object is the global configuration object for all Excalibur physics.
     *
     * [[include:Physics.md]]
     */
    /* istanbul ignore next */
    var Physics = (function () {
        function Physics() {
        }
        /**
         * Configures Excalibur to use box physics. Box physics which performs simple axis aligned arcade style physics.
         */
        Physics.useBoxPhysics = function () {
            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;
        };
        /**
         * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
         * simulated physical interactions.
         */
        Physics.useRigidBodyPhysics = function () {
            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.RigidBody;
        };
        return Physics;
    }());
    /**
     * Global acceleration that is applied to all vanilla actors (it wont effect [[Label|labels]], [[UIActor|ui actors]], or
     * [[Trigger|triggers]] in Excalibur that have an [[CollisionType.Active|active]] collision type).
     *
     *
     * This is a great way to globally simulate effects like gravity.
     */
    Physics.acc = new Algebra_1.Vector(0, 0);
    /**
     * Globally switches all Excalibur physics behavior on or off.
     */
    Physics.enabled = true;
    /**
     * Gets or sets the number of collision passes for Excalibur to perform on physics bodies.
     *
     * Reducing collision passes may cause things not to collide as expected in your game, but may increase performance.
     *
     * More passes can improve the visual quality of collisions when many objects are on the screen. This can reduce jitter, improve the
     * collision resolution of fast move objects, or the stability of large numbers of objects stacked together.
     *
     * Fewer passes will improve the performance of the game at the cost of collision quality, more passes will improve quality at the
     * cost of performance.
     *
     * The default is set to 5 passes which is a good start.
     */
    Physics.collisionPasses = 5;
    /**
     * Gets or sets the broadphase pair identification strategy.
     *
     * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
     * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy
     * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.
     */
    Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
    /**
     * Globally switches the debug information for the broadphase strategy
     */
    Physics.broadphaseDebug = false;
    /**
     * Show the normals as a result of collision on the screen.
     */
    Physics.showCollisionNormals = false;
    /**
     * Show the position, velocity, and acceleration as graphical vectors.
     */
    Physics.showMotionVectors = false;
    /**
     * Show the axis-aligned bounding boxes of the collision bodies on the screen.
     */
    Physics.showBounds = false;
    /**
     * Show the bounding collision area shapes
     */
    Physics.showArea = false;
    /**
     * Show points of collision interpreted by excalibur as a result of collision.
     */
    Physics.showContacts = false;
    /**
     * Show the surface normals of the collision areas.
     */
    Physics.showNormals = false;
    /**
     * Gets or sets the global collision resolution strategy (narrowphase).
     *
     * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.
     *
     * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated
     * simulated physical interactions.
     */
    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;
    /**
     * The default mass to use if none is specified
     */
    Physics.defaultMass = 10;
    /**
     * Gets or sets the position and velocity positional integrator, currently only Euler is supported.
     */
    Physics.integrator = Integrator.Euler;
    /**
     * Number of steps to use in integration. A higher number improves the positional accuracy over time. This can be useful to increase
     * if you have fast moving objects in your simulation or you have a large number of objects and need to increase stability.
     */
    Physics.integrationSteps = 1;
    /**
     * Gets or sets whether rotation is allowed in a RigidBody collision resolution
     */
    Physics.allowRigidBodyRotation = true;
    /**
     * Small value to help collision passes settle themselves after the narrowphase.
     */
    Physics.collisionShift = .001;
    /**
     * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplyer);
     */
    Physics.dynamicTreeVelocityMultiplyer = 2;
    /**
     * Pad RigidBody BoundingBox by a constant amount
     */
    Physics.boundsPadding = 5;
    /**
     * Surface epsilon is used to help deal with surface penatration
     */
    Physics.surfaceEpsilon = .1;
    /**
     * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent
     * bodies from tunneling through one another.
     */
    Physics.checkForFastBodies = true;
    /**
     * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the
     * body is moving at least half of its minimum diminension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,
     * Excalibur will always perform the fast body raycast regardless of speed.
     */
    Physics.disableMinimumSpeedForFastBody = false;
    exports.Physics = Physics;
});
define("Util/EasingFunctions", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
     * Given a time, the function will return a value from positive startValue to positive endValue.
     *
     * ```js
     * function Linear (t) {
     *    return t * t;
     * }
     *
     * // accelerating from zero velocity
     * function EaseInQuad (t) {
     *    return t * t;
     * }
     *
     * // decelerating to zero velocity
     * function EaseOutQuad (t) {
     *    return t * (2 - t);
     * }
     *
     * // acceleration until halfway, then deceleration
     * function EaseInOutQuad (t) {
     *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
     * }
     *
     * // accelerating from zero velocity
     * function EaseInCubic (t) {
     *    return t * t * t;
     * }
     *
     * // decelerating to zero velocity
     * function EaseOutCubic (t) {
     *    return (--t) * t * t + 1;
     * }
     *
     * // acceleration until halfway, then deceleration
     * function EaseInOutCubic (t) {
     *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
     * }
     * ```
     */
    var EasingFunctions = (function () {
        function EasingFunctions() {
        }
        return EasingFunctions;
    }());
    EasingFunctions.Linear = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        return endValue * currentTime / duration + startValue;
    };
    EasingFunctions.EaseInQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return endValue * currentTime * currentTime + startValue;
    };
    EasingFunctions.EaseOutQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return -endValue * currentTime * (currentTime - 2) + startValue;
    };
    EasingFunctions.EaseInOutQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration / 2;
        if (currentTime < 1) {
            return endValue / 2 * currentTime * currentTime + startValue;
        }
        currentTime--;
        return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    };
    EasingFunctions.EaseInCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return endValue * currentTime * currentTime * currentTime + startValue;
    };
    EasingFunctions.EaseOutCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        currentTime--;
        return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
    };
    EasingFunctions.EaseInOutCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration / 2;
        if (currentTime < 1) {
            return endValue / 2 * currentTime * currentTime * currentTime + startValue;
        }
        currentTime -= 2;
        return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
    };
    exports.EasingFunctions = EasingFunctions;
});
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
define("Promises", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Valid states for a promise to be in
     */
    var PromiseState;
    (function (PromiseState) {
        PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
        PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
        PromiseState[PromiseState["Pending"] = 2] = "Pending";
    })(PromiseState = exports.PromiseState || (exports.PromiseState = {}));
    /**
     * Promises are used to do asynchronous work and they are useful for
     * creating a chain of actions. In Excalibur they are used for loading,
     * sounds, animation, actions, and more.
     *
     * [[include:Promises.md]]
     */
    var Promise = (function () {
        function Promise() {
            this._state = PromiseState.Pending;
            this._successCallbacks = [];
            this._rejectCallback = function () { return; };
        }
        /**
         * Create and resolve a Promise with an optional value
         * @param value  An optional value to wrap in a resolved promise
         */
        Promise.resolve = function (value) {
            var promise = (new Promise()).resolve(value);
            return promise;
        };
        /**
         * Create and reject a Promise with an optional value
         * @param value  An optional value to wrap in a rejected promise
         */
        Promise.reject = function (value) {
            var promise = (new Promise()).reject(value);
            return promise;
        };
        Promise.join = function () {
            var promises = [];
            if (arguments.length > 0 && !Array.isArray(arguments[0])) {
                for (var _i = 0; _i < arguments.length; _i++) {
                    promises[_i - 0] = arguments[_i];
                }
            }
            else if (arguments.length === 1 && Array.isArray(arguments[0])) {
                promises = arguments[0];
            }
            var joinedPromise = new Promise();
            if (!promises || !promises.length) {
                return joinedPromise.resolve();
            }
            var total = promises.length;
            var successes = 0;
            var rejects = 0;
            var errors = [];
            promises.forEach(function (p) {
                p.then(function () {
                    successes += 1;
                    if (successes === total) {
                        joinedPromise.resolve();
                    }
                    else if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }, function () {
                    rejects += 1;
                    if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }).error(function (e) {
                    errors.push(e);
                    if ((errors.length + successes + rejects) === total) {
                        joinedPromise.reject(errors);
                    }
                });
            });
            return joinedPromise;
        };
        /**
         * Chain success and reject callbacks after the promise is resolved
         * @param successCallback  Call on resolution of promise
         * @param rejectCallback   Call on rejection of promise
         */
        Promise.prototype.then = function (successCallback, rejectCallback) {
            if (successCallback) {
                this._successCallbacks.push(successCallback);
                // If the promise is already resovled call immediately
                if (this.state() === PromiseState.Resolved) {
                    try {
                        successCallback.call(this, this._value);
                    }
                    catch (e) {
                        this._handleError(e);
                    }
                }
            }
            if (rejectCallback) {
                this._rejectCallback = rejectCallback;
                // If the promise is already rejected call immediately
                if (this.state() === PromiseState.Rejected) {
                    try {
                        rejectCallback.call(this, this._value);
                    }
                    catch (e) {
                        this._handleError(e);
                    }
                }
            }
            return this;
        };
        /**
         * Add an error callback to the promise
         * @param errorCallback  Call if there was an error in a callback
         */
        Promise.prototype.error = function (errorCallback) {
            if (errorCallback) {
                this._errorCallback = errorCallback;
            }
            return this;
        };
        /**
         * Resolve the promise and pass an option value to the success callbacks
         * @param value  Value to pass to the success callbacks
         */
        Promise.prototype.resolve = function (value) {
            var _this = this;
            if (this._state === PromiseState.Pending) {
                this._value = value;
                try {
                    this._state = PromiseState.Resolved;
                    this._successCallbacks.forEach(function (cb) {
                        cb.call(_this, _this._value);
                    });
                }
                catch (e) {
                    this._handleError(e);
                }
            }
            else {
                throw new Error('Cannot resolve a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Reject the promise and pass an option value to the reject callbacks
         * @param value  Value to pass to the reject callbacks
         */
        Promise.prototype.reject = function (value) {
            if (this._state === PromiseState.Pending) {
                this._value = value;
                try {
                    this._state = PromiseState.Rejected;
                    this._rejectCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
            else {
                throw new Error('Cannot reject a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Inspect the current state of a promise
         */
        Promise.prototype.state = function () {
            return this._state;
        };
        Promise.prototype._handleError = function (e) {
            if (this._errorCallback) {
                this._errorCallback.call(this, e);
            }
            else {
                // rethrow error
                throw e;
            }
        };
        return Promise;
    }());
    exports.Promise = Promise;
});
define("Collision/Side", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that describes the sides of an Actor for collision
     */
    var Side;
    (function (Side) {
        Side[Side["None"] = 0] = "None";
        Side[Side["Top"] = 1] = "Top";
        Side[Side["Bottom"] = 2] = "Bottom";
        Side[Side["Left"] = 3] = "Left";
        Side[Side["Right"] = 4] = "Right";
    })(Side = exports.Side || (exports.Side = {}));
});
define("Util/Util", ["require", "exports", "Algebra", "Collision/Side"], function (require, exports, Algebra_2, Side_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Two PI constant
     */
    exports.TwoPI = Math.PI * 2;
    /**
     * Merges one or more objects into a single target object
     *
     * @returns Merged object with properties from other objects
     * @credit https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
     */
    function extend() {
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments.length;
        // Check if a deep merge
        if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
            deep = arguments[0];
            i++;
        }
        // Merge the object into the extended object
        var assignExists = typeof Object.assign === 'function';
        var merge = null;
        if (!assignExists) {
            merge = function (obj) {
                for (var prop in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                        // If deep merge and property is an object, merge properties
                        if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                            extended[prop] = extend(true, extended[prop], obj[prop]);
                        }
                        else {
                            extended[prop] = obj[prop];
                        }
                    }
                }
            };
        }
        else {
            merge = Object.assign;
        }
        // Loop through each object and conduct a merge
        for (; i < length; i++) {
            var obj = arguments[i];
            if (!assignExists) {
                merge(obj);
            }
            else {
                merge(extended, obj);
            }
        }
        return extended;
    }
    exports.extend = extend;
    function base64Encode(inputStr) {
        var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var outputStr = '';
        var i = 0;
        while (i < inputStr.length) {
            //all three "& 0xff" added below are there to fix a known bug
            //with bytes returned by xhr.responseText
            var byte1 = inputStr.charCodeAt(i++) & 0xff;
            var byte2 = inputStr.charCodeAt(i++) & 0xff;
            var byte3 = inputStr.charCodeAt(i++) & 0xff;
            var enc1 = byte1 >> 2;
            var enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
            var enc3, enc4;
            if (isNaN(byte2)) {
                enc3 = enc4 = 64;
            }
            else {
                enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
                if (isNaN(byte3)) {
                    enc4 = 64;
                }
                else {
                    enc4 = byte3 & 63;
                }
            }
            outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
        }
        return outputStr;
    }
    exports.base64Encode = base64Encode;
    /**
     * Clamps a value between a min and max inclusive
     */
    function clamp(val, min, max) {
        return Math.min(Math.max(min, val), max);
    }
    exports.clamp = clamp;
    function randomInRange(min, max) {
        return min + Math.random() * (max - min);
    }
    exports.randomInRange = randomInRange;
    function randomIntInRange(min, max) {
        return Math.round(randomInRange(min, max));
    }
    exports.randomIntInRange = randomIntInRange;
    function canonicalizeAngle(angle) {
        var tmpAngle = angle;
        if (angle > exports.TwoPI) {
            while (tmpAngle > exports.TwoPI) {
                tmpAngle -= exports.TwoPI;
            }
        }
        if (angle < 0) {
            while (tmpAngle < 0) {
                tmpAngle += exports.TwoPI;
            }
        }
        return tmpAngle;
    }
    exports.canonicalizeAngle = canonicalizeAngle;
    function toDegrees(radians) {
        return 180 / Math.PI * radians;
    }
    exports.toDegrees = toDegrees;
    function toRadians(degrees) {
        return degrees / 180 * Math.PI;
    }
    exports.toRadians = toRadians;
    function getPosition(el) {
        var oLeft = 0, oTop = 0;
        var calcOffsetLeft = function (parent) {
            oLeft += parent.offsetLeft;
            if (parent.offsetParent) {
                calcOffsetLeft(parent.offsetParent);
            }
        };
        var calcOffsetTop = function (parent) {
            oTop += parent.offsetTop;
            if (parent.offsetParent) {
                calcOffsetTop(parent.offsetParent);
            }
        };
        calcOffsetLeft(el);
        calcOffsetTop(el);
        return new Algebra_2.Vector(oLeft, oTop);
    }
    exports.getPosition = getPosition;
    function addItemToArray(item, array) {
        if (array.indexOf(item) === -1) {
            array.push(item);
            return true;
        }
        return false;
    }
    exports.addItemToArray = addItemToArray;
    function removeItemFromArray(item, array) {
        var index = -1;
        if ((index = array.indexOf(item)) > -1) {
            array.splice(index, 1);
            return true;
        }
        return false;
    }
    exports.removeItemFromArray = removeItemFromArray;
    function contains(array, obj) {
        for (var i = 0; i < array.length; i++) {
            if (array[i] === obj) {
                return true;
            }
        }
        return false;
    }
    exports.contains = contains;
    function getOppositeSide(side) {
        if (side === Side_1.Side.Top) {
            return Side_1.Side.Bottom;
        }
        if (side === Side_1.Side.Bottom) {
            return Side_1.Side.Top;
        }
        if (side === Side_1.Side.Left) {
            return Side_1.Side.Right;
        }
        if (side === Side_1.Side.Right) {
            return Side_1.Side.Left;
        }
        return Side_1.Side.None;
    }
    exports.getOppositeSide = getOppositeSide;
    function getSideFromVector(direction) {
        var directions = [Algebra_2.Vector.Left, Algebra_2.Vector.Right, Algebra_2.Vector.Up, Algebra_2.Vector.Down];
        var directionEnum = [Side_1.Side.Left, Side_1.Side.Right, Side_1.Side.Top, Side_1.Side.Bottom];
        var max = -Number.MAX_VALUE;
        var maxIndex = -1;
        for (var i = 0; i < directions.length; i++) {
            if (directions[i].dot(direction) > max) {
                max = directions[i].dot(direction);
                maxIndex = i;
            }
        }
        return directionEnum[maxIndex];
    }
    exports.getSideFromVector = getSideFromVector;
    /**
     * Excalibur's dynamically resizing collection
     */
    var Collection = (function () {
        /**
         * @param initialSize  Initial size of the internal backing array
         */
        function Collection(initialSize) {
            if (initialSize === void 0) { initialSize = Collection.DefaultSize; }
            this._internalArray = null;
            this._endPointer = 0;
            this._internalArray = new Array(initialSize);
        }
        Collection.prototype._resize = function () {
            var newSize = this._internalArray.length * 2;
            var newArray = new Array(newSize);
            var count = this.count();
            for (var i = 0; i < count; i++) {
                newArray[i] = this._internalArray[i];
            }
            delete this._internalArray;
            this._internalArray = newArray;
        };
        /**
         * Push elements to the end of the collection
         */
        Collection.prototype.push = function (element) {
            if (this._endPointer === this._internalArray.length) {
                this._resize();
            }
            return this._internalArray[this._endPointer++] = element;
        };
        /**
         * Removes elements from the end of the collection
         */
        Collection.prototype.pop = function () {
            this._endPointer = this._endPointer - 1 < 0 ? 0 : this._endPointer - 1;
            return this._internalArray[this._endPointer];
        };
        /**
         * Returns the count of the collection
         */
        Collection.prototype.count = function () {
            return this._endPointer;
        };
        /**
         * Empties the collection
         */
        Collection.prototype.clear = function () {
            this._endPointer = 0;
        };
        /**
         * Returns the size of the internal backing array
         */
        Collection.prototype.internalSize = function () {
            return this._internalArray.length;
        };
        /**
         * Returns an element at a specific index
         * @param index  Index of element to retrieve
         */
        Collection.prototype.elementAt = function (index) {
            if (index >= this.count()) {
                //Logger.getInstance().error('Invalid parameter: ' + index);
                throw new Error('Invalid index ' + index);
            }
            return this._internalArray[index];
        };
        /**
         * Inserts an element at a specific index
         * @param index  Index to insert the element
         * @param value  Element to insert
         */
        Collection.prototype.insert = function (index, value) {
            if (index >= this.count()) {
                this._resize();
            }
            return this._internalArray[index] = value;
        };
        /**
         * Removes an element at a specific index
         * @param index  Index of element to remove
         */
        Collection.prototype.remove = function (index) {
            var count = this.count();
            if (count === 0) {
                //Logger.getInstance().error('Invalid parameter: ' + index);
                throw new Error('Invalid parameter ' + index);
            }
            // O(n) Shift
            var removed = this._internalArray[index];
            for (var i = index; i < count; i++) {
                this._internalArray[i] = this._internalArray[i + 1];
            }
            this._endPointer--;
            return removed;
        };
        /**
         * Removes an element by reference
         * @param element  Element to retrieve
         */
        Collection.prototype.removeElement = function (element) {
            var index = this._internalArray.indexOf(element);
            this.remove(index);
        };
        /**
         * Returns a array representing the collection
         */
        Collection.prototype.toArray = function () {
            return this._internalArray.slice(0, this._endPointer);
        };
        /**
         * Iterate over every element in the collection
         * @param func  Callback to call for each element passing a reference to the element and its index, returned values are ignored
         */
        Collection.prototype.forEach = function (func) {
            var i = 0, count = this.count();
            for (i; i < count; i++) {
                func.call(this, this._internalArray[i], i);
            }
        };
        /**
         * Mutate every element in the collection
         * @param func  Callback to call for each element passing a reference to the element and its index, any values returned mutate
         * the collection
         */
        Collection.prototype.map = function (func) {
            var count = this.count();
            for (var i = 0; i < count; i++) {
                this._internalArray[i] = func.call(this, this._internalArray[i], i);
            }
        };
        return Collection;
    }());
    /**
     * Default collection size
     */
    Collection.DefaultSize = 200;
    exports.Collection = Collection;
});
define("Camera", ["require", "exports", "Util/EasingFunctions", "Promises", "Algebra", "Util/Util"], function (require, exports, EasingFunctions_1, Promises_1, Algebra_3, Util_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Container to house convenience strategy methods
     * @internal
     */
    var StrategyContainer = (function () {
        function StrategyContainer(camera) {
            this.camera = camera;
        }
        /**
         * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
         * @param actor The actor to lock the camera to
         */
        StrategyContainer.prototype.lockToActor = function (actor) {
            this.camera.addStrategy(new LockCameraToActorStrategy(actor));
        };
        /**
         * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
         * @param actor The actor to lock the camera to
         * @param axis The axis to follow the actor on
         */
        StrategyContainer.prototype.lockToActorAxis = function (actor, axis) {
            this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
        };
        /**
         * Creates and adds the [[ElasticToActorStrategy]] on the current camera
         * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
         * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillationg spring that will over
         * correct and bounce around the target
         *
         * @param target Target actor to elastically follow
         * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
         * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
         */
        StrategyContainer.prototype.elasticToActor = function (actor, cameraElasticity, cameraFriction) {
            this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
        };
        /**
         * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
         * @param target Target actor to follow when it is "radius" pixels away
         * @param radius Number of pixels away before the camera will follow
         */
        StrategyContainer.prototype.radiusAroundActor = function (actor, radius) {
            this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
        };
        return StrategyContainer;
    }());
    exports.StrategyContainer = StrategyContainer;
    /**
     * Camera axis enum
     */
    var Axis;
    (function (Axis) {
        Axis[Axis["X"] = 0] = "X";
        Axis[Axis["Y"] = 1] = "Y";
    })(Axis = exports.Axis || (exports.Axis = {}));
    /**
     * Lock a camera to the exact x/y postition of an actor.
     */
    var LockCameraToActorStrategy = (function () {
        function LockCameraToActorStrategy(target) {
            this.target = target;
            this.action = function (target, _cam, _eng, _delta) {
                var center = target.getCenter();
                return center;
            };
        }
        return LockCameraToActorStrategy;
    }());
    exports.LockCameraToActorStrategy = LockCameraToActorStrategy;
    /**
     * Lock a camera to a specific axis around an actor.
     */
    var LockCameraToActorAxisStrategy = (function () {
        function LockCameraToActorAxisStrategy(target, axis) {
            var _this = this;
            this.target = target;
            this.axis = axis;
            this.action = function (target, cam, _eng, _delta) {
                var center = target.getCenter();
                var currentFocus = cam.getFocus();
                if (_this.axis === Axis.X) {
                    return new Algebra_3.Vector(center.x, currentFocus.y);
                }
                else {
                    return new Algebra_3.Vector(currentFocus.x, center.y);
                }
            };
        }
        return LockCameraToActorAxisStrategy;
    }());
    exports.LockCameraToActorAxisStrategy = LockCameraToActorAxisStrategy;
    /**
     * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
     */
    var ElasticToActorStrategy = (function () {
        /**
         * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
         * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillationg spring that will over
         * correct and bounce around the target
         *
         * @param target Target actor to elastically follow
         * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
         * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
         */
        function ElasticToActorStrategy(target, cameraElasticity, cameraFriction) {
            var _this = this;
            this.target = target;
            this.cameraElasticity = cameraElasticity;
            this.cameraFriction = cameraFriction;
            this.action = function (target, cam, _eng, _delta) {
                var position = target.getCenter();
                var focus = cam.getFocus();
                var cameraVel = new Algebra_3.Vector(cam.dx, cam.dy);
                // Calculate the strech vector, using the spring equation
                // F = kX
                // https://en.wikipedia.org/wiki/Hooke's_law
                // Apply to the current camera velocity
                var stretch = position.sub(focus).scale(_this.cameraElasticity); // stretch is X
                cameraVel = cameraVel.add(stretch);
                // Calculate the friction (-1 to apply a force in the opposition of motion)
                // Apply to the current camera velocity
                var friction = cameraVel.scale(-1).scale(_this.cameraFriction);
                cameraVel = cameraVel.add(friction);
                // Update position by velocity deltas
                focus = focus.add(cameraVel);
                return focus;
            };
        }
        return ElasticToActorStrategy;
    }());
    exports.ElasticToActorStrategy = ElasticToActorStrategy;
    var RadiusAroundActorStrategy = (function () {
        /**
         *
         * @param target Target actor to follow when it is "radius" pixels away
         * @param radius Number of pixels away before the camera will follow
         */
        function RadiusAroundActorStrategy(target, radius) {
            var _this = this;
            this.target = target;
            this.radius = radius;
            this.action = function (target, cam, _eng, _delta) {
                var position = target.getCenter();
                var focus = cam.getFocus();
                var direction = position.sub(focus);
                var distance = direction.magnitude();
                if (distance >= _this.radius) {
                    var offset = distance - _this.radius;
                    return focus.add(direction.normalize().scale(offset));
                }
                return focus;
            };
        }
        return RadiusAroundActorStrategy;
    }());
    exports.RadiusAroundActorStrategy = RadiusAroundActorStrategy;
    /**
     * Cameras
     *
     * [[BaseCamera]] is the base class for all Excalibur cameras. Cameras are used
     * to move around your game and set focus. They are used to determine
     * what is "off screen" and can be used to scale the game.
     *
     * [[include:Cameras.md]]
     */
    var BaseCamera = (function () {
        function BaseCamera() {
            this._cameraStrategies = [];
            this.strategy = new StrategyContainer(this);
            // camera physical quantities
            this.z = 1;
            this.dx = 0;
            this.dy = 0;
            this.dz = 0;
            this.ax = 0;
            this.ay = 0;
            this.az = 0;
            this.rotation = 0;
            this.rx = 0;
            this._x = 0;
            this._y = 0;
            this._cameraMoving = false;
            this._currentLerpTime = 0;
            this._lerpDuration = 1000; // 1 second   
            this._lerpStart = null;
            this._lerpEnd = null;
            //camera effects
            this._isShaking = false;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._elapsedShakeTime = 0;
            this._xShake = 0;
            this._yShake = 0;
            this._isZooming = false;
            this._maxZoomScale = 1;
            this._zoomIncrement = 0.01;
            this._easing = EasingFunctions_1.EasingFunctions.EaseInOutCubic;
        }
        Object.defineProperty(BaseCamera.prototype, "x", {
            /**
             * Get the camera's x position
             */
            get: function () {
                return this._x;
            },
            /**
             * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
             */
            set: function (value) {
                if (!this._follow && !this._cameraMoving) {
                    this._x = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "y", {
            /**
             * Get the camera's y position
             */
            get: function () {
                return this._y;
            },
            /**
             * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
             */
            set: function (value) {
                if (!this._follow && !this._cameraMoving) {
                    this._y = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "pos", {
            /**
             * Get the camera's position as a vector
             */
            get: function () {
                return new Algebra_3.Vector(this.x, this.y);
            },
            /**
             * Set the cameras position
             */
            set: function (value) {
                this.x = value.x;
                this.y = value.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "vel", {
            /**
             * Get the camera's velocity as a vector
             */
            get: function () {
                return new Algebra_3.Vector(this.dx, this.dy);
            },
            /**
             * Set the camera's velocity
             */
            set: function (value) {
                this.dx = value.x;
                this.dy = value.y;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the focal point of the camera, a new point giving the x and y position of the camera
         */
        BaseCamera.prototype.getFocus = function () {
            return new Algebra_3.Vector(this.x, this.y);
        };
        /**
         * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
         *
         * @param pos The target position to move to
         * @param duration The duration in milliseconds the move should last
         * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
         * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
         *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
         */
        BaseCamera.prototype.move = function (pos, duration, easingFn) {
            if (easingFn === void 0) { easingFn = EasingFunctions_1.EasingFunctions.EaseInOutCubic; }
            if (typeof easingFn !== 'function') {
                throw 'Please specify an EasingFunction';
            }
            // cannot move when following an actor
            if (this._follow) {
                return new Promises_1.Promise().reject(pos);
            }
            // resolve existing promise, if any
            if (this._lerpPromise && this._lerpPromise.state() === Promises_1.PromiseState.Pending) {
                this._lerpPromise.resolve(pos);
            }
            this._lerpPromise = new Promises_1.Promise();
            this._lerpStart = this.getFocus().clone();
            this._lerpDuration = duration;
            this._lerpEnd = pos;
            this._currentLerpTime = 0;
            this._cameraMoving = true;
            this._easing = easingFn;
            return this._lerpPromise;
        };
        /**
         * Sets the camera to shake at the specified magnitudes for the specified duration
         * @param magnitudeX  The x magnitude of the shake
         * @param magnitudeY  The y magnitude of the shake
         * @param duration    The duration of the shake in milliseconds
         */
        BaseCamera.prototype.shake = function (magnitudeX, magnitudeY, duration) {
            this._isShaking = true;
            this._shakeMagnitudeX = magnitudeX;
            this._shakeMagnitudeY = magnitudeY;
            this._shakeDuration = duration;
        };
        /**
         * Zooms the camera in or out by the specified scale over the specified duration.
         * If no duration is specified, it take effect immediately.
         * @param scale    The scale of the zoom
         * @param duration The duration of the zoom in milliseconds
         */
        BaseCamera.prototype.zoom = function (scale, duration) {
            if (duration === void 0) { duration = 0; }
            this._zoomPromise = new Promises_1.Promise();
            if (duration) {
                this._isZooming = true;
                this._maxZoomScale = scale;
                this._zoomIncrement = (scale - this.z) / duration;
            }
            else {
                this._isZooming = false;
                this.z = scale;
                this._zoomPromise.resolve(true);
            }
            return this._zoomPromise;
        };
        /**
         * Gets the current zoom scale
         */
        BaseCamera.prototype.getZoom = function () {
            return this.z;
        };
        /**
         * Adds a new camera strategy to this camera
         * @param cameraStrategy Instance of an [[ICameraStrategy]]
         */
        BaseCamera.prototype.addStrategy = function (cameraStrategy) {
            this._cameraStrategies.push(cameraStrategy);
        };
        /**
         * Removes a camera strategy by reference
         * @param cameraStrategy Instance of an [[ICameraStrategy]]
         */
        BaseCamera.prototype.removeStrategy = function (cameraStrategy) {
            Util_1.removeItemFromArray(cameraStrategy, this._cameraStrategies);
        };
        /**
         * Clears all camera strategies from the camera
         */
        BaseCamera.prototype.clearAllStrategies = function () {
            this._cameraStrategies.length = 0;
        };
        BaseCamera.prototype.update = function (_engine, delta) {
            // Update placements based on linear algebra
            this._x += this.dx * delta / 1000;
            this._y += this.dy * delta / 1000;
            this.z += this.dz * delta / 1000;
            this.dx += this.ax * delta / 1000;
            this.dy += this.ay * delta / 1000;
            this.dz += this.az * delta / 1000;
            this.rotation += this.rx * delta / 1000;
            if (this._isZooming) {
                var newZoom = this.z + this._zoomIncrement * delta;
                this.z = newZoom;
                if (this._zoomIncrement > 0) {
                    if (newZoom >= this._maxZoomScale) {
                        this._isZooming = false;
                        this.z = this._maxZoomScale;
                        this._zoomPromise.resolve(true);
                    }
                }
                else {
                    if (newZoom <= this._maxZoomScale) {
                        this._isZooming = false;
                        this.z = this._maxZoomScale;
                        this._zoomPromise.resolve(true);
                    }
                }
            }
            if (this._cameraMoving) {
                if (this._currentLerpTime < this._lerpDuration) {
                    if (this._lerpEnd.x < this._lerpStart.x) {
                        this._x = this._lerpStart.x - (this._easing(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                    }
                    else {
                        this._x = this._easing(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                    }
                    if (this._lerpEnd.y < this._lerpStart.y) {
                        this._y = this._lerpStart.y - (this._easing(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                    }
                    else {
                        this._y = this._easing(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                    }
                    this._currentLerpTime += delta;
                }
                else {
                    this._x = this._lerpEnd.x;
                    this._y = this._lerpEnd.y;
                    this._lerpPromise.resolve(this._lerpEnd);
                    this._lerpStart = null;
                    this._lerpEnd = null;
                    this._currentLerpTime = 0;
                    this._cameraMoving = false;
                }
            }
            if (this._isDoneShaking()) {
                this._isShaking = false;
                this._elapsedShakeTime = 0;
                this._shakeMagnitudeX = 0;
                this._shakeMagnitudeY = 0;
                this._shakeDuration = 0;
                this._xShake = 0;
                this._yShake = 0;
            }
            else {
                this._elapsedShakeTime += delta;
                this._xShake = (Math.random() * this._shakeMagnitudeX | 0) + 1;
                this._yShake = (Math.random() * this._shakeMagnitudeY | 0) + 1;
            }
            for (var _i = 0, _a = this._cameraStrategies; _i < _a.length; _i++) {
                var s = _a[_i];
                this.pos = s.action.call(s, s.target, this, _engine, delta);
            }
        };
        /**
         * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
         * @param ctx    Canvas context to apply transformations
         * @param delta  The number of milliseconds since the last update
         */
        BaseCamera.prototype.draw = function (ctx) {
            var focus = this.getFocus();
            var canvasWidth = ctx.canvas.width;
            var canvasHeight = ctx.canvas.height;
            var pixelRatio = window.devicePixelRatio;
            var zoom = this.getZoom();
            var newCanvasWidth = (canvasWidth / zoom) / pixelRatio;
            var newCanvasHeight = (canvasHeight / zoom) / pixelRatio;
            ctx.scale(zoom, zoom);
            ctx.translate(-focus.x + newCanvasWidth / 2 + this._xShake, -focus.y + newCanvasHeight / 2 + this._yShake);
        };
        BaseCamera.prototype.debugDraw = function (ctx) {
            var focus = this.getFocus();
            ctx.fillStyle = 'red';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 15, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
        };
        BaseCamera.prototype._isDoneShaking = function () {
            return !(this._isShaking) || (this._elapsedShakeTime >= this._shakeDuration);
        };
        return BaseCamera;
    }());
    exports.BaseCamera = BaseCamera;
    /**
     * An extension of [[BaseCamera]] that is locked vertically; it will only move side to side.
     *
     * Common usages: platformers.
     * @deprecated OBSOLETE: Will be removed in v0.15, please use `BaseCamera.strategy.lockToActorAxis`
     */
    var SideCamera = (function (_super) {
        __extends(SideCamera, _super);
        function SideCamera() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Sets the [[Actor]] to follow with the camera
         * @param actor  The actor to follow
         */
        SideCamera.prototype.setActorToFollow = function (actor) {
            this._follow = actor;
        };
        SideCamera.prototype.getFocus = function () {
            if (this._follow) {
                return new Algebra_3.Vector(this._follow.pos.x + this._follow.getWidth() / 2, _super.prototype.getFocus.call(this).y);
            }
            else {
                return _super.prototype.getFocus.call(this);
            }
        };
        return SideCamera;
    }(BaseCamera));
    exports.SideCamera = SideCamera;
    /**
     * An extension of [[BaseCamera]] that is locked to an [[Actor]] or
     * [[LockedCamera.getFocus|focal point]]; the actor will appear in the
     * center of the screen.
     *
     * Common usages: RPGs, adventure games, top-down games.
     * @deprecated OBSOLETE: Will be removed in v0.15, please use `BaseCamera.strategy.lockToActor`
     */
    var LockedCamera = (function (_super) {
        __extends(LockedCamera, _super);
        function LockedCamera() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Sets the [[Actor]] to follow with the camera
         * @param actor  The actor to follow
         */
        LockedCamera.prototype.setActorToFollow = function (actor) {
            this._follow = actor;
        };
        LockedCamera.prototype.getFocus = function () {
            if (this._follow) {
                return new Algebra_3.Vector(this._follow.pos.x + this._follow.getWidth() / 2, this._follow.pos.y + this._follow.getHeight() / 2);
            }
            else {
                return _super.prototype.getFocus.call(this);
            }
        };
        return LockedCamera;
    }(BaseCamera));
    exports.LockedCamera = LockedCamera;
});
define("DebugFlags", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Drawing/Color", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Provides standard colors (e.g. [[Color.Black]])
     * but you can also create custom colors using RGB, HSL, or Hex. Also provides
     * useful color operations like [[Color.lighten]], [[Color.darken]], and more.
     *
     * [[include:Colors.md]]
     */
    var Color = (function () {
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @param r  The red component of color (0-255)
         * @param g  The green component of color (0-255)
         * @param b  The blue component of color (0-255)
         * @param a  The alpha component of color (0-1.0)
         */
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = (a != null ? a : 1);
        }
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @param r  The red component of color (0-255)
         * @param g  The green component of color (0-255)
         * @param b  The blue component of color (0-255)
         * @param a  The alpha component of color (0-1.0)
         */
        Color.fromRGB = function (r, g, b, a) {
            return new Color(r, g, b, a);
        };
        /**
         * Creates a new inscance of Color from a hex string
         *
         * @param hex  CSS color string of the form #ffffff, the alpha component is optional
         */
        Color.fromHex = function (hex) {
            var hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
            var match = null;
            if (match = hex.match(hexRegEx)) {
                var r = parseInt(match[1], 16);
                var g = parseInt(match[2], 16);
                var b = parseInt(match[3], 16);
                var a = 1;
                if (match[4]) {
                    a = parseInt(match[4], 16) / 255;
                }
                return new Color(r, g, b, a);
            }
            else {
                throw new Error('Invalid hex string: ' + hex);
            }
        };
        /**
         * Creats a new instance of Color from hsla values
         *
         * @param h  Hue is represented [0-1]
         * @param s  Saturation is represented [0-1]
         * @param l  Luminance is represented [0-1]
         * @param a  Alpha is represented [0-1]
         */
        Color.fromHSL = function (h, s, l, a) {
            if (a === void 0) { a = 1.0; }
            var temp = new HSLColor(h, s, l, a);
            return temp.toRGBA();
        };
        /**
         * Lightens the current color by a specified amount
         *
         * @param factor  The amount to lighten by [0-1]
         */
        Color.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.l += (temp.l * factor);
            return temp.toRGBA();
        };
        /**
         * Darkens the current color by a specified amount
         *
         * @param factor  The amount to darken by [0-1]
         */
        Color.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.l -= (temp.l * factor);
            return temp.toRGBA();
        };
        /**
         * Saturates the current color by a specified amount
         *
         * @param factor  The amount to saturate by [0-1]
         */
        Color.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.s += (temp.s * factor);
            return temp.toRGBA();
        };
        /**
         * Desaturates the current color by a specified amount
         *
         * @param factor  The amount to desaturate by [0-1]
         */
        Color.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.s -= (temp.s * factor);
            return temp.toRGBA();
        };
        /**
         * Multiplies a color by another, results in a darker color
         *
         * @param color  The other color
         */
        Color.prototype.mulitiply = function (color) {
            var newR = ((color.r / 255 * this.r / 255) * 255);
            var newG = ((color.g / 255 * this.g / 255) * 255);
            var newB = ((color.b / 255 * this.b / 255) * 255);
            var newA = (color.a * this.a);
            return new Color(newR, newG, newB, newA);
        };
        /**
         * Screens a color by another, results in a lighter color
         *
         * @param color  The other color
         */
        Color.prototype.screen = function (color) {
            var color1 = color.invert();
            var color2 = color.invert();
            return color1.mulitiply(color2).invert();
        };
        /**
         * Inverts the current color
         */
        Color.prototype.invert = function () {
            return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
        };
        /**
         * Averages the current color with another
         *
         * @param color  The other color
         */
        Color.prototype.average = function (color) {
            var newR = (color.r + this.r) / 2;
            var newG = (color.g + this.g) / 2;
            var newB = (color.b + this.b) / 2;
            var newA = (color.a + this.a) / 2;
            return new Color(newR, newG, newB, newA);
        };
        /**
         * Returns a CSS string representation of a color.
         *
         * @param format Color representation, accepts: rgb, hsl, or hex
         */
        Color.prototype.toString = function (format) {
            if (format === void 0) { format = 'rgb'; }
            switch (format) {
                case 'rgb':
                    return this.toRGBA();
                case 'hsl':
                    return this.toHSLA();
                case 'hex':
                    return this.toHex();
                default:
                    throw new Error('Invalid Color format');
            }
        };
        /**
         * Returns Hex Value of a color component
         * @param c color component
         * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
         */
        Color.prototype._componentToHex = function (c) {
            var hex = c.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        };
        /**
         * Return Hex representation of a color.
         */
        Color.prototype.toHex = function () {
            return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
        };
        /**
         * Return RGBA representation of a color.
         */
        Color.prototype.toRGBA = function () {
            var result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
            if (this.a !== undefined || this.a !== null) {
                return 'rgba(' + result + ', ' + String(this.a) + ')';
            }
            return 'rgb(' + result + ')';
        };
        /**
         * Return HSLA representation of a color.
         */
        Color.prototype.toHSLA = function () {
            return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
        };
        /**
         * Returns a CSS string representation of a color.
         */
        Color.prototype.fillStyle = function () {
            return this.toString();
        };
        /**
         * Returns a clone of the current color.
         */
        Color.prototype.clone = function () {
            return new Color(this.r, this.g, this.b, this.a);
        };
        return Color;
    }());
    /**
     * Black (#000000)
     */
    Color.Black = Color.fromHex('#000000');
    /**
     * White (#FFFFFF)
     */
    Color.White = Color.fromHex('#FFFFFF');
    /**
     * Gray (#808080)
     */
    Color.Gray = Color.fromHex('#808080');
    /**
     * Light gray (#D3D3D3)
     */
    Color.LightGray = Color.fromHex('#D3D3D3');
    /**
     * Dark gray (#A9A9A9)
     */
    Color.DarkGray = Color.fromHex('#A9A9A9');
    /**
     * Yellow (#FFFF00)
     */
    Color.Yellow = Color.fromHex('#FFFF00');
    /**
     * Orange (#FFA500)
     */
    Color.Orange = Color.fromHex('#FFA500');
    /**
     * Red (#FF0000)
     */
    Color.Red = Color.fromHex('#FF0000');
    /**
     * Vermillion (#FF5B31)
     */
    Color.Vermillion = Color.fromHex('#FF5B31');
    /**
     * Rose (#FF007F)
     */
    Color.Rose = Color.fromHex('#FF007F');
    /**
     * Magenta (#FF00FF)
     */
    Color.Magenta = Color.fromHex('#FF00FF');
    /**
     * Violet (#7F00FF)
     */
    Color.Violet = Color.fromHex('#7F00FF');
    /**
     * Blue (#0000FF)
     */
    Color.Blue = Color.fromHex('#0000FF');
    /**
     * Azure (#007FFF)
     */
    Color.Azure = Color.fromHex('#007FFF');
    /**
     * Cyan (#00FFFF)
     */
    Color.Cyan = Color.fromHex('#00FFFF');
    /**
     * Viridian (#59978F)
     */
    Color.Viridian = Color.fromHex('#59978F');
    /**
     * Green (#00FF00)
     */
    Color.Green = Color.fromHex('#00FF00');
    /**
     * Chartreuse (#7FFF00)
     */
    Color.Chartreuse = Color.fromHex('#7FFF00');
    /**
     * Transparent (#FFFFFF00)
     */
    Color.Transparent = Color.fromHex('#FFFFFF00');
    exports.Color = Color;
    /**
     * Internal HSL Color representation
     *
     * http://en.wikipedia.org/wiki/HSL_and_HSV
     * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
     */
    var HSLColor = (function () {
        function HSLColor(h, s, l, a) {
            this.h = h;
            this.s = s;
            this.l = l;
            this.a = a;
        }
        HSLColor.hue2rgb = function (p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        };
        HSLColor.fromRGBA = function (r, g, b, a) {
            r /= 255;
            g /= 255;
            b /= 255;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0; // achromatic
            }
            else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return new HSLColor(h, s, l, a);
        };
        HSLColor.prototype.toRGBA = function () {
            var r, g, b;
            if (this.s === 0) {
                r = g = b = this.l; // achromatic
            }
            else {
                var q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
                var p = 2 * this.l - q;
                r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
                g = HSLColor.hue2rgb(p, q, this.h);
                b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
            }
            return new Color(r * 255, g * 255, b * 255, this.a);
        };
        HSLColor.prototype.toString = function () {
            var h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
            return "hsla(" + h + ", " + s + ", " + l + ", " + a + ")";
        };
        return HSLColor;
    }());
});
define("Collision/CollisionContact", ["require", "exports", "Actor", "Algebra", "Physics", "Events", "Util/Util"], function (require, exports, Actor_1, Algebra_4, Physics_1, Events_1, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Collision contacts are used internally by Excalibur to resolve collision between actors. This
     * Pair prevents collisions from being evaluated more than one time
     */
    var CollisionContact = (function () {
        function CollisionContact(bodyA, bodyB, mtv, point, normal) {
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.mtv = mtv;
            this.point = point;
            this.normal = normal;
        }
        CollisionContact.prototype.resolve = function (strategy) {
            if (strategy === Physics_1.CollisionResolutionStrategy.RigidBody) {
                this._resolveRigidBodyCollision();
            }
            else if (strategy === Physics_1.CollisionResolutionStrategy.Box) {
                this._resolveBoxCollision();
            }
            else {
                throw new Error('Unknown collision resolution strategy');
            }
        };
        CollisionContact.prototype._applyBoxImpulse = function (bodyA, bodyB, mtv) {
            if (bodyA.collisionType === Actor_1.CollisionType.Active &&
                bodyB.collisionType !== Actor_1.CollisionType.Passive) {
                // Resolve overlaps
                if (bodyA.collisionType === Actor_1.CollisionType.Active &&
                    bodyB.collisionType === Actor_1.CollisionType.Active) {
                    // split overlaps if both are Active
                    mtv = mtv.scale(.5);
                }
                // Apply mtv
                bodyA.pos.y += mtv.y;
                bodyA.pos.x += mtv.x;
                // non-zero intersection on the y axis
                if (this.mtv.x !== 0) {
                    var velX = 0;
                    // both bodies are traveling in the same direction (negative or positive)
                    if (bodyA.vel.x < 0 && bodyB.vel.x < 0) {
                        velX = Math.min(bodyA.vel.x, bodyB.vel.x);
                    }
                    else if (bodyA.vel.x > 0 && bodyB.vel.x > 0) {
                        velX = Math.max(bodyA.vel.x, bodyB.vel.x);
                    }
                    else if (bodyB.collisionType === Actor_1.CollisionType.Fixed) {
                        // bodies are traveling in opposite directions
                        if (bodyA.pos.sub(bodyB.pos).dot(bodyA.vel) > 0) {
                            velX = bodyA.vel.x;
                        }
                        else {
                            // bodyA is heading towards b
                            velX = bodyB.vel.x;
                        }
                    }
                    bodyA.vel.x = velX;
                }
                if (this.mtv.y !== 0) {
                    var velY = 0;
                    // both bodies are traveling in the same direction (negative or positive)
                    if (bodyA.vel.y < 0 && bodyB.vel.y < 0) {
                        velY = Math.min(bodyA.vel.y, bodyB.vel.y);
                    }
                    else if (bodyA.vel.y > 0 && bodyB.vel.y > 0) {
                        velY = Math.max(bodyA.vel.y, bodyB.vel.y);
                    }
                    else if (bodyB.collisionType === Actor_1.CollisionType.Fixed) {
                        // bodies are traveling in opposite directions
                        if (bodyA.pos.sub(bodyB.pos).dot(bodyA.vel) > 0) {
                            velY = bodyA.vel.y;
                        }
                        else {
                            // bodyA is heading towards b
                            velY = bodyB.vel.y;
                        }
                    }
                    bodyA.vel.y = velY;
                }
                bodyA.emit('postcollision', new Events_1.PostCollisionEvent(bodyA, bodyB, Util.getSideFromVector(mtv), mtv));
            }
        };
        CollisionContact.prototype._resolveBoxCollision = function () {
            var bodyA = this.bodyA.body.actor;
            var bodyB = this.bodyB.body.actor;
            var side = Util.getSideFromVector(this.mtv);
            var mtv = this.mtv.negate();
            // Publish collision events on both participants
            bodyA.emit('precollision', new Events_1.PreCollisionEvent(bodyA, bodyB, side, mtv));
            bodyB.emit('precollision', new Events_1.PreCollisionEvent(bodyB, bodyA, Util.getOppositeSide(side), mtv.negate()));
            this._applyBoxImpulse(bodyA, bodyB, mtv);
            this._applyBoxImpulse(bodyB, bodyA, mtv.negate());
        };
        CollisionContact.prototype._resolveRigidBodyCollision = function () {
            // perform collison on bounding areas
            var bodyA = this.bodyA.body;
            var bodyB = this.bodyB.body;
            var mtv = this.mtv; // normal pointing away from bodyA
            var normal = this.normal; // normal pointing away from bodyA
            if (bodyA.actor === bodyB.actor) {
                return;
            }
            // Publish collision events on both participants
            var side = Util.getSideFromVector(this.mtv);
            bodyA.actor.emit('precollision', new Events_1.PreCollisionEvent(this.bodyA.body.actor, this.bodyB.body.actor, side, this.mtv));
            bodyB.actor.emit('precollision', new Events_1.PreCollisionEvent(this.bodyB.body.actor, this.bodyA.body.actor, Util.getOppositeSide(side), this.mtv.negate()));
            // If any of the participants are passive then short circuit
            if (bodyA.actor.collisionType === Actor_1.CollisionType.Passive ||
                bodyB.actor.collisionType === Actor_1.CollisionType.Passive) {
                return;
            }
            var invMassA = bodyA.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyA.mass;
            var invMassB = bodyB.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyB.mass;
            var invMoiA = bodyA.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyA.moi;
            var invMoiB = bodyB.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyB.moi;
            // average restitution more relistic
            var coefRestitution = Math.min(bodyA.restitution, bodyB.restitution);
            var coefFriction = Math.min(bodyA.friction, bodyB.friction);
            normal = normal.normalize();
            var tangent = normal.normal().normalize();
            var ra = this.point.sub(this.bodyA.getCenter()); // point relative to bodyA position
            var rb = this.point.sub(this.bodyB.getCenter()); /// point relative to bodyB
            // Relative velocity in linear terms
            // Angular to linear velocity formula -> omega = v/r
            var rv = bodyB.vel.add(rb.cross(-bodyB.rx)).sub(bodyA.vel.sub(ra.cross(bodyA.rx)));
            var rvNormal = rv.dot(normal);
            var rvTangent = rv.dot(tangent);
            var raTangent = ra.dot(tangent);
            var raNormal = ra.dot(normal);
            var rbTangent = rb.dot(tangent);
            var rbNormal = rb.dot(normal);
            // If objects are moving away ignore
            if (rvNormal > 0) {
                return;
            }
            // Collision impulse formula from Chris Hecker
            // https://en.wikipedia.org/wiki/Collision_response
            var impulse = -((1 + coefRestitution) * rvNormal) /
                ((invMassA + invMassB) + invMoiA * raTangent * raTangent + invMoiB * rbTangent * rbTangent);
            if (bodyA.actor.collisionType === Actor_1.CollisionType.Fixed) {
                bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyB.rx -= impulse * invMoiB * -rb.cross(normal);
                }
                bodyB.addMtv(mtv);
            }
            else if (bodyB.actor.collisionType === Actor_1.CollisionType.Fixed) {
                bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyA.rx += impulse * invMoiA * -ra.cross(normal);
                }
                bodyA.addMtv(mtv.negate());
            }
            else {
                bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));
                bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyB.rx -= impulse * invMoiB * -rb.cross(normal);
                    bodyA.rx += impulse * invMoiA * -ra.cross(normal);
                }
                // Split the mtv in half for the two bodies, potentially we could do something smarter here
                bodyB.addMtv(mtv.scale(.5));
                bodyA.addMtv(mtv.scale(-.5));
            }
            // Friction portion of impulse
            if (coefFriction && rvTangent) {
                // Columb model of friction, formula for impulse due to friction from  
                // https://en.wikipedia.org/wiki/Collision_response
                // tangent force exerted by body on another in contact
                var t = rv.sub(normal.scale(rv.dot(normal))).normalize();
                // impulse in the direction of tangent force
                var jt = rv.dot(t) / (invMassA + invMassB + raNormal * raNormal * invMoiA + rbNormal * rbNormal * invMoiB);
                var frictionImpulse = new Algebra_4.Vector(0, 0);
                if (Math.abs(jt) <= impulse * coefFriction) {
                    frictionImpulse = t.scale(jt).negate();
                }
                else {
                    frictionImpulse = t.scale(-impulse * coefFriction);
                }
                if (bodyA.actor.collisionType === Actor_1.CollisionType.Fixed) {
                    // apply frictional impulse
                    bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);
                    }
                }
                else if (bodyB.actor.collisionType === Actor_1.CollisionType.Fixed) {
                    // apply frictional impulse
                    bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);
                    }
                }
                else {
                    // apply frictional impulse
                    bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));
                    bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));
                    // apply frictional impulse
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);
                        bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);
                    }
                }
            }
            bodyA.actor.emit('postcollision', new Events_1.PostCollisionEvent(this.bodyA.body.actor, this.bodyB.body.actor, side, this.mtv));
            bodyB.actor.emit('postcollision', new Events_1.PostCollisionEvent(this.bodyB.body.actor, this.bodyA.body.actor, Util.getOppositeSide(side), this.mtv.negate()));
        };
        return CollisionContact;
    }());
    exports.CollisionContact = CollisionContact;
});
define("Collision/ICollisionArea", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/CircleArea", ["require", "exports", "Collision/BoundingBox", "Collision/PolygonArea", "Collision/EdgeArea", "Collision/CollisionJumpTable", "Algebra", "Physics", "Drawing/Color"], function (require, exports, BoundingBox_1, PolygonArea_1, EdgeArea_1, CollisionJumpTable_1, Algebra_5, Physics_2, Color_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is a circle collision area for the excalibur rigid body physics simulation
     */
    var CircleArea = (function () {
        function CircleArea(options) {
            /**
             * This is the center position of the circle, relative to the body position
             */
            this.pos = Algebra_5.Vector.Zero.clone();
            this.pos = options.pos || Algebra_5.Vector.Zero.clone();
            this.radius = options.radius || 0;
            this.body = options.body || null;
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        CircleArea.prototype.getCenter = function () {
            if (this.body) {
                return this.pos.add(this.body.pos);
            }
            return this.pos;
        };
        /**
         * Tests if a point is contained in this collision area
         */
        CircleArea.prototype.contains = function (point) {
            var distance = this.body.pos.distance(point);
            if (distance <= this.radius) {
                return true;
            }
            return false;
        };
        /**
         * Casts a ray at the CircleArea and returns the nearest point of collision
         * @param ray
         */
        CircleArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
            var c = this.getCenter();
            var dir = ray.dir;
            var orig = ray.pos;
            var discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) -
                Math.pow(orig.sub(c).distance(), 2) +
                Math.pow(this.radius, 2));
            if (discriminant < 0) {
                // no intersection
                return null;
            }
            else {
                var toi = 0;
                if (discriminant === 0) {
                    toi = -dir.dot(orig.sub(c));
                    if (toi > 0 && toi < max) {
                        return ray.getPoint(toi);
                    }
                    return null;
                }
                else {
                    var toi1 = -dir.dot(orig.sub(c)) + discriminant;
                    var toi2 = -dir.dot(orig.sub(c)) - discriminant;
                    var mintoi = Math.min(toi1, toi2);
                    if (mintoi <= max) {
                        return ray.getPoint(mintoi);
                    }
                    return null;
                }
            }
        };
        /**
         * @inheritdoc
         */
        CircleArea.prototype.collide = function (area) {
            if (area instanceof CircleArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCircleCircle(this, area);
            }
            else if (area instanceof PolygonArea_1.PolygonArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCirclePolygon(this, area);
            }
            else if (area instanceof EdgeArea_1.EdgeArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCircleEdge(this, area);
            }
            else {
                throw new Error("Circle could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        CircleArea.prototype.getFurthestPoint = function (direction) {
            return this.getCenter().add(direction.normalize().scale(this.radius));
        };
        /**
         * Get the axis aligned bounding box for the circle area
         */
        CircleArea.prototype.getBounds = function () {
            return new BoundingBox_1.BoundingBox(this.pos.x + this.body.pos.x - this.radius, this.pos.y + this.body.pos.y - this.radius, this.pos.x + this.body.pos.x + this.radius, this.pos.y + this.body.pos.y + this.radius);
        };
        /**
         * Get axis not implemented on circles, since there are infinite axis in a circle
         */
        CircleArea.prototype.getAxes = function () {
            return null;
        };
        /**
         * Returns the moment of inertia of a circle given it's mass
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        CircleArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_2.Physics.defaultMass;
            return (mass * this.radius * this.radius) / 2;
        };
        /**
         * Tests the separating axis theorem for circles against polygons
         */
        CircleArea.prototype.testSeparatingAxisTheorem = function (polygon) {
            var axes = polygon.getAxes();
            var pc = polygon.getCenter();
            // Special SAT with circles
            var closestPointOnPoly = polygon.getFurthestPoint(this.pos.sub(pc));
            axes.push(this.pos.sub(closestPointOnPoly).normalize());
            var minOverlap = Number.MAX_VALUE;
            var minAxis = null;
            var minIndex = -1;
            for (var i = 0; i < axes.length; i++) {
                var proj1 = polygon.project(axes[i]);
                var proj2 = this.project(axes[i]);
                var overlap = proj1.getOverlap(proj2);
                if (overlap <= 0) {
                    return null;
                }
                else {
                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        minAxis = axes[i];
                        minIndex = i;
                    }
                }
            }
            if (minIndex < 0) {
                return null;
            }
            return minAxis.normalize().scale(minOverlap);
        };
        /* istanbul ignore next */
        CircleArea.prototype.recalc = function () {
            // circles don't cache
        };
        /**
         * Project the circle along a specified axis
         */
        CircleArea.prototype.project = function (axis) {
            var scalars = [];
            var point = this.getCenter();
            var dotProduct = point.dot(axis);
            scalars.push(dotProduct);
            scalars.push(dotProduct + this.radius);
            scalars.push(dotProduct - this.radius);
            return new Algebra_5.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /* istanbul ignore next */
        CircleArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_1.Color.Green.clone(); }
            var pos = this.body ? this.body.pos.add(this.pos) : this.pos;
            var rotation = this.body ? this.body.rotation : 0;
            ctx.beginPath();
            ctx.strokeStyle = color.toString();
            ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.lineTo(Math.cos(rotation) * this.radius + pos.x, Math.sin(rotation) * this.radius + pos.y);
            ctx.closePath();
            ctx.stroke();
        };
        return CircleArea;
    }());
    exports.CircleArea = CircleArea;
});
define("Collision/CollisionJumpTable", ["require", "exports", "Collision/CollisionContact", "Collision/PolygonArea"], function (require, exports, CollisionContact_1, PolygonArea_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollisionJumpTable = {
        CollideCircleCircle: function (circleA, circleB) {
            var radius = circleA.radius + circleB.radius;
            var circleAPos = circleA.body.pos.add(circleA.pos);
            var circleBPos = circleB.body.pos.add(circleB.pos);
            if (circleAPos.distance(circleBPos) > radius) {
                return null;
            }
            var axisOfCollision = circleBPos.sub(circleAPos).normalize();
            var mvt = axisOfCollision.scale(radius - circleBPos.distance(circleAPos));
            var pointOfCollision = circleA.getFurthestPoint(axisOfCollision);
            return new CollisionContact_1.CollisionContact(circleA, circleB, mvt, pointOfCollision, axisOfCollision);
        },
        CollideCirclePolygon: function (circle, polygon) {
            var minAxis = circle.testSeparatingAxisTheorem(polygon);
            if (!minAxis) {
                return null;
            }
            // make sure that the minAxis is pointing away from circle
            var samedir = minAxis.dot(polygon.getCenter().sub(circle.getCenter()));
            minAxis = samedir < 0 ? minAxis.negate() : minAxis;
            var verts = [];
            var point1 = polygon.getFurthestPoint(minAxis.negate());
            var point2 = circle.getFurthestPoint(minAxis); //.add(cc);
            if (circle.contains(point1)) {
                verts.push(point1);
            }
            if (polygon.contains(point2)) {
                verts.push(point2);
            }
            if (verts.length === 0) {
                return null;
            }
            return new CollisionContact_1.CollisionContact(circle, polygon, minAxis, verts.length === 2 ? verts[0].average(verts[1]) : verts[0], minAxis.normalize());
        },
        CollideCircleEdge: function (circle, edge) {
            // center of the circle
            var cc = circle.getCenter();
            // vector in the direction of the edge
            var e = edge.end.sub(edge.begin);
            // amount of overlap with the circle's center along the edge direction
            var u = e.dot(edge.end.sub(cc));
            var v = e.dot(cc.sub(edge.begin));
            // Potential region A collision (circle is on the left side of the edge, before the beginning)
            if (v <= 0) {
                var da = edge.begin.sub(cc);
                var dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
                // save some sqrts
                if (dda > circle.radius * circle.radius) {
                    return null; // no collision
                }
                return new CollisionContact_1.CollisionContact(circle, edge, da.normalize().scale(circle.radius - Math.sqrt(dda)), edge.begin, da.normalize());
            }
            // Potential region B collision (circle is on the right side of the edge, after the end)
            if (u <= 0) {
                var db = edge.end.sub(cc);
                var ddb = db.dot(db);
                if (ddb > circle.radius * circle.radius) {
                    return null;
                }
                return new CollisionContact_1.CollisionContact(circle, edge, db.normalize().scale(circle.radius - Math.sqrt(ddb)), edge.end, db.normalize());
            }
            // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
            var den = e.dot(e);
            var pointOnEdge = (edge.begin.scale(u).add(edge.end.scale(v))).scale(1 / den);
            var d = cc.sub(pointOnEdge);
            var dd = d.dot(d);
            if (dd > circle.radius * circle.radius) {
                return null; // no collision
            }
            var n = e.perpendicular();
            // flip correct direction
            if (n.dot(cc.sub(edge.begin)) < 0) {
                n.x = -n.x;
                n.y = -n.y;
            }
            n = n.normalize();
            var mvt = n.scale(Math.abs(circle.radius - Math.sqrt(dd)));
            return new CollisionContact_1.CollisionContact(circle, edge, mvt.negate(), pointOnEdge, n.negate());
        },
        CollideEdgeEdge: function () {
            // Edge-edge collision doesn't make sense
            return null;
        },
        CollidePolygonEdge: function (polygon, edge) {
            // 3 cases:
            // (1) Polygon lands on the full face
            // (2) Polygon lands on the right point
            // (3) Polygon lands on the left point
            var e = edge.end.sub(edge.begin);
            var edgeNormal = e.normal();
            if (polygon.contains(edge.begin)) {
                var _a = polygon.getClosestFace(edge.begin), mtv = _a.distance, face = _a.face;
                if (mtv) {
                    return new CollisionContact_1.CollisionContact(polygon, edge, mtv.negate(), edge.begin.add(mtv.negate()), face.normal().negate());
                }
            }
            if (polygon.contains(edge.end)) {
                var _b = polygon.getClosestFace(edge.end), mtv = _b.distance, face = _b.face;
                if (mtv) {
                    return new CollisionContact_1.CollisionContact(polygon, edge, mtv.negate(), edge.end.add(mtv.negate()), face.normal().negate());
                }
            }
            var pc = polygon.getCenter();
            var ec = edge.getCenter();
            var dir = ec.sub(pc).normalize();
            // build a temporary polygon from the edge to use SAT
            var linePoly = new PolygonArea_2.PolygonArea({
                points: [
                    edge.begin,
                    edge.end,
                    edge.end.add(dir.scale(30)),
                    edge.begin.add(dir.scale(30))
                ]
            });
            var minAxis = polygon.testSeparatingAxisTheorem(linePoly);
            // no minAxis, no overlap, no collision
            if (!minAxis) {
                return null;
            }
            // flip the normal and axis to always have positive collisions
            edgeNormal = edgeNormal.dot(dir) < 0 ? edgeNormal.negate() : edgeNormal;
            minAxis = minAxis.dot(dir) < 0 ? minAxis.negate() : minAxis;
            return new CollisionContact_1.CollisionContact(polygon, edge, minAxis, polygon.getFurthestPoint(edgeNormal), edgeNormal);
        },
        CollidePolygonPolygon: function (polyA, polyB) {
            // do a SAT test to find a min axis if it exists
            var minAxis = polyA.testSeparatingAxisTheorem(polyB);
            // no overlap, no collision return null
            if (!minAxis) {
                return null;
            }
            // make sure that minAxis is pointing from A -> B
            var sameDir = minAxis.dot(polyB.getCenter().sub(polyA.getCenter()));
            minAxis = sameDir < 0 ? minAxis.negate() : minAxis;
            // find rough point of collision
            // todo this could be better
            var verts = [];
            var pointA = polyA.getFurthestPoint(minAxis);
            var pointB = polyB.getFurthestPoint(minAxis.negate());
            if (polyB.contains(pointA)) {
                verts.push(pointA);
            }
            if (polyA.contains(pointB)) {
                verts.push(pointB);
            }
            // no candidates, pick something
            if (verts.length === 0) {
                verts.push(pointB);
            }
            var contact = verts.length === 2 ? verts[0].add(verts[1]).scale(.5) : verts[0];
            return new CollisionContact_1.CollisionContact(polyA, polyB, minAxis, contact, minAxis.normalize());
        }
    };
});
define("Collision/PolygonArea", ["require", "exports", "Drawing/Color", "Physics", "Collision/BoundingBox", "Collision/EdgeArea", "Collision/CollisionJumpTable", "Collision/CircleArea", "Algebra"], function (require, exports, Color_2, Physics_3, BoundingBox_2, EdgeArea_2, CollisionJumpTable_2, CircleArea_1, Algebra_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Polygon collision area for detecting collisions for actors, or independently
     */
    var PolygonArea = (function () {
        function PolygonArea(options) {
            this._transformedPoints = [];
            this._axes = [];
            this._sides = [];
            this.pos = options.pos || Algebra_6.Vector.Zero.clone();
            var winding = !!options.clockwiseWinding;
            this.points = (winding ? options.points.reverse() : options.points) || [];
            this.body = options.body || null;
            // calculate initial transformation
            this._calculateTransformation();
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        PolygonArea.prototype.getCenter = function () {
            if (this.body) {
                return this.body.pos.add(this.pos);
            }
            return this.pos;
        };
        /**
         * Calculates the underlying transformation from the body relative space to world space
         */
        PolygonArea.prototype._calculateTransformation = function () {
            var pos = this.body ? this.body.pos.add(this.pos) : this.pos;
            var angle = this.body ? this.body.rotation : 0;
            var len = this.points.length;
            this._transformedPoints.length = 0; // clear out old transform
            for (var i = 0; i < len; i++) {
                this._transformedPoints[i] = this.points[i].rotate(angle).add(pos);
            }
        };
        /**
         * Gets the points that make up the polygon in world space, from actor relative space (if specified)
         */
        PolygonArea.prototype.getTransformedPoints = function () {
            if (!this._transformedPoints.length) {
                this._calculateTransformation();
            }
            ;
            return this._transformedPoints;
        };
        /**
         * Gets the sides of the polygon in world space
         */
        PolygonArea.prototype.getSides = function () {
            if (this._sides.length) {
                return this._sides;
            }
            var lines = [];
            var points = this.getTransformedPoints();
            var len = points.length;
            for (var i = 0; i < len; i++) {
                lines.push(new Algebra_6.Line(points[i], points[(i - 1 + len) % len]));
            }
            this._sides = lines;
            return this._sides;
        };
        PolygonArea.prototype.recalc = function () {
            this._sides.length = 0;
            this._axes.length = 0;
            this._transformedPoints.length = 0;
            this.getTransformedPoints();
            this.getAxes();
            this.getSides();
        };
        /**
         * Tests if a point is contained in this collision area in world space
         */
        PolygonArea.prototype.contains = function (point) {
            // Always cast to the right, as long as we cast in a consitent fixed direction we
            // will be fine
            var testRay = new Algebra_6.Ray(point, new Algebra_6.Vector(1, 0));
            var intersectCount = this.getSides().reduce(function (accum, side) {
                if (testRay.intersect(side) >= 0) {
                    return accum + 1;
                }
                return accum;
            }, 0);
            if (intersectCount % 2 === 0) {
                return false;
            }
            return true;
        };
        /**
         * Returns a collision contact if the 2 collision areas collide, otherwise collide will
         * return null.
         * @param area
         */
        PolygonArea.prototype.collide = function (area) {
            if (area instanceof CircleArea_1.CircleArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollideCirclePolygon(area, this);
            }
            else if (area instanceof PolygonArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollidePolygonPolygon(this, area);
            }
            else if (area instanceof EdgeArea_2.EdgeArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollidePolygonEdge(this, area);
            }
            else {
                throw new Error("Polygon could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        PolygonArea.prototype.getFurthestPoint = function (direction) {
            var pts = this.getTransformedPoints();
            var furthestPoint = null;
            var maxDistance = -Number.MAX_VALUE;
            for (var i = 0; i < pts.length; i++) {
                var distance = direction.dot(pts[i]);
                if (distance > maxDistance) {
                    maxDistance = distance;
                    furthestPoint = pts[i];
                }
            }
            return furthestPoint;
        };
        /**
         * Finds the closes face to the point using perpendicular distance
         * @param point point to test against polygon
         */
        PolygonArea.prototype.getClosestFace = function (point) {
            var sides = this.getSides();
            var min = Number.POSITIVE_INFINITY;
            var faceIndex = -1;
            var distance = -1;
            for (var i = 0; i < sides.length; i++) {
                var dist = sides[i].distanceToPoint(point);
                if (dist < min) {
                    min = dist;
                    faceIndex = i;
                    distance = dist;
                }
            }
            if (faceIndex !== -1) {
                return {
                    distance: sides[faceIndex].normal().scale(distance),
                    face: sides[faceIndex]
                };
            }
            return null;
        };
        /**
         * Get the axis aligned bounding box for the polygon area
         */
        PolygonArea.prototype.getBounds = function () {
            // todo there is a faster way to do this
            var points = this.getTransformedPoints();
            var minX = points.reduce(function (prev, curr) {
                return Math.min(prev, curr.x);
            }, 999999999);
            var maxX = points.reduce(function (prev, curr) {
                return Math.max(prev, curr.x);
            }, -99999999);
            var minY = points.reduce(function (prev, curr) {
                return Math.min(prev, curr.y);
            }, 9999999999);
            var maxY = points.reduce(function (prev, curr) {
                return Math.max(prev, curr.y);
            }, -9999999999);
            return new BoundingBox_2.BoundingBox(minX, minY, maxX, maxY);
        };
        /**
         * Get the moment of inertia for an arbitrary polygon
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        PolygonArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_3.Physics.defaultMass;
            var numerator = 0;
            var denominator = 0;
            for (var i = 0; i < this.points.length; i++) {
                var iplusone = (i + 1) % this.points.length;
                var crossTerm = this.points[iplusone].cross(this.points[i]);
                numerator += crossTerm * (this.points[i].dot(this.points[i]) +
                    this.points[i].dot(this.points[iplusone]) +
                    this.points[iplusone].dot(this.points[iplusone]));
                denominator += crossTerm;
            }
            return (mass / 6) * (numerator / denominator);
        };
        /**
         * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
         */
        PolygonArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            // find the minimum contact time greater than 0
            // contact times less than 0 are behind the ray and we don't want those
            var sides = this.getSides();
            var len = sides.length;
            var minContactTime = Number.MAX_VALUE;
            var contactIndex = -1;
            for (var i = 0; i < len; i++) {
                var contactTime = ray.intersect(sides[i]);
                if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                    minContactTime = contactTime;
                    contactIndex = i;
                }
            }
            // contact was found
            if (contactIndex >= 0) {
                return ray.getPoint(minContactTime);
            }
            // no contact found
            return null;
        };
        /**
         * Get the axis associated with the edge
         */
        PolygonArea.prototype.getAxes = function () {
            if (this._axes.length) {
                return this._axes;
            }
            var axes = [];
            var points = this.getTransformedPoints();
            var len = points.length;
            for (var i = 0; i < len; i++) {
                axes.push(points[i].sub(points[(i + 1) % len]).normal());
            }
            this._axes = axes;
            return this._axes;
        };
        /**
         * Perform Separating Axis test against another polygon, returns null if no overlap in polys
         * Reference http://www.dyn4j.org/2010/01/sat/
         */
        PolygonArea.prototype.testSeparatingAxisTheorem = function (other) {
            var poly1 = this;
            var poly2 = other;
            var axes = poly1.getAxes().concat(poly2.getAxes());
            var minOverlap = Number.MAX_VALUE;
            var minAxis = null;
            var minIndex = -1;
            for (var i = 0; i < axes.length; i++) {
                var proj1 = poly1.project(axes[i]);
                var proj2 = poly2.project(axes[i]);
                var overlap = proj1.getOverlap(proj2);
                if (overlap <= 0) {
                    return null;
                }
                else {
                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        minAxis = axes[i];
                        minIndex = i;
                    }
                }
            }
            // Sanity check
            if (minIndex === -1) {
                return null;
            }
            return minAxis.normalize().scale(minOverlap);
        };
        /**
         * Project the edges of the polygon along a specified axis
         */
        PolygonArea.prototype.project = function (axis) {
            var points = this.getTransformedPoints();
            var len = points.length;
            var min = Number.MAX_VALUE;
            var max = -Number.MAX_VALUE;
            for (var i = 0; i < len; i++) {
                var scalar = points[i].dot(axis);
                min = Math.min(min, scalar);
                max = Math.max(max, scalar);
            }
            return new Algebra_6.Projection(min, max);
        };
        /* istanbul ignore next */
        PolygonArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_2.Color.Red.clone(); }
            ctx.beginPath();
            ctx.strokeStyle = color.toString();
            // Iterate through the supplied points and construct a 'polygon'
            var firstPoint = this.getTransformedPoints()[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this.getTransformedPoints().forEach(function (point) {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            ctx.stroke();
        };
        return PolygonArea;
    }());
    exports.PolygonArea = PolygonArea;
});
define("Collision/BoundingBox", ["require", "exports", "Collision/PolygonArea", "Algebra", "Drawing/Color"], function (require, exports, PolygonArea_3, Algebra_7, Color_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Axis Aligned collision primitive for Excalibur.
     */
    var BoundingBox = (function () {
        /**
         * @param left    x coordinate of the left edge
         * @param top     y coordinate of the top edge
         * @param right   x coordinate of the right edge
         * @param bottom  y coordinate of the bottom edge
         */
        function BoundingBox(left, top, right, bottom) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            if (right === void 0) { right = 0; }
            if (bottom === void 0) { bottom = 0; }
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        BoundingBox.fromPoints = function (points) {
            var minX = Infinity;
            var minY = Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            for (var i = 0; i < points.length; i++) {
                if (points[i].x < minX) {
                    minX = points[i].x;
                }
                if (points[i].x > maxX) {
                    maxX = points[i].x;
                }
                if (points[i].y < minY) {
                    minY = points[i].y;
                }
                if (points[i].y > maxY) {
                    maxY = points[i].y;
                }
            }
            return new BoundingBox(minX, minY, maxX, maxY);
        };
        /**
         * Returns the calculated width of the bounding box
         */
        BoundingBox.prototype.getWidth = function () {
            return this.right - this.left;
        };
        /**
         * Returns the calculated height of the bounding box
         */
        BoundingBox.prototype.getHeight = function () {
            return this.bottom - this.top;
        };
        /**
         * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default
         */
        BoundingBox.prototype.rotate = function (angle, point) {
            if (point === void 0) { point = Algebra_7.Vector.Zero.clone(); }
            var points = this.getPoints().map(function (p) { return p.rotate(angle, point); });
            return BoundingBox.fromPoints(points);
        };
        /**
         * Returns the perimeter of the bounding box
         */
        BoundingBox.prototype.getPerimeter = function () {
            var wx = this.getWidth();
            var wy = this.getHeight();
            return 2 * (wx + wy);
        };
        BoundingBox.prototype.getPoints = function () {
            var results = [];
            results.push(new Algebra_7.Vector(this.left, this.top));
            results.push(new Algebra_7.Vector(this.right, this.top));
            results.push(new Algebra_7.Vector(this.right, this.bottom));
            results.push(new Algebra_7.Vector(this.left, this.bottom));
            return results;
        };
        /**
         * Creates a Polygon collision area from the points of the bounding box
         */
        BoundingBox.prototype.toPolygon = function (actor) {
            return new PolygonArea_3.PolygonArea({
                body: actor ? actor.body : null,
                points: this.getPoints(),
                pos: Algebra_7.Vector.Zero.clone()
            });
        };
        /**
         * Determines whether a ray intersects with a bounding box
         */
        BoundingBox.prototype.rayCast = function (ray, farClipDistance) {
            if (farClipDistance === void 0) { farClipDistance = Infinity; }
            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/ 
            var tmin = -Infinity;
            var tmax = +Infinity;
            var xinv = ray.dir.x === 0 ? Number.MAX_VALUE : (1 / ray.dir.x);
            var yinv = ray.dir.y === 0 ? Number.MAX_VALUE : (1 / ray.dir.y);
            var tx1 = (this.left - ray.pos.x) * xinv;
            var tx2 = (this.right - ray.pos.x) * xinv;
            tmin = Math.min(tx1, tx2);
            tmax = Math.max(tx1, tx2);
            var ty1 = (this.top - ray.pos.y) * yinv;
            var ty2 = (this.bottom - ray.pos.y) * yinv;
            tmin = Math.max(tmin, Math.min(ty1, ty2));
            tmax = Math.min(tmax, Math.max(ty1, ty2));
            return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
        };
        BoundingBox.prototype.rayCastTime = function (ray, farClipDistance) {
            if (farClipDistance === void 0) { farClipDistance = Infinity; }
            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/ 
            var tmin = -Infinity;
            var tmax = +Infinity;
            var xinv = ray.dir.x === 0 ? Number.MAX_VALUE : (1 / ray.dir.x);
            var yinv = ray.dir.y === 0 ? Number.MAX_VALUE : (1 / ray.dir.y);
            var tx1 = (this.left - ray.pos.x) * xinv;
            var tx2 = (this.right - ray.pos.x) * xinv;
            tmin = Math.min(tx1, tx2);
            tmax = Math.max(tx1, tx2);
            var ty1 = (this.top - ray.pos.y) * yinv;
            var ty2 = (this.bottom - ray.pos.y) * yinv;
            tmin = Math.max(tmin, Math.min(ty1, ty2));
            tmax = Math.min(tmax, Math.max(ty1, ty2));
            if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
                return tmin;
            }
            return -1;
        };
        BoundingBox.prototype.contains = function (val) {
            if (val instanceof Algebra_7.Vector) {
                return (this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x);
            }
            else if (val instanceof BoundingBox) {
                if (this.left < val.left &&
                    this.top < val.top &&
                    val.bottom < this.bottom &&
                    val.right < this.right) {
                    return true;
                }
                return false;
            }
            return false;
        };
        /**
         * Combines this bounding box and another together returning a new bounding box
         * @param other  The bounding box to combine
         */
        BoundingBox.prototype.combine = function (other) {
            var compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
            return compositeBB;
        };
        /**
         * Test wether this bounding box collides with another returning,
         * the intersection vector that can be used to resolve the collision. If there
         * is no collision null is returned.
         * @param collidable  Other collidable to test
         */
        BoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof BoundingBox) {
                var other = collidable;
                var totalBoundingBox = this.combine(other);
                // If the total bounding box is less than the sum of the 2 bounds then there is collision
                if (totalBoundingBox.getWidth() < other.getWidth() + this.getWidth() &&
                    totalBoundingBox.getHeight() < other.getHeight() + this.getHeight()) {
                    // collision
                    var overlapX = 0;
                    if (this.right >= other.left && this.right <= other.right) {
                        overlapX = other.left - this.right;
                    }
                    else {
                        overlapX = other.right - this.left;
                    }
                    var overlapY = 0;
                    if (this.top <= other.bottom && this.top >= other.top) {
                        overlapY = other.bottom - this.top;
                    }
                    else {
                        overlapY = other.top - this.bottom;
                    }
                    if (Math.abs(overlapX) < Math.abs(overlapY)) {
                        return new Algebra_7.Vector(overlapX, 0);
                    }
                    else {
                        return new Algebra_7.Vector(0, overlapY);
                    }
                }
                else {
                    return null;
                }
            }
            return null;
        };
        /* istanbul ignore next */
        BoundingBox.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_3.Color.Yellow; }
            ctx.strokeStyle = color.toString();
            ctx.strokeRect(this.left, this.top, this.getWidth(), this.getHeight());
        };
        return BoundingBox;
    }());
    exports.BoundingBox = BoundingBox;
});
define("Collision/EdgeArea", ["require", "exports", "Collision/BoundingBox", "Collision/CollisionJumpTable", "Collision/CircleArea", "Collision/PolygonArea", "Algebra", "Physics", "Drawing/Color"], function (require, exports, BoundingBox_3, CollisionJumpTable_3, CircleArea_2, PolygonArea_4, Algebra_8, Physics_4, Color_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EdgeArea = (function () {
        function EdgeArea(options) {
            this.begin = options.begin || Algebra_8.Vector.Zero.clone();
            this.end = options.end || Algebra_8.Vector.Zero.clone();
            this.body = options.body || null;
            this.pos = this.getCenter();
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        EdgeArea.prototype.getCenter = function () {
            var pos = this.begin.average(this.end).add(this._getBodyPos());
            return pos;
        };
        EdgeArea.prototype._getBodyPos = function () {
            var bodyPos = Algebra_8.Vector.Zero.clone();
            if (this.body.pos) {
                bodyPos = this.body.pos;
            }
            return bodyPos;
        };
        EdgeArea.prototype._getTransformedBegin = function () {
            var angle = this.body ? this.body.rotation : 0;
            return this.begin.rotate(angle).add(this._getBodyPos());
        };
        EdgeArea.prototype._getTransformedEnd = function () {
            var angle = this.body ? this.body.rotation : 0;
            return this.end.rotate(angle).add(this._getBodyPos());
        };
        /**
         * Returns the slope of the line in the form of a vector
         */
        EdgeArea.prototype.getSlope = function () {
            var begin = this._getTransformedBegin();
            var end = this._getTransformedEnd();
            var distance = begin.distance(end);
            return end.sub(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         */
        EdgeArea.prototype.getLength = function () {
            var begin = this._getTransformedBegin();
            var end = this._getTransformedEnd();
            var distance = begin.distance(end);
            return distance;
        };
        /**
         * Tests if a point is contained in this collision area
         */
        EdgeArea.prototype.contains = function () {
            return false;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            var numerator = this._getTransformedBegin().sub(ray.pos);
            // Test is line and ray are parallel and non intersecting
            if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
                return null;
            }
            // Lines are parallel
            var divisor = (ray.dir.cross(this.getSlope()));
            if (divisor === 0) {
                return null;
            }
            var t = numerator.cross(this.getSlope()) / divisor;
            if (t >= 0 && t <= max) {
                var u = (numerator.cross(ray.dir) / divisor) / this.getLength();
                if (u >= 0 && u <= 1) {
                    return ray.getPoint(t);
                }
            }
            return null;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.collide = function (area) {
            if (area instanceof CircleArea_2.CircleArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollideCircleEdge(area, this);
            }
            else if (area instanceof PolygonArea_4.PolygonArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollidePolygonEdge(area, this);
            }
            else if (area instanceof EdgeArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollideEdgeEdge();
            }
            else {
                throw new Error("Edge could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        EdgeArea.prototype.getFurthestPoint = function (direction) {
            var transformedBegin = this._getTransformedBegin();
            var transformedEnd = this._getTransformedEnd();
            if (direction.dot(transformedBegin) > 0) {
                return transformedBegin;
            }
            else {
                return transformedEnd;
            }
        };
        /**
         * Get the axis aligned bounding box for the circle area
         */
        EdgeArea.prototype.getBounds = function () {
            var transformedBegin = this._getTransformedBegin();
            var transformedEnd = this._getTransformedEnd();
            return new BoundingBox_3.BoundingBox(Math.min(transformedBegin.x, transformedEnd.x), Math.min(transformedBegin.y, transformedEnd.y), Math.max(transformedBegin.x, transformedEnd.x), Math.max(transformedBegin.y, transformedEnd.y));
        };
        /**
         * Get the axis associated with the edge
         */
        EdgeArea.prototype.getAxes = function () {
            var e = this._getTransformedEnd().sub(this._getTransformedBegin());
            var edgeNormal = e.normal();
            var axes = [];
            axes.push(edgeNormal);
            axes.push(edgeNormal.negate());
            axes.push(edgeNormal.normal());
            axes.push(edgeNormal.normal().negate());
            return axes;
        };
        /**
         * Get the moment of inertia for an edge
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        EdgeArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_4.Physics.defaultMass;
            var length = this.end.sub(this.begin).distance() / 2;
            return mass * length * length;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.recalc = function () {
            // edges don't have any cached data
        };
        /**
         * Project the edge along a specified axis
         */
        EdgeArea.prototype.project = function (axis) {
            var scalars = [];
            var points = [this._getTransformedBegin(), this._getTransformedEnd()];
            var len = points.length;
            for (var i = 0; i < len; i++) {
                scalars.push(points[i].dot(axis));
            }
            return new Algebra_8.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /* istanbul ignore next */
        EdgeArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_4.Color.Red.clone(); }
            ctx.strokeStyle = color.toString();
            ctx.beginPath();
            ctx.moveTo(this.begin.x, this.begin.y);
            ctx.lineTo(this.end.x, this.end.y);
            ctx.closePath();
            ctx.stroke();
        };
        return EdgeArea;
    }());
    exports.EdgeArea = EdgeArea;
});
define("Util/DrawUtil", ["require", "exports", "Drawing/Color"], function (require, exports, Color_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Draw a line on canvas context
     *
     * @param ctx The canvas context
     * @param color The color of the line
     * @param x1 The start x coordinate
     * @param y1 The start y coordinate
     * @param x2 The ending x coordinate
     * @param y2 The ending y coordinate
     * @param thickness The line thickness
     * @param cap The [[LineCapStyle]] (butt, round, or square)
     */
    /* istanbul ignore next */
    function line(ctx, color, x1, y1, x2, y2, thickness, cap) {
        if (color === void 0) { color = Color_5.Color.Red.clone(); }
        if (thickness === void 0) { thickness = 1; }
        if (cap === void 0) { cap = 'butt'; }
        ctx.beginPath();
        ctx.lineWidth = thickness;
        ctx.lineCap = cap;
        ctx.strokeStyle = color.toString();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.closePath();
        ctx.stroke();
    }
    exports.line = line;
    /**
     * Draw the vector as a point onto the canvas.
     */
    /* istanbul ignore next */
    function point(ctx, color, point) {
        if (color === void 0) { color = Color_5.Color.Red.clone(); }
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
    }
    exports.point = point;
    /**
     * Draw the vector as a line onto the canvas starting a origin point.
     */
    /* istanbul ignore next */
    function vector(ctx, color, origin, vector, scale) {
        if (scale === void 0) { scale = 1.0; }
        var c = color ? color.toString() : 'blue';
        var v = vector.scale(scale);
        ctx.beginPath();
        ctx.strokeStyle = c;
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(origin.x + v.x, origin.y + v.y);
        ctx.closePath();
        ctx.stroke();
    }
    exports.vector = vector;
    /**
     * Draw a round rectangle on a canvas context
     *
     * @param ctx The canvas context
     * @param x The top-left x coordinate
     * @param y The top-left y coordinate
     * @param width The width of the rectangle
     * @param height The height of the rectangle
     * @param radius The border radius of the rectangle
     * @param fill The [[Color]] to fill rectangle with
     * @param stroke The [[Color]] to stroke rectangle with
     */
    function roundRect(ctx, x, y, width, height, radius, stroke, fill) {
        if (radius === void 0) { radius = 5; }
        if (stroke === void 0) { stroke = Color_5.Color.White; }
        if (fill === void 0) { fill = null; }
        var br;
        if (typeof radius === 'number') {
            br = { tl: radius, tr: radius, br: radius, bl: radius };
        }
        else {
            var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
            for (var prop in defaultRadius) {
                if (defaultRadius.hasOwnProperty(prop)) {
                    var side = prop;
                    br[side] = radius[side] || defaultRadius[side];
                }
            }
        }
        ctx.beginPath();
        ctx.moveTo(x + br.tl, y);
        ctx.lineTo(x + width - br.tr, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
        ctx.lineTo(x + width, y + height - br.br);
        ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
        ctx.lineTo(x + br.bl, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
        ctx.lineTo(x, y + br.tl);
        ctx.quadraticCurveTo(x, y, x + br.tl, y);
        ctx.closePath();
        if (fill) {
            ctx.fillStyle = fill.toString();
            ctx.fill();
        }
        if (stroke) {
            ctx.strokeStyle = stroke.toString();
            ctx.stroke();
        }
    }
    exports.roundRect = roundRect;
    function circle(ctx, x, y, radius, stroke, fill) {
        if (stroke === void 0) { stroke = Color_5.Color.White; }
        if (fill === void 0) { fill = null; }
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.closePath();
        if (fill) {
            ctx.fillStyle = fill.toString();
            ctx.fill();
        }
        if (stroke) {
            ctx.strokeStyle = stroke.toString();
            ctx.stroke();
        }
    }
    exports.circle = circle;
});
define("Util/Log", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Logging level that Excalibur will tag
     */
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Debug"] = 0] = "Debug";
        LogLevel[LogLevel["Info"] = 1] = "Info";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Error"] = 3] = "Error";
        LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    /**
     * Static singleton that represents the logging facility for Excalibur.
     * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
     * Derive from [[IAppender]] to create your own logging appenders.
     *
     * [[include:Logger.md]]
     */
    var Logger = (function () {
        function Logger() {
            this._appenders = [];
            /**
             * Gets or sets the default logging level. Excalibur will only log
             * messages if equal to or above this level. Default: [[LogLevel.Info]]
             */
            this.defaultLevel = LogLevel.Info;
            if (Logger._instance) {
                throw new Error('Logger is a singleton');
            }
            Logger._instance = this;
            // Default console appender
            Logger._instance.addAppender(new ConsoleAppender());
            return Logger._instance;
        }
        /**
         * Gets the current static instance of Logger
         */
        Logger.getInstance = function () {
            if (Logger._instance == null) {
                Logger._instance = new Logger();
            }
            return Logger._instance;
        };
        /**
         * Adds a new [[IAppender]] to the list of appenders to write to
         */
        Logger.prototype.addAppender = function (appender) {
            this._appenders.push(appender);
        };
        /**
         * Clears all appenders from the logger
         */
        Logger.prototype.clearAppenders = function () {
            this._appenders.length = 0;
        };
        /**
         * Logs a message at a given LogLevel
         * @param level  The LogLevel`to log the message at
         * @param args   An array of arguments to write to an appender
         */
        Logger.prototype._log = function (level, args) {
            if (level == null) {
                level = this.defaultLevel;
            }
            var i = 0, len = this._appenders.length;
            for (i; i < len; i++) {
                if (level >= this.defaultLevel) {
                    this._appenders[i].log(level, args);
                }
            }
        };
        /**
         * Writes a log message at the [[LogLevel.Debug]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.debug = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Debug, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Info]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Info, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Warn]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Warn, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Error]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Error, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Fatal]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.fatal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Fatal, args);
        };
        return Logger;
    }());
    Logger._instance = null;
    exports.Logger = Logger;
    /**
     * Console appender for browsers (i.e. `console.log`)
     */
    var ConsoleAppender = (function () {
        function ConsoleAppender() {
        }
        /**
         * Logs a message at the given [[LogLevel]]
         * @param level  Level to log at
         * @param args   Arguments to log
         */
        ConsoleAppender.prototype.log = function (level, args) {
            // Check for console support
            if (!console && !console.log && console.warn && console.error) {
                // todo maybe do something better than nothing
                return;
            }
            // Create a new console args array
            var consoleArgs = [];
            consoleArgs.unshift.apply(consoleArgs, args);
            consoleArgs.unshift('[' + LogLevel[level] + '] : ');
            if (level < LogLevel.Warn) {
                // Call .log for Debug/Info
                if (console.log.apply) {
                    // this is required on some older browsers that don't support apply on console.log :(
                    console.log.apply(console, consoleArgs);
                }
                else {
                    console.log(consoleArgs.join(' '));
                }
            }
            else if (level < LogLevel.Error) {
                // Call .warn for Warn
                if (console.warn.apply) {
                    console.warn.apply(console, consoleArgs);
                }
                else {
                    console.warn(consoleArgs.join(' '));
                }
            }
            else {
                // Call .error for Error/Fatal
                if (console.error.apply) {
                    console.error.apply(console, consoleArgs);
                }
                else {
                    console.error(consoleArgs.join(' '));
                }
            }
        };
        return ConsoleAppender;
    }());
    exports.ConsoleAppender = ConsoleAppender;
    /**
     * On-screen (canvas) appender
     */
    var ScreenAppender = (function () {
        /**
         * @param width   Width of the screen appender in pixels
         * @param height  Height of the screen appender in pixels
         */
        function ScreenAppender(width, height) {
            // @todo Clean this up
            this._messages = [];
            this._canvas = document.createElement('canvas');
            this._canvas.width = width || window.innerWidth;
            this._canvas.height = height || window.innerHeight;
            this._canvas.style.position = 'absolute';
            this._ctx = this._canvas.getContext('2d');
            document.body.appendChild(this._canvas);
        }
        /**
         * Logs a message at the given [[LogLevel]]
         * @param level  Level to log at
         * @param args   Arguments to log
         */
        ScreenAppender.prototype.log = function (level, args) {
            var message = args.join(',');
            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
            this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
            var pos = 10;
            var opacity = 1.0;
            for (var i = 0; i < this._messages.length; i++) {
                this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
                this._ctx.fillText(this._messages[i], 200, pos);
                pos += 10;
                opacity = opacity > 0 ? opacity - .05 : 0;
            }
        };
        return ScreenAppender;
    }());
    exports.ScreenAppender = ScreenAppender;
});
define("Util/Decorators", ["require", "exports", "Util/Log", "Util/Util"], function (require, exports, Log_1, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
     * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
     */
    function obsolete(options) {
        options = Util.extend({}, { message: 'This method will be removed in future versions of Excalibur.', alternateMethod: null }, options);
        return function (target, property, descriptor) {
            if (!(typeof descriptor.value === 'function' ||
                typeof descriptor.get === 'function' ||
                typeof descriptor.set === 'function')) {
                throw new SyntaxError('Only functions/getters/setters can be marked as obsolete');
            }
            var methodSignature = "" + (target.name || '') + (target.name ? '.' : '') + property;
            var message = methodSignature + " is marked obsolete: " + options.message +
                (options.alternateMethod ? " Use " + options.alternateMethod + " instead" : '');
            var method = Util.extend({}, descriptor);
            if (descriptor.value) {
                method.value = function () {
                    Log_1.Logger.getInstance().warn(message);
                    return descriptor.value.apply(this, arguments);
                };
                return method;
            }
            if (descriptor.get) {
                method.get = function () {
                    Log_1.Logger.getInstance().warn(message);
                    return descriptor.get.apply(this, arguments);
                };
            }
            if (descriptor.set) {
                method.set = function () {
                    Log_1.Logger.getInstance().warn(message);
                    return descriptor.set.apply(this, arguments);
                };
            }
            return method;
        };
    }
    exports.obsolete = obsolete;
});
define("Collision/Body", ["require", "exports", "Physics", "Collision/EdgeArea", "Collision/CircleArea", "Collision/PolygonArea", "Collision/Pair", "Algebra", "Drawing/Color", "Util/DrawUtil", "Util/Decorators"], function (require, exports, Physics_5, EdgeArea_3, CircleArea_3, PolygonArea_5, Pair_1, Algebra_9, Color_6, DrawUtil, Decorators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Body = (function () {
        /**
         * Constructs a new physics body associated with an actor
         */
        function Body(actor) {
            this.actor = actor;
            /**
             * [ICollisionArea|Collision area] of this physics body, defines the shape for rigid body collision
             */
            this.collisionArea = null;
            /**
             * The (x, y) position of the actor this will be in the middle of the actor if the
             * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
             * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
             */
            this.pos = new Algebra_9.Vector(0, 0);
            /**
             * The position of the actor last frame (x, y) in pixels
             */
            this.oldPos = new Algebra_9.Vector(0, 0);
            /**
             * The current velocity vector (vx, vy) of the actor in pixels/second
             */
            this.vel = new Algebra_9.Vector(0, 0);
            /**
             * The velocity of the actor last frame (vx, vy) in pixels/second
             */
            this.oldVel = new Algebra_9.Vector(0, 0);
            /**
             * The curret acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
             * be useful to simulate a gravitational effect.
             */
            this.acc = new Algebra_9.Vector(0, 0);
            /**
             * The current torque applied to the actor
             */
            this.torque = 0;
            /**
             * The current mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            this.mass = 1.0;
            /**
             * The current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            this.moi = 1000;
            /**
             * The current "motion" of the actor, used to calculated sleep in the physics simulation
             */
            this.motion = 10;
            /**
             * The coefficient of friction on this actor
             */
            this.friction = .99;
            /**
             * The coefficient of restitution of this actor, represents the amount of energy preserved after collision
             */
            this.restitution = .2;
            /**
             * The rotation of the actor in radians
             */
            this.rotation = 0; // radians
            /**
             * The rotational velocity of the actor in radians/second
             */
            this.rx = 0; //radians/sec
            this._totalMtv = Algebra_9.Vector.Zero.clone();
        }
        /**
         * Add minimum translation vectors accumulated during the current frame to resolve collisions.
         */
        Body.prototype.addMtv = function (mtv) {
            this._totalMtv.addEqual(mtv);
        };
        /**
         * Applies the accumulated translation vectors to the actors position
         */
        Body.prototype.applyMtv = function () {
            this.pos.addEqual(this._totalMtv);
            this._totalMtv.setTo(0, 0);
        };
        /**
         * Returns the body's [[BoundingBox]] calculated for this instant in world space.
         */
        Body.prototype.getBounds = function () {
            if (Physics_5.Physics.collisionResolutionStrategy === Physics_5.CollisionResolutionStrategy.Box) {
                return this.actor.getBounds();
            }
            else {
                return this.collisionArea.getBounds();
            }
        };
        /**
         * Returns the actor's [[BoundingBox]] relative to the actors position.
         */
        Body.prototype.getRelativeBounds = function () {
            if (Physics_5.Physics.collisionResolutionStrategy === Physics_5.CollisionResolutionStrategy.Box) {
                return this.actor.getRelativeBounds();
            }
            else {
                return this.actor.getRelativeBounds();
            }
        };
        /**
         * Updates the collision area geometry and internal caches
         */
        Body.prototype.update = function () {
            if (this.collisionArea) {
                this.collisionArea.recalc();
            }
        };
        /**
         * Sets up a box collision area based on the current bounds of the associated actor of this physics body.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useBoxCollision = function (center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            this.collisionArea = new PolygonArea_5.PolygonArea({
                body: this,
                points: this.actor.getRelativeBounds().getPoints(),
                pos: center // position relative to actor
            });
            // in case of a nan moi, coalesce to a safe default
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up a polygon collision area based on a list of of points relative to the anchor of the associated actor of this physics body.
         *
         * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.usePolygonCollision = function (points, center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            this.collisionArea = new PolygonArea_5.PolygonArea({
                body: this,
                points: points,
                pos: center // position relative to actor
            });
            // in case of a nan moi, collesce to a safe default
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up a [[CircleArea|circle collision area]] with a specified radius in pixels.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useCircleCollision = function (radius, center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            if (!radius) {
                radius = this.actor.getWidth() / 2;
            }
            this.collisionArea = new CircleArea_3.CircleArea({
                body: this,
                radius: radius,
                pos: center
            });
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up an [[EdgeArea|edge collision]] with a start point and an end point relative to the anchor of the associated actor
         * of this physics body.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useEdgeCollision = function (begin, end) {
            this.collisionArea = new EdgeArea_3.EdgeArea({
                begin: begin,
                end: end,
                body: this
            });
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /* istanbul ignore next */
        Body.prototype.debugDraw = function (ctx) {
            // Draw motion vectors
            if (Physics_5.Physics.showMotionVectors) {
                DrawUtil.vector(ctx, Color_6.Color.Yellow, this.pos, (this.acc.add(Physics_5.Physics.acc)));
                DrawUtil.vector(ctx, Color_6.Color.Red, this.pos, (this.vel));
                DrawUtil.point(ctx, Color_6.Color.Red, this.pos);
            }
            if (Physics_5.Physics.showBounds) {
                this.getBounds().debugDraw(ctx, Color_6.Color.Yellow);
            }
            if (Physics_5.Physics.showArea) {
                this.collisionArea.debugDraw(ctx, Color_6.Color.Green);
            }
        };
        /**
         * Returns a boolean indicating whether this body collided with
         * or was in stationary contact with
         * the body of the other [[Actor]]
         */
        Body.prototype.touching = function (other) {
            var pair = new Pair_1.Pair(this, other.body);
            pair.collide();
            if (pair.collision) {
                return true;
            }
            return false;
        };
        /**
         * Returns a boolean indicating true if this body COLLIDED with
         * the body of the other Actor in the last frame, and they are no longer touching
         * in this frame
         */
        Body.prototype.wasTouching = function (other, game) {
            var pair = new Pair_1.Pair(this, other.body);
            var wasTouchingLastFrame = false;
            if (game && game.stats.prevFrame && game.stats.prevFrame.physics.collidersHash[pair.id]) {
                wasTouchingLastFrame = true;
            }
            var currentlyTouching = this.touching(other);
            return wasTouchingLastFrame && !currentlyTouching;
        };
        return Body;
    }());
    __decorate([
        Decorators_1.obsolete({ message: 'will be removed in v0.15, use the collisionend event instead' })
    ], Body.prototype, "wasTouching", null);
    exports.Body = Body;
});
define("Collision/Pair", ["require", "exports", "Physics", "Drawing/Color", "Actor", "Util/DrawUtil"], function (require, exports, Physics_6, Color_7, Actor_2, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Models a potential collision between 2 bodies
     */
    var Pair = (function () {
        function Pair(bodyA, bodyB) {
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.id = null;
            this.collision = null;
            this.id = Pair.calculatePairHash(bodyA, bodyB);
        }
        Object.defineProperty(Pair.prototype, "canCollide", {
            /**
             * Returns whether or not it is possible for the pairs to collide
             */
            get: function () {
                var actorA = this.bodyA.actor;
                var actorB = this.bodyB.actor;
                // if both are fixed short circuit
                if (actorA.collisionType === Actor_2.CollisionType.Fixed && actorB.collisionType === Actor_2.CollisionType.Fixed) {
                    return false;
                }
                // if the other is prevent collision or is dead short circuit
                if (actorB.collisionType === Actor_2.CollisionType.PreventCollision || actorB.isKilled()) {
                    return false;
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Runs the collison intersection logic on the members of this pair
         */
        Pair.prototype.collide = function () {
            this.collision = this.bodyA.collisionArea.collide(this.bodyB.collisionArea);
        };
        /**
         * Resovles the collision body position and velocity if a collision occured
         */
        Pair.prototype.resolve = function (strategy) {
            if (this.collision) {
                this.collision.resolve(strategy);
            }
        };
        /**
         * Calculates the unique pair hash id for this collision pair
         */
        Pair.calculatePairHash = function (bodyA, bodyB) {
            if (bodyA.actor.id < bodyB.actor.id) {
                return "#" + bodyA.actor.id + "+" + bodyB.actor.id;
            }
            else {
                return "#" + bodyB.actor.id + "+" + bodyA.actor.id;
            }
        };
        /* istanbul ignore next */
        Pair.prototype.debugDraw = function (ctx) {
            if (this.collision) {
                if (Physics_6.Physics.showContacts) {
                    DrawUtil.point(ctx, Color_7.Color.Red, this.collision.point);
                }
                if (Physics_6.Physics.showCollisionNormals) {
                    DrawUtil.vector(ctx, Color_7.Color.Cyan, this.collision.point, this.collision.normal, 30);
                }
            }
        };
        return Pair;
    }());
    exports.Pair = Pair;
});
define("Debug", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Debug statistics and flags for Excalibur. If polling these values, it would be
     * best to do so on the `postupdate` event for [[Engine]], after all values have been
     * updated during a frame.
     */
    var Debug = (function () {
        function Debug() {
            /**
             * Performance statistics
             */
            this.stats = {
                /**
                 * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
                 * Best accessed on [[postframe]] event. See [[IFrameStats]]
                 */
                currFrame: new FrameStats(),
                /**
                 * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
                 * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[IFrameStats]]
                 */
                prevFrame: new FrameStats()
            };
        }
        return Debug;
    }());
    exports.Debug = Debug;
    /**
     * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid
     * creating instances of this every frame.
     */
    var FrameStats = (function () {
        function FrameStats() {
            this._id = 0;
            this._delta = 0;
            this._fps = 0;
            this._actorStats = {
                alive: 0,
                killed: 0,
                ui: 0,
                get remaining() {
                    return this.alive - this.killed;
                },
                get total() {
                    return this.remaining + this.ui;
                }
            };
            this._durationStats = {
                update: 0,
                draw: 0,
                get total() {
                    return this.update + this.draw;
                }
            };
            this._physicsStats = new PhysicsStats();
        }
        /**
         * Zero out values or clone other IFrameStat stats. Allows instance reuse.
         *
         * @param [otherStats] Optional stats to clone
         */
        FrameStats.prototype.reset = function (otherStats) {
            if (otherStats) {
                this.id = otherStats.id;
                this.delta = otherStats.delta;
                this.fps = otherStats.fps;
                this.actors.alive = otherStats.actors.alive;
                this.actors.killed = otherStats.actors.killed;
                this.actors.ui = otherStats.actors.ui;
                this.duration.update = otherStats.duration.update;
                this.duration.draw = otherStats.duration.draw;
                this._physicsStats.reset(otherStats.physics);
            }
            else {
                this.id = this.delta = this.fps = 0;
                this.actors.alive = this.actors.killed = this.actors.ui = 0;
                this.duration.update = this.duration.draw = 0;
                this._physicsStats.reset();
            }
        };
        /**
         * Provides a clone of this instance.
         */
        FrameStats.prototype.clone = function () {
            var fs = new FrameStats();
            fs.reset(this);
            return fs;
        };
        Object.defineProperty(FrameStats.prototype, "id", {
            /**
             * Gets the frame's id
             */
            get: function () {
                return this._id;
            },
            /**
             * Sets the frame's id
             */
            set: function (value) {
                this._id = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "delta", {
            /**
             * Gets the frame's delta (time since last frame)
             */
            get: function () {
                return this._delta;
            },
            /**
             * Sets the frame's delta (time since last frame). Internal use only.
             * @internal
             */
            set: function (value) {
                this._delta = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "fps", {
            /**
             * Gets the frame's frames-per-second (FPS)
             */
            get: function () {
                return this._fps;
            },
            /**
             * Sets the frame's frames-per-second (FPS). Internal use only.
             * @internal
             */
            set: function (value) {
                this._fps = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "actors", {
            /**
             * Gets the frame's actor statistics
             */
            get: function () {
                return this._actorStats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "duration", {
            /**
             * Gets the frame's duration statistics
             */
            get: function () {
                return this._durationStats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "physics", {
            /**
             * Gets the frame's physics statistics
             */
            get: function () {
                return this._physicsStats;
            },
            enumerable: true,
            configurable: true
        });
        return FrameStats;
    }());
    exports.FrameStats = FrameStats;
    var PhysicsStats = (function () {
        function PhysicsStats() {
            this._pairs = 0;
            this._collisions = 0;
            this._collidersHash = {};
            this._fastBodies = 0;
            this._fastBodyCollisions = 0;
            this._broadphase = 0;
            this._narrowphase = 0;
        }
        /**
         * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
         *
         * @param [otherStats] Optional stats to clone
         */
        PhysicsStats.prototype.reset = function (otherStats) {
            if (otherStats) {
                this.pairs = otherStats.pairs;
                this.collisions = otherStats.collisions;
                this.collidersHash = otherStats.collidersHash;
                this.fastBodies = otherStats.fastBodies;
                this.fastBodyCollisions = otherStats.fastBodyCollisions;
                this.broadphase = otherStats.broadphase;
                this.narrowphase = otherStats.narrowphase;
            }
            else {
                this.pairs = this.collisions = this.fastBodies = 0;
                this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
                this.collidersHash = {};
            }
        };
        /**
         * Provides a clone of this instance.
         */
        PhysicsStats.prototype.clone = function () {
            var ps = new PhysicsStats();
            ps.reset(this);
            return ps;
        };
        Object.defineProperty(PhysicsStats.prototype, "pairs", {
            get: function () {
                return this._pairs;
            },
            set: function (value) {
                this._pairs = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "collisions", {
            get: function () {
                return this._collisions;
            },
            set: function (value) {
                this._collisions = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "collidersHash", {
            get: function () {
                return this._collidersHash;
            },
            set: function (colliders) {
                this._collidersHash = colliders;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "fastBodies", {
            get: function () {
                return this._fastBodies;
            },
            set: function (value) {
                this._fastBodies = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "fastBodyCollisions", {
            get: function () {
                return this._fastBodyCollisions;
            },
            set: function (value) {
                this._fastBodyCollisions = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "broadphase", {
            get: function () {
                return this._broadphase;
            },
            set: function (value) {
                this._broadphase = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "narrowphase", {
            get: function () {
                return this._narrowphase;
            },
            set: function (value) {
                this._narrowphase = value;
            },
            enumerable: true,
            configurable: true
        });
        return PhysicsStats;
    }());
    exports.PhysicsStats = PhysicsStats;
});
define("Interfaces/IEvented", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("EventDispatcher", ["require", "exports", "Events"], function (require, exports, Events_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur's internal event dispatcher implementation.
     * Callbacks are fired immediately after an event is published.
     * Typically you will use [[Class.eventDispatcher]] since most classes in
     * Excalibur inherit from [[Class]]. You will rarely create an `EventDispatcher`
     * yourself.
     *
     * [[include:Events.md]]
     */
    var EventDispatcher = (function () {
        /**
         * @param target  The object that will be the recipient of events from this event dispatcher
         */
        function EventDispatcher(target) {
            this._handlers = {};
            this._wiredEventDispatchers = [];
            this._target = target;
        }
        /**
         * Emits an event for target
         * @param eventName  The name of the event to publish
         * @param event      Optionally pass an event data object to the handler
         */
        EventDispatcher.prototype.emit = function (eventName, event) {
            if (!eventName) {
                // key not mapped
                return;
            }
            eventName = eventName.toLowerCase();
            var target = this._target;
            if (!event) {
                event = new Events_2.GameEvent();
            }
            event.target = target;
            var i, len;
            if (this._handlers[eventName]) {
                i = 0;
                len = this._handlers[eventName].length;
                for (i; i < len; i++) {
                    this._handlers[eventName][i].call(target, event);
                }
            }
            i = 0;
            len = this._wiredEventDispatchers.length;
            for (i; i < len; i++) {
                this._wiredEventDispatchers[i].emit(eventName, event);
            }
        };
        /**
         * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
         * @param eventName  The name of the event to subscribe to
         * @param handler    The handler callback to fire on this event
         */
        EventDispatcher.prototype.on = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            if (!this._handlers[eventName]) {
                this._handlers[eventName] = [];
            }
            this._handlers[eventName].push(handler);
            // meta event handlers
            if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
                this.emit('subscribe', new Events_2.SubscribeEvent(eventName, handler));
            }
        };
        /**
         * Unsubscribe an event handler(s) from an event. If a specific handler
         * is specified for an event, only that handler will be unsubscribed.
         * Otherwise all handlers will be unsubscribed for that event.
         *
         * @param eventName  The name of the event to unsubscribe
         * @param handler    Optionally the specific handler to unsubscribe
         *
         */
        EventDispatcher.prototype.off = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            var eventHandlers = this._handlers[eventName];
            if (eventHandlers) {
                // if no explicit handler is give with the event name clear all handlers
                if (!handler) {
                    this._handlers[eventName].length = 0;
                }
                else {
                    var index = eventHandlers.indexOf(handler);
                    this._handlers[eventName].splice(index, 1);
                }
            }
            // meta event handlers
            if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
                this.emit('unsubscribe', new Events_2.UnsubscribeEvent(eventName, handler));
            }
        };
        /**
         * Once listens to an event one time, then unsubscribes from that event
         *
         * @param eventName The name of the event to subscribe to once
         * @param handler   The handler of the event that will be auto unsubscribed
         */
        EventDispatcher.prototype.once = function (eventName, handler) {
            var _this = this;
            var metaHandler = function (event) {
                var ev = event || new Events_2.GameEvent();
                ev.target = ev.target || _this._target;
                _this.off(eventName, handler);
                handler.call(ev.target, ev);
            };
            this.on(eventName, metaHandler);
        };
        /**
         * Wires this event dispatcher to also recieve events from another
         */
        EventDispatcher.prototype.wire = function (eventDispatcher) {
            eventDispatcher._wiredEventDispatchers.push(this);
        };
        /**
         * Unwires this event dispatcher from another
         */
        EventDispatcher.prototype.unwire = function (eventDispatcher) {
            var index = eventDispatcher._wiredEventDispatchers.indexOf(this);
            if (index > -1) {
                eventDispatcher._wiredEventDispatchers.splice(index, 1);
            }
        };
        return EventDispatcher;
    }());
    exports.EventDispatcher = EventDispatcher;
});
define("Actions/ActionContext", ["require", "exports", "Actions/Action", "Promises", "Util/EasingFunctions"], function (require, exports, Actions, Promises_2, EasingFunctions_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The fluent Action API allows you to perform "actions" on
     * [[Actor|Actors]] such as following, moving, rotating, and
     * more. You can implement your own actions by implementing
     * the [[IAction]] interface.
     *
     * [[include:Actions.md]]
     */
    var ActionContext = (function () {
        function ActionContext() {
            this._actors = [];
            this._queues = [];
            if (arguments !== null) {
                this._actors = Array.prototype.slice.call(arguments, 0);
                this._queues = this._actors.map(function (a) {
                    return a.actionQueue;
                });
            }
        }
        /**
         * Clears all queued actions from the Actor
         */
        ActionContext.prototype.clearActions = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].clearActions();
            }
        };
        ActionContext.prototype.addActorToContext = function (actor) {
            this._actors.push(actor);
            // if we run into problems replace the line below with:
            this._queues.push(actor.actionQueue);
        };
        ActionContext.prototype.removeActorFromContext = function (actor) {
            var index = this._actors.indexOf(actor);
            if (index > -1) {
                this._actors.splice(index, 1);
                this._queues.splice(index, 1);
            }
        };
        /**
         * This method will move an actor to the specified `x` and `y` position over the
         * specified duration using a given [[EasingFunctions]] and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param x         The x location to move the actor to
         * @param y         The y location to move the actor to
         * @param duration  The time it should take the actor to move to the new location in milliseconds
         * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position
         */
        ActionContext.prototype.easeTo = function (x, y, duration, easingFcn) {
            if (easingFcn === void 0) { easingFcn = EasingFunctions_2.EasingFunctions.Linear; }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.EaseTo(this._actors[i], x, y, duration, easingFcn));
            }
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position at the
         * speed specified (in pixels per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param x      The x location to move the actor to
         * @param y      The y location to move the actor to
         * @param speed  The speed in pixels per second to move
         */
        ActionContext.prototype.moveTo = function (x, y, speed) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.MoveTo(this._actors[i], x, y, speed));
            }
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position by a
         * certain time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @param x     The x location to move the actor to
         * @param y     The y location to move the actor to
         * @param time  The time it should take the actor to move to the new location in milliseconds
         */
        ActionContext.prototype.moveBy = function (x, y, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.MoveBy(this._actors[i], x, y, time));
            }
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle at the speed
         * specified (in radians per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param angleRadians  The angle to rotate to in radians
         * @param speed         The angular velocity of the rotation specified in radians per second
         * @param rotationType  The [[RotationType]] to use for this rotation
         */
        ActionContext.prototype.rotateTo = function (angleRadians, speed, rotationType) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RotateTo(this._actors[i], angleRadians, speed, rotationType));
            }
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle by a certain
         * time (in milliseconds) and return back the actor. This method is part
         * of the actor 'Action' fluent API allowing action chaining.
         * @param angleRadians  The angle to rotate to in radians
         * @param time          The time it should take the actor to complete the rotation in milliseconds
         * @param rotationType  The [[RotationType]] to use for this rotation
         */
        ActionContext.prototype.rotateBy = function (angleRadians, time, rotationType) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RotateBy(this._actors[i], angleRadians, time, rotationType));
            }
            return this;
        };
        /**
         * This method will scale an actor to the specified size at the speed
         * specified (in magnitude increase per second) and return back the
         * actor. This method is part of the actor 'Action' fluent API allowing
         * action chaining.
         * @param sizeX   The scaling factor to apply on X axis
         * @param sizeY   The scaling factor to apply on Y axis
         * @param speedX  The speed of scaling specified in magnitude increase per second on X axis
         * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis
         */
        ActionContext.prototype.scaleTo = function (sizeX, sizeY, speedX, speedY) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.ScaleTo(this._actors[i], sizeX, sizeY, speedX, speedY));
            }
            return this;
        };
        /**
         * This method will scale an actor to the specified size by a certain time
         * (in milliseconds) and return back the actor. This method is part of the
         * actor 'Action' fluent API allowing action chaining.
         * @param sizeX   The scaling factor to apply on X axis
         * @param sizeY   The scaling factor to apply on Y axis
         * @param time    The time it should take to complete the scaling in milliseconds
         */
        ActionContext.prototype.scaleBy = function (sizeX, sizeY, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.ScaleBy(this._actors[i], sizeX, sizeY, time));
            }
            return this;
        };
        /**
         * This method will cause an actor to blink (become visible and not
         * visible). Optionally, you may specify the number of blinks. Specify the amount of time
         * the actor should be visible per blink, and the amount of time not visible.
         * This method is part of the actor 'Action' fluent API allowing action chaining.
         * @param timeVisible     The amount of time to stay visible per blink in milliseconds
         * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
         * @param numBlinks       The number of times to blink
         */
        ActionContext.prototype.blink = function (timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Blink(this._actors[i], timeVisible, timeNotVisible, numBlinks));
            }
            return this;
        };
        /**
         * This method will cause an actor's opacity to change from its current value
         * to the provided value by a specified time (in milliseconds). This method is
         * part of the actor 'Action' fluent API allowing action chaining.
         * @param opacity  The ending opacity
         * @param time     The time it should take to fade the actor (in milliseconds)
         */
        ActionContext.prototype.fade = function (opacity, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Fade(this._actors[i], opacity, time));
            }
            return this;
        };
        /**
         * This method will delay the next action from executing for a certain
         * amount of time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
         */
        ActionContext.prototype.delay = function (time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Delay(this._actors[i], time));
            }
            return this;
        };
        /**
         * This method will add an action to the queue that will remove the actor from the
         * scene once it has completed its previous actions. Any actions on the
         * action queue after this action will not be executed.
         */
        ActionContext.prototype.die = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Die(this._actors[i]));
            }
            return this;
        };
        /**
         * This method allows you to call an arbitrary method as the next action in the
         * action queue. This is useful if you want to execute code in after a specific
         * action, i.e An actor arrives at a destination after traversing a path
         */
        ActionContext.prototype.callMethod = function (method) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.CallMethod(this._actors[i], method));
            }
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions a certain number of times. If the number of repeats
         * is not specified it will repeat forever. This method is part of
         * the actor 'Action' fluent API allowing action chaining
         * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
         * will repeat forever
         */
        ActionContext.prototype.repeat = function (times) {
            if (!times) {
                this.repeatForever();
                return this;
            }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Repeat(this._actors[i], times, this._actors[i].actionQueue.getActions()));
            }
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions forever. This method is part of the actor 'Action'
         * fluent API allowing action chaining.
         */
        ActionContext.prototype.repeatForever = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RepeatForever(this._actors[i], this._actors[i].actionQueue.getActions()));
            }
            return this;
        };
        /**
         * This method will cause the actor to follow another at a specified distance
         * @param actor           The actor to follow
         * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
         */
        ActionContext.prototype.follow = function (actor, followDistance) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                if (followDistance === undefined) {
                    this._queues[i].add(new Actions.Follow(this._actors[i], actor));
                }
                else {
                    this._queues[i].add(new Actions.Follow(this._actors[i], actor, followDistance));
                }
            }
            return this;
        };
        /**
         * This method will cause the actor to move towards another until they
         * collide "meet" at a specified speed.
         * @param actor  The actor to meet
         * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
         */
        ActionContext.prototype.meet = function (actor, speed) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                if (speed === undefined) {
                    this._queues[i].add(new Actions.Meet(this._actors[i], actor));
                }
                else {
                    this._queues[i].add(new Actions.Meet(this._actors[i], actor, speed));
                }
            }
            return this;
        };
        /**
         * Returns a promise that resolves when the current action queue up to now
         * is finished.
         */
        ActionContext.prototype.asPromise = function () {
            var _this = this;
            var promises = this._queues.map(function (q, i) {
                var temp = new Promises_2.Promise();
                q.add(new Actions.CallMethod(_this._actors[i], function () {
                    temp.resolve();
                }));
                return temp;
            });
            return Promises_2.Promise.join.apply(this, promises);
        };
        return ActionContext;
    }());
    exports.ActionContext = ActionContext;
});
define("Actions/IActionable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Group", ["require", "exports", "Algebra", "Actions/ActionContext", "Actor", "Util/Log", "Class"], function (require, exports, Algebra_10, ActionContext_1, Actor_3, Log_2, Class_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Groups are used for logically grouping Actors so they can be acted upon
     * in bulk.
     *
     * [[include:Groups.md]]
     */
    var Group = (function (_super) {
        __extends(Group, _super);
        function Group(name, scene) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.scene = scene;
            _this._logger = Log_2.Logger.getInstance();
            _this._members = [];
            _this.actions = new ActionContext_1.ActionContext();
            if (scene == null) {
                _this._logger.error('Invalid constructor arguments passed to Group: ', name, ', scene must not be null!');
            }
            else {
                var existingGroup = scene.groups[name];
                if (existingGroup) {
                    _this._logger.warn('Group with name', name, 'already exists. This new group will replace it.');
                }
                scene.groups[name] = _this;
            }
            return _this;
        }
        Group.prototype.add = function (actorOrActors) {
            if (actorOrActors instanceof Actor_3.Actor) {
                actorOrActors = [].concat(actorOrActors);
            }
            var i = 0, len = actorOrActors.length, groupIdx;
            for (i; i < len; i++) {
                groupIdx = this.getMembers().indexOf(actorOrActors[i]);
                if (groupIdx === -1) {
                    this._members.push(actorOrActors[i]);
                    this.scene.add(actorOrActors[i]);
                    this.actions.addActorToContext(actorOrActors[i]);
                    this.eventDispatcher.wire(actorOrActors[i].eventDispatcher);
                }
            }
        };
        Group.prototype.remove = function (actor) {
            var index = this._members.indexOf(actor);
            if (index > -1) {
                this._members.splice(index, 1);
                this.actions.removeActorFromContext(actor);
                this.eventDispatcher.unwire(actor.eventDispatcher);
            }
        };
        Group.prototype.move = function (args) {
            var i = 0, members = this.getMembers(), len = members.length;
            if (arguments.length === 1 && args instanceof Algebra_10.Vector) {
                for (i; i < len; i++) {
                    members[i].pos.x += args.x;
                    members[i].pos.y += args.y;
                }
            }
            else if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
                var x = arguments[0];
                var y = arguments[1];
                for (i; i < len; i++) {
                    members[i].pos.x += x;
                    members[i].pos.y += y;
                }
            }
            else {
                this._logger.error('Invalid arguments passed to group move', this.name, 'args:', arguments);
            }
        };
        Group.prototype.rotate = function (angle) {
            if (typeof angle !== 'number') {
                this._logger.error('Invalid arguments passed to group rotate', this.name, 'args:', arguments);
                return;
            }
            for (var _i = 0, _a = this.getMembers(); _i < _a.length; _i++) {
                var member = _a[_i];
                member.rotation += angle;
            }
        };
        Group.prototype.on = function (eventName, handler) {
            this.eventDispatcher.on(eventName, handler);
        };
        Group.prototype.off = function (eventName, handler) {
            this.eventDispatcher.off(eventName, handler);
        };
        Group.prototype.emit = function (topic, event) {
            this.eventDispatcher.emit(topic, event);
        };
        Group.prototype.contains = function (actor) {
            return this.getMembers().indexOf(actor) > -1;
        };
        Group.prototype.getMembers = function () {
            return this._members;
        };
        Group.prototype.getRandomMember = function () {
            return this._members[Math.floor(Math.random() * this._members.length)];
        };
        Group.prototype.getBounds = function () {
            return this.getMembers().map(function (a) { return a.getBounds(); }).reduce(function (prev, curr) {
                return prev.combine(curr);
            });
        };
        return Group;
    }(Class_1.Class));
    exports.Group = Group;
});
/**
 * These effects can be applied to any bitmap image but are mainly used
 * for [[Sprite]] effects or [[Animation]] effects.
 *
 * [[include:SpriteEffects.md]]
 */
define("Drawing/SpriteEffects", ["require", "exports", "Drawing/Color"], function (require, exports, Color_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Applies the "Grayscale" effect to a sprite, removing color information.
     */
    var Grayscale = (function () {
        function Grayscale() {
        }
        Grayscale.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
            pixel[firstPixel + 0] = avg;
            pixel[firstPixel + 1] = avg;
            pixel[firstPixel + 2] = avg;
        };
        return Grayscale;
    }());
    exports.Grayscale = Grayscale;
    /**
     * Applies the "Invert" effect to a sprite, inverting the pixel colors.
     */
    var Invert = (function () {
        function Invert() {
        }
        Invert.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
            pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
            pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
        };
        return Invert;
    }());
    exports.Invert = Invert;
    /**
     * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
     */
    var Opacity = (function () {
        /**
         * @param opacity  The new opacity of the sprite from 0-1.0
         */
        function Opacity(opacity) {
            this.opacity = opacity;
        }
        Opacity.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 3] = Math.round(this.opacity * pixel[firstPixel + 3]);
            }
        };
        return Opacity;
    }());
    exports.Opacity = Opacity;
    /**
     * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
     * average of the original color and the provided color
     */
    var Colorize = (function () {
        /**
         * @param color  The color to apply to the sprite
         */
        function Colorize(color) {
            this.color = color;
        }
        Colorize.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
                pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
                pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
            }
        };
        return Colorize;
    }());
    exports.Colorize = Colorize;
    /**
     * Applies the "Lighten" effect to a sprite, changes the lightness of the color according to HSL
     */
    var Lighten = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Lighten(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Lighten.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).lighten(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Lighten;
    }());
    exports.Lighten = Lighten;
    /**
     * Applies the "Darken" effect to a sprite, changes the darkness of the color according to HSL
     */
    var Darken = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Darken(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Darken.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).darken(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Darken;
    }());
    exports.Darken = Darken;
    /**
     * Applies the "Saturate" effect to a sprite, saturates the color according to HSL
     */
    var Saturate = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Saturate(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Saturate.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).saturate(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Saturate;
    }());
    exports.Saturate = Saturate;
    /**
     * Applies the "Desaturate" effect to a sprite, desaturates the color according to HSL
     */
    var Desaturate = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Desaturate(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Desaturate.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).desaturate(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Desaturate;
    }());
    exports.Desaturate = Desaturate;
    /**
     * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
     * a given color
     */
    var Fill = (function () {
        /**
         * @param color  The color to apply to the sprite
         */
        function Fill(color) {
            this.color = color;
        }
        Fill.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 0] = this.color.r;
                pixel[firstPixel + 1] = this.color.g;
                pixel[firstPixel + 2] = this.color.b;
            }
        };
        return Fill;
    }());
    exports.Fill = Fill;
});
define("Interfaces/IDrawable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Interfaces/ILoadable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Resources/Resource", ["require", "exports", "Class", "Promises", "Util/Log"], function (require, exports, Class_2, Promises_3, Log_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The [[Resource]] type allows games built in Excalibur to load generic resources.
     * For any type of remote resource it is recommended to use [[Resource]] for preloading.
     *
     * [[include:Resources.md]]
     */
    var Resource = (function (_super) {
        __extends(Resource, _super);
        /**
         * @param path          Path to the remote resource
         * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
         * @param bustCache     Whether or not to cache-bust requests
         */
        function Resource(path, responseType, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            var _this = _super.call(this) || this;
            _this.path = path;
            _this.responseType = responseType;
            _this.bustCache = bustCache;
            _this.data = null;
            _this.logger = Log_3.Logger.getInstance();
            _this.onprogress = function () { return; };
            _this.oncomplete = function () { return; };
            _this.onerror = function () { return; };
            return _this;
        }
        /**
         * Returns true if the Resource is completely loaded and is ready
         * to be drawn.
         */
        Resource.prototype.isLoaded = function () {
            return this.data !== null;
        };
        Resource.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        Resource.prototype._cacheBust = function (uri) {
            var query = /\?\w*=\w*/;
            if (query.test(uri)) {
                uri += ('&__=' + Date.now());
            }
            else {
                uri += ('?__=' + Date.now());
            }
            return uri;
        };
        Resource.prototype._start = function () {
            this.logger.debug('Started loading resource ' + this.path);
        };
        /**
         * Begin loading the resource and returns a promise to be resolved on completion
         */
        Resource.prototype.load = function () {
            var _this = this;
            var complete = new Promises_3.Promise();
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                complete.resolve(this.data);
                this.oncomplete();
                return complete;
            }
            var request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.onloadstart = function () { _this._start(); };
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function () {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    _this.logger.error('Failed to load resource ', _this.path, ' server responded with error code', request.status);
                    _this.onerror(request.response);
                    complete.resolve(request.response);
                    return;
                }
                _this.data = _this.processData(request.response);
                _this.oncomplete();
                _this.logger.debug('Completed loading resource', _this.path);
                complete.resolve(_this.data);
            };
            request.send();
            return complete;
        };
        /**
         * Returns the loaded data once the resource is loaded
         */
        Resource.prototype.getData = function () {
            return this.data;
        };
        /**
         * Sets the data for this resource directly
         */
        Resource.prototype.setData = function (data) {
            this.data = this.processData(data);
        };
        /**
         * This method is meant to be overriden to handle any additional
         * processing. Such as decoding downloaded audio bits.
         */
        Resource.prototype.processData = function (data) {
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
            // Blob requires an object url
            if (this.responseType === 'blob') {
                return URL.createObjectURL(data);
            }
            return data;
        };
        return Resource;
    }(Class_2.Class));
    exports.Resource = Resource;
});
define("Resources/Texture", ["require", "exports", "Resources/Resource", "Promises", "Drawing/Sprite"], function (require, exports, Resource_1, Promises_4, Sprite_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The [[Texture]] object allows games built in Excalibur to load image resources.
     * [[Texture]] is an [[ILoadable]] which means it can be passed to a [[Loader]]
     * to pre-load before starting a level or game.
     *
     * [[include:Textures.md]]
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        /**
         * @param path       Path to the image resource
         * @param bustCache  Optionally load texture with cache busting
         */
        function Texture(path, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            var _this = _super.call(this, path, 'blob', bustCache) || this;
            _this.path = path;
            _this.bustCache = bustCache;
            /**
             * A [[Promise]] that resolves when the Texture is loaded.
             */
            _this.loaded = new Promises_4.Promise();
            _this._isLoaded = false;
            _this._sprite = null;
            _this._sprite = new Sprite_1.Sprite(_this, 0, 0, 0, 0);
            return _this;
        }
        /**
         * Returns true if the Texture is completely loaded and is ready
         * to be drawn.
         */
        Texture.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the texture and returns a promise to be resolved on completion
         */
        Texture.prototype.load = function () {
            var _this = this;
            var complete = new Promises_4.Promise();
            var loaded = _super.prototype.load.call(this);
            loaded.then(function () {
                _this.image = new Image();
                _this.image.addEventListener('load', function () {
                    _this._isLoaded = true;
                    _this.width = _this._sprite.swidth = _this._sprite.naturalWidth = _this._sprite.width = _this.image.naturalWidth;
                    _this.height = _this._sprite.sheight = _this._sprite.naturalHeight = _this._sprite.height = _this.image.naturalHeight;
                    _this.loaded.resolve(_this.image);
                    complete.resolve(_this.image);
                });
                _this.image.src = _super.prototype.getData.call(_this);
            }, function () {
                complete.reject('Error loading texture.');
            });
            return complete;
        };
        Texture.prototype.asSprite = function () {
            return this._sprite;
        };
        return Texture;
    }(Resource_1.Resource));
    exports.Texture = Texture;
});
define("Drawing/Sprite", ["require", "exports", "Drawing/SpriteEffects", "Drawing/Color", "Algebra", "Util/Log", "Util/Util"], function (require, exports, Effects, Color_9, Algebra_11, Log_4, Util_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A [[Sprite]] is one of the main drawing primitives. It is responsible for drawing
     * images or parts of images from a [[Texture]] resource to the screen.
     *
     * [[include:Sprites.md]]
     */
    var Sprite = (function () {
        /**
         * @param image   The backing image texture to build the Sprite
         * @param sx      The x position of the sprite
         * @param sy      The y position of the sprite
         * @param swidth  The width of the sprite in pixels
         * @param sheight The height of the sprite in pixels
         */
        function Sprite(image, sx, sy, swidth, sheight) {
            var _this = this;
            this.sx = sx;
            this.sy = sy;
            this.swidth = swidth;
            this.sheight = sheight;
            this.rotation = 0.0;
            this.anchor = new Algebra_11.Vector(0.0, 0.0);
            this.scale = new Algebra_11.Vector(1, 1);
            this.logger = Log_4.Logger.getInstance();
            /**
             * Draws the sprite flipped vertically
             */
            this.flipVertical = false;
            /**
             * Draws the sprite flipped horizontally
             */
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.effects = [];
            this.naturalWidth = 0;
            this.naturalHeight = 0;
            this._spriteCanvas = null;
            this._spriteCtx = null;
            this._pixelData = null;
            this._pixelsLoaded = false;
            this._dirtyEffect = false;
            if (sx < 0 || sy < 0 || swidth < 0 || sheight < 0) {
                this.logger.error('Sprite cannot have any negative dimensions x:', sx, 'y:', sy, 'width:', swidth, 'height:', sheight);
            }
            this._texture = image;
            this._spriteCanvas = document.createElement('canvas');
            this._spriteCanvas.width = swidth;
            this._spriteCanvas.height = sheight;
            this._spriteCtx = this._spriteCanvas.getContext('2d');
            this._texture.loaded.then(function () {
                _this._spriteCanvas.width = _this._spriteCanvas.width || _this._texture.image.naturalWidth;
                _this._spriteCanvas.height = _this._spriteCanvas.height || _this._texture.image.naturalHeight;
                _this._loadPixels();
                _this._dirtyEffect = true;
            }).error(function (e) {
                _this.logger.error('Error loading texture ', _this._texture.path, e);
            });
            this.width = swidth;
            this.height = sheight;
            this.naturalWidth = swidth;
            this.naturalHeight = sheight;
        }
        Sprite.prototype._loadPixels = function () {
            if (this._texture.isLoaded() && !this._pixelsLoaded) {
                var naturalWidth = this._texture.image.naturalWidth || 0;
                var naturalHeight = this._texture.image.naturalHeight || 0;
                if (this.swidth > naturalWidth) {
                    this.logger.warn('The sprite width', this.swidth, 'exceeds the width', naturalWidth, 'of the backing texture', this._texture.path);
                }
                if (this.sheight > naturalHeight) {
                    this.logger.warn('The sprite height', this.sheight, 'exceeds the height', naturalHeight, 'of the backing texture', this._texture.path);
                }
                this._spriteCtx.drawImage(this._texture.image, Util_2.clamp(this.sx, 0, naturalWidth), Util_2.clamp(this.sy, 0, naturalHeight), Util_2.clamp(this.swidth, 0, naturalWidth), Util_2.clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
                this._pixelsLoaded = true;
            }
        };
        /**
         * Applies the [[Opacity]] effect to a sprite, setting the alpha of all pixels to a given value
         */
        Sprite.prototype.opacity = function (value) {
            this.addEffect(new Effects.Opacity(value));
        };
        /**
         * Applies the [[Grayscale]] effect to a sprite, removing color information.
         */
        Sprite.prototype.grayscale = function () {
            this.addEffect(new Effects.Grayscale());
        };
        /**
         * Applies the [[Invert]] effect to a sprite, inverting the pixel colors.
         */
        Sprite.prototype.invert = function () {
            this.addEffect(new Effects.Invert());
        };
        /**
         * Applies the [[Fill]] effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
         */
        Sprite.prototype.fill = function (color) {
            this.addEffect(new Effects.Fill(color));
        };
        /**
         * Applies the [[Colorize]] effect to a sprite, changing the color channels of all pixels to be the average of the original color
         * and the provided color.
         */
        Sprite.prototype.colorize = function (color) {
            this.addEffect(new Effects.Colorize(color));
        };
        /**
         * Applies the [[Lighten]] effect to a sprite, changes the lightness of the color according to HSL
         */
        Sprite.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Lighten(factor));
        };
        /**
         * Applies the [[Darken]] effect to a sprite, changes the darkness of the color according to HSL
         */
        Sprite.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Darken(factor));
        };
        /**
         * Applies the [[Saturate]] effect to a sprite, saturates the color according to HSL
         */
        Sprite.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Saturate(factor));
        };
        /**
         * Applies the [[Desaturate]] effect to a sprite, desaturates the color according to HSL
         */
        Sprite.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Desaturate(factor));
        };
        /**
         * Adds a new [[ISpriteEffect]] to this drawing.
         * @param effect  Effect to add to the this drawing
         */
        Sprite.prototype.addEffect = function (effect) {
            this.effects.push(effect);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this._texture.isLoaded() || !this._pixelsLoaded) {
                this._dirtyEffect = true;
            }
            else {
                this._applyEffects();
            }
        };
        Sprite.prototype.removeEffect = function (param) {
            var indexToRemove = -1;
            if (typeof param === 'number') {
                indexToRemove = param;
            }
            else {
                indexToRemove = this.effects.indexOf(param);
            }
            // bounds check
            if (indexToRemove < 0 || indexToRemove >= this.effects.length) {
                return;
            }
            this.effects.splice(indexToRemove, 1);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this._texture.isLoaded() || !this._pixelsLoaded) {
                this._dirtyEffect = true;
            }
            else {
                this._applyEffects();
            }
        };
        Sprite.prototype._applyEffects = function () {
            var naturalWidth = this._texture.image.naturalWidth || 0;
            var naturalHeight = this._texture.image.naturalHeight || 0;
            this._spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this._spriteCtx.drawImage(this._texture.image, Util_2.clamp(this.sx, 0, naturalWidth), Util_2.clamp(this.sy, 0, naturalHeight), Util_2.clamp(this.swidth, 0, naturalWidth), Util_2.clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
            this._pixelData = this._spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
            var i = 0, x = 0, y = 0, len = this.effects.length;
            for (i; i < len; i++) {
                y = 0;
                for (y; y < this.sheight; y++) {
                    x = 0;
                    for (x; x < this.swidth; x++) {
                        this.effects[i].updatePixel(x, y, this._pixelData);
                    }
                }
            }
            this._spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this._spriteCtx.putImageData(this._pixelData, 0, 0);
            this._dirtyEffect = false;
        };
        /**
         * Clears all effects from the drawing and return it to its original state.
         */
        Sprite.prototype.clearEffects = function () {
            this.effects.length = 0;
            this._applyEffects();
        };
        /**
         * Resets the internal state of the drawing (if any)
         */
        Sprite.prototype.reset = function () {
            // do nothing
        };
        Sprite.prototype.debugDraw = function (ctx, x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            var scaledSWidth = this.width * this.scale.x;
            var scaledSHeight = this.height * this.scale.y;
            var xpoint = (scaledSWidth) * this.anchor.x;
            var ypoint = (scaledSHeight) * this.anchor.y;
            ctx.strokeStyle = Color_9.Color.Black.toString();
            ctx.strokeRect(-xpoint, -ypoint, scaledSWidth, scaledSHeight);
            ctx.restore();
        };
        /**
         * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.
         * @param ctx  The 2D rendering context
         * @param x    The x coordinate of where to draw
         * @param y    The y coordinate of where to draw
         */
        Sprite.prototype.draw = function (ctx, x, y) {
            if (this._dirtyEffect) {
                this._applyEffects();
            }
            // calculating current dimensions
            this.width = this.naturalWidth * this.scale.x;
            this.height = this.naturalHeight * this.scale.y;
            ctx.save();
            var xpoint = this.width * this.anchor.x;
            var ypoint = this.height * this.anchor.y;
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            var scaledSWidth = this.swidth * this.scale.x;
            var scaledSHeight = this.sheight * this.scale.y;
            // todo cache flipped sprites
            if (this.flipHorizontal) {
                ctx.translate(scaledSWidth, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, scaledSHeight);
                ctx.scale(1, -1);
            }
            ctx.drawImage(this._spriteCanvas, 0, 0, this.swidth, this.sheight, -xpoint, -ypoint, scaledSWidth, scaledSHeight);
            ctx.restore();
        };
        /**
         * Produces a copy of the current sprite
         */
        Sprite.prototype.clone = function () {
            var result = new Sprite(this._texture, this.sx, this.sy, this.swidth, this.sheight);
            result.scale = this.scale.clone();
            result.rotation = this.rotation;
            result.flipHorizontal = this.flipHorizontal;
            result.flipVertical = this.flipVertical;
            var i = 0, len = this.effects.length;
            for (i; i < len; i++) {
                result.addEffect(this.effects[i]);
            }
            return result;
        };
        return Sprite;
    }());
    exports.Sprite = Sprite;
});
define("Drawing/Animation", ["require", "exports", "Drawing/SpriteEffects", "Algebra", "Util/Util"], function (require, exports, Effects, Algebra_12, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Animations allow you to display a series of images one after another,
     * creating the illusion of change. Generally these images will come from a [[SpriteSheet]] source.
     *
     * [[include:Animations.md]]
     */
    var Animation = (function () {
        /**
         * Typically you will use a [[SpriteSheet]] to generate an [[Animation]].
         *
         * @param engine  Reference to the current game engine
         * @param images  An array of sprites to create the frames for the animation
         * @param speed   The number in milliseconds to display each frame in the animation
         * @param loop    Indicates whether the animation should loop after it is completed
         */
        function Animation(engine, images, speed, loop) {
            /**
             * Current frame index being shown
             */
            this.currentFrame = 0;
            this._oldTime = Date.now();
            this.anchor = new Algebra_12.Vector(0.0, 0.0);
            this.rotation = 0.0;
            this.scale = new Algebra_12.Vector(1, 1);
            /**
             * Indicates whether the animation should loop after it is completed
             */
            this.loop = true;
            /**
             * Indicates the frame index the animation should freeze on for a non-looping
             * animation. By default it is the last frame.
             */
            this.freezeFrame = -1;
            /**
             * Flip each frame vertically. Sets [[Sprite.flipVertical]].
             */
            this.flipVertical = false;
            /**
             * Flip each frame horizontally. Sets [[Sprite.flipHorizontal]].
             */
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.naturalWidth = 0;
            this.naturalHeight = 0;
            this.sprites = images;
            this.speed = speed;
            this._engine = engine;
            if (loop != null) {
                this.loop = loop;
            }
            if (images && images[0]) {
                this.height = images[0] ? images[0].height : 0;
                this.width = images[0] ? images[0].width : 0;
                this.naturalWidth = images[0] ? images[0].naturalWidth : 0;
                this.naturalHeight = images[0] ? images[0].naturalHeight : 0;
                this.freezeFrame = images.length - 1;
            }
        }
        /**
         * Applies the opacity effect to a sprite, setting the alpha of all pixels to a given value
         */
        Animation.prototype.opacity = function (value) {
            this.addEffect(new Effects.Opacity(value));
        };
        /**
         * Applies the grayscale effect to a sprite, removing color information.
         */
        Animation.prototype.grayscale = function () {
            this.addEffect(new Effects.Grayscale());
        };
        /**
         * Applies the invert effect to a sprite, inverting the pixel colors.
         */
        Animation.prototype.invert = function () {
            this.addEffect(new Effects.Invert());
        };
        /**
         * Applies the fill effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
         */
        Animation.prototype.fill = function (color) {
            this.addEffect(new Effects.Fill(color));
        };
        /**
         * Applies the colorize effect to a sprite, changing the color channels of all pixels to be the average of the original color and the
         * provided color.
         */
        Animation.prototype.colorize = function (color) {
            this.addEffect(new Effects.Colorize(color));
        };
        /**
         * Applies the lighten effect to a sprite, changes the lightness of the color according to hsl
         */
        Animation.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Lighten(factor));
        };
        /**
         * Applies the darken effect to a sprite, changes the darkness of the color according to hsl
         */
        Animation.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Darken(factor));
        };
        /**
         * Applies the saturate effect to a sprite, saturates the color according to hsl
         */
        Animation.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Saturate(factor));
        };
        /**
         * Applies the desaturate effect to a sprite, desaturates the color according to hsl
         */
        Animation.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Desaturate(factor));
        };
        /**
         * Add a [[ISpriteEffect]] manually
         */
        Animation.prototype.addEffect = function (effect) {
            for (var i in this.sprites) {
                this.sprites[i].addEffect(effect);
            }
        };
        Animation.prototype.removeEffect = function (param) {
            for (var i in this.sprites) {
                this.sprites[i].removeEffect(param);
            }
        };
        /**
         * Clear all sprite effects
         */
        Animation.prototype.clearEffects = function () {
            for (var i in this.sprites) {
                this.sprites[i].clearEffects();
            }
        };
        Animation.prototype._setAnchor = function (point) {
            //if (!this.anchor.equals(point)) {
            for (var i in this.sprites) {
                this.sprites[i].anchor.setTo(point.x, point.y);
            }
            //}
        };
        Animation.prototype._setRotation = function (radians) {
            //if (this.rotation !== radians) {
            for (var i in this.sprites) {
                this.sprites[i].rotation = radians;
            }
            //}
        };
        Animation.prototype._setScale = function (scale) {
            //if (!this.scale.equals(scale)) {
            for (var i in this.sprites) {
                this.sprites[i].scale = scale;
            }
            //}
        };
        /**
         * Resets the animation to first frame.
         */
        Animation.prototype.reset = function () {
            this.currentFrame = 0;
        };
        /**
         * Indicates whether the animation is complete, animations that loop are never complete.
         */
        Animation.prototype.isDone = function () {
            return (!this.loop && this.currentFrame >= this.sprites.length);
        };
        /**
         * Not meant to be called by game developers. Ticks the animation forward internally and
         * calculates whether to change to the frame.
         * @internal
         */
        Animation.prototype.tick = function () {
            var time = Date.now();
            if ((time - this._oldTime) > this.speed) {
                this.currentFrame = (this.loop ? (this.currentFrame + 1) % this.sprites.length : this.currentFrame + 1);
                this._oldTime = time;
            }
        };
        Animation.prototype._updateValues = function () {
            this._setAnchor(this.anchor);
            this._setRotation(this.rotation);
            this._setScale(this.scale);
        };
        /**
         * Skips ahead a specified number of frames in the animation
         * @param frames  Frames to skip ahead
         */
        Animation.prototype.skip = function (frames) {
            this.currentFrame = (this.currentFrame + frames) % this.sprites.length;
        };
        Animation.prototype.draw = function (ctx, x, y) {
            this.tick();
            this._updateValues();
            var currSprite;
            if (this.currentFrame < this.sprites.length) {
                currSprite = this.sprites[this.currentFrame];
                if (this.flipVertical) {
                    currSprite.flipVertical = this.flipVertical;
                }
                if (this.flipHorizontal) {
                    currSprite.flipHorizontal = this.flipHorizontal;
                }
                currSprite.draw(ctx, x, y);
            }
            if (this.freezeFrame !== -1 && this.currentFrame >= this.sprites.length) {
                currSprite = this.sprites[Util.clamp(this.freezeFrame, 0, this.sprites.length - 1)];
                currSprite.draw(ctx, x, y);
            }
            // add the calculated width
            if (currSprite) {
                this.width = currSprite.width;
                this.height = currSprite.height;
            }
        };
        /**
         * Plays an animation at an arbitrary location in the game.
         * @param x  The x position in the game to play
         * @param y  The y position in the game to play
         */
        Animation.prototype.play = function (x, y) {
            this.reset();
            this._engine.playAnimation(this, x, y);
        };
        return Animation;
    }());
    exports.Animation = Animation;
});
define("Drawing/SpriteSheet", ["require", "exports", "Drawing/Sprite", "Drawing/Animation", "Drawing/Color", "Drawing/SpriteEffects", "Util/Log", "Label"], function (require, exports, Sprite_2, Animation_1, Color_10, Effects, Log_5, Label_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Sprite sheets are a useful mechanism for slicing up image resources into
     * separate sprites or for generating in game animations. [[Sprite|Sprites]] are organized
     * in row major order in the [[SpriteSheet]].
     *
     * [[include:SpriteSheets.md]]
     */
    var SpriteSheet = (function () {
        /**
         * @param image     The backing image texture to build the SpriteSheet
         * @param columns   The number of columns in the image texture
         * @param rows      The number of rows in the image texture
         * @param spWidth   The width of each individual sprite in pixels
         * @param spHeight  The height of each individual sprite in pixels
         */
        function SpriteSheet(image, columns, rows, spWidth, spHeight) {
            this.image = image;
            this.columns = columns;
            this.rows = rows;
            this.sprites = [];
            this._internalImage = image.image;
            this.sprites = new Array(columns * rows);
            // TODO: Inspect actual image dimensions with preloading
            /*if(spWidth * columns > this.internalImage.naturalWidth){
               throw new Error("SpriteSheet specified is wider than image width");
            }
      
            if(spHeight * rows > this.internalImage.naturalHeight){
               throw new Error("SpriteSheet specified is higher than image height");
            }*/
            var i = 0;
            var j = 0;
            for (i = 0; i < rows; i++) {
                for (j = 0; j < columns; j++) {
                    this.sprites[j + i * columns] = new Sprite_2.Sprite(this.image, j * spWidth, i * spHeight, spWidth, spHeight);
                }
            }
        }
        /**
         * Create an animation from the this SpriteSheet by listing out the
         * sprite indices. Sprites are organized in row major order in the SpriteSheet.
         * @param engine   Reference to the current game [[Engine]]
         * @param indices  An array of sprite indices to use in the animation
         * @param speed    The number in milliseconds to display each frame in the animation
         */
        SpriteSheet.prototype.getAnimationByIndices = function (engine, indices, speed) {
            var _this = this;
            var images = indices.map(function (index) {
                return _this.sprites[index];
            });
            images = images.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, images, speed);
        };
        /**
         * Create an animation from the this SpriteSheet by specifing the range of
         * images with the beginning and ending index
         * @param engine      Reference to the current game Engine
         * @param beginIndex  The index to start taking frames
         * @param endIndex    The index to stop taking frames
         * @param speed       The number in milliseconds to display each frame in the animation
         */
        SpriteSheet.prototype.getAnimationBetween = function (engine, beginIndex, endIndex, speed) {
            var images = this.sprites.slice(beginIndex, endIndex);
            images = images.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, images, speed);
        };
        /**
         * Treat the entire SpriteSheet as one animation, organizing the frames in
         * row major order.
         * @param engine  Reference to the current game [[Engine]]
         * @param speed   The number in milliseconds to display each frame the animation
         */
        SpriteSheet.prototype.getAnimationForAll = function (engine, speed) {
            var sprites = this.sprites.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, sprites, speed);
        };
        /**
         * Retreive a specific sprite from the SpriteSheet by its index. Sprites are organized
         * in row major order in the SpriteSheet.
         * @param index  The index of the sprite
         */
        SpriteSheet.prototype.getSprite = function (index) {
            if (index >= 0 && index < this.sprites.length) {
                return this.sprites[index];
            }
            else {
                throw new Error('Invalid index: ' + index);
            }
        };
        return SpriteSheet;
    }());
    exports.SpriteSheet = SpriteSheet;
    /**
     * Sprite fonts are a used in conjunction with a [[Label]] to specify
     * a particular bitmap as a font. Note that some font features are not
     * supported by Sprite fonts.
     *
     * [[include:SpriteFonts.md]]
     */
    var SpriteFont = (function (_super) {
        __extends(SpriteFont, _super);
        /**
         * @param image           The backing image texture to build the SpriteFont
         * @param alphabet        A string representing all the characters in the image, in row major order.
         * @param caseInsensitive  Indicate whether this font takes case into account
         * @param columns         The number of columns of characters in the image
         * @param rows            The number of rows of characters in the image
         * @param spWidth         The width of each character in pixels
         * @param spHeight        The height of each character in pixels
         */
        function SpriteFont(image, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            var _this = _super.call(this, image, columns, rows, spWidth, spHeight) || this;
            _this.image = image;
            _this.alphabet = alphabet;
            _this.caseInsensitive = caseInsensitive;
            _this.spWidth = spWidth;
            _this.spHeight = spHeight;
            _this._currentColor = Color_10.Color.Black.clone();
            _this._currentOpacity = 1.0;
            _this._sprites = {};
            // text shadow
            _this._textShadowOn = false;
            _this._textShadowDirty = true;
            _this._textShadowColor = Color_10.Color.Black.clone();
            _this._textShadowSprites = {};
            _this._shadowOffsetX = 5;
            _this._shadowOffsetY = 5;
            _this._sprites = _this.getTextSprites();
            return _this;
        }
        /**
         * Returns a dictionary that maps each character in the alphabet to the appropriate [[Sprite]].
         */
        SpriteFont.prototype.getTextSprites = function () {
            var lookup = {};
            for (var i = 0; i < this.alphabet.length; i++) {
                var char = this.alphabet[i];
                if (this.caseInsensitive) {
                    char = char.toLowerCase();
                }
                lookup[char] = this.sprites[i].clone();
            }
            return lookup;
        };
        /**
         * Sets the text shadow for sprite fonts
         * @param offsetX      The x offset in pixels to place the shadow
         * @param offsetY      The y offset in pixels to place the shadow
         * @param shadowColor  The color of the text shadow
         */
        SpriteFont.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this._textShadowOn = true;
            this._shadowOffsetX = offsetX;
            this._shadowOffsetY = offsetY;
            this._textShadowColor = shadowColor.clone();
            this._textShadowDirty = true;
            for (var character in this._sprites) {
                this._textShadowSprites[character] = this._sprites[character].clone();
            }
        };
        /**
         * Toggles text shadows on or off
         */
        SpriteFont.prototype.useTextShadow = function (on) {
            this._textShadowOn = on;
            if (on) {
                this.setTextShadow(5, 5, this._textShadowColor);
            }
        };
        /**
         * Draws the current sprite font
         */
        SpriteFont.prototype.draw = function (ctx, text, x, y, options) {
            options = this._parseOptions(options);
            if (this._currentColor.toString() !== options.color.toString() || this._currentOpacity !== options.opacity) {
                this._currentOpacity = options.opacity;
                this._currentColor = options.color;
                for (var char in this._sprites) {
                    this._sprites[char].clearEffects();
                    this._sprites[char].fill(options.color);
                    this._sprites[char].opacity(options.opacity);
                }
            }
            if (this._textShadowOn && this._textShadowDirty && this._textShadowColor) {
                for (var characterShadow in this._textShadowSprites) {
                    this._textShadowSprites[characterShadow].clearEffects();
                    this._textShadowSprites[characterShadow].addEffect(new Effects.Fill(this._textShadowColor.clone()));
                }
                this._textShadowDirty = false;
            }
            // find the current length of text in pixels
            var sprite = this.sprites[0];
            // find the current height fo the text in pixels
            var height = sprite.sheight;
            // calculate appropriate scale for font size
            var scale = options.fontSize / height;
            var length = (text.length * sprite.swidth * scale) + (text.length * options.letterSpacing);
            var currX = x;
            if (options.textAlign === Label_1.TextAlign.Left || options.textAlign === Label_1.TextAlign.Start) {
                currX = x;
            }
            else if (options.textAlign === Label_1.TextAlign.Right || options.textAlign === Label_1.TextAlign.End) {
                currX = x - length;
            }
            else if (options.textAlign === Label_1.TextAlign.Center) {
                currX = x - length / 2;
            }
            var currY = y - height * scale;
            if (options.baseAlign === Label_1.BaseAlign.Top || options.baseAlign === Label_1.BaseAlign.Hanging) {
                currY = y;
            }
            else if (options.baseAlign === Label_1.BaseAlign.Ideographic ||
                options.baseAlign === Label_1.BaseAlign.Bottom ||
                options.baseAlign === Label_1.BaseAlign.Alphabetic) {
                currY = y - height * scale;
            }
            else if (options.baseAlign === Label_1.BaseAlign.Middle) {
                currY = y - (height * scale) / 2;
            }
            for (var i = 0; i < text.length; i++) {
                var character = text[i];
                if (this.caseInsensitive) {
                    character = character.toLowerCase();
                }
                try {
                    // if text shadow
                    if (this._textShadowOn) {
                        this._textShadowSprites[character].scale.x = scale;
                        this._textShadowSprites[character].scale.y = scale;
                        this._textShadowSprites[character].draw(ctx, currX + this._shadowOffsetX, currY + this._shadowOffsetY);
                    }
                    var charSprite = this._sprites[character];
                    charSprite.scale.x = scale;
                    charSprite.scale.y = scale;
                    charSprite.draw(ctx, currX, currY);
                    currX += (charSprite.width + options.letterSpacing);
                }
                catch (e) {
                    Log_5.Logger.getInstance().error("SpriteFont Error drawing char " + character);
                }
            }
        };
        SpriteFont.prototype._parseOptions = function (options) {
            return {
                fontSize: options.fontSize || 10,
                letterSpacing: options.letterSpacing || 0,
                color: options.color || Color_10.Color.Black.clone(),
                textAlign: typeof options.textAlign === undefined ? Label_1.TextAlign.Left : options.textAlign,
                baseAlign: typeof options.baseAlign === undefined ? Label_1.BaseAlign.Bottom : options.baseAlign,
                maxWidth: options.maxWidth || -1,
                opacity: options.opacity || 0
            };
        };
        return SpriteFont;
    }(SpriteSheet));
    exports.SpriteFont = SpriteFont;
});
define("Label", ["require", "exports", "Drawing/Color", "Actor"], function (require, exports, Color_11, Actor_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing the different font size units
     * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
     */
    var FontUnit;
    (function (FontUnit) {
        /**
         * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
         */
        FontUnit[FontUnit["Em"] = 0] = "Em";
        /**
         * Rem is similar to the Em, it is a scalable unit. 1 rem is eqaul to the font size of the root element
         */
        FontUnit[FontUnit["Rem"] = 1] = "Rem";
        /**
         * Pixel is a unit of length in screen pixels
         */
        FontUnit[FontUnit["Px"] = 2] = "Px";
        /**
         * Point is a physical unit length (1/72 of an inch)
         */
        FontUnit[FontUnit["Pt"] = 3] = "Pt";
        /**
         * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
         */
        FontUnit[FontUnit["Percent"] = 4] = "Percent";
    })(FontUnit = exports.FontUnit || (exports.FontUnit = {}));
    /**
     * Enum representing the different horizontal text alignments
     */
    var TextAlign;
    (function (TextAlign) {
        /**
         * The text is left-aligned.
         */
        TextAlign[TextAlign["Left"] = 0] = "Left";
        /**
         * The text is right-aligned.
         */
        TextAlign[TextAlign["Right"] = 1] = "Right";
        /**
         * The text is centered.
         */
        TextAlign[TextAlign["Center"] = 2] = "Center";
        /**
         * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
         * right-aligned for right-to-left locales).
         */
        TextAlign[TextAlign["Start"] = 3] = "Start";
        /**
         * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
         * left-aligned for right-to-left locales).
         */
        TextAlign[TextAlign["End"] = 4] = "End";
    })(TextAlign = exports.TextAlign || (exports.TextAlign = {}));
    /**
     * Enum representing the different baseline text alignments
     */
    var BaseAlign;
    (function (BaseAlign) {
        /**
         * The text baseline is the top of the em square.
         */
        BaseAlign[BaseAlign["Top"] = 0] = "Top";
        /**
         * The text baseline is the hanging baseline.  Currently unsupported; this will act like
         * alphabetic.
         */
        BaseAlign[BaseAlign["Hanging"] = 1] = "Hanging";
        /**
         * The text baseline is the middle of the em square.
         */
        BaseAlign[BaseAlign["Middle"] = 2] = "Middle";
        /**
         * The text baseline is the normal alphabetic baseline.
         */
        BaseAlign[BaseAlign["Alphabetic"] = 3] = "Alphabetic";
        /**
         * The text baseline is the ideographic baseline; this is the bottom of
         * the body of the characters, if the main body of characters protrudes
         * beneath the alphabetic baseline.  Currently unsupported; this will
         * act like alphabetic.
         */
        BaseAlign[BaseAlign["Ideographic"] = 4] = "Ideographic";
        /**
         * The text baseline is the bottom of the bounding box.  This differs
         * from the ideographic baseline in that the ideographic baseline
         * doesn't consider descenders.
         */
        BaseAlign[BaseAlign["Bottom"] = 5] = "Bottom";
    })(BaseAlign = exports.BaseAlign || (exports.BaseAlign = {}));
    /**
     * Enum representing the different possible font styles
     */
    var FontStyle;
    (function (FontStyle) {
        FontStyle[FontStyle["Normal"] = 0] = "Normal";
        FontStyle[FontStyle["Italic"] = 1] = "Italic";
        FontStyle[FontStyle["Oblique"] = 2] = "Oblique";
    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
    /**
     * Labels are the way to draw small amounts of text to the screen. They are
     * actors and inherit all of the benefits and capabilities.
     *
     * [[include:Labels.md]]
     */
    var Label = (function (_super) {
        __extends(Label, _super);
        /**
         * @param text        The text of the label
         * @param x           The x position of the label
         * @param y           The y position of the label
         * @param fontFamily  Use any valid CSS font string for the label's font. Web fonts are supported. Default is `10px sans-serif`.
         * @param spriteFont  Use an Excalibur sprite font for the label's font, if a SpriteFont is provided it will take precedence
         * over a css font.
         */
        function Label(text, x, y, fontFamily, spriteFont) {
            var _this = _super.call(this, x, y) || this;
            /**
             * Sets or gets the bold property of the label's text, by default it's false
             */
            _this.bold = false;
            /**
             * The font size in the selected units, default is 10 (default units is pixel)
             */
            _this.fontSize = 10;
            /**
             * The font style for this label, the default is [[FontStyle.Normal]]
             */
            _this.fontStyle = FontStyle.Normal;
            /**
             * The css units for a font size such as px, pt, em (SpriteFont only support px), by default is 'px';
             */
            _this.fontUnit = FontUnit.Px;
            /**
             * Gets or sets the horizontal text alignment property for the label.
             */
            _this.textAlign = TextAlign.Left;
            /**
             * Gets or sets the baseline alignment property for the label.
             */
            _this.baseAlign = BaseAlign.Bottom;
            /**
             * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
             */
            _this.letterSpacing = 0; //px
            /**
             * Whether or not the [[SpriteFont]] will be case-sensitive when matching characters.
             */
            _this.caseInsensitive = true;
            _this._textShadowOn = false;
            _this._shadowOffsetX = 0;
            _this._shadowOffsetY = 0;
            _this._shadowColor = Color_11.Color.Black.clone();
            _this.text = text || '';
            _this.color = Color_11.Color.Black.clone();
            _this.spriteFont = spriteFont;
            _this.collisionType = Actor_4.CollisionType.PreventCollision;
            _this.fontFamily = fontFamily || 'sans-serif'; // coalesce to default canvas font
            if (spriteFont) {
                //this._textSprites = spriteFont.getTextSprites();
            }
            return _this;
        }
        /**
         * Returns the width of the text in the label (in pixels);
         * @param ctx  Rendering context to measure the string with
         */
        Label.prototype.getTextWidth = function (ctx) {
            var oldFont = ctx.font;
            ctx.font = this._fontString;
            var width = ctx.measureText(this.text).width;
            ctx.font = oldFont;
            return width;
        };
        // TypeScript doesn't support string enums :(
        Label.prototype._lookupFontUnit = function (fontUnit) {
            switch (fontUnit) {
                case FontUnit.Em:
                    return 'em';
                case FontUnit.Rem:
                    return 'rem';
                case FontUnit.Pt:
                    return 'pt';
                case FontUnit.Px:
                    return 'px';
                case FontUnit.Percent:
                    return '%';
                default:
                    return 'px';
            }
        };
        Label.prototype._lookupTextAlign = function (textAlign) {
            switch (textAlign) {
                case TextAlign.Left:
                    return 'left';
                case TextAlign.Right:
                    return 'right';
                case TextAlign.Center:
                    return 'center';
                case TextAlign.End:
                    return 'end';
                case TextAlign.Start:
                    return 'start';
                default:
                    return 'start';
            }
        };
        Label.prototype._lookupBaseAlign = function (baseAlign) {
            switch (baseAlign) {
                case BaseAlign.Alphabetic:
                    return 'alphabetic';
                case BaseAlign.Bottom:
                    return 'bottom';
                case BaseAlign.Hanging:
                    return 'hangin';
                case BaseAlign.Ideographic:
                    return 'ideographic';
                case BaseAlign.Middle:
                    return 'middle';
                case BaseAlign.Top:
                    return 'top';
                default:
                    return 'alphabetic';
            }
        };
        Label.prototype._lookupFontStyle = function (fontStyle) {
            var boldstring = this.bold ? ' bold' : '';
            switch (fontStyle) {
                case FontStyle.Italic:
                    return 'italic' + boldstring;
                case FontStyle.Normal:
                    return 'normal' + boldstring;
                case FontStyle.Oblique:
                    return 'oblique' + boldstring;
                default:
                    return 'normal' + boldstring;
            }
        };
        /**
         * Sets the text shadow for sprite fonts
         * @param offsetX      The x offset in pixels to place the shadow
         * @param offsetY      The y offset in pixels to place the shadow
         * @param shadowColor  The color of the text shadow
         */
        Label.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this.spriteFont.setTextShadow(offsetX, offsetY, shadowColor);
        };
        /**
         * Toggles text shadows on or off, only applies when using sprite fonts
         */
        Label.prototype.useTextShadow = function (on) {
            this.spriteFont.useTextShadow(on);
        };
        /**
         * Clears the current text shadow
         */
        Label.prototype.clearTextShadow = function () {
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
            this._shadowColor = Color_11.Color.Black.clone();
        };
        Label.prototype.update = function (engine, delta) {
            _super.prototype.update.call(this, engine, delta);
            /*
           if (this.spriteFont && (this._color !== this.color || this.previousOpacity !== this.opacity)) {
              for (var character in this._textSprites) {
                 this._textSprites[character].clearEffects();
                 this._textSprites[character].fill(this.color.clone());
                 this._textSprites[character].opacity(this.opacity);
                 
              }
              this._color = this.color;
              this.previousOpacity = this.opacity;
           }
      
           if (this.spriteFont && this._textShadowOn && this._shadowColorDirty && this._shadowColor) {
              for (var characterShadow in this._shadowSprites) {
                 this._shadowSprites[characterShadow].clearEffects();
                 this._shadowSprites[characterShadow].addEffect(new Effects.Fill(this._shadowColor.clone()));
              }
              this._shadowColorDirty = false;
           }*/
        };
        Label.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            if (this._textShadowOn) {
                ctx.save();
                ctx.translate(this._shadowOffsetX, this._shadowOffsetY);
                this._fontDraw(ctx);
                ctx.restore();
            }
            this._fontDraw(ctx);
            _super.prototype.draw.call(this, ctx, delta);
            ctx.restore();
        };
        Label.prototype._fontDraw = function (ctx) {
            if (this.spriteFont) {
                this.spriteFont.draw(ctx, this.text, 0, 0, {
                    color: this.color.clone(),
                    baseAlign: this.baseAlign,
                    textAlign: this.textAlign,
                    fontSize: this.fontSize,
                    letterSpacing: this.letterSpacing,
                    opacity: this.opacity
                });
            }
            else {
                var oldAlign = ctx.textAlign;
                var oldTextBaseline = ctx.textBaseline;
                ctx.textAlign = this._lookupTextAlign(this.textAlign);
                ctx.textBaseline = this._lookupBaseAlign(this.baseAlign);
                if (this.color) {
                    this.color.a = this.opacity;
                }
                ctx.fillStyle = this.color.toString();
                ctx.font = this._fontString;
                if (this.maxWidth) {
                    ctx.fillText(this.text, 0, 0, this.maxWidth);
                }
                else {
                    ctx.fillText(this.text, 0, 0);
                }
                ctx.textAlign = oldAlign;
                ctx.textBaseline = oldTextBaseline;
            }
        };
        Object.defineProperty(Label.prototype, "_fontString", {
            get: function () {
                return this._lookupFontStyle(this.fontStyle) + " " + this.fontSize + this._lookupFontUnit(this.fontUnit) + " " + this.fontFamily;
            },
            enumerable: true,
            configurable: true
        });
        Label.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
        };
        return Label;
    }(Actor_4.Actor));
    exports.Label = Label;
});
define("Interfaces/IAudio", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Interfaces/IAudioImplementation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Resources/Sound", ["require", "exports", "Util/Log", "Util/Util", "Promises"], function (require, exports, Log_6, Util, Promises_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // set up audio context reference
    // when we introduce multi-tracking, we may need to move this to a factory method
    if (window.AudioContext) {
        var audioContext = new window.AudioContext();
    }
    /**
     * An audio implementation for HTML5 audio.
     */
    var AudioTag = (function () {
        function AudioTag() {
            this.responseType = 'blob';
        }
        /**
         * Transforms raw Blob data into a object URL for use in audio tag
         */
        AudioTag.prototype.processData = function (data) {
            var url = URL.createObjectURL(data);
            return Promises_5.Promise.resolve(url);
        };
        /**
         * Creates a new instance of an audio tag referencing the provided audio URL
         */
        AudioTag.prototype.createInstance = function (url) {
            return new AudioTagInstance(url);
        };
        return AudioTag;
    }());
    exports.AudioTag = AudioTag;
    /**
     * An audio implementation for Web Audio API.
     */
    var WebAudio = (function () {
        function WebAudio() {
            this._logger = Log_6.Logger.getInstance();
            this.responseType = 'arraybuffer';
        }
        /**
         * Processes raw arraybuffer data and decodes into WebAudio buffer (async).
         */
        WebAudio.prototype.processData = function (data) {
            var _this = this;
            var complete = new Promises_5.Promise();
            audioContext.decodeAudioData(data, function (buffer) {
                complete.resolve(buffer);
            }, function () {
                _this._logger.error('Unable to decode ' +
                    ' this browser may not fully support this format, or the file may be corrupt, ' +
                    'if this is an mp3 try removing id3 tags and album art from the file.');
                complete.resolve(undefined);
            });
            return complete;
        };
        /**
         * Creates a new WebAudio AudioBufferSourceNode to play a sound instance
         */
        WebAudio.prototype.createInstance = function (buffer) {
            return new WebAudioInstance(buffer);
        };
        /**
         * Play an empty sound to unlock Safari WebAudio context. Call this function
         * right after a user interaction event. Typically used by [[PauseAfterLoader]]
         * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         */
        WebAudio.unlock = function () {
            if (WebAudio._unlocked || !audioContext) {
                return;
            }
            // create empty buffer and play it
            var buffer = audioContext.createBuffer(1, 1, 22050);
            var source = audioContext.createBufferSource();
            var ended = false;
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.onended = function () { return ended = true; };
            if (source.noteOn) {
                // deprecated
                source.noteOn(0);
            }
            else {
                source.start(0);
            }
            // by checking the play state after some time, we know if we're really unlocked
            setTimeout(function () {
                if (source.playbackState) {
                    var legacySource = source;
                    if (legacySource.playbackState === legacySource.PLAYING_STATE ||
                        legacySource.playbackState === legacySource.FINISHED_STATE) {
                        WebAudio._unlocked = true;
                    }
                }
                else {
                    if (audioContext.currentTime > 0 || ended) {
                        WebAudio._unlocked = true;
                    }
                }
            }, 0);
        };
        WebAudio.isUnlocked = function () {
            return this._unlocked;
        };
        return WebAudio;
    }());
    WebAudio._unlocked = false;
    exports.WebAudio = WebAudio;
    /**
     * Factory method that gets the audio implementation to use
     */
    function getAudioImplementation() {
        if (window.AudioContext) {
            return new WebAudio();
        }
        else {
            return new AudioTag();
        }
    }
    exports.getAudioImplementation = getAudioImplementation;
    ;
    /**
     * The [[Sound]] object allows games built in Excalibur to load audio
     * components, from soundtracks to sound effects. [[Sound]] is an [[ILoadable]]
     * which means it can be passed to a [[Loader]] to pre-load before a game or level.
     *
     * [[include:Sounds.md]]
     */
    var Sound = (function () {
        /**
         * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
         */
        function Sound() {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i] = arguments[_i];
            }
            this._logger = Log_6.Logger.getInstance();
            this._data = null;
            this._tracks = [];
            this._isLoaded = false;
            this._isPaused = false;
            this._loop = false;
            this._volume = 1.0;
            this.onprogress = function () { return; };
            this.oncomplete = function () { return; };
            this.onerror = function () { return; };
            this._wasPlayingOnHidden = false;
            /* Chrome : MP3, WAV, Ogg
               * Firefox : WAV, Ogg,
               * IE : MP3, WAV coming soon
               * Safari MP3, WAV, Ogg
               */
            this.path = '';
            for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {
                var path = paths_1[_a];
                if (Sound.canPlayFile(path)) {
                    this.path = path;
                    break;
                }
            }
            if (!this.path) {
                this._logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
                this._logger.warn('Attempting to use', paths[0]);
                this.path = paths[0]; // select the first specified
            }
            this.sound = getAudioImplementation();
        }
        /**
         * Whether or not the browser can play this file as HTML5 Audio
         */
        Sound.canPlayFile = function (file) {
            try {
                var a = new Audio();
                var filetype = /.*\.([A-Za-z0-9]+)$/;
                var type = file.match(filetype)[1];
                if (a.canPlayType('audio/' + type)) {
                    return true;
                }
                else {
                    return false;
                }
            }
            catch (e) {
                Log_6.Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
                return false;
            }
        };
        Sound.prototype.wireEngine = function (engine) {
            var _this = this;
            if (engine) {
                this._engine = engine;
                this._engine.on('hidden', function () {
                    if (engine.pauseAudioWhenHidden && _this.isPlaying()) {
                        _this._wasPlayingOnHidden = true;
                        _this.pause();
                    }
                });
                this._engine.on('visible', function () {
                    if (engine.pauseAudioWhenHidden && _this._wasPlayingOnHidden) {
                        _this.play();
                        _this._wasPlayingOnHidden = false;
                    }
                });
            }
        };
        /**
         * Returns how many instances of the sound are currently playing
         */
        Sound.prototype.instanceCount = function () {
            return this._tracks.length;
        };
        /**
         * Sets the volume of the sound clip
         * @param volume  A volume value between 0-1.0
         */
        Sound.prototype.setVolume = function (volume) {
            this._volume = volume;
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.setVolume(volume);
            }
            this._logger.debug('Set volume for all instances of sound', this.path, 'to', volume);
        };
        /**
         * Indicates whether the clip should loop when complete
         * @param loop  Set the looping flag
         */
        Sound.prototype.setLoop = function (loop) {
            this._loop = loop;
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.setLoop(loop);
            }
            this._logger.debug('Set loop for all instances of sound', this.path, 'to', loop);
        };
        /**
         * Whether or not the sound is playing right now
         */
        Sound.prototype.isPlaying = function () {
            return this._tracks.some(function (t) { return t.isPlaying(); });
        };
        /**
         * Play the sound, returns a promise that resolves when the sound is done playing
         * An optional volume argument can be passed in to play the sound. Max volume is 1.0
         */
        Sound.prototype.play = function (volume) {
            var _this = this;
            if (this._isLoaded) {
                var resumed = [];
                // ensure we resume *current* tracks (if paused)
                for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                    var track = _a[_i];
                    resumed.push(track.play());
                }
                // when paused, don't start playing new track
                if (this._isPaused) {
                    this._isPaused = false;
                    this._logger.debug('Resuming paused instances for sound', this.path, this._tracks);
                    // resolve when resumed tracks are done
                    return Promises_5.Promise.join(resumed);
                }
                // push a new track
                var newTrack = this.sound.createInstance(this._data);
                newTrack.setLoop(this._loop);
                if (volume) {
                    newTrack.setVolume(Util.clamp(volume, 0.0, 1.0));
                }
                else {
                    newTrack.setVolume(this._volume);
                }
                this._tracks.push(newTrack);
                this._logger.debug('Playing new instance for sound', this.path);
                return newTrack.play().then(function () {
                    // when done, remove track
                    _this._tracks.splice(_this._tracks.indexOf(newTrack), 1);
                    return true;
                });
            }
            else {
                return Promises_5.Promise.resolve(true);
            }
        };
        /**
         * Stop the sound, and do not rewind
         */
        Sound.prototype.pause = function () {
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.pause();
            }
            this._isPaused = true;
            this._logger.debug('Paused all instances of sound', this.path);
        };
        /**
         * Stop the sound and rewind
         */
        Sound.prototype.stop = function () {
            this._isPaused = false;
            var tracks = this._tracks.concat([]);
            for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {
                var track = tracks_1[_i];
                track.stop();
            }
            this._logger.debug('Stopped all instances of sound', this.path);
        };
        /**
         * Returns true if the sound is loaded
         */
        Sound.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the sound and returns a promise to be resolved on completion
         */
        Sound.prototype.load = function () {
            var _this = this;
            var complete = new Promises_5.Promise();
            if (!!this.getData()) {
                this._logger.debug('Already have data for audio resource', this.path);
                complete.resolve(this.sound);
                this.oncomplete();
                return complete;
            }
            this._logger.debug('Started loading sound', this.path);
            try {
                this._fetchResource(function (request) {
                    if (request.status !== 200) {
                        _this._logger.error('Failed to load audio resource ', _this.path, ' server responded with error code', request.status);
                        _this.onerror(request.response);
                        complete.resolve(null);
                        return;
                    }
                    // load sound
                    _this.setData(request.response).then(function () {
                        _this.oncomplete();
                        _this._logger.debug('Completed loading sound', _this.path);
                        complete.resolve(_this.sound);
                    }, function (e) { return complete.resolve(e); });
                });
            }
            catch (e) {
                this._logger.error('Error loading sound! If this is a cross origin error, \
            you must host your sound with your html and javascript.');
                this.onerror(e);
                complete.resolve(e);
            }
            return complete;
        };
        /* istanbul ignore next */
        Sound.prototype._fetchResource = function (onload) {
            var request = new XMLHttpRequest();
            request.open('GET', this.path, true);
            request.responseType = this.sound.responseType;
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function () { return onload(request); };
            request.send();
        };
        /**
         * Gets the raw sound data (e.g. blob URL or AudioBuffer)
         */
        Sound.prototype.getData = function () {
            return this._data;
        };
        /**
         * Sets raw sound data and returns a Promise that is resolved when sound data is processed
         *
         * @param data The XHR data for the sound implementation to process (Blob or ArrayBuffer)
         */
        Sound.prototype.setData = function (data) {
            var _this = this;
            return this.sound.processData(data).then(function (data) {
                _this._isLoaded = true;
                _this._data = _this.processData(data);
                return data;
            });
        };
        /**
         * Set the raw sound data (e.g. blob URL or AudioBuffer)
         */
        Sound.prototype.processData = function (data) {
            return data;
        };
        return Sound;
    }());
    exports.Sound = Sound;
    /**
     * Internal class representing a HTML5 audio instance
     */
    /* istanbul ignore next */
    var AudioTagInstance = (function () {
        function AudioTagInstance(src) {
            this._isPlaying = false;
            this._isPaused = false;
            this._loop = false;
            this._volume = 1.0;
            this._audioElement = new Audio(src);
        }
        AudioTagInstance.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        Object.defineProperty(AudioTagInstance.prototype, "loop", {
            get: function () {
                return this._loop;
            },
            enumerable: true,
            configurable: true
        });
        AudioTagInstance.prototype.setLoop = function (value) {
            this._loop = value;
            this._audioElement.loop = value;
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype.setVolume = function (value) {
            this._volume = value;
            this._audioElement.volume = Util.clamp(value, 0, 1.0);
        };
        AudioTagInstance.prototype.play = function () {
            if (this._isPaused) {
                this._resume();
            }
            else if (!this._isPlaying) {
                this._start();
            }
            return this._playingPromise;
        };
        AudioTagInstance.prototype._start = function () {
            this._audioElement.load();
            this._audioElement.loop = this._loop;
            this._audioElement.play();
            this._isPlaying = true;
            this._isPaused = false;
            this._playingPromise = new Promises_5.Promise();
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype._resume = function () {
            if (!this._isPaused) {
                return;
            }
            this._audioElement.play();
            this._isPaused = false;
            this._isPlaying = true;
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype.pause = function () {
            if (!this._isPlaying) {
                return;
            }
            this._audioElement.pause();
            this._isPaused = true;
            this._isPlaying = false;
        };
        AudioTagInstance.prototype.stop = function () {
            if (!this._isPlaying) {
                return;
            }
            this._audioElement.pause();
            this._audioElement.currentTime = 0;
            this._handleOnEnded();
        };
        AudioTagInstance.prototype._wireUpOnEnded = function () {
            var _this = this;
            if (!this._loop) {
                this._audioElement.onended = function () { return _this._handleOnEnded(); };
            }
        };
        AudioTagInstance.prototype._handleOnEnded = function () {
            this._isPlaying = false;
            this._isPaused = false;
            this._playingPromise.resolve(true);
        };
        return AudioTagInstance;
    }());
    /**
     * Internal class representing a Web Audio AudioBufferSourceNode instance
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
     */
    /* istanbul ignore next */
    var WebAudioInstance = (function () {
        function WebAudioInstance(_buffer) {
            this._buffer = _buffer;
            this._volumeNode = audioContext.createGain();
            this._isPlaying = false;
            this._isPaused = false;
            this._loop = false;
            this._volume = 1.0;
            /**
             * Current playback offset (in seconds)
             */
            this._currentOffset = 0;
        }
        WebAudioInstance.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        WebAudioInstance.prototype.setVolume = function (value) {
            this._volume = value;
            this._volumeNode.gain.value = Util.clamp(value, 0, 1.0);
        };
        WebAudioInstance.prototype.setLoop = function (value) {
            this._loop = value;
            if (this._bufferSource) {
                this._bufferSource.loop = value;
                this._wireUpOnEnded();
            }
        };
        WebAudioInstance.prototype.play = function () {
            if (this._isPaused) {
                this._resume();
            }
            else if (!this._isPlaying) {
                this._start();
            }
            return this._playingPromise;
        };
        WebAudioInstance.prototype._start = function () {
            this._volumeNode.connect(audioContext.destination);
            this._createBufferSource();
            this._bufferSource.start(0, 0);
            this._startTime = new Date().getTime();
            this._currentOffset = 0;
            this._isPlaying = true;
            this._isPaused = false;
            this._playingPromise = new Promises_5.Promise();
            this._wireUpOnEnded();
        };
        WebAudioInstance.prototype._resume = function () {
            if (!this._isPaused) {
                return;
            }
            // a buffer source can only be started once
            // so we need to dispose of the previous instance before
            // "resuming" the next one
            this._bufferSource.onended = null; // dispose of any previous event handler
            this._createBufferSource();
            var duration = (1 / this._bufferSource.playbackRate.value) * this._buffer.duration;
            this._bufferSource.start(0, this._currentOffset % duration);
            this._isPaused = false;
            this._isPlaying = true;
            this._wireUpOnEnded();
        };
        WebAudioInstance.prototype._createBufferSource = function () {
            this._bufferSource = audioContext.createBufferSource();
            this._bufferSource.buffer = this._buffer;
            this._bufferSource.loop = this._loop;
            this._bufferSource.playbackRate.value = 1.0;
            this._bufferSource.connect(this._volumeNode);
        };
        WebAudioInstance.prototype.pause = function () {
            if (!this._isPlaying) {
                return;
            }
            this._bufferSource.stop(0);
            // Playback rate will be a scale factor of how fast/slow the audio is being played
            // default is 1.0
            // we need to invert it to get the time scale
            var pbRate = 1 / (this._bufferSource.playbackRate.value || 1.0);
            this._currentOffset = ((new Date().getTime() - this._startTime) * pbRate) / 1000; // in seconds
            this._isPaused = true;
            this._isPlaying = false;
        };
        WebAudioInstance.prototype.stop = function () {
            if (!this._isPlaying) {
                return;
            }
            this._bufferSource.stop(0);
            // handler will not be wired up if we were looping
            if (!this._bufferSource.onended) {
                this._handleOnEnded();
            }
            this._currentOffset = 0;
            this._isPlaying = false;
            this._isPaused = false;
        };
        WebAudioInstance.prototype._wireUpOnEnded = function () {
            var _this = this;
            if (!this._loop) {
                this._bufferSource.onended = function () { return _this._handleOnEnded(); };
            }
        };
        WebAudioInstance.prototype._handleOnEnded = function () {
            // pausing calls stop(0) which triggers onended event
            // so we don't "resolve" yet (when we resume we'll try again)
            if (!this._isPaused) {
                this._isPlaying = false;
                this._playingPromise.resolve(true);
            }
        };
        return WebAudioInstance;
    }());
});
define("Interfaces/ILoader", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Loader", ["require", "exports", "Drawing/Color", "Resources/Sound", "Util/Log", "Promises", "Class", "Util/DrawUtil"], function (require, exports, Color_12, Sound_1, Log_7, Promises_6, Class_3, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Pre-loading assets
     *
     * The loader provides a mechanism to preload multiple resources at
     * one time. The loader must be passed to the engine in order to
     * trigger the loading progress bar.
     *
     * The [[Loader]] itself implements [[ILoadable]] so you can load loaders.
     *
     * ## Example: Pre-loading resources for a game
     *
     * ```js
     * // create a loader
     * var loader = new ex.Loader();
     *
     * // create a resource dictionary (best practice is to keep a separate file)
     * var resources = {
     *   TextureGround: new ex.Texture("/images/textures/ground.png"),
     *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
     * };
     *
     * // loop through dictionary and add to loader
     * for (var loadable in resources) {
     *   if (resources.hasOwnProperty(loadable)) {
     *     loader.addResource(resources[loadable]);
     *   }
     * }
     *
     * // start game
     * game.start(loader).then(function () {
     *   console.log("Game started!");
     * });
     * ```
     */
    var Loader = (function (_super) {
        __extends(Loader, _super);
        /**
         * @param loadables  Optionally provide the list of resources you want to load at constructor time
         */
        function Loader(loadables) {
            var _this = _super.call(this) || this;
            _this._resourceList = [];
            _this._index = 0;
            _this._resourceCount = 0;
            _this._numLoaded = 0;
            _this._progressCounts = {};
            _this._totalCounts = {};
            // logo drawing stuff
            /* tslint:disable:max-line-length */
            // base64 string encoding of the excalibur logo (logo-white.png)
            _this.logo = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=';
            /* tslint:enable:max-line-length */
            _this.logoWidth = 468;
            _this.logoHeight = 118;
            _this.backgroundColor = '#176BAA';
            _this.getData = function () { return; };
            _this.setData = function () { return; };
            _this.processData = function () { return; };
            _this.onprogress = function (e) {
                Log_7.Logger.getInstance().debug('[ex.Loader] Loading ' + (100 * e.loaded / e.total).toFixed(0));
                return;
            };
            _this.oncomplete = function () { return; };
            _this.onerror = function () { return; };
            if (loadables) {
                _this.addResources(loadables);
            }
            return _this;
        }
        Object.defineProperty(Loader.prototype, "_image", {
            get: function () {
                if (!this._imageElement) {
                    this._imageElement = new Image();
                    this._imageElement.src = this.logo;
                }
                return this._imageElement;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Loader.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Add a resource to the loader to load
         * @param loadable  Resource to add
         */
        Loader.prototype.addResource = function (loadable) {
            var key = this._index++;
            this._resourceList.push(loadable);
            this._progressCounts[key] = 0;
            this._totalCounts[key] = 1;
            this._resourceCount++;
        };
        /**
         * Add a list of resources to the loader to load
         * @param loadables  The list of resources to load
         */
        Loader.prototype.addResources = function (loadables) {
            var i = 0, len = loadables.length;
            for (i; i < len; i++) {
                this.addResource(loadables[i]);
            }
        };
        /**
         * Returns true if the loader has completely loaded all resources
         */
        Loader.prototype.isLoaded = function () {
            return this._numLoaded === this._resourceCount;
        };
        /**
         * Begin loading all of the supplied resources, returning a promise
         * that resolves when loading of all is complete
         */
        Loader.prototype.load = function () {
            var _this = this;
            var complete = new Promises_6.Promise();
            var me = this;
            if (this._resourceList.length === 0) {
                me.oncomplete.call(me);
                return complete.resolve();
            }
            var progressArray = new Array(this._resourceList.length);
            var progressChunks = this._resourceList.length;
            this._resourceList.forEach(function (r, i) {
                if (_this._engine) {
                    r.wireEngine(_this._engine);
                }
                r.onprogress = function (e) {
                    var total = e.total;
                    var loaded = e.loaded;
                    progressArray[i] = { loaded: ((loaded / total) * (100 / progressChunks)), total: 100 };
                    var progressResult = progressArray.reduce(function (accum, next) {
                        return { loaded: (accum.loaded + next.loaded), total: 100 };
                    }, { loaded: 0, total: 100 });
                    me.onprogress.call(me, progressResult);
                };
                r.oncomplete = r.onerror = function () {
                    me._numLoaded++;
                    if (me._numLoaded === me._resourceCount) {
                        me.oncomplete.call(me);
                        complete.resolve();
                    }
                };
            });
            function loadNext(list, index) {
                if (!list[index]) {
                    return;
                }
                list[index].load().then(function () {
                    loadNext(list, index + 1);
                });
            }
            loadNext(this._resourceList, 0);
            return complete;
        };
        /**
         * Loader draw function. Draws the default Excalibur loading screen.
         * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
         * to customize the drawing, or just override entire method.
         */
        Loader.prototype.draw = function (ctx) {
            var canvasHeight = this._engine.canvasHeight / window.devicePixelRatio;
            var canvasWidth = this._engine.canvasWidth / window.devicePixelRatio;
            ctx.fillStyle = this.backgroundColor;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            var y = canvasHeight / 2;
            var width = Math.min(this.logoWidth, canvasWidth * 0.75);
            var x = (canvasWidth / 2) - (width / 2);
            var imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
            var oldAntialias = this._engine.getAntialiasing();
            this._engine.setAntialiasing(true);
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, x, y - imageHeight - 20, width, imageHeight);
            // loading box
            ctx.lineWidth = 2;
            DrawUtil.roundRect(ctx, x, y, width, 20, 10);
            var progress = width * (this._numLoaded / this._resourceCount);
            var margin = 5;
            var progressWidth = progress - margin * 2;
            var height = 20 - margin * 2;
            DrawUtil.roundRect(ctx, x + margin, y + margin, progressWidth > 0 ? progressWidth : 0, height, 5, null, Color_12.Color.White);
            this._engine.setAntialiasing(oldAntialias);
        };
        /**
         * Perform any calculations or logic in the `update` method. The default `Loader` does not
         * do anything in this method so it is safe to override.
         */
        Loader.prototype.update = function (_engine, _delta) {
            // overridable update
        };
        return Loader;
    }(Class_3.Class));
    exports.Loader = Loader;
    /**
     * A [[Loader]] that pauses after loading to allow user
     * to proceed to play the game. Typically you will
     * want to use this loader for iOS to allow sounds
     * to play after loading (Apple Safari requires user
     * interaction to allow sounds, even for games)
     *
     * **Note:** Because Loader is not part of a Scene, you must
     * call `update` and `draw` manually on "child" objects.
     *
     * ## Implementing a Trigger
     *
     * The `PauseAfterLoader` requires an element to act as the trigger button
     * to start the game.
     *
     * For example, let's create an `<a>` tag to be our trigger and call it `tap-to-play`.
     *
     * ```html
     * <div id="wrapper">
     *    <canvas id="game"></canvas>
     *    <a id="tap-to-play" href='javascript:void(0);'>Tap to Play</a>
     * </div>
     * ```
     *
     * We've put it inside a wrapper to position it properly over the game canvas.
     *
     * Now let's add some CSS to style it (insert into `<head>`):
     *
     * ```html
     * <style>
     *     #wrapper {
     *         position: relative;
     *         width: 500px;
     *         height: 500px;
     *     }
     *     #tap-to-play {
     *         display: none;
     *         font-size: 24px;
     *         font-family: sans-serif;
     *         text-align: center;
     *         border: 3px solid white;
     *         position: absolute;
     *         color: white;
     *         width: 200px;
     *         height: 50px;
     *         line-height: 50px;
     *         text-decoration: none;
     *         left: 147px;
     *         top: 80%;
     *     }
     * </style>
     * ```
     *
     * Now we can create a `PauseAfterLoader` with a reference to our trigger button:
     *
     * ```ts
     * var loader = new ex.PauseAfterLoader('tap-to-play', [...]);
     * ```
     *
     * ## Use PauseAfterLoader for iOS
     *
     * The primary use case for pausing before starting the game is to
     * pass Apple's requirement of user interaction. The Web Audio context
     * in Safari is disabled by default until user interaction.
     *
     * Therefore, you can use this snippet to only use PauseAfterLoader when
     * iOS is detected (see [this thread](http://stackoverflow.com/questions/9038625/detect-if-device-is-ios)
     * for more techniques).
     *
     * ```ts
     * var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(<any>window).MSStream;
     * var loader: ex.Loader = iOS ? new ex.PauseAfterLoader('tap-to-play') : new ex.Loader();
     *
     * loader.addResource(...);
     * ```
     */
    var PauseAfterLoader = (function (_super) {
        __extends(PauseAfterLoader, _super);
        function PauseAfterLoader(triggerElementId, loadables) {
            var _this = _super.call(this, loadables) || this;
            _this._handleOnTrigger = function () {
                if (_this._waitPromise.state() !== Promises_6.PromiseState.Pending) {
                    return false;
                }
                // unlock Safari WebAudio context
                Sound_1.WebAudio.unlock();
                // continue to play game
                _this._waitPromise.resolve(_this._loadedValue);
                // hide DOM element
                _this._playTrigger.style.display = 'none';
                return false;
            };
            _this._playTrigger = document.getElementById(triggerElementId);
            _this._playTrigger.addEventListener('click', _this._handleOnTrigger);
            return _this;
        }
        PauseAfterLoader.prototype.load = function () {
            var _this = this;
            this._waitPromise = new Promises_6.Promise();
            // wait until user indicates to proceed before finishing load
            _super.prototype.load.call(this).then(function (value) {
                _this._loaded = true;
                _this._loadedValue = value;
                // show element
                _this._playTrigger.style.display = 'block';
            }, function (value) {
                _this._waitPromise.reject(value);
            });
            return this._waitPromise;
        };
        return PauseAfterLoader;
    }(Loader));
    exports.PauseAfterLoader = PauseAfterLoader;
});
define("Interfaces/IActorTrait", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Traits/CapturePointer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Propogates pointer events to the actor
     */
    var CapturePointer = (function () {
        function CapturePointer() {
        }
        CapturePointer.prototype.update = function (actor, engine) {
            if (!actor.enableCapturePointer) {
                return;
            }
            if (actor.isKilled()) {
                return;
            }
            engine.input.pointers.propogate(actor);
        };
        return CapturePointer;
    }());
    exports.CapturePointer = CapturePointer;
});
define("Traits/EulerMovement", ["require", "exports", "Physics", "Actor"], function (require, exports, Physics_7, Actor_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EulerMovement = (function () {
        function EulerMovement() {
        }
        EulerMovement.prototype.update = function (actor, _engine, delta) {
            // Update placements based on linear algebra
            var seconds = delta / 1000;
            var totalAcc = actor.acc.clone();
            // Only active vanilla actors are affected by global acceleration
            if (actor.collisionType === Actor_5.CollisionType.Active) {
                totalAcc.addEqual(Physics_7.Physics.acc);
            }
            actor.oldVel = actor.vel;
            actor.vel.addEqual(totalAcc.scale(seconds));
            actor.pos.addEqual(actor.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
            actor.rx += actor.torque * (1.0 / actor.moi) * seconds;
            actor.rotation += actor.rx * seconds;
            actor.scale.x += actor.sx * delta / 1000;
            actor.scale.y += actor.sy * delta / 1000;
        };
        return EulerMovement;
    }());
    exports.EulerMovement = EulerMovement;
});
define("Util/CullingBox", ["require", "exports", "Algebra", "Drawing/Color"], function (require, exports, Algebra_13, Color_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CullingBox = (function () {
        function CullingBox() {
            this._topLeft = new Algebra_13.Vector(0, 0);
            this._topRight = new Algebra_13.Vector(0, 0);
            this._bottomLeft = new Algebra_13.Vector(0, 0);
            this._bottomRight = new Algebra_13.Vector(0, 0);
        }
        CullingBox.prototype.isSpriteOffScreen = function (actor, engine) {
            var drawingWidth = actor.currentDrawing.width;
            var drawingHeight = actor.currentDrawing.height;
            var rotation = actor.rotation;
            var anchor = actor.getCenter();
            var worldPos = actor.getWorldPos();
            this._topLeft.x = worldPos.x - (drawingWidth / 2);
            this._topLeft.y = worldPos.y - (drawingHeight / 2);
            this._topLeft = this._topLeft.rotate(rotation, anchor);
            this._topRight.x = worldPos.x + (drawingWidth / 2);
            this._topRight.y = worldPos.y - (drawingHeight / 2);
            this._topRight = this._topRight.rotate(rotation, anchor);
            this._bottomLeft.x = worldPos.x - (drawingWidth / 2);
            this._bottomLeft.y = worldPos.y + (drawingHeight / 2);
            this._bottomLeft = this._bottomLeft.rotate(rotation, anchor);
            this._bottomRight.x = worldPos.x + (drawingWidth / 2);
            this._bottomRight.y = worldPos.y + (drawingHeight / 2);
            this._bottomRight = this._bottomRight.rotate(rotation, anchor);
            ///
            var topLeftScreen = engine.worldToScreenCoordinates(this._topLeft);
            var topRightScreen = engine.worldToScreenCoordinates(this._topRight);
            var bottomLeftScreen = engine.worldToScreenCoordinates(this._bottomLeft);
            var bottomRightScreen = engine.worldToScreenCoordinates(this._bottomRight);
            this._xCoords = [];
            this._yCoords = [];
            this._xCoords.push(topLeftScreen.x, topRightScreen.x, bottomLeftScreen.x, bottomRightScreen.x);
            this._yCoords.push(topLeftScreen.y, topRightScreen.y, bottomLeftScreen.y, bottomRightScreen.y);
            this._xMin = Math.min.apply(null, this._xCoords);
            this._yMin = Math.min.apply(null, this._yCoords);
            this._xMax = Math.max.apply(null, this._xCoords);
            this._yMax = Math.max.apply(null, this._yCoords);
            var minWorld = engine.screenToWorldCoordinates(new Algebra_13.Vector(this._xMin, this._yMin));
            var maxWorld = engine.screenToWorldCoordinates(new Algebra_13.Vector(this._xMax, this._yMax));
            this._xMinWorld = minWorld.x;
            this._yMinWorld = minWorld.y;
            this._xMaxWorld = maxWorld.x;
            this._yMaxWorld = maxWorld.y;
            var boundingPoints = [
                new Algebra_13.Vector(this._xMin, this._yMin),
                new Algebra_13.Vector(this._xMax, this._yMin),
                new Algebra_13.Vector(this._xMin, this._yMax),
                new Algebra_13.Vector(this._xMax, this._yMax)
            ]; // bottomright
            // sprite can be wider than canvas screen (and still visible within canvas)
            // top or bottom of sprite must be within canvas
            if (boundingPoints[0].x < 0 && boundingPoints[1].x > engine.canvas.clientWidth &&
                (boundingPoints[0].y > 0 || boundingPoints[2].y < engine.canvas.clientHeight)) {
                return false;
            }
            // sprite can be taller than canvas screen (and still visible within canvas)
            // left or right of sprite must be within canvas
            if (boundingPoints[0].y < 0 && boundingPoints[2].y > engine.canvas.clientHeight &&
                (boundingPoints[1].x > 0 || boundingPoints[0].x < engine.canvas.clientWidth)) {
                return false;
            }
            // otherwise if any corner is visible, we're not offscreen
            for (var i = 0; i < boundingPoints.length; i++) {
                if (boundingPoints[i].x > 0 &&
                    boundingPoints[i].y > 0 &&
                    boundingPoints[i].x < engine.canvas.clientWidth &&
                    boundingPoints[i].y < engine.canvas.clientHeight) {
                    return false;
                }
            }
            return true;
        };
        CullingBox.prototype.debugDraw = function (ctx) {
            // bounding rectangle
            ctx.beginPath();
            ctx.strokeStyle = Color_13.Color.White.toString();
            ctx.rect(this._xMinWorld, this._yMinWorld, this._xMaxWorld - this._xMinWorld, this._yMaxWorld - this._yMinWorld);
            ctx.stroke();
            ctx.fillStyle = Color_13.Color.Red.toString();
            ctx.beginPath();
            ctx.arc(this._topLeft.x, this._topLeft.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Green.toString();
            ctx.beginPath();
            ctx.arc(this._topRight.x, this._topRight.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Blue.toString();
            ctx.beginPath();
            ctx.arc(this._bottomLeft.x, this._bottomLeft.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Magenta.toString();
            ctx.beginPath();
            ctx.arc(this._bottomRight.x, this._bottomRight.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        return CullingBox;
    }());
    exports.CullingBox = CullingBox;
});
define("Traits/OffscreenCulling", ["require", "exports", "Util/CullingBox", "Algebra", "Events"], function (require, exports, CullingBox_1, Algebra_14, Events_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OffscreenCulling = (function () {
        function OffscreenCulling() {
            this.cullingBox = new CullingBox_1.CullingBox();
        }
        OffscreenCulling.prototype.update = function (actor, engine) {
            var eventDispatcher = actor.eventDispatcher;
            var anchor = actor.anchor;
            var globalScale = actor.getGlobalScale();
            var width = globalScale.x * actor.getWidth() / actor.scale.x;
            var height = globalScale.y * actor.getHeight() / actor.scale.y;
            var worldPos = actor.getWorldPos();
            var actorScreenCoords = engine.worldToScreenCoordinates(new Algebra_14.Vector(worldPos.x - anchor.x * width, worldPos.y - anchor.y * height));
            var zoom = 1.0;
            if (actor.scene && actor.scene.camera) {
                zoom = Math.abs(actor.scene.camera.getZoom());
            }
            var isSpriteOffScreen = true;
            if (actor.currentDrawing != null) {
                isSpriteOffScreen = this.cullingBox.isSpriteOffScreen(actor, engine);
            }
            if (!actor.isOffScreen) {
                if ((actorScreenCoords.x + width * zoom < 0 ||
                    actorScreenCoords.y + height * zoom < 0 ||
                    actorScreenCoords.x > engine.canvasWidth ||
                    actorScreenCoords.y > engine.canvasHeight) &&
                    isSpriteOffScreen) {
                    eventDispatcher.emit('exitviewport', new Events_3.ExitViewPortEvent(actor));
                    actor.isOffScreen = true;
                }
            }
            else {
                if ((actorScreenCoords.x + width * zoom > 0 &&
                    actorScreenCoords.y + height * zoom > 0 &&
                    actorScreenCoords.x < engine.canvasWidth &&
                    actorScreenCoords.y < engine.canvasHeight) ||
                    !isSpriteOffScreen) {
                    eventDispatcher.emit('enterviewport', new Events_3.EnterViewPortEvent(actor));
                    actor.isOffScreen = false;
                }
            }
        };
        return OffscreenCulling;
    }());
    exports.OffscreenCulling = OffscreenCulling;
});
define("Traits/TileMapCollisionDetection", ["require", "exports", "Actor", "Collision/Side", "Events"], function (require, exports, Actor_6, Side_2, Events_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TileMapCollisionDetection = (function () {
        function TileMapCollisionDetection() {
        }
        TileMapCollisionDetection.prototype.update = function (actor, engine) {
            var eventDispatcher = actor.eventDispatcher;
            if (actor.collisionType !== Actor_6.CollisionType.PreventCollision && engine.currentScene && engine.currentScene.tileMaps) {
                for (var j = 0; j < engine.currentScene.tileMaps.length; j++) {
                    var map = engine.currentScene.tileMaps[j];
                    var intersectMap;
                    var side = Side_2.Side.None;
                    var max = 2;
                    while (intersectMap = map.collides(actor)) {
                        if (max-- < 0) {
                            break;
                        }
                        side = actor.getSideFromIntersect(intersectMap);
                        eventDispatcher.emit('precollision', new Events_4.PreCollisionEvent(actor, null, side, intersectMap));
                        if (actor.collisionType === Actor_6.CollisionType.Active) {
                            actor.pos.y += intersectMap.y;
                            actor.pos.x += intersectMap.x;
                            eventDispatcher.emit('postcollision', new Events_4.PostCollisionEvent(actor, null, side, intersectMap));
                        }
                    }
                }
            }
        };
        return TileMapCollisionDetection;
    }());
    exports.TileMapCollisionDetection = TileMapCollisionDetection;
});
define("Traits/Index", ["require", "exports", "Traits/CapturePointer", "Traits/EulerMovement", "Traits/OffscreenCulling", "Traits/TileMapCollisionDetection"], function (require, exports, CapturePointer_1, EulerMovement_1, OffscreenCulling_1, TileMapCollisionDetection_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(CapturePointer_1);
    __export(EulerMovement_1);
    __export(OffscreenCulling_1);
    __export(TileMapCollisionDetection_1);
});
define("Particles", ["require", "exports", "Actor", "Drawing/Color", "Algebra", "Util/Util", "Util/DrawUtil", "Traits/Index"], function (require, exports, Actor_7, Color_14, Algebra_15, Util, DrawUtil, Traits) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that represents the types of emitter nozzles
     */
    var EmitterType;
    (function (EmitterType) {
        /**
         * Constant for the circular emitter type
         */
        EmitterType[EmitterType["Circle"] = 0] = "Circle";
        /**
         * Constant for the rectangular emitter type
         */
        EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
    })(EmitterType = exports.EmitterType || (exports.EmitterType = {}));
    /**
     * Particle is used in a [[ParticleEmitter]]
     */
    var Particle = (function () {
        function Particle(emitter, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            this.position = new Algebra_15.Vector(0, 0);
            this.velocity = new Algebra_15.Vector(0, 0);
            this.acceleration = new Algebra_15.Vector(0, 0);
            this.particleRotationalVelocity = 0;
            this.currentRotation = 0;
            this.focus = null;
            this.focusAccel = 0;
            this.opacity = 1;
            this.beginColor = Color_14.Color.White.clone();
            this.endColor = Color_14.Color.White.clone();
            // Life is counted in ms
            this.life = 300;
            this.fadeFlag = false;
            // Color transitions
            this._rRate = 1;
            this._gRate = 1;
            this._bRate = 1;
            this._aRate = 0;
            this._currentColor = Color_14.Color.White.clone();
            this.emitter = null;
            this.particleSize = 5;
            this.particleSprite = null;
            this.sizeRate = 0;
            this.elapsedMultiplier = 0;
            this.emitter = emitter;
            this.life = life || this.life;
            this.opacity = opacity || this.opacity;
            this.endColor = endColor || this.endColor.clone();
            this.beginColor = beginColor || this.beginColor.clone();
            this._currentColor = this.beginColor.clone();
            this.position = position || this.position;
            this.velocity = velocity || this.velocity;
            this.acceleration = acceleration || this.acceleration;
            this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
            this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
            this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
            this._aRate = this.opacity / this.life;
            this.startSize = startSize || 0;
            this.endSize = endSize || 0;
            if ((this.endSize > 0) && (this.startSize > 0)) {
                this.sizeRate = (this.endSize - this.startSize) / this.life;
                this.particleSize = this.startSize;
            }
        }
        Particle.prototype.kill = function () {
            this.emitter.removeParticle(this);
        };
        Particle.prototype.update = function (delta) {
            this.life = this.life - delta;
            this.elapsedMultiplier = this.elapsedMultiplier + delta;
            if (this.life < 0) {
                this.kill();
            }
            if (this.fadeFlag) {
                this.opacity = Util.clamp(this._aRate * this.life, 0.0001, 1);
            }
            if ((this.startSize > 0) && (this.endSize > 0)) {
                this.particleSize = Util.clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
            }
            this._currentColor.r = Util.clamp(this._currentColor.r + this._rRate * delta, 0, 255);
            this._currentColor.g = Util.clamp(this._currentColor.g + this._gRate * delta, 0, 255);
            this._currentColor.b = Util.clamp(this._currentColor.b + this._bRate * delta, 0, 255);
            this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);
            if (this.focus) {
                var accel = this.focus.sub(this.position).normalize().scale(this.focusAccel).scale(delta / 1000);
                this.velocity = this.velocity.add(accel);
            }
            else {
                this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
            }
            this.position = this.position.add(this.velocity.scale(delta / 1000));
            if (this.particleRotationalVelocity) {
                this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1000) % (2 * Math.PI);
            }
        };
        Particle.prototype.draw = function (ctx) {
            if (this.particleSprite) {
                this.particleSprite.rotation = this.currentRotation;
                this.particleSprite.scale.setTo(this.particleSize, this.particleSize);
                this.particleSprite.draw(ctx, this.position.x, this.position.y);
                return;
            }
            this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);
            ctx.fillStyle = this._currentColor.toString();
            ctx.beginPath();
            ctx.arc(this.position.x, this.position.y, this.particleSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        };
        return Particle;
    }());
    exports.Particle = Particle;
    /**
     * Using a particle emitter is a great way to create interesting effects
     * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
     * extend [[Actor]] allowing you to use all of the features that come with.
     *
     * [[include:Particles.md]]
     */
    var ParticleEmitter = (function (_super) {
        __extends(ParticleEmitter, _super);
        /**
         * @param x       The x position of the emitter
         * @param y       The y position of the emitter
         * @param width   The width of the emitter
         * @param height  The height of the emitter
         */
        function ParticleEmitter(x, y, width, height) {
            var _this = _super.call(this, x, y, width, height, Color_14.Color.White) || this;
            _this._particlesToEmit = 0;
            _this.numParticles = 0;
            /**
             * Gets or sets the isEmitting flag
             */
            _this.isEmitting = true;
            /**
             * Gets or sets the backing particle collection
             */
            _this.particles = null;
            /**
             * Gets or sets the backing deadParticle collection
             */
            _this.deadParticles = null;
            /**
             * Gets or sets the minimum particle velocity
             */
            _this.minVel = 0;
            /**
             * Gets or sets the maximum particle velocity
             */
            _this.maxVel = 0;
            /**
             * Gets or sets the acceleration vector for all particles
             */
            _this.acceleration = new Algebra_15.Vector(0, 0);
            /**
             * Gets or sets the minimum angle in radians
             */
            _this.minAngle = 0;
            /**
             * Gets or sets the maximum angle in radians
             */
            _this.maxAngle = 0;
            /**
             * Gets or sets the emission rate for particles (particles/sec)
             */
            _this.emitRate = 1; //particles/sec
            /**
             * Gets or sets the life of each particle in milliseconds
             */
            _this.particleLife = 2000;
            /**
             * Gets or sets the opacity of each particle from 0 to 1.0
             */
            _this.opacity = 1;
            /**
             * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
             */
            _this.fadeFlag = false;
            /**
             * Gets or sets the optional focus where all particles should accelerate towards
             */
            _this.focus = null;
            /**
             * Gets or sets the acceleration for focusing particles if a focus has been specified
             */
            _this.focusAccel = 1;
            /*
             * Gets or sets the optional starting size for the particles
             */
            _this.startSize = null;
            /*
             * Gets or sets the optional ending size for the particles
             */
            _this.endSize = null;
            /**
             * Gets or sets the minimum size of all particles
             */
            _this.minSize = 5;
            /**
             * Gets or sets the maximum size of all particles
             */
            _this.maxSize = 5;
            /**
             * Gets or sets the beginning color of all particles
             */
            _this.beginColor = Color_14.Color.White;
            /**
             * Gets or sets the ending color of all particles
             */
            _this.endColor = Color_14.Color.White;
            /**
             * Gets or sets the sprite that a particle should use
             * @warning Performance intensive
             */
            _this.particleSprite = null;
            /**
             * Gets or sets the emitter type for the particle emitter
             */
            _this.emitterType = EmitterType.Rectangle;
            /**
             * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]
             */
            _this.radius = 0;
            /**
             * Gets or sets the particle rotational speed velocity
             */
            _this.particleRotationalVelocity = 0;
            /**
             * Indicates whether particles should start with a random rotation
             */
            _this.randomRotation = false;
            _this.collisionType = Actor_7.CollisionType.PreventCollision;
            _this.particles = new Util.Collection();
            _this.deadParticles = new Util.Collection();
            // Remove offscreen culling from particle emitters
            for (var i = 0; i < _this.traits.length; i++) {
                if (_this.traits[i] instanceof Traits.OffscreenCulling) {
                    _this.traits.splice(i, 1);
                }
            }
            return _this;
        }
        ParticleEmitter.prototype.removeParticle = function (particle) {
            this.deadParticles.push(particle);
        };
        /**
         * Causes the emitter to emit particles
         * @param particleCount  Number of particles to emit right now
         */
        ParticleEmitter.prototype.emitParticles = function (particleCount) {
            for (var i = 0; i < particleCount; i++) {
                this.particles.push(this._createParticle());
            }
        };
        ParticleEmitter.prototype.clearParticles = function () {
            this.particles.clear();
        };
        // Creates a new particle given the constraints of the emitter
        ParticleEmitter.prototype._createParticle = function () {
            // todo implement emitter constraints;
            var ranX = 0;
            var ranY = 0;
            var angle = Util.randomInRange(this.minAngle, this.maxAngle);
            var vel = Util.randomInRange(this.minVel, this.maxVel);
            var size = this.startSize || Util.randomInRange(this.minSize, this.maxSize);
            var dx = vel * Math.cos(angle);
            var dy = vel * Math.sin(angle);
            if (this.emitterType === EmitterType.Rectangle) {
                ranX = Util.randomInRange(this.pos.x, this.pos.x + this.getWidth());
                ranY = Util.randomInRange(this.pos.y, this.pos.y + this.getHeight());
            }
            else if (this.emitterType === EmitterType.Circle) {
                var radius = Util.randomInRange(0, this.radius);
                ranX = radius * Math.cos(angle) + this.pos.x;
                ranY = radius * Math.sin(angle) + this.pos.y;
            }
            var p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Algebra_15.Vector(ranX, ranY), new Algebra_15.Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
            p.fadeFlag = this.fadeFlag;
            p.particleSize = size;
            if (this.particleSprite) {
                p.particleSprite = this.particleSprite;
            }
            p.particleRotationalVelocity = this.particleRotationalVelocity;
            if (this.randomRotation) {
                p.currentRotation = Util.randomInRange(0, Math.PI * 2);
            }
            if (this.focus) {
                p.focus = this.focus.add(new Algebra_15.Vector(this.pos.x, this.pos.y));
                p.focusAccel = this.focusAccel;
            }
            return p;
        };
        ParticleEmitter.prototype.update = function (engine, delta) {
            var _this = this;
            _super.prototype.update.call(this, engine, delta);
            if (this.isEmitting) {
                this._particlesToEmit += this.emitRate * (delta / 1000);
                //var numParticles = Math.ceil(this.emitRate * delta / 1000);
                if (this._particlesToEmit > 1.0) {
                    this.emitParticles(Math.floor(this._particlesToEmit));
                    this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
                }
            }
            this.particles.forEach(function (p) { return p.update(delta); });
            this.deadParticles.forEach(function (p) { return _this.particles.removeElement(p); });
            this.deadParticles.clear();
        };
        ParticleEmitter.prototype.draw = function (ctx) {
            // todo is there a more efficient to draw 
            // possibly use a webgl offscreen canvas and shaders to do particles?
            this.particles.forEach(function (p) { return p.draw(ctx); });
        };
        ParticleEmitter.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            ctx.fillStyle = Color_14.Color.Black.toString();
            ctx.fillText('Particles: ' + this.particles.count(), this.pos.x, this.pos.y + 20);
            if (this.focus) {
                ctx.fillRect(this.focus.x + this.pos.x, this.focus.y + this.pos.y, 3, 3);
                DrawUtil.line(ctx, Color_14.Color.Yellow, this.focus.x + this.pos.x, this.focus.y + this.pos.y, _super.prototype.getCenter.call(this).x, _super.prototype.getCenter.call(this).y);
                ctx.fillText('Focus', this.focus.x + this.pos.x, this.focus.y + this.pos.y);
            }
        };
        return ParticleEmitter;
    }(Actor_7.Actor));
    exports.ParticleEmitter = ParticleEmitter;
});
define("TileMap", ["require", "exports", "Collision/BoundingBox", "Drawing/Color", "Class", "Algebra", "Util/Log", "Events"], function (require, exports, BoundingBox_4, Color_15, Class_4, Algebra_16, Log_8, Events) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The [[TileMap]] class provides a lightweight way to do large complex scenes with collision
     * without the overhead of actors.
     *
     * [[include:TileMaps.md]]
     */
    var TileMap = (function (_super) {
        __extends(TileMap, _super);
        /**
         * @param x             The x coordinate to anchor the TileMap's upper left corner (should not be changed once set)
         * @param y             The y coordinate to anchor the TileMap's upper left corner (should not be changed once set)
         * @param cellWidth     The individual width of each cell (in pixels) (should not be changed once set)
         * @param cellHeight    The individual height of each cell (in pixels) (should not be changed once set)
         * @param rows          The number of rows in the TileMap (should not be changed once set)
         * @param cols          The number of cols in the TileMap (should not be changed once set)
         */
        function TileMap(x, y, cellWidth, cellHeight, rows, cols) {
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.cellWidth = cellWidth;
            _this.cellHeight = cellHeight;
            _this.rows = rows;
            _this.cols = cols;
            _this._collidingX = -1;
            _this._collidingY = -1;
            _this._onScreenXStart = 0;
            _this._onScreenXEnd = 9999;
            _this._onScreenYStart = 0;
            _this._onScreenYEnd = 9999;
            _this._spriteSheets = {};
            _this.logger = Log_8.Logger.getInstance();
            _this.data = [];
            _this.data = new Array(rows * cols);
            for (var i = 0; i < cols; i++) {
                for (var j = 0; j < rows; j++) {
                    (function () {
                        var cd = new Cell(i * cellWidth + x, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                        _this.data[i + j * cols] = cd;
                    })();
                }
            }
            return _this;
        }
        TileMap.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        TileMap.prototype.registerSpriteSheet = function (key, spriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        };
        /**
         * Returns the intersection vector that can be used to resolve collisions with actors. If there
         * is no collision null is returned.
         */
        TileMap.prototype.collides = function (actor) {
            var width = actor.pos.x + actor.getWidth();
            var height = actor.pos.y + actor.getHeight();
            var actorBounds = actor.getBounds();
            var overlaps = [];
            // trace points for overlap
            for (var x = actorBounds.left; x <= width; x += Math.min(actor.getWidth() / 2, this.cellWidth / 2)) {
                for (var y = actorBounds.top; y <= height; y += Math.min(actor.getHeight() / 2, this.cellHeight / 2)) {
                    var cell = this.getCellByPoint(x, y);
                    if (cell && cell.solid) {
                        var overlap = actorBounds.collides(cell.getBounds());
                        var dir = actor.getCenter().sub(cell.getCenter());
                        if (overlap && overlap.dot(dir) > 0) {
                            overlaps.push(overlap);
                        }
                    }
                }
            }
            if (overlaps.length === 0) {
                return null;
            }
            // Return the smallest change other than zero
            var result = overlaps.reduce(function (accum, next) {
                var x = accum.x;
                var y = accum.y;
                if (Math.abs(accum.x) < Math.abs(next.x)) {
                    x = next.x;
                }
                if (Math.abs(accum.y) < Math.abs(next.y)) {
                    y = next.y;
                }
                return new Algebra_16.Vector(x, y);
            });
            return result;
        };
        /**
         * Returns the [[Cell]] by index (row major order)
         */
        TileMap.prototype.getCellByIndex = function (index) {
            return this.data[index];
        };
        /**
         * Returns the [[Cell]] by its x and y coordinates
         */
        TileMap.prototype.getCell = function (x, y) {
            if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
                return null;
            }
            return this.data[x + y * this.cols];
        };
        /**
         * Returns the [[Cell]] by testing a point in global coordinates,
         * returns `null` if no cell was found.
         */
        TileMap.prototype.getCellByPoint = function (x, y) {
            x = Math.floor((x - this.x) / this.cellWidth);
            y = Math.floor((y - this.y) / this.cellHeight);
            var cell = this.getCell(x, y);
            if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
                return cell;
            }
            return null;
        };
        TileMap.prototype.update = function (engine, delta) {
            this.emit('preupdate', new Events.PreUpdateEvent(engine, delta, this));
            var worldCoordsUpperLeft = engine.screenToWorldCoordinates(new Algebra_16.Vector(0, 0));
            var worldCoordsLowerRight = engine.screenToWorldCoordinates(new Algebra_16.Vector(engine.canvas.clientWidth, engine.canvas.clientHeight));
            this._onScreenXStart = Math.max(Math.floor(worldCoordsUpperLeft.x / this.cellWidth) - 2, 0);
            this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
            this._onScreenXEnd = Math.max(Math.floor(worldCoordsLowerRight.x / this.cellWidth) + 2, 0);
            this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
            this.emit('postupdate', new Events.PostUpdateEvent(engine, delta, this));
        };
        /**
         * Draws the tile map to the screen. Called by the [[Scene]].
         * @param ctx    The current rendering context
         * @param delta  The number of milliseconds since the last draw
         */
        TileMap.prototype.draw = function (ctx, delta) {
            this.emit('predraw', new Events.PreDrawEvent(ctx, delta, this));
            ctx.save();
            ctx.translate(this.x, this.y);
            var x = this._onScreenXStart, xEnd = Math.min(this._onScreenXEnd, this.cols);
            var y = this._onScreenYStart, yEnd = Math.min(this._onScreenYEnd, this.rows);
            var cs, csi, cslen;
            for (x; x < xEnd; x++) {
                for (y; y < yEnd; y++) {
                    // get non-negative tile sprites
                    cs = this.getCell(x, y).sprites.filter(function (s) {
                        return s.spriteId > -1;
                    });
                    for (csi = 0, cslen = cs.length; csi < cslen; csi++) {
                        var ss = this._spriteSheets[cs[csi].spriteSheetKey];
                        // draw sprite, warning if sprite doesn't exist
                        if (ss) {
                            var sprite = ss.getSprite(cs[csi].spriteId);
                            if (sprite) {
                                sprite.draw(ctx, x * this.cellWidth, y * this.cellHeight);
                            }
                            else {
                                this.logger.warn('Sprite does not exist for id', cs[csi].spriteId, 'in sprite sheet', cs[csi].spriteSheetKey, sprite, ss);
                            }
                        }
                        else {
                            this.logger.warn('Sprite sheet', cs[csi].spriteSheetKey, 'does not exist', ss);
                        }
                    }
                }
                y = this._onScreenYStart;
            }
            ctx.restore();
            this.emit('postdraw', new Events.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Draws all the tile map's debug info. Called by the [[Scene]].
         * @param ctx  The current rendering context
         */
        TileMap.prototype.debugDraw = function (ctx) {
            var width = this.cols * this.cellWidth;
            var height = this.rows * this.cellHeight;
            ctx.save();
            ctx.strokeStyle = Color_15.Color.Red.toString();
            for (var x = 0; x < this.cols + 1; x++) {
                ctx.beginPath();
                ctx.moveTo(this.x + x * this.cellWidth, this.y);
                ctx.lineTo(this.x + x * this.cellWidth, this.y + height);
                ctx.stroke();
            }
            for (var y = 0; y < this.rows + 1; y++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + y * this.cellHeight);
                ctx.lineTo(this.x + width, this.y + y * this.cellHeight);
                ctx.stroke();
            }
            var solid = Color_15.Color.Red.clone();
            solid.a = .3;
            this.data.filter(function (cell) {
                return cell.solid;
            }).forEach(function (cell) {
                ctx.fillStyle = solid.toString();
                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
            });
            if (this._collidingY > -1 && this._collidingX > -1) {
                ctx.fillStyle = Color_15.Color.Cyan.toString();
                ctx.fillRect(this.x + this._collidingX * this.cellWidth, this.y + this._collidingY * this.cellHeight, this.cellWidth, this.cellHeight);
            }
            ctx.restore();
        };
        return TileMap;
    }(Class_4.Class));
    exports.TileMap = TileMap;
    /**
     * Tile sprites are used to render a specific sprite from a [[TileMap]]'s spritesheet(s)
     */
    var TileSprite = (function () {
        /**
         * @param spriteSheetKey  The key of the spritesheet to use
         * @param spriteId        The index of the sprite in the [[SpriteSheet]]
         */
        function TileSprite(spriteSheetKey, spriteId) {
            this.spriteSheetKey = spriteSheetKey;
            this.spriteId = spriteId;
        }
        return TileSprite;
    }());
    exports.TileSprite = TileSprite;
    /**
     * TileMap Cell
     *
     * A light-weight object that occupies a space in a collision map. Generally
     * created by a [[TileMap]].
     *
     * Cells can draw multiple sprites. Note that the order of drawing is the order
     * of the sprites in the array so the last one will be drawn on top. You can
     * use transparency to create layers this way.
     */
    var Cell = (function () {
        /**
         * @param x       Gets or sets x coordinate of the cell in world coordinates
         * @param y       Gets or sets y coordinate of the cell in world coordinates
         * @param width   Gets or sets the width of the cell
         * @param height  Gets or sets the height of the cell
         * @param index   The index of the cell in row major order
         * @param solid   Gets or sets whether this cell is solid
         * @param sprites The list of tile sprites to use to draw in this cell (in order)
         */
        function Cell(x, y, width, height, index, solid, sprites) {
            if (solid === void 0) { solid = false; }
            if (sprites === void 0) { sprites = []; }
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.index = index;
            this.solid = solid;
            this.sprites = sprites;
            this._bounds = new BoundingBox_4.BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
        }
        /**
         * Returns the bounding box for this cell
         */
        Cell.prototype.getBounds = function () {
            return this._bounds;
        };
        /**
         * Gets the center coordinate of this cell
         */
        Cell.prototype.getCenter = function () {
            return new Algebra_16.Vector(this.x + this.width / 2, this.y + this.height / 2);
        };
        /**
         * Add another [[TileSprite]] to this cell
         */
        Cell.prototype.pushSprite = function (tileSprite) {
            this.sprites.push(tileSprite);
        };
        /**
         * Remove an instance of [[TileSprite]] from this cell
         */
        Cell.prototype.removeSprite = function (tileSprite) {
            var index = -1;
            if ((index = this.sprites.indexOf(tileSprite)) > -1) {
                this.sprites.splice(index, 1);
            }
        };
        /**
         * Clear all sprites from this cell
         */
        Cell.prototype.clearSprites = function () {
            this.sprites.length = 0;
        };
        return Cell;
    }());
    exports.Cell = Cell;
});
define("Timer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The Excalibur timer hooks into the internal timer and fires callbacks,
     * after a certain interval, optionally repeating.
     */
    var Timer = (function () {
        /**
         * @param fcn        The callback to be fired after the interval is complete.
         * @param interval   Interval length
         * @param repeats    Indicates whether this call back should be fired only once, or repeat after every interval as completed.
         */
        function Timer(fcn, interval, repeats) {
            this.id = 0;
            this.interval = 10;
            this.fcn = function () { return; };
            this.repeats = false;
            this._elapsedTime = 0;
            this._totalTimeAlive = 0;
            this._paused = false;
            this.complete = false;
            this.scene = null;
            this.id = Timer.id++;
            this.interval = interval || this.interval;
            this.fcn = fcn || this.fcn;
            this.repeats = repeats || this.repeats;
        }
        /**
         * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
         * @param delta  Number of elapsed milliseconds since the last update.
         */
        Timer.prototype.update = function (delta) {
            if (!this._paused) {
                this._totalTimeAlive += delta;
                this._elapsedTime += delta;
                if (!this.complete && this._elapsedTime >= this.interval) {
                    this.fcn.call(this);
                    if (this.repeats) {
                        this._elapsedTime = 0;
                    }
                    else {
                        this.complete = true;
                    }
                }
            }
        };
        /**
         * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
         * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
         */
        Timer.prototype.reset = function (newInterval) {
            if (!!newInterval && newInterval >= 0) {
                this.interval = newInterval;
            }
            this.complete = false;
            this._elapsedTime = 0;
        };
        Timer.prototype.getTimeRunning = function () {
            return this._totalTimeAlive;
        };
        /**
         * Pauses the timer so that no more time will be incremented towards the next call
         */
        Timer.prototype.pause = function () {
            this._paused = true;
        };
        /**
         * Unpauses the timer. Time will now increment towards the next call
         */
        Timer.prototype.unpause = function () {
            this._paused = false;
        };
        /**
         * Cancels the timer, preventing any further executions.
         */
        Timer.prototype.cancel = function () {
            if (this.scene) {
                this.scene.cancelTimer(this);
            }
        };
        return Timer;
    }());
    Timer.id = 0;
    exports.Timer = Timer;
});
define("Trigger", ["require", "exports", "Drawing/Color", "Actions/Action", "EventDispatcher", "Actor", "Algebra", "Events", "Util/Util"], function (require, exports, Color_16, Action_1, EventDispatcher_1, Actor_8, Algebra_17, Events_5, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var triggerDefaults = {
        pos: Algebra_17.Vector.Zero.clone(),
        width: 10,
        height: 10,
        visible: false,
        action: function () { return; },
        filter: function () { return true; },
        repeat: -1
    };
    /**
     * Triggers are a method of firing arbitrary code on collision. These are useful
     * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
     * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
     *
     * [[include:Triggers.md]]
     */
    var Trigger = (function (_super) {
        __extends(Trigger, _super);
        /**
         *
         * @param opts Trigger options
         */
        function Trigger(opts) {
            var _this = _super.call(this, opts.pos.x, opts.pos.y, opts.width, opts.height) || this;
            /**
             * Action to fire when triggered by collision
             */
            _this.action = function () { return; };
            /**
             * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
             * filter return true for the collided actor.
             */
            _this.filter = function () { return true; };
            /**
             * Number of times to repeat before killing the trigger,
             */
            _this.repeat = -1;
            opts = Util.extend({}, triggerDefaults, opts);
            _this.filter = opts.filter || _this.filter;
            _this.repeat = opts.repeat || _this.repeat;
            _this.action = opts.action || _this.action;
            if (opts.target) {
                _this.target = opts.target;
            }
            _this.visible = opts.visible;
            _this.collisionType = Actor_8.CollisionType.Passive;
            _this.eventDispatcher = new EventDispatcher_1.EventDispatcher(_this);
            _this.actionQueue = new Action_1.ActionQueue(_this);
            _this.on('collisionstart', function (evt) {
                if (_this.filter(evt.other)) {
                    _this.emit('enter', new Events_5.EnterTriggerEvent(_this, evt.other));
                    _this._dispatchAction();
                    // remove trigger if its done, -1 repeat forever
                    if (_this.repeat === 0) {
                        _this.kill();
                    }
                }
            });
            _this.on('collisionend', function (evt) {
                if (_this.filter(evt.other)) {
                    _this.emit('exit', new Events_5.ExitTriggerEvent(_this, evt.other));
                }
            });
            return _this;
        }
        Object.defineProperty(Trigger.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
                this.filter = function (actor) { return actor === target; };
            },
            enumerable: true,
            configurable: true
        });
        Trigger.prototype._initialize = function (engine) {
            _super.prototype._initialize.call(this, engine);
            this._engine = engine;
        };
        Trigger.prototype._dispatchAction = function () {
            this.action.call(this);
            this.repeat--;
        };
        /* istanbul ignore next */
        Trigger.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            // Meant to draw debug information about actors
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            var bb = this.getBounds();
            var wp = this.getWorldPos();
            bb.left = bb.left - wp.x;
            bb.right = bb.right - wp.x;
            bb.top = bb.top - wp.y;
            bb.bottom = bb.bottom - wp.y;
            // Currently collision primitives cannot rotate 
            // ctx.rotate(this.rotation);
            ctx.fillStyle = Color_16.Color.Violet.toString();
            ctx.strokeStyle = Color_16.Color.Violet.toString();
            ctx.fillText('Trigger', 10, 10);
            bb.debugDraw(ctx);
            ctx.restore();
        };
        return Trigger;
    }(Actor_8.Actor));
    exports.Trigger = Trigger;
});
define("Actions/Index", ["require", "exports", "Actions/ActionContext", "Actions/RotationType", "Actions/Action"], function (require, exports, ActionContext_2, RotationType_1, actions) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(ActionContext_2);
    __export(RotationType_1);
    exports.Actions = actions;
    // legacy Internal.Actions namespace support
    exports.Internal = { Actions: actions };
});
define("Collision/DynamicTree", ["require", "exports", "Physics", "Collision/BoundingBox", "Util/Log"], function (require, exports, Physics_8, BoundingBox_5, Log_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Dynamic Tree Node used for tracking bounds within the tree
     */
    var TreeNode = (function () {
        function TreeNode(parent) {
            this.parent = parent;
            this.parent = parent || null;
            this.body = null;
            this.bounds = new BoundingBox_5.BoundingBox();
            this.left = null;
            this.right = null;
            this.height = 0;
        }
        TreeNode.prototype.isLeaf = function () {
            return (!this.left && !this.right);
        };
        return TreeNode;
    }());
    exports.TreeNode = TreeNode;
    /**
     * The DynamicTrees provides a spatial partiioning data structure for quickly querying for overlapping bounding boxes for
     * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
     *
     * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
     * Every non-leaf node is a bounding box that contains child bounding boxes.
     */
    var DynamicTree = (function () {
        function DynamicTree(worldBounds) {
            if (worldBounds === void 0) { worldBounds = new BoundingBox_5.BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE); }
            this.worldBounds = worldBounds;
            this.root = null;
            this.nodes = {};
        }
        /**
         * Inserts a node into the dynamic tree
         */
        DynamicTree.prototype._insert = function (leaf) {
            // If there are no nodes in the tree, make this the root leaf
            if (this.root === null) {
                this.root = leaf;
                this.root.parent = null;
                return;
            }
            // Search the tree for a node that is not a leaf and find the best place to insert
            var leafAABB = leaf.bounds;
            var currentRoot = this.root;
            while (!currentRoot.isLeaf()) {
                var left = currentRoot.left;
                var right = currentRoot.right;
                var area = currentRoot.bounds.getPerimeter();
                var combinedAABB = currentRoot.bounds.combine(leafAABB);
                var combinedArea = combinedAABB.getPerimeter();
                // Calculate cost heuristic for creating a new parent and leaf
                var cost = 2 * combinedArea;
                // Minimum cost of pushing the leaf down the tree
                var inheritanceCost = 2 * (combinedArea - area);
                // Cost of descending
                var leftCost = 0;
                var leftCombined = leafAABB.combine(left.bounds);
                var newArea;
                var oldArea;
                if (left.isLeaf()) {
                    leftCost = leftCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = left.bounds.getPerimeter();
                    newArea = leftCombined.getPerimeter();
                    leftCost = (newArea - oldArea) + inheritanceCost;
                }
                var rightCost = 0;
                var rightCombined = leafAABB.combine(right.bounds);
                if (right.isLeaf()) {
                    rightCost = rightCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = right.bounds.getPerimeter();
                    newArea = rightCombined.getPerimeter();
                    rightCost = (newArea - oldArea) + inheritanceCost;
                }
                // cost is acceptable
                if (cost < leftCost && cost < rightCost) {
                    break;
                }
                // Descend to the depths
                if (leftCost < rightCost) {
                    currentRoot = left;
                }
                else {
                    currentRoot = right;
                }
            }
            // Create the new parent node and insert into the tree
            var oldParent = currentRoot.parent;
            var newParent = new TreeNode(oldParent);
            newParent.bounds = leafAABB.combine(currentRoot.bounds);
            newParent.height = currentRoot.height + 1;
            if (oldParent !== null) {
                // The sibling node was not the root
                if (oldParent.left === currentRoot) {
                    oldParent.left = newParent;
                }
                else {
                    oldParent.right = newParent;
                }
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
            }
            else {
                // The sibling node was the root
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
                this.root = newParent;
            }
            // Walk up the tree fixing heights and AABBs
            var currentNode = leaf.parent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                if (!currentNode.left) {
                    throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
                }
                if (!currentNode.right) {
                    throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
                }
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode = currentNode.parent;
            }
        };
        /**
         * Removes a node from the dynamic tree
         */
        DynamicTree.prototype._remove = function (leaf) {
            if (leaf === this.root) {
                this.root = null;
                return;
            }
            var parent = leaf.parent;
            var grandParent = parent.parent;
            var sibling;
            if (parent.left === leaf) {
                sibling = parent.right;
            }
            else {
                sibling = parent.left;
            }
            if (grandParent) {
                if (grandParent.left === parent) {
                    grandParent.left = sibling;
                }
                else {
                    grandParent.right = sibling;
                }
                sibling.parent = grandParent;
                var currentNode = grandParent;
                while (currentNode) {
                    currentNode = this._balance(currentNode);
                    currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                    currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                    currentNode = currentNode.parent;
                }
            }
            else {
                this.root = sibling;
                sibling.parent = null;
            }
        };
        /**
         * Tracks a body in the dynamic tree
         */
        DynamicTree.prototype.trackBody = function (body) {
            var node = new TreeNode();
            node.body = body;
            node.bounds = body.getBounds();
            node.bounds.left -= 2;
            node.bounds.top -= 2;
            node.bounds.right += 2;
            node.bounds.bottom += 2;
            this.nodes[body.actor.id] = node;
            this._insert(node);
        };
        /**
         * Updates the dynamic tree given the current bounds of each body being tracked
         */
        DynamicTree.prototype.updateBody = function (body) {
            var node = this.nodes[body.actor.id];
            if (!node) {
                return false;
            }
            var b = body.getBounds();
            // if the body is outside the world no longer update it
            if (!this.worldBounds.contains(b)) {
                Log_9.Logger.getInstance().warn('Actor with id ' + body.actor.id +
                    ' is outside the world bounds and will no longer be tracked for physics');
                this.untrackBody(body);
                return false;
            }
            if (node.bounds.contains(b)) {
                return false;
            }
            this._remove(node);
            b.left -= Physics_8.Physics.boundsPadding;
            b.top -= Physics_8.Physics.boundsPadding;
            b.right += Physics_8.Physics.boundsPadding;
            b.bottom += Physics_8.Physics.boundsPadding;
            var multdx = body.vel.x * Physics_8.Physics.dynamicTreeVelocityMultiplyer;
            var multdy = body.vel.y * Physics_8.Physics.dynamicTreeVelocityMultiplyer;
            if (multdx < 0) {
                b.left += multdx;
            }
            else {
                b.right += multdx;
            }
            if (multdy < 0) {
                b.top += multdy;
            }
            else {
                b.bottom += multdy;
            }
            node.bounds = b;
            this._insert(node);
            return true;
        };
        /**
         * Untracks a body from the dynamic tree
         */
        DynamicTree.prototype.untrackBody = function (body) {
            var node = this.nodes[body.actor.id];
            if (!node) {
                return;
            }
            this._remove(node);
            this.nodes[body.actor.id] = null;
            delete this.nodes[body.actor.id];
        };
        /**
         * Balances the tree about a node
         */
        DynamicTree.prototype._balance = function (node) {
            if (node === null) {
                throw new Error('Cannot balance at null node');
            }
            if (node.isLeaf() || node.height < 2) {
                return node;
            }
            var left = node.left;
            var right = node.right;
            var a = node;
            var b = left;
            var c = right;
            var d = left.left;
            var e = left.right;
            var f = right.left;
            var g = right.right;
            var balance = c.height - b.height;
            // Rotate c node up
            if (balance > 1) {
                // Swap the right node with it's parent
                c.left = a;
                c.parent = a.parent;
                a.parent = c;
                // The original node's old parent should point to the right node
                // this is mega confusing
                if (c.parent) {
                    if (c.parent.left === a) {
                        c.parent.left = c;
                    }
                    else {
                        c.parent.right = c;
                    }
                }
                else {
                    this.root = c;
                }
                // Rotate
                if (f.height > g.height) {
                    c.right = f;
                    a.right = g;
                    g.parent = a;
                    a.bounds = b.bounds.combine(g.bounds);
                    c.bounds = a.bounds.combine(f.bounds);
                    a.height = 1 + Math.max(b.height, g.height);
                    c.height = 1 + Math.max(a.height, f.height);
                }
                else {
                    c.right = g;
                    a.right = f;
                    f.parent = a;
                    a.bounds = b.bounds.combine(f.bounds);
                    c.bounds = a.bounds.combine(g.bounds);
                    a.height = 1 + Math.max(b.height, f.height);
                    c.height = 1 + Math.max(a.height, g.height);
                }
                return c;
            }
            // Rotate left node up
            if (balance < -1) {
                // swap
                b.left = a;
                b.parent = a.parent;
                a.parent = b;
                // node's old parent should point to b
                if (b.parent) {
                    if (b.parent.left === a) {
                        b.parent.left = b;
                    }
                    else {
                        if (b.parent.right !== a) {
                            throw 'Error rotating Dynamic Tree';
                        }
                        b.parent.right = b;
                    }
                }
                else {
                    this.root = b;
                }
                // rotate
                if (d.height > e.height) {
                    b.right = d;
                    a.left = e;
                    e.parent = a;
                    a.bounds = c.bounds.combine(e.bounds);
                    b.bounds = a.bounds.combine(d.bounds);
                    a.height = 1 + Math.max(c.height, e.height);
                    b.height = 1 + Math.max(a.height, d.height);
                }
                else {
                    b.right = e;
                    a.left = d;
                    d.parent = a;
                    a.bounds = c.bounds.combine(d.bounds);
                    b.bounds = a.bounds.combine(e.bounds);
                    a.height = 1 + Math.max(c.height, d.height);
                    b.height = 1 + Math.max(a.height, e.height);
                }
                return b;
            }
            return node;
        };
        /**
         * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
         */
        DynamicTree.prototype.getHeight = function () {
            if (this.root === null) {
                return 0;
            }
            return this.root.height;
        };
        /**
         * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
         *
         * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
         * that you are complete with your query and you do not want to continue. Returning false will continue searching
         * the tree until all possible colliders have been returned.
         */
        DynamicTree.prototype.query = function (body, callback) {
            var bounds = body.getBounds();
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.collides(bounds)) {
                    if (currentNode.isLeaf() && currentNode.body !== body) {
                        if (callback.call(body, currentNode.body)) {
                            return true;
                        }
                    }
                    else {
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                return false;
            };
            helper(this.root);
        };
        /**
         * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
         * long ray to test the tree specified by `max`.
         *
         * In the query callback, it will be passed a potential body that intersects with the racast. Returning true from this
         * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
         * the tree until all possible bodies that would intersect with the ray have been returned.
         */
        DynamicTree.prototype.rayCastQuery = function (ray, max, callback) {
            if (max === void 0) { max = Infinity; }
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                    if (currentNode.isLeaf()) {
                        if (callback.call(ray, currentNode.body)) {
                            // ray hit a leaf! return the body
                            return true;
                        }
                    }
                    else {
                        // ray hit but not at a leaf, recurse deeper
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                return false; // ray missed         
            };
            helper(this.root);
        };
        DynamicTree.prototype.getNodes = function () {
            var helper = function (currentNode) {
                if (currentNode) {
                    return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
                }
                else {
                    return [];
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.debugDraw = function (ctx) {
            // draw all the nodes in the Dynamic Tree
            var helper = function (currentNode) {
                if (currentNode) {
                    if (currentNode.isLeaf()) {
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'green';
                    }
                    else {
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'white';
                    }
                    currentNode.bounds.debugDraw(ctx);
                    if (currentNode.left) {
                        helper(currentNode.left);
                    }
                    if (currentNode.right) {
                        helper(currentNode.right);
                    }
                }
            };
            helper(this.root);
        };
        return DynamicTree;
    }());
    exports.DynamicTree = DynamicTree;
});
define("Collision/ICollisionResolver", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/DynamicTreeCollisionBroadphase", ["require", "exports", "Physics", "Collision/DynamicTree", "Collision/Pair", "Algebra", "Actor", "Util/Log", "Events"], function (require, exports, Physics_9, DynamicTree_1, Pair_2, Algebra_18, Actor_9, Log_10, Events_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DynamicTreeCollisionBroadphase = (function () {
        function DynamicTreeCollisionBroadphase() {
            this._dynamicCollisionTree = new DynamicTree_1.DynamicTree();
            this._collisionHash = {};
            this._collisionPairCache = [];
            this._lastFramePairs = [];
            this._lastFramePairsHash = {};
        }
        /**
         * Tracks a physics body for collisions
         */
        DynamicTreeCollisionBroadphase.prototype.track = function (target) {
            if (!target) {
                Log_10.Logger.getInstance().warn('Cannot track null physics body');
                return;
            }
            this._dynamicCollisionTree.trackBody(target);
        };
        /**
         * Untracks a physics body
         */
        DynamicTreeCollisionBroadphase.prototype.untrack = function (target) {
            if (!target) {
                Log_10.Logger.getInstance().warn('Cannot untrack a null physics body');
                return;
            }
            this._dynamicCollisionTree.untrackBody(target);
        };
        DynamicTreeCollisionBroadphase.prototype._canCollide = function (actorA, actorB) {
            // if the collision pair has been calculated already short circuit
            var hash = Pair_2.Pair.calculatePairHash(actorA.body, actorB.body);
            if (this._collisionHash[hash]) {
                return false; // pair exists easy exit return false
            }
            // if both are fixed short circuit
            if (actorA.collisionType === Actor_9.CollisionType.Fixed && actorB.collisionType === Actor_9.CollisionType.Fixed) {
                return false;
            }
            // if the other is prevent collision or is dead short circuit
            if (actorB.collisionType === Actor_9.CollisionType.PreventCollision || actorB.isKilled()) {
                return false;
            }
            // they can collide
            return true;
        };
        /**
         * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
         */
        DynamicTreeCollisionBroadphase.prototype.broadphase = function (targets, delta, stats) {
            var _this = this;
            var seconds = delta / 1000;
            // TODO optimization use only the actors that are moving to start 
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== Actor_9.CollisionType.PreventCollision;
            });
            // clear old list of collision pairs
            this._collisionPairCache = [];
            this._collisionHash = {};
            // check for normal collision pairs
            var actor;
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor = potentialColliders[j];
                // Query the collision tree for potential colliders
                this._dynamicCollisionTree.query(actor.body, function (other) {
                    if (_this._canCollide(actor, other.actor)) {
                        var pair = new Pair_2.Pair(actor.body, other);
                        _this._collisionHash[pair.id] = true;
                        _this._collisionPairCache.push(pair);
                    }
                    // Always return false, to query whole tree. Returning true in the query method stops searching
                    return false;
                });
            }
            if (stats) {
                stats.physics.pairs = this._collisionPairCache.length;
            }
            // Check dynamic tree for fast moving objects
            // Fast moving objects are those moving at least there smallest bound per frame
            if (Physics_9.Physics.checkForFastBodies) {
                for (var _i = 0, potentialColliders_1 = potentialColliders; _i < potentialColliders_1.length; _i++) {
                    var actor = potentialColliders_1[_i];
                    // Skip non-active objects. Does not make sense on other collison types
                    if (actor.collisionType !== Actor_9.CollisionType.Active) {
                        continue;
                    }
                    ;
                    // Maximum travel distance next frame
                    var updateDistance = (actor.vel.magnitude() * seconds) +
                        (actor.acc.magnitude() * .5 * seconds * seconds); // acc term
                    // Find the minimum dimension
                    var minDimension = Math.min(actor.body.getBounds().getHeight(), actor.body.getBounds().getWidth());
                    if (Physics_9.Physics.disableMinimumSpeedForFastBody || updateDistance > (minDimension / 2)) {
                        if (stats) {
                            stats.physics.fastBodies++;
                        }
                        // start with the oldPos because the integration for actors has already happened
                        // objects resting on a surface may be slightly penatrating in the current position
                        var updateVec = actor.pos.sub(actor.oldPos);
                        var centerPoint = actor.body.collisionArea.getCenter();
                        var furthestPoint = actor.body.collisionArea.getFurthestPoint(actor.vel);
                        var origin = furthestPoint.sub(updateVec);
                        var ray = new Algebra_18.Ray(origin, actor.vel);
                        // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface 
                        ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics_9.Physics.surfaceEpsilon));
                        var minBody;
                        var minTranslate = new Algebra_18.Vector(Infinity, Infinity);
                        this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics_9.Physics.surfaceEpsilon * 2, function (other) {
                            if (actor.body !== other && other.collisionArea) {
                                var hitPoint = other.collisionArea.rayCast(ray, updateDistance + Physics_9.Physics.surfaceEpsilon * 10);
                                if (hitPoint) {
                                    var translate = hitPoint.sub(origin);
                                    if (translate.magnitude() < minTranslate.magnitude()) {
                                        minTranslate = translate;
                                        minBody = other;
                                    }
                                }
                            }
                            return false;
                        });
                        if (minBody && Algebra_18.Vector.isValid(minTranslate)) {
                            var pair = new Pair_2.Pair(actor.body, minBody);
                            if (!this._collisionHash[pair.id]) {
                                this._collisionHash[pair.id] = true;
                                this._collisionPairCache.push(pair);
                            }
                            // move the fast moving object to the other body
                            // need to push into the surface by ex.Physics.surfaceEpsilon
                            var shift = centerPoint.sub(furthestPoint);
                            actor.pos = origin.add(shift).add(minTranslate).add(ray.dir.scale(2 * Physics_9.Physics.surfaceEpsilon));
                            actor.body.collisionArea.recalc();
                            if (stats) {
                                stats.physics.fastBodyCollisions++;
                            }
                        }
                    }
                }
            }
            // return cache
            return this._collisionPairCache;
        };
        /**
         * Applies narrow phase on collision pairs to find actual area intersections
         * Adds actual colliding pairs to stats' Frame data
         */
        DynamicTreeCollisionBroadphase.prototype.narrowphase = function (pairs, stats) {
            for (var i = 0; i < pairs.length; i++) {
                pairs[i].collide();
                if (stats && pairs[i].collision) {
                    stats.physics.collisions++;
                    stats.physics.collidersHash[pairs[i].id] = pairs[i];
                }
            }
            return pairs.filter(function (p) { return p.collision; });
        };
        /**
         * Perform collision resolution given a strategy (rigid body or box) and move objects out of intersect.
         */
        DynamicTreeCollisionBroadphase.prototype.resolve = function (pairs, delta, strategy) {
            for (var _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++) {
                var pair = pairs_1[_i];
                pair.resolve(strategy);
                if (pair.collision) {
                    pair.bodyA.applyMtv();
                    pair.bodyB.applyMtv();
                    // todo still don't like this, this is a small integration step to resolve narrowphase collisions
                    pair.bodyA.actor.integrate(delta * Physics_9.Physics.collisionShift);
                    pair.bodyB.actor.integrate(delta * Physics_9.Physics.collisionShift);
                }
            }
            return pairs.filter(function (p) { return p.canCollide; });
        };
        DynamicTreeCollisionBroadphase.prototype.runCollisionStartEnd = function (pairs) {
            var currentFrameHash = {};
            for (var _i = 0, pairs_2 = pairs; _i < pairs_2.length; _i++) {
                var p = pairs_2[_i];
                // load currentFrameHash
                currentFrameHash[p.id] = p;
                // find all new collisions
                if (!this._lastFramePairsHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionstart', new Events_6.CollisionStartEvent(actor1, actor2, p));
                    actor2.emit('collisionstart', new Events_6.CollisionStartEvent(actor2, actor1, p));
                }
            }
            // find all old collisions
            for (var _a = 0, _b = this._lastFramePairs; _a < _b.length; _a++) {
                var p = _b[_a];
                if (!currentFrameHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionend', new Events_6.CollisionEndEvent(actor1, actor2));
                    actor2.emit('collisionend', new Events_6.CollisionEndEvent(actor2, actor1));
                }
            }
            // reset the last frame cache
            this._lastFramePairs = pairs;
            this._lastFramePairsHash = currentFrameHash;
        };
        /**
         * Update the dynamic tree positions
         */
        DynamicTreeCollisionBroadphase.prototype.update = function (targets) {
            var updated = 0, i = 0, len = targets.length;
            for (i; i < len; i++) {
                if (this._dynamicCollisionTree.updateBody(targets[i].body)) {
                    updated++;
                }
            }
            return updated;
        };
        /* istanbul ignore next */
        DynamicTreeCollisionBroadphase.prototype.debugDraw = function (ctx) {
            if (Physics_9.Physics.broadphaseDebug) {
                this._dynamicCollisionTree.debugDraw(ctx);
            }
            if (Physics_9.Physics.showContacts || Physics_9.Physics.showCollisionNormals) {
                for (var _i = 0, _a = this._collisionPairCache; _i < _a.length; _i++) {
                    var pair = _a[_i];
                    pair.debugDraw(ctx);
                }
            }
        };
        return DynamicTreeCollisionBroadphase;
    }());
    exports.DynamicTreeCollisionBroadphase = DynamicTreeCollisionBroadphase;
});
define("Collision/IPhysics", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/NaiveCollisionBroadphase", ["require", "exports", "Physics", "Collision/CollisionContact", "Collision/Pair", "Actor", "Events"], function (require, exports, Physics_10, CollisionContact_2, Pair_3, Actor_10, Events_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NaiveCollisionBroadphase = (function () {
        function NaiveCollisionBroadphase() {
            this._lastFramePairs = [];
            this._lastFramePairsHash = {};
        }
        NaiveCollisionBroadphase.prototype.track = function () {
            // pass
        };
        NaiveCollisionBroadphase.prototype.untrack = function () {
            // pass
        };
        /**
         * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
         */
        NaiveCollisionBroadphase.prototype.broadphase = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== Actor_10.CollisionType.PreventCollision;
            });
            var actor1;
            var actor2;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor1 = potentialColliders[j];
                for (var i = j + 1; i < l; i++) {
                    actor2 = potentialColliders[i];
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor1.collides(actor2)) {
                        var pair = new Pair_3.Pair(actor1.body, actor2.body);
                        pair.collision = new CollisionContact_2.CollisionContact(actor1.collisionArea, actor2.collisionArea, minimumTranslationVector, actor1.pos, minimumTranslationVector);
                        if (!collisionPairs.some(function (cp) {
                            return cp.id === pair.id;
                        })) {
                            collisionPairs.push(pair);
                        }
                    }
                }
            }
            return collisionPairs;
        };
        /**
         * Identify actual collisions from those pairs, and calculate collision impulse
         */
        NaiveCollisionBroadphase.prototype.narrowphase = function (pairs) {
            return pairs;
        };
        NaiveCollisionBroadphase.prototype.runCollisionStartEnd = function (pairs) {
            var currentFrameHash = {};
            for (var _i = 0, pairs_3 = pairs; _i < pairs_3.length; _i++) {
                var p = pairs_3[_i];
                // load currentFrameHash
                currentFrameHash[p.id] = p;
                // find all new collisions
                if (!this._lastFramePairsHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionstart', new Events_7.CollisionStartEvent(actor1, actor2, p));
                    actor2.emit('collisionstart', new Events_7.CollisionStartEvent(actor2, actor1, p));
                }
            }
            // find all old collisions
            for (var _a = 0, _b = this._lastFramePairs; _a < _b.length; _a++) {
                var p = _b[_a];
                if (!currentFrameHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionend', new Events_7.CollisionEndEvent(actor1, actor2));
                    actor2.emit('collisionend', new Events_7.CollisionEndEvent(actor2, actor1));
                }
            }
            // reset the last frame cache
            this._lastFramePairs = pairs;
            this._lastFramePairsHash = currentFrameHash;
        };
        /**
         * Resolve the position and velocity of the physics bodies
         */
        NaiveCollisionBroadphase.prototype.resolve = function (pairs) {
            for (var _i = 0, pairs_4 = pairs; _i < pairs_4.length; _i++) {
                var pair = pairs_4[_i];
                pair.resolve(Physics_10.Physics.collisionResolutionStrategy);
            }
            return pairs.filter(function (p) { return p.canCollide; });
        };
        NaiveCollisionBroadphase.prototype.update = function () {
            return 0;
        };
        NaiveCollisionBroadphase.prototype.debugDraw = function () {
            return;
        };
        return NaiveCollisionBroadphase;
    }());
    exports.NaiveCollisionBroadphase = NaiveCollisionBroadphase;
});
define("Collision/Index", ["require", "exports", "Collision/Body", "Collision/BoundingBox", "Collision/CircleArea", "Collision/CollisionContact", "Collision/CollisionJumpTable", "Collision/DynamicTree", "Collision/DynamicTreeCollisionBroadphase", "Collision/EdgeArea", "Collision/NaiveCollisionBroadphase", "Collision/Pair", "Collision/PolygonArea", "Collision/Side"], function (require, exports, Body_1, BoundingBox_6, CircleArea_4, CollisionContact_3, CollisionJumpTable_4, DynamicTree_2, DynamicTreeCollisionBroadphase_1, EdgeArea_4, NaiveCollisionBroadphase_1, Pair_4, PolygonArea_6, Side_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Body_1);
    __export(BoundingBox_6);
    __export(CircleArea_4);
    __export(CollisionContact_3);
    __export(CollisionJumpTable_4);
    __export(DynamicTree_2);
    __export(DynamicTreeCollisionBroadphase_1);
    __export(EdgeArea_4);
    __export(NaiveCollisionBroadphase_1);
    __export(Pair_4);
    __export(PolygonArea_6);
    __export(Side_3);
});
define("Drawing/Polygon", ["require", "exports", "Algebra"], function (require, exports, Algebra_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Creates a closed polygon drawing given a list of [[Vector]]s.
     *
     * @warning Use sparingly as Polygons are performance intensive
     */
    var Polygon = (function () {
        /**
         * @param points  The vectors to use to build the polygon in order
         */
        function Polygon(points) {
            /**
             * The width of the lines of the polygon
             */
            this.lineWidth = 5;
            /**
             * Indicates whether the polygon is filled or not.
             */
            this.filled = false;
            this._points = [];
            this.anchor = new Algebra_19.Vector(0, 0);
            this.rotation = 0;
            this.scale = new Algebra_19.Vector(1, 1);
            this._points = points;
            var minX = this._points.reduce(function (prev, curr) {
                return Math.min(prev, curr.x);
            }, 0);
            var maxX = this._points.reduce(function (prev, curr) {
                return Math.max(prev, curr.x);
            }, 0);
            this.width = maxX - minX;
            var minY = this._points.reduce(function (prev, curr) {
                return Math.min(prev, curr.y);
            }, 0);
            var maxY = this._points.reduce(function (prev, curr) {
                return Math.max(prev, curr.y);
            }, 0);
            this.height = maxY - minY;
            this.naturalHeight = this.height;
            this.naturalWidth = this.width;
        }
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.addEffect = function () {
            // not supported on polygons
        };
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.removeEffect = function () {
            // not supported on polygons
        };
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.clearEffects = function () {
            // not supported on polygons
        };
        Polygon.prototype.reset = function () {
            //pass
        };
        Polygon.prototype.draw = function (ctx, x, y) {
            ctx.save();
            ctx.translate(x + this.anchor.x, y + this.anchor.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            ctx.beginPath();
            ctx.lineWidth = this.lineWidth;
            // Iterate through the supplied points and construct a 'polygon'
            var firstPoint = this._points[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            var i = 0, len = this._points.length;
            for (i; i < len; i++) {
                ctx.lineTo(this._points[i].x, this._points[i].y);
            }
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            if (this.filled) {
                ctx.fillStyle = this.fillColor.toString();
                ctx.fill();
            }
            ctx.strokeStyle = this.lineColor.toString();
            if (this.flipHorizontal) {
                ctx.translate(this.width, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, this.height);
                ctx.scale(1, -1);
            }
            ctx.stroke();
            ctx.restore();
        };
        return Polygon;
    }());
    exports.Polygon = Polygon;
});
define("Drawing/Index", ["require", "exports", "Drawing/Animation", "Drawing/Color", "Drawing/Polygon", "Drawing/Sprite", "Drawing/SpriteSheet", "Drawing/SpriteEffects"], function (require, exports, Animation_2, Color_17, Polygon_1, Sprite_3, SpriteSheet_1, effects) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Animation_2);
    __export(Color_17);
    __export(Polygon_1);
    __export(Sprite_3);
    __export(SpriteSheet_1);
    exports.Effects = effects;
});
define("Interfaces/Index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
/**
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 *
 * [[include:Random.md]]
 */
define("Math/Random", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * 32-bit mask
     */
    var BITMASK32 = 0xFFFFFFFF;
    /**
     * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
     * of numbers each time it is called.
     * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
     * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
     *
     * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
     */
    var Random = (function () {
        /**
         * If no seed is specified, the Date.now() is used
         */
        function Random(seed) {
            this.seed = seed;
            // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
            this._lowerMask = 0x7FFFFFFF; // 31 bits same as _r
            this._upperMask = 0x80000000; // 34 high bits
            // Word size, 64 bits
            this._w = 32;
            // Degree of recurrance
            this._n = 624;
            // Middle word, an offset used in the recurrance defining the series x, 1<=m<n
            this._m = 397;
            // coefficients of teh rational normal form twist matrix
            this._a = 0x9908B0DF;
            // tempering bit shifts and masks
            this._u = 11;
            this._s = 7;
            this._b = 0x9d2c5680;
            this._t = 15;
            this._c = 0xefc60000;
            this._l = 18;
            this._f = 1812433253;
            this._mt = new Array(this._n);
            // need to mask to support higher bit machines
            this._mt[0] = (seed || Date.now()) >>> 0;
            for (var i = 1; i < this._n; i++) {
                var s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
                // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits         
                this._mt[i] = (((this._f * ((s & 0xFFFF0000) >>> 16)) << 16) + (this._f * (s & 0xFFFF)) + i) >>> 0;
            }
            this._index = this._n;
        }
        /**
         * Apply the twist
         */
        Random.prototype._twist = function () {
            var mag01 = [0x0, this._a];
            var y = 0;
            for (var i = 0; i < this._n - this._m; i++) {
                y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
                this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            }
            for (; i < this._n - 1; i++) {
                y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
                this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            }
            y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
            this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            this._index = 0;
        };
        /**
         * Return next 32 bit integer number in sequence
         */
        Random.prototype.nextInt = function () {
            if (this._index >= this._n) {
                this._twist();
            }
            var y = this._mt[this._index++];
            y ^= y >>> this._u;
            y ^= ((y << this._s) & this._b);
            y ^= ((y << this._t) & this._c);
            y ^= (y >>> this._l);
            return y >>> 0;
        };
        /**
         * Return a random floating point number between [0, 1)
         */
        Random.prototype.next = function () {
            return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
        };
        /**
         * Return a random floating point in range [min, max) min is included, max is not included
         */
        Random.prototype.floating = function (min, max) {
            return (max - min) * this.next() + min;
        };
        /**
         * Return a random integer in range [min, max] min is included, max is included.
         * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
         */
        Random.prototype.integer = function (min, max) {
            return Math.floor((max - min + 1) * this.next() + min);
        };
        /**
         * Returns true or false randomly with 50/50 odds by default.
         * By default the likelihood of returning a true is .5 (50%).
         * @param likelihood takes values between [0, 1]
         */
        Random.prototype.bool = function (likelihood) {
            if (likelihood === void 0) { likelihood = .5; }
            return this.next() <= likelihood;
        };
        /**
         * Returns one element from an array at random
         */
        Random.prototype.pickOne = function (array) {
            return array[this.integer(0, array.length - 1)];
        };
        /**
         * Returns a new array random picking elements from the original
         * @param array Original array to pick from
         * @param numPicks can be any positive number
         * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
         * just that it is possible)
         */
        Random.prototype.pickSet = function (array, numPicks, allowDuplicates) {
            if (allowDuplicates === void 0) { allowDuplicates = false; }
            if (allowDuplicates) {
                return this._pickSetWithDuplicates(array, numPicks);
            }
            else {
                return this._pickSetWithoutDuplicates(array, numPicks);
            }
        };
        /**
         * Returns a new array randomly picking elements in the original (not reused)
         * @param numPicks must be less than or equal to the number of elements in the array.
         */
        Random.prototype._pickSetWithoutDuplicates = function (array, numPicks) {
            if (numPicks > array.length || numPicks < 0) {
                throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
            }
            if (numPicks === array.length) {
                return array;
            }
            var result = new Array(numPicks);
            var currentPick = 0;
            var tempArray = array.slice(0);
            while (currentPick < numPicks) {
                var index = this.integer(0, tempArray.length - 1);
                result[currentPick++] = tempArray[index];
                tempArray.splice(index, 1);
            }
            return result;
        };
        /**
         * Returns a new array random picking elements from the original allowing duplicates
         * @param numPicks can be any positive number
         */
        Random.prototype._pickSetWithDuplicates = function (array, numPicks) {
            // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
            if (numPicks < 0) {
                throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
            }
            var result = new Array(numPicks);
            for (var i = 0; i < numPicks; i++) {
                result.push(this.pickOne(array));
            }
            return result;
        };
        /**
         * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
         * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
         */
        Random.prototype.shuffle = function (array) {
            var tempArray = array.slice(0);
            var swap = null;
            for (var i = 0; i < tempArray.length - 2; i++) {
                var randomIndex = this.integer(i, tempArray.length - 1);
                swap = tempArray[i];
                tempArray[i] = tempArray[randomIndex];
                tempArray[randomIndex] = swap;
            }
            return tempArray;
        };
        /**
         * Generate a list of random integer numbers
         * @param length the length of the final array
         * @param min the minimum integer number to generate inclusive
         * @param max the maximum integer number to generate inclusive
         */
        Random.prototype.range = function (length, min, max) {
            var result = new Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = this.integer(min, max);
            }
            return result;
        };
        /**
         * Returns the result of a d4 dice roll
         */
        Random.prototype.d4 = function () {
            return this.integer(1, 4);
        };
        /**
         * Returns the result of a d6 dice roll
         */
        Random.prototype.d6 = function () {
            return this.integer(1, 6);
        };
        /**
         * Returns the result of a d8 dice roll
         */
        Random.prototype.d8 = function () {
            return this.integer(1, 8);
        };
        /**
         * Returns the result of a d10 dice roll
         */
        Random.prototype.d10 = function () {
            return this.integer(1, 10);
        };
        /**
         * Returns the result of a d12 dice roll
         */
        Random.prototype.d12 = function () {
            return this.integer(1, 12);
        };
        /**
         * Returns the result of a d20 dice roll
         */
        Random.prototype.d20 = function () {
            return this.integer(1, 20);
        };
        return Random;
    }());
    exports.Random = Random;
});
define("Math/PerlinNoise", ["require", "exports", "Math/Random", "Drawing/Color", "Util/Util"], function (require, exports, Random_1, Color_18, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _lerp(time, a, b) {
        return a + time * (b - a);
    }
    function _fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }
    /**
     * Generates perlin noise based on the 2002 Siggraph paper http://mrl.nyu.edu/~perlin/noise/
     * Also https://flafla2.github.io/2014/08/09/perlinnoise.html
     */
    var PerlinGenerator = (function () {
        function PerlinGenerator(options) {
            this._perm = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
                140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26,
                197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
                171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,
                211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80,
                73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
                173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206,
                59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70,
                221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178,
                185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81,
                51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115,
                121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
                78, 66, 215, 61, 156, 180];
            this._p = new Uint8Array(512);
            this._defaultPerlinOptions = {
                octaves: 1,
                frequency: 1,
                amplitude: 1,
                persistance: .5
            };
            options = Util.extend({}, this._defaultPerlinOptions, options);
            this.persistance = options.persistance;
            this.amplitude = options.amplitude;
            this.frequency = options.frequency;
            this.octaves = options.octaves;
            if (options.seed) {
                this._random = new Random_1.Random(options.seed);
            }
            else {
                this._random = new Random_1.Random();
            }
            this._perm = this._random.shuffle(this._perm);
            for (var i = 0; i < 512; i++) {
                this._p[i] = this._perm[i % 256] & 0xFF;
            }
        }
        PerlinGenerator.prototype.noise = function () {
            var amp = this.amplitude;
            var freq = this.frequency;
            var total = 0;
            var maxValue = 0;
            for (var i = 0; i < this.octaves; i++) {
                switch (arguments.length) {
                    case 1:
                        total += this._noise1d(arguments[0] * freq) * amp;
                        break;
                    case 2:
                        total += this._noise2d(arguments[0] * freq, arguments[1] * freq) * amp;
                        break;
                    case 3:
                        total += this._noise3d(arguments[0] * freq, arguments[1] * freq, arguments[2] * freq) * amp;
                        break;
                    /* istanbul ignore next */
                    default: throw new Error('Invalid arguments for perlin noise');
                }
                maxValue += amp;
                amp *= this.persistance;
                freq *= 2;
            }
            return total / maxValue;
        };
        /**
         * Generates a list starting at 0 and ending at 1 of contious perlin noise, by default the step is 1/length;
         *
         */
        PerlinGenerator.prototype.sequence = function (length, step) {
            if (!step) {
                step = 1 / length;
            }
            var array = new Array(length);
            for (var i = 0; i < length; i++) {
                array[i] = this.noise(i * step);
            }
            return array;
        };
        /**
         * Generates a 2D grid of perlin noise given a step value packed into a 1D array i = (x + y*width),
         * by default the step will 1/(min(dimension))
         */
        PerlinGenerator.prototype.grid = function (width, height, step) {
            if (!step) {
                step = 1 / (Math.min(width, height));
            }
            var array = new Array(width * height);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    array[x + y * width] = this.noise(x * step, y * step);
                }
            }
            return array;
        };
        PerlinGenerator.prototype._gradient3d = function (hash, x, y, z) {
            var h = hash & 0xF;
            var u = h < 8 ? x : y;
            var v = h < 4 ? y : ((h === 12 || h === 14) ? x : z);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        };
        PerlinGenerator.prototype._gradient2d = function (hash, x, y) {
            var value = (hash & 1) === 0 ? x : y;
            return (hash & 2) === 0 ? -value : value;
        };
        PerlinGenerator.prototype._gradient1d = function (hash, x) {
            return (hash & 1) === 0 ? -x : x;
        };
        PerlinGenerator.prototype._noise1d = function (x) {
            var intX = Math.floor(x) & 0xFF; // force 0-255 integers to lookup in permutation
            x -= Math.floor(x);
            var fadeX = _fade(x);
            return (_lerp(fadeX, this._gradient1d(this._p[intX], x), this._gradient1d(this._p[intX + 1], x - 1)) + 1) / 2;
        };
        PerlinGenerator.prototype._noise2d = function (x, y) {
            var intX = Math.floor(x) & 0xFF;
            var intY = Math.floor(y) & 0xFF;
            x -= Math.floor(x);
            y -= Math.floor(y);
            var fadeX = _fade(x);
            var fadeY = _fade(y);
            var a = this._p[intX] + intY;
            var b = this._p[intX + 1] + intY;
            return (_lerp(fadeY, _lerp(fadeX, this._gradient2d(this._p[a], x, y), this._gradient2d(this._p[b], x - 1, y)), _lerp(fadeX, this._gradient2d(this._p[a + 1], x, y - 1), this._gradient2d(this._p[b + 1], x - 1, y - 1))) + 1) / 2;
        };
        PerlinGenerator.prototype._noise3d = function (x, y, z) {
            var intX = Math.floor(x) & 0xFF;
            var intY = Math.floor(y) & 0xFF;
            var intZ = Math.floor(z) & 0xFF;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            var fadeX = _fade(x);
            var fadeY = _fade(y);
            var fadeZ = _fade(z);
            var a = this._p[intX] + intY;
            var b = this._p[intX + 1] + intY;
            var aa = this._p[a] + intZ;
            var ba = this._p[b] + intZ;
            var ab = this._p[a + 1] + intZ;
            var bb = this._p[b + 1] + intZ;
            return (_lerp(fadeZ, _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa], x, y, z), this._gradient3d(this._p[ba], x - 1, y, z)), _lerp(fadeX, this._gradient3d(this._p[ab], x, y - 1, z), this._gradient3d(this._p[bb], x - 1, y - 1, z))), _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa + 1], x, y, z - 1), this._gradient3d(this._p[ba + 1], x - 1, y, z - 1)), _lerp(fadeX, this._gradient3d(this._p[ab + 1], x, y - 1, z - 1), this._gradient3d(this._p[bb + 1], x - 1, y - 1, z - 1)))) + 1) / 2;
        };
        return PerlinGenerator;
    }());
    exports.PerlinGenerator = PerlinGenerator;
    /**
     * A helper to draw 2D perlin maps given a perlin generator and a function
     */
    var PerlinDrawer2D = (function () {
        /**
         * @param generator - An existing perlin generator
         * @param colorFcn - A color function that takes a value between [0, 255] derived from the perlin generator, and returns a color
         */
        function PerlinDrawer2D(generator, colorFcn) {
            this.generator = generator;
            this.colorFcn = colorFcn;
            if (!colorFcn) {
                this.colorFcn = function (val) { return val < 125 ? Color_18.Color.Black : Color_18.Color.White; };
            }
        }
        /**
         * Returns an image of 2D perlin noise
         */
        PerlinDrawer2D.prototype.image = function (width, height) {
            var image = document.createElement('img');
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext('2d');
            this.draw(ctx, 0, 0, width, height);
            image.src = canvas.toDataURL();
            return image;
        };
        /**
         * This draws a 2D perlin grid on a canvas context, not recommended to be called every frame due to performance
         */
        PerlinDrawer2D.prototype.draw = function (ctx, x, y, width, height) {
            var grid = this.generator.grid(width, height);
            var imageData = ctx.getImageData(x, y, width, height);
            for (var j = 0; j < height; j++) {
                for (var i = 0; i < width; i++) {
                    var val = grid[i + width * j];
                    var c = Math.floor(val * 255) & 0xff;
                    var pixel = (i + j * imageData.width) * 4;
                    var color = this.colorFcn(c);
                    imageData.data[pixel] = color.r;
                    imageData.data[pixel + 1] = color.g;
                    imageData.data[pixel + 2] = color.b;
                    imageData.data[pixel + 3] = Math.floor(color.a * 255);
                }
            }
            ctx.putImageData(imageData, x, y);
        };
        return PerlinDrawer2D;
    }());
    exports.PerlinDrawer2D = PerlinDrawer2D;
});
define("Math/Index", ["require", "exports", "Math/PerlinNoise", "Math/Random"], function (require, exports, PerlinNoise_1, Random_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(PerlinNoise_1);
    __export(Random_2);
});
define("PostProcessing/IPostProcessor", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("PostProcessing/ColorBlindCorrector", ["require", "exports", "Util/Log"], function (require, exports, Log_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ColorBlindness;
    (function (ColorBlindness) {
        ColorBlindness[ColorBlindness["Protanope"] = 0] = "Protanope";
        ColorBlindness[ColorBlindness["Deuteranope"] = 1] = "Deuteranope";
        ColorBlindness[ColorBlindness["Tritanope"] = 2] = "Tritanope";
    })(ColorBlindness = exports.ColorBlindness || (exports.ColorBlindness = {}));
    /**
     * This post processor can correct colors and simulate color blindness.
     * It is possible to use this on every game, but the game's performance
     * will suffer measurably. It's better to use it as a helpful tool while developing your game.
     * Remember, the best practice is to design with color blindness in mind.
     *
     * [[include:ColorBlind.md]]
     */
    var ColorBlindCorrector = (function () {
        function ColorBlindCorrector(engine, simulate, colorMode) {
            if (simulate === void 0) { simulate = false; }
            if (colorMode === void 0) { colorMode = ColorBlindness.Protanope; }
            this.engine = engine;
            this.simulate = simulate;
            this.colorMode = colorMode;
            this._vertexShader = 'attribute vec2 a_position;' +
                'attribute vec2 a_texCoord;' +
                'uniform vec2 u_resolution;' +
                'varying vec2 v_texCoord;' +
                'void main() {' +
                // convert the rectangle from pixels to 0.0 to 1.0
                'vec2 zeroToOne = a_position / u_resolution;' +
                // convert from 0->1 to 0->2
                'vec2 zeroToTwo = zeroToOne * 2.0;' +
                // convert from 0->2 to -1->+1 (clipspace)
                'vec2 clipSpace = zeroToTwo - 1.0;' +
                'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' +
                // pass the texCoord to the fragment shader
                // The GPU will interpolate this value between points.
                'v_texCoord = a_texCoord;' +
                '}';
            this._fragmentShader = 'precision mediump float;' +
                // our texture
                'uniform sampler2D u_image;' +
                // the texCoords passed in from the vertex shader.
                'varying vec2 v_texCoord;' +
                // Color blind conversions
                /*'mat3 m[9] =' +
                '{' +
                   'mat3(1.0, 0.0, 0.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0  ),' + // normal
                   'mat3(0.567, 0.433, 0.0,  0.558, 0.442, 0.0,  0.0, 0.242, 0.758),' + // protanopia
                   'mat3(0.817, 0.183, 0.0,  0.333, 0.667, 0.0,  0.0, 0.125,0.875),' + // protanomaly
                   'mat3(0.625, 0.375, 0.0,  0.7, 0.3, 0.0,  0.0, 0.3,0.7  ),' + // deuteranopia
                   'mat3(0.8, 0.2, 0.0,  0.258, 0.742, 0.0,  0.0, 0.142,0.858),' + // deuteranomaly
                   'mat3(0.95, 0.05, 0.0,  0.0, 0.433, 0.567,  0.0, 0.475,0.525),' + // tritanopia
                   'mat3(0.967, 0.033, 0.0,  0.0, 0.733, 0.267,  0.0, 0.183,0.817),' + // tritanomaly
                   'mat3(0.299, 0.587, 0.114,  0.299, 0.587, 0.114,  0.299, 0.587,0.114),' + // achromatopsia
                   'mat3(0.618, 0.320, 0.062,  0.163, 0.775, 0.062,  0.163, 0.320,0.516)' +  // achromatomaly
                '};' +*/
                'void main() {' +
                'vec4 o =  texture2D(u_image, v_texCoord);' +
                // RGB to LMS matrix conversion
                'float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);' +
                'float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);' +
                'float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);' +
                // Simulate color blindness
                '//MODE CODE//' +
                /* Deuteranope for testing
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                      'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                      'float s = 0.0 * L + 0.0 * M + 1.0 * S;' +*/
                // LMS to RGB matrix conversion
                'vec4 error;' +
                'error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);' +
                'error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);' +
                'error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);' +
                'error.a = 1.0;' +
                'vec4 diff = o - error;' +
                'vec4 correction;' +
                'correction.r = 0.0;' +
                'correction.g =  (diff.r * 0.7) + (diff.g * 1.0);' +
                'correction.b =  (diff.r * 0.7) + (diff.b * 1.0);' +
                'correction = o + correction;' +
                'correction.a = o.a;' +
                '//SIMULATE//' +
                '}';
            this._internalCanvas = document.createElement('canvas');
            this._internalCanvas.width = engine.drawWidth;
            this._internalCanvas.height = engine.drawHeight;
            this._gl = this._internalCanvas.getContext('webgl', { preserveDrawingBuffer: true });
            this._program = this._gl.createProgram();
            var fragmentShader = this._getShader('Fragment', this._getFragmentShaderByMode(colorMode));
            var vertextShader = this._getShader('Vertex', this._vertexShader);
            this._gl.attachShader(this._program, vertextShader);
            this._gl.attachShader(this._program, fragmentShader);
            this._gl.linkProgram(this._program);
            if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {
                Log_11.Logger.getInstance().error('Unable to link shader program!');
            }
            this._gl.useProgram(this._program);
        }
        ColorBlindCorrector.prototype._getFragmentShaderByMode = function (colorMode) {
            var code = '';
            if (colorMode === ColorBlindness.Protanope) {
                code =
                    'float l = 0.0 * L + 2.02344 * M + -2.52581 * S;' +
                        'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                        'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
            }
            else if (colorMode === ColorBlindness.Deuteranope) {
                code =
                    'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                        'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                        'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
            }
            else if (colorMode === ColorBlindness.Tritanope) {
                code =
                    'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                        'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                        'float s = -0.395913 * L + 0.801109 * M + 0.0 * S;';
            }
            if (this.simulate) {
                this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = error.rgba;');
            }
            else {
                this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = correction.rgba;');
            }
            return this._fragmentShader.replace('//MODE CODE//', code);
        };
        ColorBlindCorrector.prototype._setRectangle = function (x, y, width, height) {
            var x1 = x;
            var x2 = x + width;
            var y1 = y;
            var y2 = y + height;
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2
            ]), this._gl.STATIC_DRAW);
        };
        ColorBlindCorrector.prototype._getShader = function (type, program) {
            var shader;
            if (type === 'Fragment') {
                shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
            }
            else if (type === 'Vertex') {
                shader = this._gl.createShader(this._gl.VERTEX_SHADER);
            }
            else {
                Log_11.Logger.getInstance().error('Error unknown shader type', type);
            }
            this._gl.shaderSource(shader, program);
            this._gl.compileShader(shader);
            if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {
                Log_11.Logger.getInstance().error('Unable to compile shader!', this._gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        };
        ColorBlindCorrector.prototype.process = function (image, out) {
            // look up where the vertex data needs to go.
            var positionLocation = this._gl.getAttribLocation(this._program, 'a_position');
            var texCoordLocation = this._gl.getAttribLocation(this._program, 'a_texCoord');
            var texCoordBuffer = this._gl.createBuffer();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, texCoordBuffer);
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([
                0.0, 0.0,
                1.0, 0.0,
                0.0, 1.0,
                0.0, 1.0,
                1.0, 0.0,
                1.0, 1.0
            ]), this._gl.STATIC_DRAW);
            this._gl.enableVertexAttribArray(texCoordLocation);
            this._gl.vertexAttribPointer(texCoordLocation, 2, this._gl.FLOAT, false, 0, 0);
            // Create a texture.
            var texture = this._gl.createTexture();
            this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
            // Set the parameters so we can render any size image.
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
            // Flip the texture when unpacking into the gl context, gl reads textures in the opposite order as everything else :/
            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);
            // Upload the image into the texture.
            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
            // lookup uniforms
            var resolutionLocation = this._gl.getUniformLocation(this._program, 'u_resolution');
            // set the resolution
            this._gl.uniform2f(resolutionLocation, this._internalCanvas.width, this._internalCanvas.height);
            // Create a buffer for the position of the rectangle corners.
            var positionBuffer = this._gl.createBuffer();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, positionBuffer);
            this._gl.enableVertexAttribArray(positionLocation);
            this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);
            // Set a rectangle the same size as the image.
            this._setRectangle(0, 0, image.width, image.height);
            // Draw the rectangle.
            this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
            // Grab tranformed image from internal canvas
            var pixelData = new Uint8Array(image.width * image.height * 4);
            this._gl.readPixels(0, 0, image.width, image.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixelData);
            image.data.set(pixelData);
            out.putImageData(image, 0, 0);
        };
        return ColorBlindCorrector;
    }());
    exports.ColorBlindCorrector = ColorBlindCorrector;
});
define("PostProcessing/Index", ["require", "exports", "PostProcessing/ColorBlindCorrector"], function (require, exports, ColorBlindCorrector_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(ColorBlindCorrector_1);
});
define("Resources/Index", ["require", "exports", "Resources/Resource", "Resources/Sound", "Resources/Texture"], function (require, exports, Resource_2, Sound_2, Texture_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Resource_2);
    __export(Sound_2);
    __export(Texture_1);
});
define("Input/Gamepad", ["require", "exports", "Class", "Events"], function (require, exports, Class_5, Events_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
     * to provide controller support for your games.
     *
     * [[include:Gamepads.md]]
     */
    var Gamepads = (function (_super) {
        __extends(Gamepads, _super);
        function Gamepads(engine) {
            var _this = _super.call(this) || this;
            /**
             * Whether or not to poll for Gamepad input (default: `false`)
             */
            _this.enabled = false;
            /**
             * Whether or not Gamepad API is supported
             */
            _this.supported = !!navigator.getGamepads;
            _this._gamePadTimeStamps = [0, 0, 0, 0];
            _this._oldPads = [];
            _this._pads = [];
            _this._initSuccess = false;
            _this._navigator = navigator;
            _this._minimumConfiguration = null;
            _this._engine = engine;
            return _this;
        }
        Gamepads.prototype.init = function () {
            if (!this.supported) {
                return;
            }
            if (this._initSuccess) {
                return;
            }
            // In Chrome, this will return 4 undefined items until a button is pressed
            // In FF, this will not return any items until a button is pressed
            this._oldPads = this._clonePads(this._navigator.getGamepads());
            if (this._oldPads.length && this._oldPads[0]) {
                this._initSuccess = true;
            }
        };
        /**
         * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
         * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
         * all other controllers with more axis or buttons are valid as well. If no minimum
         * configuration is set all pads are valid.
         */
        Gamepads.prototype.setMinimumGamepadConfiguration = function (config) {
            this._enableAndUpdate(); // if config is used, implicitly enable
            this._minimumConfiguration = config;
        };
        /**
         * When implicitly enabled, set the enabled flag and run an update so information is updated
         */
        Gamepads.prototype._enableAndUpdate = function () {
            if (!this.enabled) {
                this.enabled = true;
                this.update();
            }
        };
        /**
         * Checks a navigator gamepad against the minimum configuration if present.
         */
        Gamepads.prototype._isGamepadValid = function (pad) {
            if (!this._minimumConfiguration) {
                return true;
            }
            ;
            if (!pad) {
                return false;
            }
            ;
            var axesLength = pad.axes.filter(function (value) {
                return (typeof value !== undefined);
            }).length;
            var buttonLength = pad.buttons.filter(function (value) {
                return (typeof value !== undefined);
            }).length;
            return axesLength >= this._minimumConfiguration.axis &&
                buttonLength >= this._minimumConfiguration.buttons &&
                pad.connected;
        };
        Gamepads.prototype.on = function (eventName, handler) {
            this._enableAndUpdate(); // implicitly enable
            _super.prototype.on.call(this, eventName, handler);
        };
        Gamepads.prototype.off = function (eventName, handler) {
            this._enableAndUpdate(); // implicitly enable
            _super.prototype.off.call(this, eventName, handler);
        };
        /**
         * Updates Gamepad state and publishes Gamepad events
         */
        Gamepads.prototype.update = function () {
            if (!this.enabled || !this.supported) {
                return;
            }
            this.init();
            var gamepads = this._navigator.getGamepads();
            for (var i = 0; i < gamepads.length; i++) {
                if (!gamepads[i]) {
                    var gamepad = this.at(i);
                    // If was connected, but now isn't emit the disconnect event
                    if (gamepad.connected) {
                        this.eventDispatcher.emit('disconnect', new Events_8.GamepadDisconnectEvent(i, gamepad));
                    }
                    // Reset connection status
                    gamepad.connected = false;
                    continue;
                }
                else {
                    if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                        this.eventDispatcher.emit('connect', new Events_8.GamepadConnectEvent(i, this.at(i)));
                    }
                    // Set connection status
                    this.at(i).connected = true;
                }
                ;
                // Only supported in Chrome
                if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                    continue;
                }
                this._gamePadTimeStamps[i] = gamepads[i].timestamp;
                // Add reference to navigator gamepad
                this.at(i).navigatorGamepad = gamepads[i];
                // Buttons
                var b, bi, a, ai, value;
                for (b in Buttons) {
                    bi = Buttons[b];
                    if (typeof bi === 'number') {
                        if (gamepads[i].buttons[bi]) {
                            value = gamepads[i].buttons[bi].value;
                            if (value !== this._oldPads[i].getButton(bi)) {
                                if (gamepads[i].buttons[bi].pressed) {
                                    this.at(i).updateButton(bi, value);
                                    this.at(i).eventDispatcher.emit('button', new Events_8.GamepadButtonEvent(bi, value, this.at(i)));
                                }
                                else {
                                    this.at(i).updateButton(bi, 0);
                                }
                            }
                        }
                    }
                }
                // Axes
                for (a in Axes) {
                    ai = Axes[a];
                    if (typeof ai === 'number') {
                        value = gamepads[i].axes[ai];
                        if (value !== this._oldPads[i].getAxes(ai)) {
                            this.at(i).updateAxes(ai, value);
                            this.at(i).eventDispatcher.emit('axis', new Events_8.GamepadAxisEvent(ai, value, this.at(i)));
                        }
                    }
                }
                this._oldPads[i] = this._clonePad(gamepads[i]);
            }
        };
        /**
         * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
         */
        Gamepads.prototype.at = function (index) {
            this._enableAndUpdate(); // implicitly enable gamepads when at() is called         
            if (index >= this._pads.length) {
                // Ensure there is a pad to retrieve
                for (var i = this._pads.length - 1, max = index; i < max; i++) {
                    this._pads.push(new Gamepad());
                    this._oldPads.push(new Gamepad());
                }
            }
            return this._pads[index];
        };
        /**
         * Returns a list of all valid gamepads that meet the minimum configuration requirement.
         */
        Gamepads.prototype.getValidGamepads = function () {
            this._enableAndUpdate();
            var result = [];
            for (var i = 0; i < this._pads.length; i++) {
                if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                    result.push(this.at(i));
                }
            }
            return result;
        };
        /**
         * Gets the number of connected gamepads
         */
        Gamepads.prototype.count = function () {
            return this._pads.filter(function (p) { return p.connected; }).length;
        };
        Gamepads.prototype._clonePads = function (pads) {
            var arr = [];
            for (var i = 0, len = pads.length; i < len; i++) {
                arr.push(this._clonePad(pads[i]));
            }
            return arr;
        };
        /**
         * Fastest way to clone a known object is to do it yourself
         */
        Gamepads.prototype._clonePad = function (pad) {
            var i, len;
            var clonedPad = new Gamepad();
            if (!pad) {
                return clonedPad;
            }
            for (i = 0, len = pad.buttons.length; i < len; i++) {
                if (pad.buttons[i]) {
                    clonedPad.updateButton(i, pad.buttons[i].value);
                }
            }
            for (i = 0, len = pad.axes.length; i < len; i++) {
                clonedPad.updateAxes(i, pad.axes[i]);
            }
            return clonedPad;
        };
        return Gamepads;
    }(Class_5.Class));
    /**
     * The minimum value an axis has to move before considering it a change
     */
    Gamepads.MinAxisMoveThreshold = 0.05;
    exports.Gamepads = Gamepads;
    /**
     * Gamepad holds state information for a connected controller. See [[Gamepads]]
     * for more information on handling controller input.
     */
    var Gamepad = (function (_super) {
        __extends(Gamepad, _super);
        function Gamepad() {
            var _this = _super.call(this) || this;
            _this.connected = false;
            _this._buttons = new Array(16);
            _this._axes = new Array(4);
            var i;
            for (i = 0; i < _this._buttons.length; i++) {
                _this._buttons[i] = 0;
            }
            for (i = 0; i < _this._axes.length; i++) {
                _this._axes[i] = 0;
            }
            return _this;
        }
        /**
         * Whether or not the given button is pressed
         * @param button     The button to query
         * @param threshold  The threshold over which the button is considered to be pressed
         */
        Gamepad.prototype.isButtonPressed = function (button, threshold) {
            if (threshold === void 0) { threshold = 1; }
            return this._buttons[button] >= threshold;
        };
        /**
         * Gets the given button value between 0 and 1
         */
        Gamepad.prototype.getButton = function (button) {
            return this._buttons[button];
        };
        /**
         * Gets the given axis value between -1 and 1. Values below
         * [[MinAxisMoveThreshold]] are considered 0.
         */
        Gamepad.prototype.getAxes = function (axes) {
            var value = this._axes[axes];
            if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
                return 0;
            }
            else {
                return value;
            }
        };
        Gamepad.prototype.updateButton = function (buttonIndex, value) {
            this._buttons[buttonIndex] = value;
        };
        Gamepad.prototype.updateAxes = function (axesIndex, value) {
            this._axes[axesIndex] = value;
        };
        return Gamepad;
    }(Class_5.Class));
    exports.Gamepad = Gamepad;
    /**
     * Gamepad Buttons enumeration
     */
    var Buttons;
    (function (Buttons) {
        /**
         * Face 1 button (e.g. A)
         */
        Buttons[Buttons["Face1"] = 0] = "Face1";
        /**
         * Face 2 button (e.g. B)
         */
        Buttons[Buttons["Face2"] = 1] = "Face2";
        /**
         * Face 3 button (e.g. X)
         */
        Buttons[Buttons["Face3"] = 2] = "Face3";
        /**
         * Face 4 button (e.g. Y)
         */
        Buttons[Buttons["Face4"] = 3] = "Face4";
        /**
         * Left bumper button
         */
        Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
        /**
         * Right bumper button
         */
        Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
        /**
         * Left trigger button
         */
        Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
        /**
         * Right trigger button
         */
        Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
        /**
         * Select button
         */
        Buttons[Buttons["Select"] = 8] = "Select";
        /**
         * Start button
         */
        Buttons[Buttons["Start"] = 9] = "Start";
        /**
         * Left analog stick press (e.g. L3)
         */
        Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
        /**
         * Right analog stick press (e.g. R3)
         */
        Buttons[Buttons["RightStick"] = 11] = "RightStick";
        /**
         * D-pad up
         */
        Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
        /**
         * D-pad down
         */
        Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
        /**
         * D-pad left
         */
        Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
        /**
         * D-pad right
         */
        Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
    })(Buttons = exports.Buttons || (exports.Buttons = {}));
    /**
     * Gamepad Axes enumeration
     */
    var Axes;
    (function (Axes) {
        /**
         * Left analogue stick X direction
         */
        Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
        /**
         * Left analogue stick Y direction
         */
        Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
        /**
         * Right analogue stick X direction
         */
        Axes[Axes["RightStickX"] = 2] = "RightStickX";
        /**
         * Right analogue stick Y direction
         */
        Axes[Axes["RightStickY"] = 3] = "RightStickY";
    })(Axes = exports.Axes || (exports.Axes = {}));
});
define("Input/Pointer", ["require", "exports", "Engine", "Events", "UIActor", "Algebra", "Class", "Util/Util"], function (require, exports, Engine_1, Events_9, UIActor_1, Algebra_20, Class_6, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The type of pointer for a [[PointerEvent]].
     */
    var PointerType;
    (function (PointerType) {
        PointerType[PointerType["Touch"] = 0] = "Touch";
        PointerType[PointerType["Mouse"] = 1] = "Mouse";
        PointerType[PointerType["Pen"] = 2] = "Pen";
        PointerType[PointerType["Unknown"] = 3] = "Unknown";
    })(PointerType = exports.PointerType || (exports.PointerType = {}));
    /**
     * The mouse button being pressed.
     */
    var PointerButton;
    (function (PointerButton) {
        PointerButton[PointerButton["Left"] = 0] = "Left";
        PointerButton[PointerButton["Middle"] = 1] = "Middle";
        PointerButton[PointerButton["Right"] = 2] = "Right";
        PointerButton[PointerButton["Unknown"] = 3] = "Unknown";
    })(PointerButton = exports.PointerButton || (exports.PointerButton = {}));
    var WheelDeltaMode;
    (function (WheelDeltaMode) {
        WheelDeltaMode[WheelDeltaMode["Pixel"] = 0] = "Pixel";
        WheelDeltaMode[WheelDeltaMode["Line"] = 1] = "Line";
        WheelDeltaMode[WheelDeltaMode["Page"] = 2] = "Page";
    })(WheelDeltaMode = exports.WheelDeltaMode || (exports.WheelDeltaMode = {}));
    /**
     * Determines the scope of handling mouse/touch events. See [[Pointers]] for more information.
     */
    var PointerScope;
    (function (PointerScope) {
        /**
         * Handle events on the `canvas` element only. Events originating outside the
         * `canvas` will not be handled.
         */
        PointerScope[PointerScope["Canvas"] = 0] = "Canvas";
        /**
         * Handles events on the entire document. All events will be handled by Excalibur.
         */
        PointerScope[PointerScope["Document"] = 1] = "Document";
    })(PointerScope = exports.PointerScope || (exports.PointerScope = {}));
    /**
     * A constant used to normalize wheel events across different browsers
     *
     * This normalization factor is pulled from https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
     */
    var ScrollWheelNormalizationFactor = -1 / 40;
    /**
     * Pointer events
     *
     * Represents a mouse, touch, or stylus event. See [[Pointers]] for more information on
     * handling pointer input.
     *
     * For mouse-based events, you can inspect [[PointerEvent.button]] to see what button was pressed.
     */
    var PointerEvent = (function (_super) {
        __extends(PointerEvent, _super);
        /**
         * @param pageX        The `x` coordinate of the event (in document coordinates)
         * @param pageY        The `y` coordinate of the event (in document coordinates)
         * @param screenX      The `x` coordinate of the event (in screen coordinates)
         * @param screenY      The `y` coordinate of the event (in screen coordinates)
         * @param index        The index of the pointer (zero-based)
         * @param pointerType  The type of pointer
         * @param button       The button pressed (if [[PointerType.Mouse]])
         * @param ev           The raw DOM event being handled
         * @param pos          (Will be added to signature in 0.14.0 release) The position of the event (in world coordinates)
         */
        function PointerEvent(x, y, pageX, pageY, screenX, screenY, index, pointerType, button, ev) {
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.pageX = pageX;
            _this.pageY = pageY;
            _this.screenX = screenX;
            _this.screenY = screenY;
            _this.index = index;
            _this.pointerType = pointerType;
            _this.button = button;
            _this.ev = ev;
            return _this;
        }
        Object.defineProperty(PointerEvent.prototype, "pos", {
            get: function () {
                return new Algebra_20.Vector(this.x, this.y);
            },
            enumerable: true,
            configurable: true
        });
        return PointerEvent;
    }(Events_9.GameEvent));
    exports.PointerEvent = PointerEvent;
    ;
    /**
     * Wheel Events
     *
     * Represents a mouse wheel event. See [[Pointers]] for more information on
     * handling point input.
     */
    var WheelEvent = (function (_super) {
        __extends(WheelEvent, _super);
        /**
         * @param x            The `x` coordinate of the event (in world coordinates)
         * @param y            The `y` coordinate of the event (in world coordinates)
         * @param pageX        The `x` coordinate of the event (in document coordinates)
         * @param pageY        The `y` coordinate of the event (in document coordinates)
         * @param screenX      The `x` coordinate of the event (in screen coordinates)
         * @param screenY      The `y` coordinate of the event (in screen coordinates)
         * @param index        The index of the pointer (zero-based)
         * @param deltaX       The type of pointer
         * @param deltaY       The type of pointer
         * @param deltaZ       The type of pointer
         * @param deltaMode    The type of movement [[WheelDeltaMode]]
         * @param ev           The raw DOM event being handled
         */
        function WheelEvent(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.pageX = pageX;
            _this.pageY = pageY;
            _this.screenX = screenX;
            _this.screenY = screenY;
            _this.index = index;
            _this.deltaX = deltaX;
            _this.deltaY = deltaY;
            _this.deltaZ = deltaZ;
            _this.deltaMode = deltaMode;
            _this.ev = ev;
            return _this;
        }
        return WheelEvent;
    }(Events_9.GameEvent));
    exports.WheelEvent = WheelEvent;
    ;
    /**
     * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to
     * [W3C Pointer Events](http://www.w3.org/TR/pointerevents/).
     *
     * [[include:Pointers.md]]
     */
    var Pointers = (function (_super) {
        __extends(Pointers, _super);
        function Pointers(engine) {
            var _this = _super.call(this) || this;
            _this._pointerDown = [];
            _this._pointerUp = [];
            _this._pointerMove = [];
            _this._pointerCancel = [];
            _this._wheel = [];
            _this._pointers = [];
            _this._activePointers = [];
            _this._engine = engine;
            _this._pointers.push(new Pointer());
            _this._activePointers = [-1];
            _this.primary = _this._pointers[0];
            return _this;
        }
        Pointers.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Initializes pointer event listeners
         */
        Pointers.prototype.init = function (target) {
            target = target || this._engine.canvas;
            // Touch Events
            target.addEventListener('touchstart', this._handleTouchEvent('down', this._pointerDown));
            target.addEventListener('touchend', this._handleTouchEvent('up', this._pointerUp));
            target.addEventListener('touchmove', this._handleTouchEvent('move', this._pointerMove));
            target.addEventListener('touchcancel', this._handleTouchEvent('cancel', this._pointerCancel));
            // W3C Pointer Events
            // Current: IE11, IE10
            if (window.PointerEvent) {
                // IE11
                this._engine.canvas.style.touchAction = 'none';
                target.addEventListener('pointerdown', this._handlePointerEvent('down', this._pointerDown));
                target.addEventListener('pointerup', this._handlePointerEvent('up', this._pointerUp));
                target.addEventListener('pointermove', this._handlePointerEvent('move', this._pointerMove));
                target.addEventListener('pointercancel', this._handlePointerEvent('cancel', this._pointerMove));
            }
            else if (window.MSPointerEvent) {
                // IE10
                this._engine.canvas.style.msTouchAction = 'none';
                target.addEventListener('MSPointerDown', this._handlePointerEvent('down', this._pointerDown));
                target.addEventListener('MSPointerUp', this._handlePointerEvent('up', this._pointerUp));
                target.addEventListener('MSPointerMove', this._handlePointerEvent('move', this._pointerMove));
                target.addEventListener('MSPointerCancel', this._handlePointerEvent('cancel', this._pointerMove));
            }
            else {
                // Mouse Events
                target.addEventListener('mousedown', this._handleMouseEvent('down', this._pointerDown));
                target.addEventListener('mouseup', this._handleMouseEvent('up', this._pointerUp));
                target.addEventListener('mousemove', this._handleMouseEvent('move', this._pointerMove));
            }
            // MDN MouseWheelEvent
            if ('onwheel' in document.createElement('div')) {
                // Modern Browsers
                target.addEventListener('wheel', this._handleWheelEvent('wheel', this._wheel));
            }
            else if (document.onmousewheel !== undefined) {
                // Webkit and IE
                target.addEventListener('mousewheel', this._handleWheelEvent('wheel', this._wheel));
            }
            else {
                // Remaining browser and older Firefox
                target.addEventListener('MozMousePixelScroll', this._handleWheelEvent('wheel', this._wheel));
            }
        };
        Pointers.prototype.update = function () {
            this._pointerUp.length = 0;
            this._pointerDown.length = 0;
            this._pointerMove.length = 0;
            this._pointerCancel.length = 0;
            this._wheel.length = 0;
        };
        /**
         * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
         * @param index  The pointer index to retrieve
         */
        Pointers.prototype.at = function (index) {
            if (index >= this._pointers.length) {
                // Ensure there is a pointer to retrieve
                for (var i = this._pointers.length - 1, max = index; i < max; i++) {
                    this._pointers.push(new Pointer());
                    this._activePointers.push(-1);
                }
            }
            return this._pointers[index];
        };
        /**
         * Get number of pointers being watched
         */
        Pointers.prototype.count = function () {
            return this._pointers.length;
        };
        /**
         * Propogates events to actor if necessary
         */
        Pointers.prototype.propogate = function (actor) {
            var isUIActor = actor instanceof UIActor_1.UIActor;
            var i = 0, len = this._pointerUp.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerUp[i].x, this._pointerUp[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerup', this._pointerUp[i]);
                }
            }
            i = 0;
            len = this._pointerDown.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerDown[i].x, this._pointerDown[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerdown', this._pointerDown[i]);
                }
            }
            if (actor.capturePointer.captureMoveEvents) {
                i = 0;
                len = this._pointerMove.length;
                for (i; i < len; i++) {
                    if (actor.contains(this._pointerMove[i].x, this._pointerMove[i].y, !isUIActor)) {
                        actor.eventDispatcher.emit('pointermove', this._pointerMove[i]);
                    }
                }
            }
            i = 0;
            len = this._pointerCancel.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerCancel[i].x, this._pointerCancel[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointercancel', this._pointerCancel[i]);
                }
            }
            i = 0;
            len = this._wheel.length;
            for (i; i < len; i++) {
                if (actor.contains(this._wheel[i].x, this._wheel[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerwheel', this._wheel[i]);
                }
            }
        };
        Pointers.prototype._handleMouseEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, PointerType.Mouse, e.button, e);
                eventArr.push(pe);
                _this.at(0).eventDispatcher.emit(eventName, pe);
            };
        };
        Pointers.prototype._handleTouchEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                    var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                    if (index === -1) {
                        continue;
                    }
                    var x = e.changedTouches[i].pageX - Util.getPosition(_this._engine.canvas).x;
                    var y = e.changedTouches[i].pageY - Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.changedTouches[i].pageX, e.changedTouches[i].pageY, x, y, index, PointerType.Touch, PointerButton.Unknown, e);
                    eventArr.push(pe);
                    _this.at(index).eventDispatcher.emit(eventName, pe);
                    // only with multi-pointer
                    if (_this._pointers.length > 1) {
                        if (eventName === 'up') {
                            // remove pointer ID from pool when pointer is lifted
                            _this._activePointers[index] = -1;
                        }
                        else if (eventName === 'down') {
                            // set pointer ID to given index
                            _this._activePointers[index] = e.changedTouches[i].identifier;
                        }
                    }
                }
            };
        };
        Pointers.prototype._handlePointerEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                // get the index for this pointer ID if multi-pointer is asked for
                var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.pointerId) : 0;
                if (index === -1) {
                    return;
                }
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, index, _this._stringToPointerType(e.pointerType), e.button, e);
                eventArr.push(pe);
                _this.at(index).eventDispatcher.emit(eventName, pe);
                // only with multi-pointer
                if (_this._pointers.length > 1) {
                    if (eventName === 'up') {
                        // remove pointer ID from pool when pointer is lifted
                        _this._activePointers[index] = -1;
                    }
                    else if (eventName === 'down') {
                        // set pointer ID to given index
                        _this._activePointers[index] = e.pointerId;
                    }
                }
            };
        };
        Pointers.prototype._handleWheelEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                // Should we prevent page scroll because of this event
                if (_this._engine.pageScrollPreventionMode === Engine_1.ScrollPreventionMode.All ||
                    (_this._engine.pageScrollPreventionMode === Engine_1.ScrollPreventionMode.Canvas && e.target === _this._engine.canvas)) {
                    e.preventDefault();
                }
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                // deltaX, deltaY, and deltaZ are the standard modern properties
                // wheelDeltaX, wheelDeltaY, are legacy properties in webkit browsers and older IE
                // e.detail is only used in opera
                var deltaX = e.deltaX ||
                    (e.wheelDeltaX * ScrollWheelNormalizationFactor) ||
                    0;
                var deltaY = e.deltaY ||
                    (e.wheelDeltaY * ScrollWheelNormalizationFactor) ||
                    (e.wheelDelta * ScrollWheelNormalizationFactor) ||
                    e.detail ||
                    0;
                var deltaZ = e.deltaZ || 0;
                var deltaMode = WheelDeltaMode.Pixel;
                if (e.deltaMode) {
                    if (e.deltaMode === 1) {
                        deltaMode = WheelDeltaMode.Line;
                    }
                    else if (e.deltaMode === 2) {
                        deltaMode = WheelDeltaMode.Page;
                    }
                }
                var we = new WheelEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, deltaX, deltaY, deltaZ, deltaMode, e);
                eventArr.push(we);
                _this.at(0).eventDispatcher.emit(eventName, we);
            };
        };
        /**
         * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
         * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
         */
        Pointers.prototype._getPointerIndex = function (pointerId) {
            var idx;
            if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
                return idx;
            }
            for (var i = 0; i < this._activePointers.length; i++) {
                if (this._activePointers[i] === -1) {
                    return i;
                }
            }
            // ignore pointer because game isn't watching
            return -1;
        };
        Pointers.prototype._stringToPointerType = function (s) {
            switch (s) {
                case 'touch':
                    return PointerType.Touch;
                case 'mouse':
                    return PointerType.Mouse;
                case 'pen':
                    return PointerType.Pen;
                default:
                    return PointerType.Unknown;
            }
        };
        return Pointers;
    }(Class_6.Class));
    exports.Pointers = Pointers;
    /**
     * Captures and dispatches PointerEvents
     */
    var Pointer = (function (_super) {
        __extends(Pointer, _super);
        function Pointer() {
            var _this = _super.call(this) || this;
            /**
             * The last position on the document this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastPagePos = null;
            /**
             * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastScreenPos = null;
            /**
             * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastWorldPos = null;
            _this.on('move', _this._onPointerMove);
            return _this;
        }
        Pointer.prototype._onPointerMove = function (ev) {
            this.lastWorldPos = new Algebra_20.Vector(ev.x, ev.y);
            this.lastPagePos = new Algebra_20.Vector(ev.pageX, ev.pageY);
            this.lastScreenPos = new Algebra_20.Vector(ev.screenX, ev.screenY);
        };
        return Pointer;
    }(Class_6.Class));
    exports.Pointer = Pointer;
});
define("Input/Keyboard", ["require", "exports", "Class", "Events"], function (require, exports, Class_7, Events_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing input key codes
     */
    var Keys;
    (function (Keys) {
        Keys[Keys["Num1"] = 97] = "Num1";
        Keys[Keys["Num2"] = 98] = "Num2";
        Keys[Keys["Num3"] = 99] = "Num3";
        Keys[Keys["Num4"] = 100] = "Num4";
        Keys[Keys["Num5"] = 101] = "Num5";
        Keys[Keys["Num6"] = 102] = "Num6";
        Keys[Keys["Num7"] = 103] = "Num7";
        Keys[Keys["Num8"] = 104] = "Num8";
        Keys[Keys["Num9"] = 105] = "Num9";
        Keys[Keys["Num0"] = 96] = "Num0";
        Keys[Keys["Numlock"] = 144] = "Numlock";
        Keys[Keys["Semicolon"] = 186] = "Semicolon";
        Keys[Keys["A"] = 65] = "A";
        Keys[Keys["B"] = 66] = "B";
        Keys[Keys["C"] = 67] = "C";
        Keys[Keys["D"] = 68] = "D";
        Keys[Keys["E"] = 69] = "E";
        Keys[Keys["F"] = 70] = "F";
        Keys[Keys["G"] = 71] = "G";
        Keys[Keys["H"] = 72] = "H";
        Keys[Keys["I"] = 73] = "I";
        Keys[Keys["J"] = 74] = "J";
        Keys[Keys["K"] = 75] = "K";
        Keys[Keys["L"] = 76] = "L";
        Keys[Keys["M"] = 77] = "M";
        Keys[Keys["N"] = 78] = "N";
        Keys[Keys["O"] = 79] = "O";
        Keys[Keys["P"] = 80] = "P";
        Keys[Keys["Q"] = 81] = "Q";
        Keys[Keys["R"] = 82] = "R";
        Keys[Keys["S"] = 83] = "S";
        Keys[Keys["T"] = 84] = "T";
        Keys[Keys["U"] = 85] = "U";
        Keys[Keys["V"] = 86] = "V";
        Keys[Keys["W"] = 87] = "W";
        Keys[Keys["X"] = 88] = "X";
        Keys[Keys["Y"] = 89] = "Y";
        Keys[Keys["Z"] = 90] = "Z";
        Keys[Keys["Shift"] = 16] = "Shift";
        Keys[Keys["Alt"] = 18] = "Alt";
        Keys[Keys["Up"] = 38] = "Up";
        Keys[Keys["Down"] = 40] = "Down";
        Keys[Keys["Left"] = 37] = "Left";
        Keys[Keys["Right"] = 39] = "Right";
        Keys[Keys["Space"] = 32] = "Space";
        Keys[Keys["Esc"] = 27] = "Esc";
    })(Keys = exports.Keys || (exports.Keys = {}));
    ;
    /**
     * Event thrown on a game object for a key event
     */
    var KeyEvent = (function (_super) {
        __extends(KeyEvent, _super);
        /**
         * @param key  The key responsible for throwing the event
         */
        function KeyEvent(key) {
            var _this = _super.call(this) || this;
            _this.key = key;
            return _this;
        }
        return KeyEvent;
    }(Events_10.GameEvent));
    exports.KeyEvent = KeyEvent;
    /**
     * Provides keyboard support for Excalibur.
     *
     * [[include:Keyboard.md]]
     */
    var Keyboard = (function (_super) {
        __extends(Keyboard, _super);
        function Keyboard(engine) {
            var _this = _super.call(this) || this;
            _this._keys = [];
            _this._keysUp = [];
            _this._keysDown = [];
            _this._engine = engine;
            return _this;
        }
        Keyboard.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Initialize Keyboard event listeners
         */
        Keyboard.prototype.init = function (global) {
            var _this = this;
            global = global || window;
            global.addEventListener('blur', function () {
                _this._keys.length = 0; // empties array efficiently
            });
            // key up is on window because canvas cannot have focus
            global.addEventListener('keyup', function (ev) {
                var code = _this._normalizeKeyCode(ev.keyCode);
                var key = _this._keys.indexOf(code);
                _this._keys.splice(key, 1);
                _this._keysUp.push(code);
                var keyEvent = new KeyEvent(code);
                // alias the old api, we may want to deprecate this in the future
                _this.eventDispatcher.emit('up', keyEvent);
                _this.eventDispatcher.emit('release', keyEvent);
            });
            // key down is on window because canvas cannot have focus
            global.addEventListener('keydown', function (ev) {
                var code = _this._normalizeKeyCode(ev.keyCode);
                if (_this._keys.indexOf(code) === -1) {
                    _this._keys.push(code);
                    _this._keysDown.push(code);
                    var keyEvent = new KeyEvent(code);
                    _this.eventDispatcher.emit('down', keyEvent);
                    _this.eventDispatcher.emit('press', keyEvent);
                }
            });
        };
        Keyboard.prototype.update = function () {
            // Reset keysDown and keysUp after update is complete
            this._keysDown.length = 0;
            this._keysUp.length = 0;
            // Emit synthetic "hold" event
            for (var i = 0; i < this._keys.length; i++) {
                this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));
            }
        };
        /**
         * Gets list of keys being pressed down
         */
        Keyboard.prototype.getKeys = function () {
            return this._keys;
        };
        /**
         * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
         * @param key Test whether a key was just pressed
         */
        Keyboard.prototype.wasPressed = function (key) {
            return this._keysDown.indexOf(key) > -1;
        };
        /**
         * Tests if a certain key is held down. This is persisted between frames.
         * @param key  Test whether a key is held down
         */
        Keyboard.prototype.isHeld = function (key) {
            return this._keys.indexOf(key) > -1;
        };
        /**
         * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
         * @param key  Test whether a key was just released
         */
        Keyboard.prototype.wasReleased = function (key) {
            return this._keysUp.indexOf(key) > -1;
        };
        /**
         * Normalizes some browser event key codes to map to standard Excalibur key codes
         * @param code Event keyCode
         * @see http://unixpapa.com/js/key.html
         */
        Keyboard.prototype._normalizeKeyCode = function (code) {
            switch (code) {
                case 59:
                    return Keys.Semicolon;
                default:
                    return code;
            }
        };
        return Keyboard;
    }(Class_7.Class));
    exports.Keyboard = Keyboard;
});
define("Input/IEngineInput", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
/**
 * Provides support for mice, keyboards, and controllers.
 *
 * [[include:Input.md]]
 */
define("Input/Index", ["require", "exports", "Input/Gamepad", "Input/Pointer", "Input/Keyboard"], function (require, exports, Gamepad_1, Pointer_1, Keyboard_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @typedoc
     */
    __export(Gamepad_1);
    __export(Pointer_1);
    __export(Keyboard_1);
});
define("Util/Index", ["require", "exports", "Util/Util", "Util/DrawUtil"], function (require, exports, Util_3, drawUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Util_3);
    exports.DrawUtil = drawUtil;
});
define("Util/Detector", ["require", "exports", "Util/Log"], function (require, exports, Log_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is the list of features that will be used to log the supported
     * features to the console when Detector.logBrowserFeatures() is called.
     */
    var REPORTED_FEATURES = {
        webgl: 'WebGL',
        webaudio: 'WebAudio',
        gamepadapi: 'Gamepad API'
    };
    /**
     * Excalibur internal feature detection helper class
     */
    var Detector = (function () {
        function Detector() {
            this._features = null;
            this.failedTests = [];
            // critical browser features required for ex to run
            this._criticalTests = {
                // Test canvas/2d context support
                canvasSupport: function () {
                    var elem = document.createElement('canvas');
                    return !!(elem.getContext && elem.getContext('2d'));
                },
                // Test array buffer support ex uses for downloading binary data
                arrayBufferSupport: function () {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', '/');
                    try {
                        xhr.responseType = 'arraybuffer';
                    }
                    catch (e) {
                        return false;
                    }
                    return xhr.responseType === 'arraybuffer';
                },
                // Test data urls ex uses for sprites
                dataUrlSupport: function () {
                    var canvas = document.createElement('canvas');
                    return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
                },
                // Test object url support for loading
                objectUrlSupport: function () {
                    return ('URL' in window) && ('revokeObjectURL' in URL) && ('createObjectURL' in URL);
                },
                // RGBA support for colors
                rgbaSupport: function () {
                    var style = document.createElement('a').style;
                    style.cssText = 'background-color:rgba(150,255,150,.5)';
                    return ('' + style.backgroundColor).indexOf('rgba') > -1;
                }
            };
            // warnings excalibur performance will be degraded
            this._warningTest = {
                webAudioSupport: function () {
                    return !!(window.AudioContext ||
                        window.webkitAudioContext ||
                        window.mozAudioContext ||
                        window.msAudioContext ||
                        window.oAudioContext);
                },
                webglSupport: function () {
                    var elem = document.createElement('canvas');
                    return !!(elem.getContext && elem.getContext('webgl'));
                }
            };
            this._features = this._loadBrowserFeatures();
        }
        /**
         * Returns a map of currently supported browser features. This method
         * treats the features as a singleton and will only calculate feature
         * support if it has not previously been done.
         */
        Detector.prototype.getBrowserFeatures = function () {
            if (this._features === null) {
                this._features = this._loadBrowserFeatures();
            }
            return this._features;
        };
        /**
         * Report on non-critical browser support for debugging purposes.
         * Use native browser console colors for visibility.
         */
        Detector.prototype.logBrowserFeatures = function () {
            var msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
            var args = [
                'font-weight: bold; color: navy',
                'font-weight: normal; color: inherit'
            ];
            var supported = this.getBrowserFeatures();
            for (var _i = 0, _a = Object.keys(REPORTED_FEATURES); _i < _a.length; _i++) {
                var feature = _a[_i];
                if (supported[feature]) {
                    msg += '(%c\u2713%c)'; // (✓)
                    args.push('font-weight: bold; color: green');
                    args.push('font-weight: normal; color: inherit');
                }
                else {
                    msg += '(%c\u2717%c)'; // (✗)
                    args.push('font-weight: bold; color: red');
                    args.push('font-weight: normal; color: inherit');
                }
                ;
                msg += ' ' + REPORTED_FEATURES[feature] + '\n';
            }
            args.unshift(msg);
            console.log.apply(console, args);
        };
        /**
         * Executes several IIFE's to get a constant reference to supported
         * features within the current execution context.
         */
        Detector.prototype._loadBrowserFeatures = function () {
            var _this = this;
            return {
                // IIFE to check canvas support
                canvas: (function () {
                    return _this._criticalTests.canvasSupport();
                })(),
                // IIFE to check arraybuffer support
                arraybuffer: (function () {
                    return _this._criticalTests.arrayBufferSupport();
                })(),
                // IIFE to check dataurl support
                dataurl: (function () {
                    return _this._criticalTests.dataUrlSupport();
                })(),
                // IIFE to check objecturl support
                objecturl: (function () {
                    return _this._criticalTests.objectUrlSupport();
                })(),
                // IIFE to check rgba support
                rgba: (function () {
                    return _this._criticalTests.rgbaSupport();
                })(),
                // IIFE to check webaudio support
                webaudio: (function () {
                    return _this._warningTest.webAudioSupport();
                })(),
                // IIFE to check webgl support
                webgl: (function () {
                    return _this._warningTest.webglSupport();
                })(),
                // IIFE to check gamepadapi support
                gamepadapi: (function () {
                    return !!navigator.getGamepads;
                })()
            };
        };
        Detector.prototype.test = function () {
            // Critical test will for ex not to run
            var failedCritical = false;
            for (var test in this._criticalTests) {
                if (!this._criticalTests[test].call(this)) {
                    this.failedTests.push(test);
                    Log_12.Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                    failedCritical = true;
                }
            }
            if (failedCritical) {
                return false;
            }
            // Warning tests do not for ex to return false to compatibility
            for (var warning in this._warningTest) {
                if (!this._warningTest[warning]()) {
                    Log_12.Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
                }
            }
            return true;
        };
        return Detector;
    }());
    exports.Detector = Detector;
});
define("Util/SortedList", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A sorted list implementation. NOTE: this implementation is not self-balancing
     */
    var SortedList = (function () {
        function SortedList(getComparable) {
            this._getComparable = getComparable;
        }
        SortedList.prototype.find = function (element) {
            return this._find(this._root, element);
        };
        SortedList.prototype._find = function (node, element) {
            if (node == null) {
                return false;
            }
            else if (this._getComparable.call(element) === node.getKey()) {
                if (node.getData().indexOf(element) > -1) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                return this._find(node.getLeft(), element);
            }
            else {
                return this._find(node.getRight(), element);
            }
        };
        // returns the array of elements at a specific key value
        SortedList.prototype.get = function (key) {
            return this._get(this._root, key);
        };
        SortedList.prototype._get = function (node, key) {
            if (node == null) {
                return [];
            }
            else if (key === node.getKey()) {
                return node.getData();
            }
            else if (key < node.getKey()) {
                return this._get(node.getLeft(), key);
            }
            else {
                return this._get(node.getRight(), key);
            }
        };
        SortedList.prototype.add = function (element) {
            if (this._root == null) {
                this._root = new BinaryTreeNode(this._getComparable.call(element), [element], null, null);
                return true;
            }
            else {
                return this._insert(this._root, element);
            }
        };
        SortedList.prototype._insert = function (node, element) {
            if (node != null) {
                if (this._getComparable.call(element) === node.getKey()) {
                    if (node.getData().indexOf(element) > -1) {
                        return false; // the element we're trying to insert already exists
                    }
                    else {
                        node.getData().push(element);
                        return true;
                    }
                }
                else if (this._getComparable.call(element) < node.getKey()) {
                    if (node.getLeft() == null) {
                        node.setLeft(new BinaryTreeNode(this._getComparable.call(element), [element], null, null));
                        return true;
                    }
                    else {
                        return this._insert(node.getLeft(), element);
                    }
                }
                else {
                    if (node.getRight() == null) {
                        node.setRight(new BinaryTreeNode(this._getComparable.call(element), [element], null, null));
                        return true;
                    }
                    else {
                        return this._insert(node.getRight(), element);
                    }
                }
            }
            return false;
        };
        SortedList.prototype.removeByComparable = function (element) {
            this._root = this._remove(this._root, element);
        };
        SortedList.prototype._remove = function (node, element) {
            if (node == null) {
                return null;
            }
            else if (this._getComparable.call(element) === node.getKey()) {
                var elementIndex = node.getData().indexOf(element);
                // if the node contains the element, remove the element
                if (elementIndex > -1) {
                    node.getData().splice(elementIndex, 1);
                    // if we have removed the last element at this node, remove the node
                    if (node.getData().length === 0) {
                        // if the node is a leaf
                        if (node.getLeft() == null && node.getRight() == null) {
                            return null;
                        }
                        else if (node.getLeft() == null) {
                            return node.getRight();
                        }
                        else if (node.getRight() == null) {
                            return node.getLeft();
                        }
                        // if node has 2 children
                        var temp = this._findMinNode(node.getRight());
                        node.setKey(temp.getKey());
                        node.setData(temp.getData());
                        node.setRight(this._cleanup(node.getRight(), temp)); //"cleanup nodes" (move them up recursively)
                        return node;
                    }
                    else {
                        // this prevents the node from being removed since it still contains elements
                        return node;
                    }
                }
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                node.setLeft(this._remove(node.getLeft(), element));
                return node;
            }
            else {
                node.setRight(this._remove(node.getRight(), element));
                return node;
            }
            return null;
        };
        // called once we have successfully removed the element we wanted, recursively corrects the part of the tree below the removed node
        SortedList.prototype._cleanup = function (node, element) {
            var comparable = element.getKey();
            if (node == null) {
                return null;
            }
            else if (comparable === node.getKey()) {
                // if the node is a leaf
                if (node.getLeft() == null && node.getRight() == null) {
                    return null;
                }
                else if (node.getLeft() == null) {
                    return node.getRight();
                }
                else if (node.getRight() == null) {
                    return node.getLeft();
                }
                // if node has 2 children
                var temp = this._findMinNode(node.getRight());
                node.setKey(temp.getKey());
                node.setData(temp.getData());
                node.setRight(this._cleanup(node.getRight(), temp));
                return node;
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                node.setLeft(this._cleanup(node.getLeft(), element));
                return node;
            }
            else {
                node.setRight(this._cleanup(node.getRight(), element));
                return node;
            }
        };
        SortedList.prototype._findMinNode = function (node) {
            var current = node;
            while (current.getLeft() != null) {
                current = current.getLeft();
            }
            return current;
        };
        SortedList.prototype.list = function () {
            var results = new Array();
            this._list(this._root, results);
            return results;
        };
        SortedList.prototype._list = function (treeNode, results) {
            if (treeNode != null) {
                this._list(treeNode.getLeft(), results);
                treeNode.getData().forEach(function (element) {
                    results.push(element);
                });
                this._list(treeNode.getRight(), results);
            }
        };
        return SortedList;
    }());
    exports.SortedList = SortedList;
    /**
     * A tree node part of [[SortedList]]
     */
    var BinaryTreeNode = (function () {
        function BinaryTreeNode(key, data, left, right) {
            this._key = key;
            this._data = data;
            this._left = left;
            this._right = right;
        }
        BinaryTreeNode.prototype.getKey = function () {
            return this._key;
        };
        BinaryTreeNode.prototype.setKey = function (key) {
            this._key = key;
        };
        BinaryTreeNode.prototype.getData = function () {
            return this._data;
        };
        BinaryTreeNode.prototype.setData = function (data) {
            this._data = data;
        };
        BinaryTreeNode.prototype.getLeft = function () {
            return this._left;
        };
        BinaryTreeNode.prototype.setLeft = function (left) {
            this._left = left;
        };
        BinaryTreeNode.prototype.getRight = function () {
            return this._right;
        };
        BinaryTreeNode.prototype.setRight = function (right) {
            this._right = right;
        };
        return BinaryTreeNode;
    }());
    exports.BinaryTreeNode = BinaryTreeNode;
    /**
     * Mock element for testing
     *
     * @internal
     */
    var MockedElement = (function () {
        function MockedElement(key) {
            this._key = 0;
            this._key = key;
        }
        MockedElement.prototype.getTheKey = function () {
            return this._key;
        };
        MockedElement.prototype.setKey = function (key) {
            this._key = key;
        };
        return MockedElement;
    }());
    exports.MockedElement = MockedElement;
});
define("Index", ["require", "exports", "Actor", "Algebra", "Camera", "Class", "Debug", "Engine", "EventDispatcher", "Events", "Group", "Label", "Loader", "Particles", "Physics", "Promises", "Scene", "TileMap", "Timer", "Trigger", "UIActor", "Actions/Index", "Collision/Index", "Drawing/Index", "Math/Index", "PostProcessing/Index", "Resources/Index", "Events", "Input/Index", "Traits/Index", "Util/Index", "Util/Decorators", "Util/Detector", "Util/CullingBox", "Util/EasingFunctions", "Util/Log", "Util/SortedList"], function (require, exports, Actor_11, Algebra_21, Camera_1, Class_8, Debug_1, Engine_2, EventDispatcher_2, Events_11, Group_1, Label_2, Loader_1, Particles_1, Physics_11, Promises_7, Scene_1, TileMap_1, Timer_1, Trigger_1, UIActor_2, Index_1, Index_2, Index_3, Index_4, Index_5, Index_6, events, input, traits, util, Decorators_2, Detector_1, CullingBox_2, EasingFunctions_3, Log_13, SortedList_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The current Excalibur version string
     */
    exports.EX_VERSION = '0.14.0';
    // This file is used as the bundle entrypoint and exports everything
    // that will be exposed as the `ex` global variable.
    __export(Actor_11);
    __export(Algebra_21);
    __export(Camera_1);
    __export(Class_8);
    __export(Debug_1);
    __export(Engine_2);
    __export(EventDispatcher_2);
    __export(Events_11);
    __export(Group_1);
    __export(Label_2);
    __export(Loader_1);
    __export(Particles_1);
    __export(Physics_11);
    __export(Promises_7);
    __export(Scene_1);
    __export(TileMap_1);
    __export(Timer_1);
    __export(Trigger_1);
    __export(UIActor_2);
    __export(Index_1);
    __export(Index_2);
    __export(Index_3);
    __export(Index_4);
    __export(Index_5);
    __export(Index_6);
    exports.Events = events;
    exports.Input = input;
    exports.Traits = traits;
    exports.Util = util;
    __export(Decorators_2);
    __export(Detector_1);
    __export(CullingBox_2);
    __export(EasingFunctions_3);
    __export(Log_13);
    __export(SortedList_1);
});
define("Engine", ["require", "exports", "Index", "Promises", "Algebra", "UIActor", "Actor", "Timer", "TileMap", "Loader", "Util/Detector", "Events", "Util/Log", "Drawing/Color", "Scene", "Debug", "Class", "Input/Index", "Util/Util", "Collision/BoundingBox"], function (require, exports, Index_7, Promises_8, Algebra_22, UIActor_3, Actor_12, Timer_2, TileMap_2, Loader_2, Detector_2, Events_12, Log_14, Color_19, Scene_2, Debug_2, Class_9, Input, Util, BoundingBox_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing the different display modes available to Excalibur
     */
    var DisplayMode;
    (function (DisplayMode) {
        /**
         * Show the game as full screen
         */
        DisplayMode[DisplayMode["FullScreen"] = 0] = "FullScreen";
        /**
         * Scale the game to the parent DOM container
         */
        DisplayMode[DisplayMode["Container"] = 1] = "Container";
        /**
         * Show the game as a fixed size
         */
        DisplayMode[DisplayMode["Fixed"] = 2] = "Fixed";
        /**
         * Allow the game to be positioned with the [[IEngineOptions.position]] option
         */
        DisplayMode[DisplayMode["Position"] = 3] = "Position";
    })(DisplayMode = exports.DisplayMode || (exports.DisplayMode = {}));
    /**
     * Enum representing the different mousewheel event bubble prevention
     */
    var ScrollPreventionMode;
    (function (ScrollPreventionMode) {
        /**
         * Do not prevent any page scrolling
         */
        ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
        /**
         * Prevent page scroll if mouse is over the game canvas
         */
        ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
        /**
         * Prevent all page scrolling via mouse wheel
         */
        ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
    })(ScrollPreventionMode = exports.ScrollPreventionMode || (exports.ScrollPreventionMode = {}));
    /**
     * The Excalibur Engine
     *
     * The [[Engine]] is the main driver for a game. It is responsible for
     * starting/stopping the game, maintaining state, transmitting events,
     * loading resources, and managing the scene.
     *
     * [[include:Engine.md]]
     */
    var Engine = (function (_super) {
        __extends(Engine, _super);
        /**
         * Creates a new game using the given [[IEngineOptions]]. By default, if no options are provided,
         * the game will be rendered full screen (taking up all available browser window space).
         * You can customize the game rendering through [[IEngineOptions]].
         *
         * Example:
         *
         * ```js
         * var game = new ex.Engine({
         *   width: 0, // the width of the canvas
         *   height: 0, // the height of the canvas
         *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
         *   displayMode: ex.DisplayMode.FullScreen, // the display mode
         *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
         *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
         * });
         *
         * // call game.start, which is a Promise
         * game.start().then(function () {
         *   // ready, set, go!
         * });
         * ```
         */
        function Engine(options) {
            var _this = _super.call(this) || this;
            _this._hasStarted = false;
            /**
             * Access Excalibur debugging functionality.
             */
            _this.debug = new Debug_2.Debug();
            /**
             * Gets or sets the list of post processors to apply at the end of drawing a frame (such as [[ColorBlindCorrector]])
             */
            _this.postProcessors = [];
            /**
             * Contains all the scenes currently registered with Excalibur
             */
            _this.scenes = {};
            _this._animations = [];
            /**
             * Indicates whether the engine is set to fullscreen or not
             */
            _this.isFullscreen = false;
            /**
             * Indicates the current [[DisplayMode]] of the engine.
             */
            _this.displayMode = DisplayMode.FullScreen;
            /**
             * Indicates whether audio should be paused when the game is no longer visible.
             */
            _this.pauseAudioWhenHidden = true;
            /**
             * Indicates whether the engine should draw with debug information
             */
            _this.isDebug = false;
            _this.debugColor = new Color_19.Color(255, 255, 255);
            /**
             * The action to take when a fatal exception is thrown
             */
            _this.onFatalException = function (e) { Log_14.Logger.getInstance().fatal(e); };
            _this._isSmoothingEnabled = true;
            _this._timescale = 1.0;
            _this._isLoading = false;
            options = Util.extend({}, Engine._DefaultEngineOptions, options);
            // Check compatibility 
            var detector = new Detector_2.Detector();
            if (!options.suppressMinimumBrowserFeatureDetection && !(_this._compatible = detector.test())) {
                var message = document.createElement('div');
                message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
                document.body.appendChild(message);
                detector.failedTests.forEach(function (test) {
                    var testMessage = document.createElement('div');
                    testMessage.innerText = 'Browser feature missing ' + test;
                    document.body.appendChild(testMessage);
                });
                if (options.canvasElementId) {
                    var canvas = document.getElementById(options.canvasElementId);
                    if (canvas) {
                        canvas.parentElement.removeChild(canvas);
                    }
                }
                return _this;
            }
            else {
                _this._compatible = true;
            }
            // Use native console API for color fun
            if (console.log && !options.suppressConsoleBootMessage) {
                console.log("%cPowered by Excalibur.js (v" + Index_7.EX_VERSION + ")", 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
                console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
                console.log('Visit', 'http://excaliburjs.com', 'for more information');
            }
            _this._logger = Log_14.Logger.getInstance();
            // If debug is enabled, let's log browser features to the console.
            if (_this._logger.defaultLevel === Log_14.LogLevel.Debug) {
                detector.logBrowserFeatures();
            }
            _this._logger.debug('Building engine...');
            _this.canvasElementId = options.canvasElementId;
            if (options.canvasElementId) {
                _this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
                _this.canvas = document.getElementById(options.canvasElementId);
            }
            else {
                _this._logger.debug('Using generated canvas element');
                _this.canvas = document.createElement('canvas');
            }
            if (options.width && options.height) {
                if (options.displayMode === undefined) {
                    _this.displayMode = DisplayMode.Fixed;
                }
                _this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
                _this.canvas.width = options.width;
                _this.canvas.height = options.height;
            }
            else if (!options.displayMode) {
                _this._logger.debug('Engine viewport is fullscreen');
                _this.displayMode = DisplayMode.FullScreen;
            }
            if (options.backgroundColor) {
                _this.backgroundColor = options.backgroundColor.clone();
            }
            _this._loader = new Loader_2.Loader();
            _this._initialize(options);
            _this.rootScene = _this.currentScene = new Scene_2.Scene(_this);
            _this.addScene('root', _this.rootScene);
            _this.goToScene('root');
            return _this;
        }
        Object.defineProperty(Engine.prototype, "canvasWidth", {
            /**
             * The width of the game canvas in pixels (physical width component of the
             * resolution of the canvas element)
             */
            get: function () {
                return this.canvas.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfCanvasWidth", {
            /**
             * Returns half width of the game canvas in pixels (half physical width component)
             */
            get: function () {
                return this.canvas.width / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "canvasHeight", {
            /**
             * The height of the game canvas in pixels, (physical height component of
             * the resolution of the canvas element)
             */
            get: function () {
                return this.canvas.height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfCanvasHeight", {
            /**
             * Returns half height of the game canvas in pixels (half physical height component)
             */
            get: function () {
                return this.canvas.height / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "drawWidth", {
            /**
             * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                if (this.currentScene && this.currentScene.camera) {
                    return (this.canvasWidth / this.currentScene.camera.getZoom()) / this.pixelRatio;
                }
                return this.canvasWidth / this.pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfDrawWidth", {
            /**
             * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                return this.drawWidth / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "drawHeight", {
            /**
             * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                if (this.currentScene && this.currentScene.camera) {
                    return (this.canvasHeight / this.currentScene.camera.getZoom()) / this.pixelRatio;
                }
                return this.canvasHeight / this.pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfDrawHeight", {
            /**
             * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                return this.drawHeight / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "isHiDpi", {
            /**
             * Returns whether excalibur detects the current screen to be HiDPI
             */
            get: function () {
                return this.pixelRatio !== 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "stats", {
            /**
             * Access [[stats]] that holds frame statistics.
             */
            get: function () {
                return this.debug.stats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "pixelRatio", {
            /**
             * Returns the calculated pixel ration for use in rendering
             */
            get: function () {
                var devicePixelRatio = window.devicePixelRatio || 1;
                var pixelRatio = devicePixelRatio;
                return pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Engine.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Returns a BoundingBox of the top left corner of the screen
         * and the bottom right corner of the screen.
         */
        Engine.prototype.getWorldBounds = function () {
            var left = this.screenToWorldCoordinates(Algebra_22.Vector.Zero).x;
            var top = this.screenToWorldCoordinates(Algebra_22.Vector.Zero).y;
            var right = left + this.drawWidth;
            var bottom = top + this.drawHeight;
            return new BoundingBox_7.BoundingBox(left, top, right, bottom);
        };
        Object.defineProperty(Engine.prototype, "timescale", {
            /**
             * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
             */
            get: function () {
                return this._timescale;
            },
            /**
             * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
             * when using time-based movement.
             */
            set: function (value) {
                if (value <= 0) {
                    Log_14.Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');
                    return;
                }
                this._timescale = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Plays a sprite animation on the screen at the specified `x` and `y`
         * (in game coordinates, not screen pixels). These animations play
         * independent of actors, and will be cleaned up internally as soon
         * as they are complete. Note animations that loop will never be
         * cleaned up.
         *
         * @param animation  Animation to play
         * @param x          x game coordinate to play the animation
         * @param y          y game coordinate to play the animation
         */
        Engine.prototype.playAnimation = function (animation, x, y) {
            this._animations.push(new AnimationNode(animation, x, y));
        };
        /**
         * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap
         * will be drawn and updated.
         */
        Engine.prototype.addTileMap = function (tileMap) {
            this.currentScene.addTileMap(tileMap);
        };
        /**
         * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.
         */
        Engine.prototype.removeTileMap = function (tileMap) {
            this.currentScene.removeTileMap(tileMap);
        };
        /**
         * Adds a [[Timer]] to the [[currentScene]].
         * @param timer  The timer to add to the [[currentScene]].
         */
        Engine.prototype.addTimer = function (timer) {
            return this.currentScene.addTimer(timer);
        };
        /**
         * Removes a [[Timer]] from the [[currentScene]].
         * @param timer  The timer to remove to the [[currentScene]].
         */
        Engine.prototype.removeTimer = function (timer) {
            return this.currentScene.removeTimer(timer);
        };
        /**
         * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
         * would levels or menus.
         *
         * @param key  The name of the scene, must be unique
         * @param scene The scene to add to the engine
         */
        Engine.prototype.addScene = function (key, scene) {
            if (this.scenes[key]) {
                this._logger.warn('Scene', key, 'already exists overwriting');
            }
            this.scenes[key] = scene;
            scene.engine = this;
        };
        /**
         * @internal
         */
        Engine.prototype.removeScene = function (entity) {
            if (entity instanceof Scene_2.Scene) {
                // remove scene
                for (var key in this.scenes) {
                    if (this.scenes.hasOwnProperty(key)) {
                        if (this.scenes[key] === entity) {
                            delete this.scenes[key];
                        }
                    }
                }
            }
            if (typeof entity === 'string') {
                // remove scene
                delete this.scenes[entity];
            }
        };
        Engine.prototype.add = function (entity) {
            if (entity instanceof UIActor_3.UIActor) {
                this.currentScene.addUIActor(entity);
                return;
            }
            if (entity instanceof Actor_12.Actor) {
                this._addChild(entity);
            }
            if (entity instanceof Timer_2.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof TileMap_2.TileMap) {
                this.addTileMap(entity);
            }
            if (arguments.length === 2) {
                this.addScene(arguments[0], arguments[1]);
            }
        };
        Engine.prototype.remove = function (entity) {
            if (entity instanceof UIActor_3.UIActor) {
                this.currentScene.removeUIActor(entity);
                return;
            }
            if (entity instanceof Actor_12.Actor) {
                this._removeChild(entity);
            }
            if (entity instanceof Timer_2.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof TileMap_2.TileMap) {
                this.removeTileMap(entity);
            }
            if (entity instanceof Scene_2.Scene) {
                this.removeScene(entity);
            }
            if (typeof entity === 'string') {
                this.removeScene(entity);
            }
        };
        /**
         * Adds an actor to the [[currentScene]] of the game. This is synonymous
         * to calling `engine.currentScene.add(actor)`.
         *
         * Actors can only be drawn if they are a member of a scene, and only
         * the [[currentScene]] may be drawn or updated.
         *
         * @param actor  The actor to add to the [[currentScene]]
         */
        Engine.prototype._addChild = function (actor) {
            this.currentScene.add(actor);
        };
        /**
         * Removes an actor from the [[currentScene]] of the game. This is synonymous
         * to calling `engine.currentScene.remove(actor)`.
         * Actors that are removed from a scene will no longer be drawn or updated.
         *
         * @param actor  The actor to remove from the [[currentScene]].
         */
        Engine.prototype._removeChild = function (actor) {
            this.currentScene.remove(actor);
        };
        /**
         * Changes the currently updating and drawing scene to a different,
         * named scene. Calls the [[Scene]] lifecycle events.
         * @param key  The key of the scene to transition to.
         */
        Engine.prototype.goToScene = function (key) {
            if (this.scenes[key]) {
                var oldScene = this.currentScene;
                var newScene = this.scenes[key];
                this._logger.debug('Going to scene:', key);
                // only deactivate when initialized
                if (this.currentScene.isInitialized) {
                    this.currentScene.onDeactivate.call(this.currentScene);
                    this.currentScene.eventDispatcher.emit('deactivate', new Events_12.DeactivateEvent(newScene, this.currentScene));
                }
                // set current scene to new one
                this.currentScene = newScene;
                // initialize the current scene if has not been already
                this.currentScene._initialize(this);
                this.currentScene.onActivate.call(this.currentScene);
                this.currentScene.eventDispatcher.emit('activate', new Events_12.ActivateEvent(oldScene, this.currentScene));
            }
            else {
                this._logger.error('Scene', key, 'does not exist!');
            }
        };
        /**
         * Transforms the current x, y from screen coordinates to world coordinates
         * @param point  Screen coordinate to convert
         */
        Engine.prototype.screenToWorldCoordinates = function (point) {
            var newX = point.x;
            var newY = point.y;
            // transform back to world space
            newX = (newX / this.canvas.clientWidth) * this.drawWidth;
            newY = (newY / this.canvas.clientHeight) * this.drawHeight;
            // transform based on zoom
            newX = newX - this.halfDrawWidth;
            newY = newY - this.halfDrawHeight;
            // shift by focus
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                newX += focus.x;
                newY += focus.y;
            }
            return new Algebra_22.Vector(Math.floor(newX), Math.floor(newY));
        };
        /**
         * Transforms a world coordinate, to a screen coordinate
         * @param point  World coordinate to convert
         */
        Engine.prototype.worldToScreenCoordinates = function (point) {
            var screenX = point.x;
            var screenY = point.y;
            // shift by focus
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                screenX -= focus.x;
                screenY -= focus.y;
            }
            // transform back on zoom
            screenX = screenX + this.halfDrawWidth;
            screenY = screenY + this.halfDrawHeight;
            // transform back to screen space
            screenX = (screenX * this.canvas.clientWidth) / this.drawWidth;
            screenY = (screenY * this.canvas.clientHeight) / this.drawHeight;
            return new Algebra_22.Vector(Math.floor(screenX), Math.floor(screenY));
        };
        /**
         * Sets the internal canvas height based on the selected display mode.
         */
        Engine.prototype._setHeightByDisplayMode = function (parent) {
            if (this.displayMode === DisplayMode.Container) {
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight;
            }
            if (this.displayMode === DisplayMode.FullScreen) {
                document.body.style.margin = '0px';
                document.body.style.overflow = 'hidden';
                this.canvas.width = parent.innerWidth;
                this.canvas.height = parent.innerHeight;
            }
        };
        /**
         * Initializes the internal canvas, rendering context, displaymode, and native event listeners
         */
        Engine.prototype._initialize = function (options) {
            var _this = this;
            if (options.displayMode) {
                this.displayMode = options.displayMode;
            }
            if (this.displayMode === DisplayMode.FullScreen || this.displayMode === DisplayMode.Container) {
                var parent = (this.displayMode === DisplayMode.Container ?
                    (this.canvas.parentElement || document.body) : window);
                this._setHeightByDisplayMode(parent);
                window.addEventListener('resize', function () {
                    _this._logger.debug('View port resized');
                    _this._setHeightByDisplayMode(parent);
                    _this._logger.info('parent.clientHeight ' + parent.clientHeight);
                    _this.setAntialiasing(_this._isSmoothingEnabled);
                });
            }
            else if (this.displayMode === DisplayMode.Position) {
                this._intializeDisplayModePosition(options);
            }
            // initialize inputs
            this.input = {
                keyboard: new Input.Keyboard(this),
                pointers: new Input.Pointers(this),
                gamepads: new Input.Gamepads(this)
            };
            this.input.keyboard.init();
            this.input.pointers.init(options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas);
            this.input.gamepads.init();
            this.pageScrollPreventionMode = options.scrollPreventionMode;
            // Issue #385 make use of the visibility api
            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
            var hidden, visibilityChange;
            if (typeof document.hidden !== 'undefined') {
                hidden = 'hidden';
                visibilityChange = 'visibilitychange';
            }
            else if ('msHidden' in document) {
                hidden = 'msHidden';
                visibilityChange = 'msvisibilitychange';
            }
            else if ('webkitHidden' in document) {
                hidden = 'webkitHidden';
                visibilityChange = 'webkitvisibilitychange';
            }
            document.addEventListener(visibilityChange, function () {
                if (document[hidden]) {
                    _this.eventDispatcher.emit('hidden', new Events_12.HiddenEvent(_this));
                    _this._logger.debug('Window hidden');
                }
                else {
                    _this.eventDispatcher.emit('visible', new Events_12.VisibleEvent(_this));
                    _this._logger.debug('Window visible');
                }
            });
            this.ctx = this.canvas.getContext('2d');
            if (!options.suppressHiDPIScaling) {
                this._initializeHiDpi();
            }
            if (!this.canvasElementId) {
                document.body.appendChild(this.canvas);
            }
        };
        Engine.prototype._intializeDisplayModePosition = function (options) {
            if (!options.position) {
                throw new Error('DisplayMode of Position was selected but no position option was given');
            }
            else {
                this.canvas.style.display = 'block';
                this.canvas.style.position = 'absolute';
                if (typeof options.position === 'string') {
                    var specifiedPosition = options.position.split(' ');
                    switch (specifiedPosition[0]) {
                        case 'top':
                            this.canvas.style.top = '0px';
                            break;
                        case 'bottom':
                            this.canvas.style.bottom = '0px';
                            break;
                        case 'middle':
                            this.canvas.style.top = '50%';
                            var offsetY = -this.halfDrawHeight;
                            this.canvas.style.marginTop = offsetY.toString();
                            break;
                        default:
                            throw new Error('Invalid Position Given');
                    }
                    if (specifiedPosition[1]) {
                        switch (specifiedPosition[1]) {
                            case 'left':
                                this.canvas.style.left = '0px';
                                break;
                            case 'right':
                                this.canvas.style.right = '0px';
                                break;
                            case 'center':
                                this.canvas.style.left = '50%';
                                var offsetX = -this.halfDrawWidth;
                                this.canvas.style.marginLeft = offsetX.toString();
                                break;
                            default:
                                throw new Error('Invalid Position Given');
                        }
                    }
                }
                else {
                    if (options.position.top) {
                        typeof options.position.top === 'number' ?
                            this.canvas.style.top = options.position.top.toString() + 'px' :
                            this.canvas.style.top = options.position.top;
                    }
                    if (options.position.right) {
                        typeof options.position.right === 'number' ?
                            this.canvas.style.right = options.position.right.toString() + 'px' :
                            this.canvas.style.right = options.position.right;
                    }
                    if (options.position.bottom) {
                        typeof options.position.bottom === 'number' ?
                            this.canvas.style.bottom = options.position.bottom.toString() + 'px' :
                            this.canvas.style.bottom = options.position.bottom;
                    }
                    if (options.position.left) {
                        typeof options.position.left === 'number' ?
                            this.canvas.style.left = options.position.left.toString() + 'px' :
                            this.canvas.style.left = options.position.left;
                    }
                }
            }
        };
        Engine.prototype._initializeHiDpi = function () {
            // Scale the canvas if needed
            if (this.isHiDpi) {
                var oldWidth = this.canvas.width;
                var oldHeight = this.canvas.height;
                this.canvas.width = oldWidth * this.pixelRatio;
                this.canvas.height = oldHeight * this.pixelRatio;
                this.canvas.style.width = oldWidth + 'px';
                this.canvas.style.height = oldHeight + 'px';
                this._logger.warn("Hi DPI screen detected, resetting canvas resolution from \n                           " + oldWidth + "x" + oldHeight + " to " + this.canvas.width + "x" + this.canvas.height + " \n                           css size will remain " + oldWidth + "x" + oldHeight);
                this.ctx.scale(this.pixelRatio, this.pixelRatio);
                this._logger.warn("Canvas drawing context was scaled by " + this.pixelRatio);
            }
        };
        /**
         * If supported by the browser, this will set the antialiasing flag on the
         * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
         * image resources.
         * @param isSmooth  Set smoothing to true or false
         */
        Engine.prototype.setAntialiasing = function (isSmooth) {
            this._isSmoothingEnabled = isSmooth;
            var ctx = this.ctx;
            ctx.imageSmoothingEnabled = isSmooth;
            for (var _i = 0, _a = ['webkitImageSmoothingEnabled', 'mozImageSmoothingEnabled', 'msImageSmoothingEnabled']; _i < _a.length; _i++) {
                var smoothing = _a[_i];
                if (smoothing in ctx) {
                    ctx[smoothing] = isSmooth;
                }
            }
            ;
        };
        /**
         * Return the current smoothing status of the canvas
         */
        Engine.prototype.getAntialiasing = function () {
            return this.ctx.imageSmoothingEnabled ||
                this.ctx.webkitImageSmoothingEnabled ||
                this.ctx.mozImageSmoothingEnabled ||
                this.ctx.msImageSmoothingEnabled;
        };
        /**
         * Updates the entire state of the game
         * @param delta  Number of milliseconds elapsed since the last update.
         */
        Engine.prototype._update = function (delta) {
            if (this._isLoading) {
                // suspend updates untill loading is finished
                this._loader.update(this, delta);
                // Update input listeners
                this.input.keyboard.update();
                this.input.pointers.update();
                this.input.gamepads.update();
                return;
            }
            this.emit('preupdate', new Events_12.PreUpdateEvent(this, delta, this));
            // process engine level events
            this.currentScene.update(this, delta);
            // update animations
            this._animations = this._animations.filter(function (a) {
                return !a.animation.isDone();
            });
            // Update input listeners
            this.input.keyboard.update();
            this.input.pointers.update();
            this.input.gamepads.update();
            // Publish update event
            this.emit('postupdate', new Events_12.PostUpdateEvent(this, delta, this));
        };
        /**
         * Draws the entire game
         * @param delta  Number of milliseconds elapsed since the last draw.
         */
        Engine.prototype._draw = function (delta) {
            var ctx = this.ctx;
            this.emit('predraw', new Events_12.PreDrawEvent(ctx, delta, this));
            if (this._isLoading) {
                this._loader.draw(ctx, delta);
                // Drawing nothing else while loading
                return;
            }
            ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            ctx.fillStyle = this.backgroundColor.toString();
            ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            this.currentScene.draw(this.ctx, delta);
            // todo needs to be a better way of doing this
            var a = 0, len = this._animations.length;
            for (a; a < len; a++) {
                this._animations[a].animation.draw(ctx, this._animations[a].x, this._animations[a].y);
            }
            // Draw debug information
            if (this.isDebug) {
                this.ctx.font = 'Consolas';
                this.ctx.fillStyle = this.debugColor.toString();
                var keys = this.input.keyboard.getKeys();
                for (var j = 0; j < keys.length; j++) {
                    this.ctx.fillText(keys[j].toString() + ' : ' + (Input.Keys[keys[j]] ? Input.Keys[keys[j]] : 'Not Mapped'), 100, 10 * j + 10);
                }
                this.ctx.fillText('FPS:' + this.stats.currFrame.fps.toFixed(2).toString(), 10, 10);
            }
            // Post processing
            for (var i = 0; i < this.postProcessors.length; i++) {
                this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight), this.ctx);
            }
            this.emit('postdraw', new Events_12.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Starts the internal game loop for Excalibur after loading
         * any provided assets.
         * @param loader  Optional [[ILoader]] to use to load resources. The default loader is [[Loader]], override to provide your own
         * custom loader.
         */
        Engine.prototype.start = function (loader) {
            var _this = this;
            if (!this._compatible) {
                var promise = new Promises_8.Promise();
                return promise.reject('Excalibur is incompatible with your browser');
            }
            var loadingComplete;
            if (loader) {
                this._loader = loader;
                this._loader.wireEngine(this);
                loadingComplete = this.load(this._loader);
            }
            else {
                loadingComplete = Promises_8.Promise.resolve();
            }
            loadingComplete.then(function () {
                _this.emit('start', new Events_12.GameStartEvent(_this));
            });
            if (!this._hasStarted) {
                this._hasStarted = true;
                this._logger.debug('Starting game...');
                Engine.createMainLoop(this, window.requestAnimationFrame, Date.now)();
                this._logger.debug('Game started');
            }
            else {
                // Game already started;
            }
            return loadingComplete;
        };
        Engine.createMainLoop = function (game, raf, nowFn) {
            var lastTime = nowFn();
            return function mainloop() {
                if (!game._hasStarted) {
                    return;
                }
                try {
                    game._requestId = raf(mainloop);
                    game.emit('preframe', new Events_12.PreFrameEvent(game, game.stats.prevFrame));
                    // Get the time to calculate time-elapsed
                    var now = nowFn();
                    var elapsed = Math.floor(now - lastTime) || 1;
                    // Resolves issue #138 if the game has been paused, or blurred for 
                    // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability 
                    // and provides more expected behavior when the engine comes back
                    // into focus
                    if (elapsed > 200) {
                        elapsed = 1;
                    }
                    var delta = elapsed * game.timescale;
                    // reset frame stats (reuse existing instances)
                    var frameId = game.stats.prevFrame.id + 1;
                    game.stats.prevFrame.reset(game.stats.currFrame);
                    game.stats.currFrame.reset();
                    game.stats.currFrame.id = frameId;
                    game.stats.currFrame.delta = delta;
                    game.stats.currFrame.fps = 1.0 / (delta / 1000);
                    var beforeUpdate = nowFn();
                    game._update(delta);
                    var afterUpdate = nowFn();
                    game._draw(delta);
                    var afterDraw = nowFn();
                    game.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
                    game.stats.currFrame.duration.draw = afterDraw - afterUpdate;
                    lastTime = now;
                    game.emit('postframe', new Events_12.PostFrameEvent(game, game.stats.currFrame));
                }
                catch (e) {
                    window.cancelAnimationFrame(game._requestId);
                    game.stop();
                    game.onFatalException(e);
                }
            };
        };
        /**
         * Stops Excalibur's main loop, useful for pausing the game.
         */
        Engine.prototype.stop = function () {
            if (this._hasStarted) {
                this.emit('stop', new Events_12.GameStopEvent(this));
                this._hasStarted = false;
                this._logger.debug('Game stopped');
            }
        };
        /**
         * Returns the Engine's Running status, Useful for checking whether engine is running or paused.
         */
        Engine.prototype.isPaused = function () {
            return !(this._hasStarted);
        };
        /**
         * Takes a screen shot of the current viewport and returns it as an
         * HTML Image Element.
         */
        Engine.prototype.screenshot = function () {
            var result = new Image();
            var raw = this.canvas.toDataURL('image/png');
            result.src = raw;
            return result;
        };
        /**
         * Another option available to you to load resources into the game.
         * Immediately after calling this the game will pause and the loading screen
         * will appear.
         * @param loader  Some [[ILoadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
         */
        Engine.prototype.load = function (loader) {
            var _this = this;
            var complete = new Promises_8.Promise();
            this._isLoading = true;
            loader.load().then(function () {
                setTimeout(function () {
                    _this._isLoading = false;
                    complete.resolve();
                }, 500);
            });
            return complete;
        };
        return Engine;
    }(Class_9.Class));
    /**
     * Default [[IEngineOptions]]
     */
    Engine._DefaultEngineOptions = {
        width: 0,
        height: 0,
        canvasElementId: '',
        pointerScope: Input.PointerScope.Document,
        suppressConsoleBootMessage: null,
        suppressMinimumBrowserFeatureDetection: null,
        suppressHiDPIScaling: null,
        scrollPreventionMode: ScrollPreventionMode.Canvas,
        backgroundColor: Color_19.Color.fromHex('#2185d0') // Excalibur blue
    };
    exports.Engine = Engine;
    /**
     * @internal
     */
    var AnimationNode = (function () {
        function AnimationNode(animation, x, y) {
            this.animation = animation;
            this.x = x;
            this.y = y;
        }
        return AnimationNode;
    }());
});
define("UIActor", ["require", "exports", "Algebra", "Actor", "Traits/Index"], function (require, exports, Algebra_23, Actor_13, Traits) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does
     * not participate in collisions. Drawn on top of all other actors.
     */
    var UIActor = (function (_super) {
        __extends(UIActor, _super);
        /**
         * @param x       The starting x coordinate of the actor
         * @param y       The starting y coordinate of the actor
         * @param width   The starting width of the actor
         * @param height  The starting height of the actor
         */
        function UIActor(x, y, width, height) {
            var _this = _super.call(this, x, y, width, height) || this;
            _this.traits = [];
            _this.traits.push(new Traits.CapturePointer());
            _this.anchor.setTo(0, 0);
            _this.collisionType = Actor_13.CollisionType.PreventCollision;
            _this.enableCapturePointer = true;
            return _this;
        }
        UIActor.prototype.onInitialize = function (engine) {
            this._engine = engine;
        };
        UIActor.prototype.contains = function (x, y, useWorld) {
            if (useWorld === void 0) { useWorld = true; }
            if (useWorld) {
                return _super.prototype.contains.call(this, x, y);
            }
            var coords = this._engine.worldToScreenCoordinates(new Algebra_23.Vector(x, y));
            return _super.prototype.contains.call(this, coords.x, coords.y);
        };
        return UIActor;
    }(Actor_13.Actor));
    exports.UIActor = UIActor;
});
define("Util/Actors", ["require", "exports", "UIActor", "Label", "Trigger"], function (require, exports, UIActor_4, Label_3, Trigger_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isVanillaActor(actor) {
        return !(actor instanceof UIActor_4.UIActor) &&
            !(actor instanceof Trigger_2.Trigger) &&
            !(actor instanceof Label_3.Label);
    }
    exports.isVanillaActor = isVanillaActor;
    function isUIActor(actor) {
        return actor instanceof UIActor_4.UIActor;
    }
    exports.isUIActor = isUIActor;
});
define("Scene", ["require", "exports", "UIActor", "Physics", "Events", "Util/Log", "Timer", "Collision/DynamicTreeCollisionBroadphase", "Util/SortedList", "Group", "TileMap", "Camera", "Actor", "Class", "Util/Util", "Util/Actors", "Trigger"], function (require, exports, UIActor_5, Physics_12, Events_13, Log_15, Timer_3, DynamicTreeCollisionBroadphase_2, SortedList_2, Group_2, TileMap_3, Camera_2, Actor_14, Class_10, Util, ActorUtils, Trigger_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * [[Actor|Actors]] are composed together into groupings called Scenes in
     * Excalibur. The metaphor models the same idea behind real world
     * actors in a scene. Only actors in scenes will be updated and drawn.
     *
     * Typical usages of a scene include: levels, menus, loading screens, etc.
     *
     * [[include:Scenes.md]]
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene(engine) {
            var _this = _super.call(this) || this;
            /**
             * The actors in the current scene
             */
            _this.actors = [];
            /**
             * The triggers in the current scene
             */
            _this.triggers = [];
            /**
             * The [[TileMap]]s in the scene, if any
             */
            _this.tileMaps = [];
            /**
             * The [[Group]]s in the scene, if any
             */
            _this.groups = {};
            /**
             * The [[UIActor]]s in a scene, if any; these are drawn last
             */
            _this.uiActors = [];
            _this._isInitialized = false;
            _this._sortedDrawingTree = new SortedList_2.SortedList(Actor_14.Actor.prototype.getZIndex);
            _this._broadphase = new DynamicTreeCollisionBroadphase_2.DynamicTreeCollisionBroadphase();
            _this._killQueue = [];
            _this._triggerKillQueue = [];
            _this._timers = [];
            _this._cancelQueue = [];
            _this._logger = Log_15.Logger.getInstance();
            _this.camera = new Camera_2.BaseCamera();
            if (engine) {
                _this.camera.x = engine.halfDrawWidth;
                _this.camera.y = engine.halfDrawHeight;
            }
            return _this;
        }
        Scene.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         */
        Scene.prototype.onInitialize = function (engine) {
            // will be overridden
            if (this.camera) {
                this.camera.x = engine.halfDrawWidth;
                this.camera.y = engine.halfDrawHeight;
            }
            this._logger.debug('Scene.onInitialize', this, engine);
        };
        /**
         * This is called when the scene is made active and started. It is meant to be overriden,
         * this is where you should setup any DOM UI or event handlers needed for the scene.
         */
        Scene.prototype.onActivate = function () {
            // will be overridden
            this._logger.debug('Scene.onActivate', this);
        };
        /**
         * This is called when the scene is made transitioned away from and stopped. It is meant to be overriden,
         * this is where you should cleanup any DOM UI or event handlers needed for the scene.
         */
        Scene.prototype.onDeactivate = function () {
            // will be overridden
            this._logger.debug('Scene.onDeactivate', this);
        };
        /**
         * Initializes actors in the scene
         */
        Scene.prototype._initializeChildren = function () {
            for (var _i = 0, _a = this.actors; _i < _a.length; _i++) {
                var child = _a[_i];
                child._initialize(this.engine);
            }
        };
        Object.defineProperty(Scene.prototype, "isInitialized", {
            /**
             * Gets whether or not the [[Scene]] has been initialized
             */
            get: function () {
                return this._isInitialized;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes the scene before the first update, meant to be called by engine not by users of
         * Excalibur
         * @internal
         */
        Scene.prototype._initialize = function (engine) {
            if (!this.isInitialized) {
                this.onInitialize.call(this, engine);
                this.eventDispatcher.emit('initialize', new Events_13.InitializeEvent(engine, this));
                this._initializeChildren();
                this._isInitialized = true;
            }
        };
        /**
         * Updates all the actors and timers in the scene. Called by the [[Engine]].
         * @param engine  Reference to the current Engine
         * @param delta   The number of milliseconds since the last update
         */
        Scene.prototype.update = function (engine, delta) {
            this.emit('preupdate', new Events_13.PreUpdateEvent(engine, delta, this));
            var i, len;
            // Remove timers in the cancel queue before updating them
            for (i = 0, len = this._cancelQueue.length; i < len; i++) {
                this.removeTimer(this._cancelQueue[i]);
            }
            this._cancelQueue.length = 0;
            // Cycle through timers updating timers
            for (var _i = 0, _a = this._timers; _i < _a.length; _i++) {
                var timer = _a[_i];
                timer.update(delta);
            }
            ;
            // Cycle through actors updating UI actors
            for (i = 0, len = this.uiActors.length; i < len; i++) {
                this.uiActors[i].update(engine, delta);
            }
            // Cycle through actors updating tile maps
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].update(engine, delta);
            }
            // Cycle through actors updating actors
            for (i = 0, len = this.actors.length; i < len; i++) {
                this.actors[i].update(engine, delta);
            }
            // Cycle through triggers updating
            for (i = 0, len = this.triggers.length; i < len; i++) {
                this.triggers[i].update(engine, delta);
            }
            this._collectActorStats(engine);
            // Run the broadphase and narrowphase
            if (this._broadphase && Physics_12.Physics.enabled) {
                var beforeBroadphase = Date.now();
                this._broadphase.update(this.actors, delta);
                var pairs = this._broadphase.broadphase(this.actors, delta, engine.stats.currFrame);
                var afterBroadphase = Date.now();
                var beforeNarrowphase = Date.now();
                var iter = Physics_12.Physics.collisionPasses;
                var collisionDelta = delta / iter;
                while (iter > 0) {
                    // Run the narrowphase
                    pairs = this._broadphase.narrowphase(pairs, engine.stats.currFrame);
                    // Run collision resolution strategy
                    pairs = this._broadphase.resolve(pairs, collisionDelta, Physics_12.Physics.collisionResolutionStrategy);
                    this._broadphase.runCollisionStartEnd(pairs);
                    iter--;
                }
                var afterNarrowphase = Date.now();
                engine.stats.currFrame.physics.broadphase = afterBroadphase - beforeBroadphase;
                engine.stats.currFrame.physics.narrowphase = afterNarrowphase - beforeNarrowphase;
            }
            engine.stats.currFrame.actors.killed = this._killQueue.length + this._triggerKillQueue.length;
            this._processKillQueue(this._killQueue, this.actors);
            this._processKillQueue(this._triggerKillQueue, this.triggers);
            if (this.camera) {
                this.camera.update(engine, delta);
            }
            this.emit('postupdate', new Events_13.PostUpdateEvent(engine, delta, this));
        };
        Scene.prototype._processKillQueue = function (killQueue, collection) {
            // Remove actors from scene graph after being killed
            var actorIndex;
            for (var _i = 0, killQueue_1 = killQueue; _i < killQueue_1.length; _i++) {
                var killed = killQueue_1[_i];
                actorIndex = collection.indexOf(killed);
                if (actorIndex > -1) {
                    this._sortedDrawingTree.removeByComparable(killed);
                    collection.splice(actorIndex, 1);
                }
            }
            killQueue.length = 0;
        };
        /**
         * Draws all the actors in the Scene. Called by the [[Engine]].
         * @param ctx    The current rendering context
         * @param delta  The number of milliseconds since the last draw
         */
        Scene.prototype.draw = function (ctx, delta) {
            this.emit('predraw', new Events_13.PreDrawEvent(ctx, delta, this));
            ctx.save();
            if (this.camera) {
                this.camera.draw(ctx);
            }
            var i, len;
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].draw(ctx, delta);
            }
            var sortedChildren = this._sortedDrawingTree.list();
            for (i = 0, len = sortedChildren.length; i < len; i++) {
                // only draw actors that are visible and on screen
                if (sortedChildren[i].visible && !sortedChildren[i].isOffScreen) {
                    sortedChildren[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                ctx.strokeStyle = 'yellow';
                this.debugDraw(ctx);
            }
            ctx.restore();
            for (i = 0, len = this.uiActors.length; i < len; i++) {
                // only draw ui actors that are visible and on screen
                if (this.uiActors[i].visible) {
                    this.uiActors[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                for (i = 0, len = this.uiActors.length; i < len; i++) {
                    this.uiActors[i].debugDraw(ctx);
                }
            }
            this.emit('postdraw', new Events_13.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
         * @param ctx  The current rendering context
         */
        /* istanbul ignore next */
        Scene.prototype.debugDraw = function (ctx) {
            this.emit('predebugdraw', new Events_13.PreDebugDrawEvent(ctx, this));
            var i, len;
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].debugDraw(ctx);
            }
            for (i = 0, len = this.actors.length; i < len; i++) {
                this.actors[i].debugDraw(ctx);
            }
            for (i = 0, len = this.triggers.length; i < len; i++) {
                this.triggers[i].debugDraw(ctx);
            }
            this._broadphase.debugDraw(ctx, 20);
            this.camera.debugDraw(ctx);
            this.emit('postdebugdraw', new Events_13.PostDebugDrawEvent(ctx, this));
        };
        /**
         * Checks whether an actor is contained in this scene or not
         */
        Scene.prototype.contains = function (actor) {
            return this.actors.indexOf(actor) > -1;
        };
        Scene.prototype.add = function (entity) {
            if (entity instanceof Actor_14.Actor) {
                entity.unkill();
            }
            if (entity instanceof UIActor_5.UIActor) {
                if (!Util.contains(this.uiActors, entity)) {
                    this.addUIActor(entity);
                }
                return;
            }
            if (entity instanceof Actor_14.Actor) {
                if (!Util.contains(this.actors, entity)) {
                    this._addChild(entity);
                }
                return;
            }
            if (entity instanceof Timer_3.Timer) {
                if (!Util.contains(this._timers, entity)) {
                    this.addTimer(entity);
                }
                return;
            }
            if (entity instanceof TileMap_3.TileMap) {
                if (!Util.contains(this.tileMaps, entity)) {
                    this.addTileMap(entity);
                }
            }
        };
        Scene.prototype.remove = function (entity) {
            if (entity instanceof UIActor_5.UIActor) {
                this.removeUIActor(entity);
                return;
            }
            if (entity instanceof Actor_14.Actor) {
                this._broadphase.untrack(entity.body);
                this._removeChild(entity);
            }
            if (entity instanceof Timer_3.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof TileMap_3.TileMap) {
                this.removeTileMap(entity);
            }
        };
        /**
         * Adds (any) actor to act as a piece of UI, meaning it is always positioned
         * in screen coordinates. UI actors do not participate in collisions.
         * @todo Should this be `UIActor` only?
         */
        Scene.prototype.addUIActor = function (actor) {
            this.uiActors.push(actor);
            actor.scene = this;
        };
        /**
         * Removes an actor as a piece of UI
         */
        Scene.prototype.removeUIActor = function (actor) {
            var index = this.uiActors.indexOf(actor);
            if (index > -1) {
                this.uiActors.splice(index, 1);
            }
        };
        /**
         * Adds an actor to the scene, once this is done the actor will be drawn and updated.
         */
        Scene.prototype._addChild = function (actor) {
            this._broadphase.track(actor.body);
            actor.scene = this;
            if (actor instanceof Trigger_3.Trigger) {
                this.triggers.push(actor);
            }
            else {
                this.actors.push(actor);
            }
            this._sortedDrawingTree.add(actor);
        };
        /**
         * Adds a [[TileMap]] to the scene, once this is done the TileMap will be drawn and updated.
         */
        Scene.prototype.addTileMap = function (tileMap) {
            this.tileMaps.push(tileMap);
        };
        /**
         * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.
         */
        Scene.prototype.removeTileMap = function (tileMap) {
            var index = this.tileMaps.indexOf(tileMap);
            if (index > -1) {
                this.tileMaps.splice(index, 1);
            }
        };
        /**
         * Removes an actor from the scene, it will no longer be drawn or updated.
         */
        Scene.prototype._removeChild = function (actor) {
            this._broadphase.untrack(actor.body);
            if (actor instanceof Trigger_3.Trigger) {
                this._triggerKillQueue.push(actor);
            }
            else {
                this._killQueue.push(actor);
            }
            actor.parent = null;
        };
        /**
         * Adds a [[Timer]] to the scene
         * @param timer  The timer to add
         */
        Scene.prototype.addTimer = function (timer) {
            this._timers.push(timer);
            timer.scene = this;
            return timer;
        };
        /**
         * Removes a [[Timer]] from the scene.
         * @warning Can be dangerous, use [[cancelTimer]] instead
         * @param timer  The timer to remove
         */
        Scene.prototype.removeTimer = function (timer) {
            var i = this._timers.indexOf(timer);
            if (i !== -1) {
                this._timers.splice(i, 1);
            }
            return timer;
        };
        /**
         * Cancels a [[Timer]], removing it from the scene nicely
         * @param timer  The timer to cancel
         */
        Scene.prototype.cancelTimer = function (timer) {
            this._cancelQueue.push(timer);
            return timer;
        };
        /**
         * Tests whether a [[Timer]] is active in the scene
         */
        Scene.prototype.isTimerActive = function (timer) {
            return (this._timers.indexOf(timer) > -1 && !timer.complete);
        };
        /**
         * Creates and adds a [[Group]] to the scene with a name
         */
        Scene.prototype.createGroup = function (name) {
            return new Group_2.Group(name, this);
        };
        /**
         * Returns a [[Group]] by name
         */
        Scene.prototype.getGroup = function (name) {
            return this.groups[name];
        };
        Scene.prototype.removeGroup = function (group) {
            if (typeof group === 'string') {
                delete this.groups[group];
            }
            else if (group instanceof Group_2.Group) {
                delete this.groups[group.name];
            }
            else {
                this._logger.error('Invalid arguments to removeGroup', group);
            }
        };
        /**
         * Removes the given actor from the sorted drawing tree
         */
        Scene.prototype.cleanupDrawTree = function (actor) {
            this._sortedDrawingTree.removeByComparable(actor);
        };
        /**
         * Updates the given actor's position in the sorted drawing tree
         */
        Scene.prototype.updateDrawTree = function (actor) {
            this._sortedDrawingTree.add(actor);
        };
        Scene.prototype._collectActorStats = function (engine) {
            for (var _i = 0, _a = this.uiActors; _i < _a.length; _i++) {
                var _ui = _a[_i];
                engine.stats.currFrame.actors.ui++;
            }
            for (var _b = 0, _c = this.actors; _b < _c.length; _b++) {
                var actor = _c[_b];
                engine.stats.currFrame.actors.alive++;
                for (var _d = 0, _e = actor.children; _d < _e.length; _d++) {
                    var child = _e[_d];
                    if (ActorUtils.isUIActor(child)) {
                        engine.stats.currFrame.actors.ui++;
                    }
                    else {
                        engine.stats.currFrame.actors.alive++;
                    }
                }
            }
        };
        return Scene;
    }(Class_10.Class));
    exports.Scene = Scene;
});
define("Events", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
     * some events are unique to a type, others are not.
     *
     */
    var GameEvent = (function () {
        function GameEvent() {
        }
        return GameEvent;
    }());
    exports.GameEvent = GameEvent;
    /**
     * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
     */
    var KillEvent = (function (_super) {
        __extends(KillEvent, _super);
        function KillEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return KillEvent;
    }(GameEvent));
    exports.KillEvent = KillEvent;
    /**
     * The 'start' event is emitted on engine when has started and is ready for interaction.
     */
    var GameStartEvent = (function (_super) {
        __extends(GameStartEvent, _super);
        function GameStartEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return GameStartEvent;
    }(GameEvent));
    exports.GameStartEvent = GameStartEvent;
    /**
     * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
     */
    var GameStopEvent = (function (_super) {
        __extends(GameStopEvent, _super);
        function GameStopEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return GameStopEvent;
    }(GameEvent));
    exports.GameStopEvent = GameStopEvent;
    /**
     * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
     * transform so that all drawing takes place with the actor as the origin.
     *
     */
    var PreDrawEvent = (function (_super) {
        __extends(PreDrawEvent, _super);
        function PreDrawEvent(ctx, delta, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PreDrawEvent;
    }(GameEvent));
    exports.PreDrawEvent = PreDrawEvent;
    /**
     * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
     * transform so that all drawing takes place with the actor as the origin.
     *
     */
    var PostDrawEvent = (function (_super) {
        __extends(PostDrawEvent, _super);
        function PostDrawEvent(ctx, delta, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PostDrawEvent;
    }(GameEvent));
    exports.PostDrawEvent = PostDrawEvent;
    /**
     * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
     */
    var PreDebugDrawEvent = (function (_super) {
        __extends(PreDebugDrawEvent, _super);
        function PreDebugDrawEvent(ctx, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.target = target;
            return _this;
        }
        return PreDebugDrawEvent;
    }(GameEvent));
    exports.PreDebugDrawEvent = PreDebugDrawEvent;
    /**
     * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
     */
    var PostDebugDrawEvent = (function (_super) {
        __extends(PostDebugDrawEvent, _super);
        function PostDebugDrawEvent(ctx, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.target = target;
            return _this;
        }
        return PostDebugDrawEvent;
    }(GameEvent));
    exports.PostDebugDrawEvent = PostDebugDrawEvent;
    /**
     * The 'preupdate' event is emitted on actors, scenes, and engine before the update starts.
     */
    var PreUpdateEvent = (function (_super) {
        __extends(PreUpdateEvent, _super);
        function PreUpdateEvent(engine, delta, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PreUpdateEvent;
    }(GameEvent));
    exports.PreUpdateEvent = PreUpdateEvent;
    /**
     * The 'postupdate' event is emitted on actors, scenes, and engine after the update ends.
     */
    var PostUpdateEvent = (function (_super) {
        __extends(PostUpdateEvent, _super);
        function PostUpdateEvent(engine, delta, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PostUpdateEvent;
    }(GameEvent));
    exports.PostUpdateEvent = PostUpdateEvent;
    /**
     * The 'preframe' event is emitted on the engine, before the frame begins.
     */
    var PreFrameEvent = (function (_super) {
        __extends(PreFrameEvent, _super);
        function PreFrameEvent(engine, prevStats) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.prevStats = prevStats;
            _this.target = engine;
            return _this;
        }
        return PreFrameEvent;
    }(GameEvent));
    exports.PreFrameEvent = PreFrameEvent;
    /**
     * The 'postframe' event is emitted on the engine, after a frame ends.
     */
    var PostFrameEvent = (function (_super) {
        __extends(PostFrameEvent, _super);
        function PostFrameEvent(engine, stats) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.stats = stats;
            _this.target = engine;
            return _this;
        }
        return PostFrameEvent;
    }(GameEvent));
    exports.PostFrameEvent = PostFrameEvent;
    /**
     * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.
     */
    var GamepadConnectEvent = (function (_super) {
        __extends(GamepadConnectEvent, _super);
        function GamepadConnectEvent(index, gamepad) {
            var _this = _super.call(this) || this;
            _this.index = index;
            _this.gamepad = gamepad;
            _this.target = gamepad;
            return _this;
        }
        return GamepadConnectEvent;
    }(GameEvent));
    exports.GamepadConnectEvent = GamepadConnectEvent;
    /**
     * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.
     */
    var GamepadDisconnectEvent = (function (_super) {
        __extends(GamepadDisconnectEvent, _super);
        function GamepadDisconnectEvent(index, gamepad) {
            var _this = _super.call(this) || this;
            _this.index = index;
            _this.gamepad = gamepad;
            _this.target = gamepad;
            return _this;
        }
        return GamepadDisconnectEvent;
    }(GameEvent));
    exports.GamepadDisconnectEvent = GamepadDisconnectEvent;
    /**
     * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
     */
    var GamepadButtonEvent = (function (_super) {
        __extends(GamepadButtonEvent, _super);
        /**
         * @param button  The Gamepad button
         * @param value   A numeric value between 0 and 1
         */
        function GamepadButtonEvent(button, value, target) {
            var _this = _super.call(this) || this;
            _this.button = button;
            _this.value = value;
            _this.target = target;
            return _this;
        }
        return GamepadButtonEvent;
    }(GameEvent));
    exports.GamepadButtonEvent = GamepadButtonEvent;
    /**
     * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
     */
    var GamepadAxisEvent = (function (_super) {
        __extends(GamepadAxisEvent, _super);
        /**
         * @param axis  The Gamepad axis
         * @param value A numeric value between -1 and 1
         */
        function GamepadAxisEvent(axis, value, target) {
            var _this = _super.call(this) || this;
            _this.axis = axis;
            _this.value = value;
            _this.target = target;
            return _this;
        }
        return GamepadAxisEvent;
    }(GameEvent));
    exports.GamepadAxisEvent = GamepadAxisEvent;
    /**
     * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by
     * [[EventDispatcher|event dispatchers]].
     */
    var SubscribeEvent = (function (_super) {
        __extends(SubscribeEvent, _super);
        function SubscribeEvent(topic, handler) {
            var _this = _super.call(this) || this;
            _this.topic = topic;
            _this.handler = handler;
            return _this;
        }
        return SubscribeEvent;
    }(GameEvent));
    exports.SubscribeEvent = SubscribeEvent;
    /**
     * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by
     * [[EventDispatcher|event dispatchers]].
     */
    var UnsubscribeEvent = (function (_super) {
        __extends(UnsubscribeEvent, _super);
        function UnsubscribeEvent(topic, handler) {
            var _this = _super.call(this) || this;
            _this.topic = topic;
            _this.handler = handler;
            return _this;
        }
        return UnsubscribeEvent;
    }(GameEvent));
    exports.UnsubscribeEvent = UnsubscribeEvent;
    /**
     * Event received by the [[Engine]] when the browser window is visible on a screen.
     */
    var VisibleEvent = (function (_super) {
        __extends(VisibleEvent, _super);
        function VisibleEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return VisibleEvent;
    }(GameEvent));
    exports.VisibleEvent = VisibleEvent;
    /**
     * Event received by the [[Engine]] when the browser window is hidden from all screens.
     */
    var HiddenEvent = (function (_super) {
        __extends(HiddenEvent, _super);
        function HiddenEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return HiddenEvent;
    }(GameEvent));
    exports.HiddenEvent = HiddenEvent;
    /**
     * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves
     */
    var PreCollisionEvent = (function (_super) {
        __extends(PreCollisionEvent, _super);
        /**
         * @param actor         The actor the event was thrown on
         * @param other         The actor that will collided with the current actor
         * @param side          The side that will be collided with the current actor
         * @param intersection  Intersection vector
         */
        function PreCollisionEvent(actor, other, side, intersection) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.side = side;
            _this.intersection = intersection;
            _this.target = actor;
            return _this;
        }
        return PreCollisionEvent;
    }(GameEvent));
    exports.PreCollisionEvent = PreCollisionEvent;
    /**
     * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame
     */
    var PostCollisionEvent = (function (_super) {
        __extends(PostCollisionEvent, _super);
        /**
         * @param actor         The actor the event was thrown on
         * @param other         The actor that did collide with the current actor
         * @param side          The side that did collide with the current actor
         * @param intersection  Intersection vector
         */
        function PostCollisionEvent(actor, other, side, intersection) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.side = side;
            _this.intersection = intersection;
            _this.target = actor;
            return _this;
        }
        return PostCollisionEvent;
    }(GameEvent));
    exports.PostCollisionEvent = PostCollisionEvent;
    /**
     * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.
     */
    var CollisionStartEvent = (function (_super) {
        __extends(CollisionStartEvent, _super);
        /**
         *
         */
        function CollisionStartEvent(actor, other, pair) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.pair = pair;
            _this.target = actor;
            return _this;
        }
        return CollisionStartEvent;
    }(GameEvent));
    exports.CollisionStartEvent = CollisionStartEvent;
    /**
     * Event thrown when the [[Actor|actor]] is no longer colliding with another
     */
    var CollisionEndEvent = (function (_super) {
        __extends(CollisionEndEvent, _super);
        /**
         *
         */
        function CollisionEndEvent(actor, other) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.target = actor;
            return _this;
        }
        return CollisionEndEvent;
    }(GameEvent));
    exports.CollisionEndEvent = CollisionEndEvent;
    /**
     * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call
     */
    var InitializeEvent = (function (_super) {
        __extends(InitializeEvent, _super);
        /**
         * @param engine  The reference to the current engine
         */
        function InitializeEvent(engine, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.target = target;
            return _this;
        }
        return InitializeEvent;
    }(GameEvent));
    exports.InitializeEvent = InitializeEvent;
    /**
     * Event thrown on a [[Scene]] on activation
     */
    var ActivateEvent = (function (_super) {
        __extends(ActivateEvent, _super);
        /**
         * @param oldScene  The reference to the old scene
         */
        function ActivateEvent(oldScene, target) {
            var _this = _super.call(this) || this;
            _this.oldScene = oldScene;
            _this.target = target;
            return _this;
        }
        return ActivateEvent;
    }(GameEvent));
    exports.ActivateEvent = ActivateEvent;
    /**
     * Event thrown on a [[Scene]] on deactivation
     */
    var DeactivateEvent = (function (_super) {
        __extends(DeactivateEvent, _super);
        /**
         * @param newScene  The reference to the new scene
         */
        function DeactivateEvent(newScene, target) {
            var _this = _super.call(this) || this;
            _this.newScene = newScene;
            _this.target = target;
            return _this;
        }
        return DeactivateEvent;
    }(GameEvent));
    exports.DeactivateEvent = DeactivateEvent;
    /**
     * Event thrown on an [[Actor]] when it completely leaves the screen.
     */
    var ExitViewPortEvent = (function (_super) {
        __extends(ExitViewPortEvent, _super);
        function ExitViewPortEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return ExitViewPortEvent;
    }(GameEvent));
    exports.ExitViewPortEvent = ExitViewPortEvent;
    /**
     * Event thrown on an [[Actor]] when it completely leaves the screen.
     */
    var EnterViewPortEvent = (function (_super) {
        __extends(EnterViewPortEvent, _super);
        function EnterViewPortEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return EnterViewPortEvent;
    }(GameEvent));
    exports.EnterViewPortEvent = EnterViewPortEvent;
    var EnterTriggerEvent = (function (_super) {
        __extends(EnterTriggerEvent, _super);
        function EnterTriggerEvent(target, actor) {
            var _this = _super.call(this) || this;
            _this.target = target;
            _this.actor = actor;
            return _this;
        }
        return EnterTriggerEvent;
    }(GameEvent));
    exports.EnterTriggerEvent = EnterTriggerEvent;
    var ExitTriggerEvent = (function (_super) {
        __extends(ExitTriggerEvent, _super);
        function ExitTriggerEvent(target, actor) {
            var _this = _super.call(this) || this;
            _this.target = target;
            _this.actor = actor;
            return _this;
        }
        return ExitTriggerEvent;
    }(GameEvent));
    exports.ExitTriggerEvent = ExitTriggerEvent;
});
define("Class", ["require", "exports", "EventDispatcher"], function (require, exports, EventDispatcher_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur base class that provides basic functionality such as [[EventDispatcher]]
     * and extending abilities for vanilla Javascript projects
     */
    var Class = (function () {
        function Class() {
            this.eventDispatcher = new EventDispatcher_3.EventDispatcher(this);
        }
        /**
         * Alias for `addEventListener`. You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @param eventName  Name of the event to listen for
         * @param handler    Event handler for the thrown event
         */
        Class.prototype.on = function (eventName, handler) {
            this.eventDispatcher.on(eventName, handler);
        };
        /**
         * Alias for `removeEventListener`. If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified only that handler will be removed.
         *
         * @param eventName  Name of the event to listen for
         * @param handler    Event handler for the thrown event
         */
        Class.prototype.off = function (eventName, handler) {
            this.eventDispatcher.off(eventName, handler);
        };
        /**
         * Emits a new event
         * @param eventName   Name of the event to emit
         * @param eventObject Data associated with this event
         */
        Class.prototype.emit = function (eventName, eventObject) {
            this.eventDispatcher.emit(eventName, eventObject);
        };
        /**
         * Once listens to an event one time, then unsubscribes from that event
         *
         * @param eventName The name of the event to subscribe to once
         * @param handler   The handler of the event that will be auto unsubscribed
         */
        Class.prototype.once = function (eventName, handler) {
            this.eventDispatcher.once(eventName, handler);
        };
        /**
         * You may wish to extend native Excalibur functionality in vanilla Javascript.
         * Any method on a class inheriting [[Class]] may be extended to support
         * additional functionality. In the example below we create a new type called `MyActor`.
         *
         *
         * ```js
         * var MyActor = Actor.extend({
         *
         *    constructor: function() {
         *       this.newprop = 'something';
         *       Actor.apply(this, arguments);
         *    },
         *
         *    update: function(engine, delta) {
         *       // Implement custom update
         *       // Call super constructor update
         *       Actor.prototype.update.call(this, engine, delta);
         *
         *       console.log("Something cool!");
         *    }
         * });
         *
         * var myActor = new MyActor(100, 100, 100, 100, Color.Azure);
         * ```
         *
         * In TypeScript, you only need to use the `extends` syntax, you do not need
         * to use this method of extension.
         *
         * @param methods A JSON object contain any methods/properties you want to extend
         */
        Class.extend = function (methods) {
            var parent = this;
            var child;
            if (methods && methods.hasOwnProperty('constructor')) {
                child = methods.constructor;
            }
            else {
                child = function () { return parent.apply(this, arguments); };
            }
            // Using constructor allows JS to lazily instantiate super classes
            var Super = function () { this.constructor = child; };
            Super.prototype = parent.prototype;
            child.prototype = new Super;
            if (methods) {
                for (var prop in methods) {
                    if (methods.hasOwnProperty(prop)) {
                        child.prototype[prop] = methods[prop];
                    }
                }
            }
            // Make subclasses extendable
            child.extend = Class.extend;
            return child;
        };
        return Class;
    }());
    exports.Class = Class;
});
define("Actor", ["require", "exports", "Physics", "Class", "Collision/BoundingBox", "Resources/Texture", "Events", "Drawing/Color", "Drawing/Sprite", "Util/Log", "Actions/ActionContext", "Actions/Action", "Algebra", "Collision/Body", "Collision/Side", "Traits/Index", "Drawing/SpriteEffects", "Util/Util"], function (require, exports, Physics_13, Class_11, BoundingBox_8, Texture_2, Events_14, Color_20, Sprite_4, Log_16, ActionContext_3, Action_2, Algebra_24, Body_2, Side_4, Traits, Effects, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The most important primitive in Excalibur is an `Actor`. Anything that
     * can move on the screen, collide with another `Actor`, respond to events,
     * or interact with the current scene, must be an actor. An `Actor` **must**
     * be part of a [[Scene]] for it to be drawn to the screen.
     *
     * [[include:Actors.md]]
     *
     */
    var Actor = (function (_super) {
        __extends(Actor, _super);
        /**
         * @param x       The starting x coordinate of the actor
         * @param y       The starting y coordinate of the actor
         * @param width   The starting width of the actor
         * @param height  The starting height of the actor
         * @param color   The starting color of the actor. Leave null to draw a transparent actor. The opacity of the color will be used as the
         * initial [[opacity]].
         */
        function Actor(x, y, width, height, color) {
            var _this = _super.call(this) || this;
            /**
             * The unique identifier for the actor
             */
            _this.id = Actor.maxId++;
            /**
             * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
             * acceleration, mass, inertia, etc.
             */
            _this.body = new Body_2.Body(_this);
            _this._height = 0;
            _this._width = 0;
            /**
             * The scale vector of the actor
             */
            _this.scale = new Algebra_24.Vector(1, 1);
            /**
             * The x scalar velocity of the actor in scale/second
             */
            _this.sx = 0; //scale/sec
            /**
             * The y scalar velocity of the actor in scale/second
             */
            _this.sy = 0; //scale/sec
            /**
             * Indicates whether the actor is physically in the viewport
             */
            _this.isOffScreen = false;
            /**
             * The visibility of an actor
             */
            _this.visible = true;
            /**
             * The opacity of an actor. Passing in a color in the [[constructor]] will use the
             * color's opacity.
             */
            _this.opacity = 1;
            _this.previousOpacity = 1;
            /**
             * Convenience reference to the global logger
             */
            _this.logger = Log_16.Logger.getInstance();
            /**
             * The scene that the actor is in
             */
            _this.scene = null;
            /**
             * The parent of this actor
             */
            _this.parent = null;
            // TODO: Replace this with the new actor collection once z-indexing is built
            /**
             * The children of this actor
             */
            _this.children = [];
            /**
             * Gets or sets the current collision type of this actor. By
             * default it is ([[CollisionType.PreventCollision]]).
             */
            _this.collisionType = CollisionType.PreventCollision;
            _this.collisionGroups = [];
            _this._collisionHandlers = {};
            _this._isInitialized = false;
            _this.frames = {};
            _this._effectsDirty = false;
            /**
             * Access to the current drawing for the actor, this can be
             * an [[Animation]], [[Sprite]], or [[Polygon]].
             * Set drawings with [[setDrawing]].
             */
            _this.currentDrawing = null;
            /**
             * Modify the current actor update pipeline.
             */
            _this.traits = [];
            /**
             * Whether or not to enable the [[CapturePointer]] trait that propagates
             * pointer events to this actor
             */
            _this.enableCapturePointer = false;
            /**
             * Configuration for [[CapturePointer]] trait
             */
            _this.capturePointer = {
                captureMoveEvents: false
            };
            _this._zIndex = 0;
            _this._isKilled = false;
            _this._opacityFx = new Effects.Opacity(_this.opacity);
            _this.pos.x = x || 0;
            _this.pos.y = y || 0;
            _this._width = width || 0;
            _this._height = height || 0;
            if (color) {
                _this.color = color;
                // set default opacity of an actor to the color
                _this.opacity = color.a;
            }
            // Build default pipeline
            //this.traits.push(new ex.Traits.EulerMovement());
            // TODO: TileMaps should be converted to a collision area
            _this.traits.push(new Traits.TileMapCollisionDetection());
            _this.traits.push(new Traits.OffscreenCulling());
            _this.traits.push(new Traits.CapturePointer());
            // Build the action queue
            _this.actionQueue = new Action_2.ActionQueue(_this);
            _this.actions = new ActionContext_3.ActionContext(_this);
            // default anchor is in the middle
            _this.anchor = new Algebra_24.Vector(.5, .5);
            // Initialize default collision area to be box
            _this.body.useBoxCollision();
            return _this;
        }
        Object.defineProperty(Actor.prototype, "collisionArea", {
            /**
             * Gets the collision area shape to use for collision possible options are [CircleArea|circles], [PolygonArea|polygons], and
             * [EdgeArea|edges].
             */
            get: function () {
                return this.body.collisionArea;
            },
            /**
             * Gets the collision area shape to use for collision possible options are [CircleArea|circles], [PolygonArea|polygons], and
             * [EdgeArea|edges].
             */
            set: function (area) {
                this.body.collisionArea = area;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "x", {
            /**
             * Gets the x position of the actor relative to it's parent (if any)
             */
            get: function () {
                return this.body.pos.x;
            },
            /**
             * Sets the x position of the actor relative to it's parent (if any)
             */
            set: function (theX) {
                this.body.pos.x = theX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "y", {
            /**
             * Gets the y position of the actor relative to it's parent (if any)
             */
            get: function () {
                return this.body.pos.y;
            },
            /**
             * Sets the y position of the actor relative to it's parent (if any)
             */
            set: function (theY) {
                this.body.pos.y = theY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "pos", {
            /**
             * Gets the position vector of the actor in pixels
             */
            get: function () {
                return this.body.pos;
            },
            /**
             * Sets the position vector of the actor in pixels
             */
            set: function (thePos) {
                this.body.pos.setTo(thePos.x, thePos.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "oldPos", {
            /**
             * Gets the position vector of the actor from the last frame
             */
            get: function () {
                return this.body.oldPos;
            },
            /**
             * Sets the position vector of the actor in the last frame
             */
            set: function (thePos) {
                this.body.oldPos.setTo(thePos.x, thePos.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "vel", {
            /**
             * Gets the velocity vector of the actor in pixels/sec
             */
            get: function () {
                return this.body.vel;
            },
            /**
             * Sets the velocity vector of the actor in pixels/sec
             */
            set: function (theVel) {
                this.body.vel.setTo(theVel.x, theVel.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "oldVel", {
            /**
             * Gets the velocity vector of the actor from the last frame
             */
            get: function () {
                return this.body.oldVel;
            },
            /**
             * Sets the velocity vector of the actor from the last frame
             */
            set: function (theVel) {
                this.body.oldVel.setTo(theVel.x, theVel.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "acc", {
            /**
             * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
             * useful to simulate a gravitational effect.
             */
            get: function () {
                return this.body.acc;
            },
            /**
             * Sets the acceleration vector of teh actor in pixels/second/second
             */
            set: function (theAcc) {
                this.body.acc.setTo(theAcc.x, theAcc.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "rotation", {
            /**
             * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
             */
            get: function () {
                return this.body.rotation;
            },
            /**
             * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
             */
            set: function (theAngle) {
                this.body.rotation = theAngle;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "rx", {
            /**
             * Gets the rotational velocity of the actor in radians/second
             */
            get: function () {
                return this.body.rx;
            },
            /**
             * Sets the rotational velocity of the actor in radians/sec
             */
            set: function (angularVelocity) {
                this.body.rx = angularVelocity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "torque", {
            /**
             * Gets the current torque applied to the actor. Torque can be thought of as rotational force
             */
            get: function () {
                return this.body.torque;
            },
            /**
             * Sets the current torque applied to the actor. Torque can be thought of as rotational force
             */
            set: function (theTorque) {
                this.body.torque = theTorque;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "mass", {
            /**
             * Get the current mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            get: function () {
                return this.body.mass;
            },
            /**
             * Sets the mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            set: function (theMass) {
                this.body.mass = theMass;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "moi", {
            /**
             * Gets the current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            get: function () {
                return this.body.moi;
            },
            /**
             * Sets the current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            set: function (theMoi) {
                this.body.moi = theMoi;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "friction", {
            /**
             * Gets the coefficient of friction on this actor, this can be thought of as how sticky or slippery an object is.
             */
            get: function () {
                return this.body.friction;
            },
            /**
             * Sets the coefficient of friction of this actor, this can ve thought of as how stick or slippery an object is.
             */
            set: function (theFriction) {
                this.body.friction = theFriction;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "restitution", {
            /**
             * Gets the coefficient of restitution of this actor, represents the amount of energy preserved after collision. Think of this
             * as bounciness.
             */
            get: function () {
                return this.body.restitution;
            },
            /**
             * Sets the coefficient of restitution of this actor, represents the amount of energy preserved after collision. Think of this
             * as bounciness.
             */
            set: function (theRestitution) {
                this.body.restitution = theRestitution;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Actor.prototype, "color", {
            /**
             * Sets the color of the actor. A rectangle of this color will be
             * drawn if no [[IDrawable]] is specified as the actors drawing.
             *
             * The default is `null` which prevents a rectangle from being drawn.
             */
            get: function () {
                return this._color;
            },
            set: function (v) {
                this._color = v.clone();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         */
        Actor.prototype.onInitialize = function (_engine) {
            // Override me
        };
        Object.defineProperty(Actor.prototype, "isInitialized", {
            /**
             * Gets wether the actor is Initialized
             */
            get: function () {
                return this._isInitialized;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
         * @internal
         */
        Actor.prototype._initialize = function (engine) {
            if (!this.isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.emit('initialize', new Events_14.InitializeEvent(engine, this));
                this._isInitialized = true;
            }
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child._initialize(engine);
            }
        };
        Actor.prototype._checkForPointerOptIn = function (eventName) {
            if (eventName) {
                var normalized = eventName.toLowerCase();
                if (normalized === 'pointerup' || normalized === 'pointerdown' || normalized === 'pointermove') {
                    this.enableCapturePointer = true;
                    if (normalized === 'pointermove') {
                        this.capturePointer.captureMoveEvents = true;
                    }
                }
            }
        };
        Actor.prototype.on = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.on(eventName, handler);
        };
        Actor.prototype.once = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.once(eventName, handler);
        };
        /**
         * If the current actor is a member of the scene, this will remove
         * it from the scene graph. It will no longer be drawn or updated.
         */
        Actor.prototype.kill = function () {
            if (this.scene) {
                this.emit('kill', new Events_14.KillEvent(this));
                this.scene.remove(this);
                this._isKilled = true;
            }
            else {
                this.logger.warn('Cannot kill actor, it was never added to the Scene');
            }
        };
        /**
         * If the current actor is killed, it will now not be killed.
         */
        Actor.prototype.unkill = function () {
            this._isKilled = false;
        };
        /**
         * Indicates wether the actor has been killed.
         */
        Actor.prototype.isKilled = function () {
            return this._isKilled;
        };
        /**
         * Adds a child actor to this actor. All movement of the child actor will be
         * relative to the parent actor. Meaning if the parent moves the child will
         * move with it.
         * @param actor The child actor to add
         */
        Actor.prototype.add = function (actor) {
            actor.collisionType = CollisionType.PreventCollision;
            if (Util.addItemToArray(actor, this.children)) {
                actor.parent = this;
            }
        };
        /**
         * Removes a child actor from this actor.
         * @param actor The child actor to remove
         */
        Actor.prototype.remove = function (actor) {
            if (Util.removeItemFromArray(actor, this.children)) {
                actor.parent = null;
            }
        };
        Actor.prototype.setDrawing = function (key) {
            key = key.toString();
            if (this.currentDrawing !== this.frames[key]) {
                if (this.frames[key] != null) {
                    this.frames[key].reset();
                    this.currentDrawing = this.frames[key];
                }
                else {
                    Log_16.Logger.getInstance().error('the specified drawing key \'' + key + '\' does not exist');
                }
            }
        };
        Actor.prototype.addDrawing = function () {
            if (arguments.length === 2) {
                this.frames[arguments[0]] = arguments[1];
                if (!this.currentDrawing) {
                    this.currentDrawing = arguments[1];
                }
                this._effectsDirty = true;
            }
            else {
                if (arguments[0] instanceof Sprite_4.Sprite) {
                    this.addDrawing('default', arguments[0]);
                }
                if (arguments[0] instanceof Texture_2.Texture) {
                    this.addDrawing('default', arguments[0].asSprite());
                }
            }
        };
        Object.defineProperty(Actor.prototype, "z", {
            get: function () {
                return this.getZIndex();
            },
            set: function (newZ) {
                this.setZIndex(newZ);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
         * Actors with a higher z-index are drawn on top of actors with a lower z-index
         */
        Actor.prototype.getZIndex = function () {
            return this._zIndex;
        };
        /**
         * Sets the z-index of an actor and updates it in the drawing list for the scene.
         * The z-index determines the relative order an actor is drawn in.
         * Actors with a higher z-index are drawn on top of actors with a lower z-index
         * @param newIndex new z-index to assign
         */
        Actor.prototype.setZIndex = function (newIndex) {
            this.scene.cleanupDrawTree(this);
            this._zIndex = newIndex;
            this.scene.updateDrawTree(this);
        };
        /**
         * Adds an actor to a collision group. Actors with no named collision groups are
         * considered to be in every collision group.
         *
         * Once in a collision group(s) actors will only collide with other actors in
         * that group.
         *
         * @param name The name of the collision group
         */
        Actor.prototype.addCollisionGroup = function (name) {
            this.collisionGroups.push(name);
        };
        /**
         * Removes an actor from a collision group.
         * @param name The name of the collision group
         */
        Actor.prototype.removeCollisionGroup = function (name) {
            var index = this.collisionGroups.indexOf(name);
            if (index !== -1) {
                this.collisionGroups.splice(index, 1);
            }
        };
        /**
         * Get the center point of an actor
         */
        Actor.prototype.getCenter = function () {
            return new Algebra_24.Vector(this.pos.x + this.getWidth() / 2 - this.anchor.x * this.getWidth(), this.pos.y + this.getHeight() / 2 - this.anchor.y * this.getHeight());
        };
        /**
         * Gets the calculated width of an actor, factoring in scale
         */
        Actor.prototype.getWidth = function () {
            return this._width * this.getGlobalScale().x;
        };
        /**
         * Sets the width of an actor, factoring in the current scale
         */
        Actor.prototype.setWidth = function (width) {
            this._width = width / this.scale.x;
        };
        /**
         * Gets the calculated height of an actor, factoring in scale
         */
        Actor.prototype.getHeight = function () {
            return this._height * this.getGlobalScale().y;
        };
        /**
         * Sets the height of an actor, factoring in the current scale
         */
        Actor.prototype.setHeight = function (height) {
            this._height = height / this.scale.y;
        };
        /**
         * Gets the left edge of the actor
         */
        Actor.prototype.getLeft = function () {
            return this.getBounds().left;
        };
        /**
         * Gets the right edge of the actor
         */
        Actor.prototype.getRight = function () {
            return this.getBounds().right;
        };
        /**
         * Gets the top edge of the actor
         */
        Actor.prototype.getTop = function () {
            return this.getBounds().top;
        };
        /**
         * Gets the bottom edge of the actor
         */
        Actor.prototype.getBottom = function () {
            return this.getBounds().bottom;
        };
        /**
         * Gets this actor's rotation taking into account any parent relationships
         *
         * @returns Rotation angle in radians
         */
        Actor.prototype.getWorldRotation = function () {
            if (!this.parent) {
                return this.rotation;
            }
            return this.rotation + this.parent.getWorldRotation();
        };
        /**
         * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
         *
         * @returns Position in world coordinates
         */
        Actor.prototype.getWorldPos = function () {
            if (!this.parent) {
                return this.pos.clone();
            }
            // collect parents                  
            var parents = [];
            var root = this;
            parents.push(this);
            // find parents
            while (root.parent) {
                root = root.parent;
                parents.push(root);
            }
            // calculate position       
            var x = parents.reduceRight(function (px, p) {
                if (p.parent) {
                    return px + (p.pos.x * p.getGlobalScale().x);
                }
                return px + p.pos.x;
            }, 0);
            var y = parents.reduceRight(function (py, p) {
                if (p.parent) {
                    return py + (p.pos.y * p.getGlobalScale().y);
                }
                return py + p.pos.y;
            }, 0);
            // rotate around root anchor
            var ra = root.getWorldPos(); // 10, 10
            var r = this.getWorldRotation();
            return new Algebra_24.Vector(x, y).rotate(r, ra);
        };
        /**
         * Gets the global scale of the Actor
         */
        Actor.prototype.getGlobalScale = function () {
            if (!this.parent) {
                return new Algebra_24.Vector(this.scale.x, this.scale.y);
            }
            var parentScale = this.parent.getGlobalScale();
            return new Algebra_24.Vector(this.scale.x * parentScale.x, this.scale.y * parentScale.y);
        };
        /**
         * Returns the actor's [[BoundingBox]] calculated for this instant in world space.
         */
        Actor.prototype.getBounds = function () {
            // todo cache bounding box
            var anchor = this._getCalculatedAnchor();
            var pos = this.getWorldPos();
            return new BoundingBox_8.BoundingBox(pos.x - anchor.x, pos.y - anchor.y, pos.x + this.getWidth() - anchor.x, pos.y + this.getHeight() - anchor.y).rotate(this.rotation, pos);
        };
        /**
         * Returns the actor's [[BoundingBox]] relative to the actors position.
         */
        Actor.prototype.getRelativeBounds = function () {
            // todo cache bounding box
            var anchor = this._getCalculatedAnchor();
            return new BoundingBox_8.BoundingBox(-anchor.x, -anchor.y, this.getWidth() - anchor.x, this.getHeight() - anchor.y).rotate(this.rotation);
        };
        /**
         * Tests whether the x/y specified are contained in the actor
         * @param x  X coordinate to test (in world coordinates)
         * @param y  Y coordinate to test (in world coordinates)
         * @param recurse checks whether the x/y are contained in any child actors (if they exist).
         */
        Actor.prototype.contains = function (x, y, recurse) {
            if (recurse === void 0) { recurse = false; }
            var containment = this.getBounds().contains(new Algebra_24.Vector(x, y));
            if (recurse) {
                return containment || this.children.some(function (child) {
                    return child.contains(x, y, true);
                });
            }
            return containment;
        };
        /**
         * Returns the side of the collision based on the intersection
         * @param intersect The displacement vector returned by a collision
         */
        Actor.prototype.getSideFromIntersect = function (intersect) {
            if (intersect) {
                if (Math.abs(intersect.x) > Math.abs(intersect.y)) {
                    if (intersect.x < 0) {
                        return Side_4.Side.Right;
                    }
                    return Side_4.Side.Left;
                }
                else {
                    if (intersect.y < 0) {
                        return Side_4.Side.Bottom;
                    }
                    return Side_4.Side.Top;
                }
            }
            return Side_4.Side.None;
        };
        /**
         * Test whether the actor has collided with another actor, returns the side of the current actor that collided.
         * @param actor The other actor to test
         */
        Actor.prototype.collidesWithSide = function (actor) {
            var separationVector = this.collides(actor);
            if (!separationVector) {
                return Side_4.Side.None;
            }
            if (Math.abs(separationVector.x) > Math.abs(separationVector.y)) {
                if (this.pos.x < actor.pos.x) {
                    return Side_4.Side.Right;
                }
                else {
                    return Side_4.Side.Left;
                }
            }
            else {
                if (this.pos.y < actor.pos.y) {
                    return Side_4.Side.Bottom;
                }
                else {
                    return Side_4.Side.Top;
                }
            }
        };
        /**
         * Test whether the actor has collided with another actor, returns the intersection vector on collision. Returns
         * `null` when there is no collision;
         * @param actor The other actor to test
         */
        Actor.prototype.collides = function (actor) {
            var bounds = this.getBounds();
            var otherBounds = actor.getBounds();
            var intersect = bounds.collides(otherBounds);
            return intersect;
        };
        /**
         * Register a handler to fire when this actor collides with another in a specified group
         * @param group The group name to listen for
         * @param func The callback to fire on collision with another actor from the group. The callback is passed the other actor.
         */
        Actor.prototype.onCollidesWith = function (group, func) {
            if (!this._collisionHandlers[group]) {
                this._collisionHandlers[group] = [];
            }
            this._collisionHandlers[group].push(func);
        };
        Actor.prototype.getCollisionHandlers = function () {
            return this._collisionHandlers;
        };
        /**
         * Removes all collision handlers for this group on this actor
         * @param group Group to remove all handlers for on this actor.
         */
        Actor.prototype.removeCollidesWith = function (group) {
            this._collisionHandlers[group] = [];
        };
        /**
         * Returns true if the two actors are less than or equal to the distance specified from each other
         * @param actor     Actor to test
         * @param distance  Distance in pixels to test
         */
        Actor.prototype.within = function (actor, distance) {
            return Math.sqrt(Math.pow(this.pos.x - actor.pos.x, 2) + Math.pow(this.pos.y - actor.pos.y, 2)) <= distance;
        };
        Actor.prototype._getCalculatedAnchor = function () {
            return new Algebra_24.Vector(this.getWidth() * this.anchor.x, this.getHeight() * this.anchor.y);
        };
        Actor.prototype._reapplyEffects = function (drawing) {
            drawing.removeEffect(this._opacityFx);
            drawing.addEffect(this._opacityFx);
        };
        /**
         * Perform euler integration at the specified time step
         */
        Actor.prototype.integrate = function (delta) {
            // Update placements based on linear algebra
            var seconds = delta / 1000;
            var totalAcc = this.acc.clone();
            // Only active vanilla actors are affected by global acceleration
            if (this.collisionType === CollisionType.Active) {
                totalAcc.addEqual(Physics_13.Physics.acc);
            }
            this.vel.addEqual(totalAcc.scale(seconds));
            this.pos.addEqual(this.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
            this.rx += this.torque * (1.0 / this.moi) * seconds;
            this.rotation += this.rx * seconds;
            this.scale.x += this.sx * delta / 1000;
            this.scale.y += this.sy * delta / 1000;
            // Update physics body
            this.body.update();
        };
        /**
         * Called by the Engine, updates the state of the actor
         * @param engine The reference to the current game engine
         * @param delta  The time elapsed since the last update in milliseconds
         */
        Actor.prototype.update = function (engine, delta) {
            this._initialize(engine);
            this.emit('preupdate', new Events_14.PreUpdateEvent(engine, delta, this));
            // Update action queue
            this.actionQueue.update(delta);
            // Update color only opacity
            if (this.color) {
                this.color.a = this.opacity;
            }
            // calculate changing opacity
            if (this.previousOpacity !== this.opacity) {
                this.previousOpacity = this.opacity;
                this._opacityFx.opacity = this.opacity;
                this._effectsDirty = true;
            }
            // Capture old values before integration step updates them
            this.oldVel.setTo(this.vel.x, this.vel.y);
            this.oldPos.setTo(this.pos.x, this.pos.y);
            // Run Euler integration
            this.integrate(delta);
            // Update actor pipeline (movement, collision detection, event propagation, offscreen culling)
            for (var _i = 0, _a = this.traits; _i < _a.length; _i++) {
                var trait = _a[_i];
                trait.update(this, engine, delta);
            }
            // Update child actors
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].update(engine, delta);
            }
            this.emit('postupdate', new Events_14.PostUpdateEvent(engine, delta, this));
        };
        /**
         * Called by the Engine, draws the actor to the screen
         * @param ctx   The rendering context
         * @param delta The time since the last draw in milliseconds
         */
        Actor.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale.x, this.scale.y);
            // translate canvas by anchor offset
            ctx.save();
            ctx.translate(-(this._width * this.anchor.x), -(this._height * this.anchor.y));
            this.emit('predraw', new Events_14.PreDrawEvent(ctx, delta, this));
            if (this.currentDrawing) {
                var drawing = this.currentDrawing;
                // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula          
                var offsetX = (this._width - drawing.naturalWidth * drawing.scale.x) * this.anchor.x;
                var offsetY = (this._height - drawing.naturalHeight * drawing.scale.y) * this.anchor.y;
                if (this._effectsDirty) {
                    this._reapplyEffects(this.currentDrawing);
                    this._effectsDirty = false;
                }
                this.currentDrawing.draw(ctx, offsetX, offsetY);
            }
            else {
                if (this.color) {
                    ctx.fillStyle = this.color.toString();
                    ctx.fillRect(0, 0, this._width, this._height);
                }
            }
            ctx.restore();
            // Draw child actors
            for (var i = 0; i < this.children.length; i++) {
                if (this.children[i].visible) {
                    this.children[i].draw(ctx, delta);
                }
            }
            this.emit('postdraw', new Events_14.PostDrawEvent(ctx, delta, this));
            ctx.restore();
        };
        /**
         * Called by the Engine, draws the actors debugging to the screen
         * @param ctx The rendering context
         */
        /* istanbul ignore next */
        Actor.prototype.debugDraw = function (ctx) {
            this.emit('predebugdraw', new Events_14.PreDebugDrawEvent(ctx, this));
            this.body.debugDraw(ctx);
            // Draw actor bounding box
            var bb = this.getBounds();
            bb.debugDraw(ctx);
            // Draw actor Id
            ctx.fillText('id: ' + this.id, bb.left + 3, bb.top + 10);
            // Draw actor anchor Vector
            ctx.fillStyle = Color_20.Color.Yellow.toString();
            ctx.beginPath();
            ctx.arc(this.getWorldPos().x, this.getWorldPos().y, 3, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            // Culling Box debug draw
            for (var j = 0; j < this.traits.length; j++) {
                if (this.traits[j] instanceof Traits.OffscreenCulling) {
                    this.traits[j].cullingBox.debugDraw(ctx);
                }
            }
            // Unit Circle debug draw
            ctx.strokeStyle = Color_20.Color.Yellow.toString();
            ctx.beginPath();
            var radius = Math.min(this.getWidth(), this.getHeight());
            ctx.arc(this.getWorldPos().x, this.getWorldPos().y, radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            var ticks = {
                '0 Pi': 0,
                'Pi/2': Math.PI / 2,
                'Pi': Math.PI,
                '3/2 Pi': 3 * Math.PI / 2
            };
            var oldFont = ctx.font;
            for (var tick in ticks) {
                ctx.fillStyle = Color_20.Color.Yellow.toString();
                ctx.font = '14px';
                ctx.textAlign = 'center';
                ctx.fillText(tick, this.getWorldPos().x + Math.cos(ticks[tick]) * (radius + 10), this.getWorldPos().y + Math.sin(ticks[tick]) * (radius + 10));
            }
            ctx.font = oldFont;
            // Draw child actors
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].debugDraw(ctx);
            }
            this.emit('postdebugdraw', new Events_14.PostDebugDrawEvent(ctx, this));
        };
        return Actor;
    }(Class_11.Class));
    /**
     * Indicates the next id to be set
     */
    Actor.maxId = 0;
    exports.Actor = Actor;
    /**
     * An enum that describes the types of collisions actors can participate in
     */
    var CollisionType;
    (function (CollisionType) {
        /**
         * Actors with the `PreventCollision` setting do not participate in any
         * collisions and do not raise collision events.
         */
        CollisionType[CollisionType["PreventCollision"] = 0] = "PreventCollision";
        /**
         * Actors with the `Passive` setting only raise collision events, but are not
         * influenced or moved by other actors and do not influence or move other actors.
         */
        CollisionType[CollisionType["Passive"] = 1] = "Passive";
        /**
         * Actors with the `Active` setting raise collision events and participate
         * in collisions with other actors and will be push or moved by actors sharing
         * the `Active` or `Fixed` setting.
         */
        CollisionType[CollisionType["Active"] = 2] = "Active";
        /**
         * Actors with the `Fixed` setting raise collision events and participate in
         * collisions with other actors. Actors with the `Fixed` setting will not be
         * pushed or moved by other actors sharing the `Fixed`. Think of Fixed
         * actors as "immovable/onstoppable" objects. If two `Fixed` actors meet they will
         * not be pushed or moved by each other, they will not interact except to throw
         * collision events.
         */
        CollisionType[CollisionType["Fixed"] = 3] = "Fixed";
    })(CollisionType = exports.CollisionType || (exports.CollisionType = {}));
});
define("Actions/Action", ["require", "exports", "Actions/RotationType", "Algebra", "Util/Log", "Util/Util"], function (require, exports, RotationType_2, Algebra_25, Log_17, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EaseTo = (function () {
        function EaseTo(actor, x, y, duration, easingFcn) {
            this.actor = actor;
            this.easingFcn = easingFcn;
            this._currentLerpTime = 0;
            this._lerpDuration = 1 * 1000; // 1 second
            this._lerpStart = new Algebra_25.Vector(0, 0);
            this._lerpEnd = new Algebra_25.Vector(0, 0);
            this._initialized = false;
            this._stopped = false;
            this._distance = 0;
            this._lerpDuration = duration;
            this._lerpEnd = new Algebra_25.Vector(x, y);
        }
        EaseTo.prototype._initialize = function () {
            this._lerpStart = new Algebra_25.Vector(this.actor.pos.x, this.actor.pos.y);
            this._currentLerpTime = 0;
            this._distance = this._lerpStart.distance(this._lerpEnd);
        };
        EaseTo.prototype.update = function (delta) {
            if (!this._initialized) {
                this._initialize();
                this._initialized = true;
            }
            var newX = this.actor.pos.x;
            var newY = this.actor.pos.y;
            if (this._currentLerpTime < this._lerpDuration) {
                if (this._lerpEnd.x < this._lerpStart.x) {
                    newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                }
                else {
                    newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                }
                if (this._lerpEnd.y < this._lerpStart.y) {
                    newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                }
                else {
                    newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                }
                this.actor.pos.x = newX;
                this.actor.pos.y = newY;
                this._currentLerpTime += delta;
            }
            else {
                this.actor.pos.x = this._lerpEnd.x;
                this.actor.pos.y = this._lerpEnd.y;
                //this._lerpStart = null;
                //this._lerpEnd = null;
                //this._currentLerpTime = 0;
            }
        };
        EaseTo.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._lerpStart) >= this._distance;
        };
        EaseTo.prototype.reset = function () {
            this._initialized = false;
        };
        EaseTo.prototype.stop = function () {
            this._stopped = true;
        };
        return EaseTo;
    }());
    exports.EaseTo = EaseTo;
    var MoveTo = (function () {
        function MoveTo(actor, destx, desty, speed) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = new Algebra_25.Vector(destx, desty);
            this._speed = speed;
        }
        MoveTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
                this._distance = this._start.distance(this._end);
                this._dir = this._end.sub(this._start).normalize();
            }
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete(this._actor)) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        MoveTo.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._start) >= this._distance;
        };
        MoveTo.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        MoveTo.prototype.reset = function () {
            this._started = false;
        };
        return MoveTo;
    }());
    exports.MoveTo = MoveTo;
    var MoveBy = (function () {
        function MoveBy(actor, destx, desty, time) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = new Algebra_25.Vector(destx, desty);
            if (time <= 0) {
                Log_17.Logger.getInstance().error('Attempted to moveBy time less than or equal to zero : ' + time);
                throw new Error('Cannot move in time <= 0');
            }
            this._time = time;
        }
        MoveBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
                this._distance = this._start.distance(this._end);
                this._dir = this._end.sub(this._start).normalize();
                this._speed = this._distance / (this._time / 1000);
            }
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete(this._actor)) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        MoveBy.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._start) >= this._distance;
        };
        MoveBy.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        MoveBy.prototype.reset = function () {
            this._started = false;
        };
        return MoveBy;
    }());
    exports.MoveBy = MoveBy;
    var Follow = (function () {
        function Follow(actor, actorToFollow, followDistance) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._actorToFollow = actorToFollow;
            this._current = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
            this._end = new Algebra_25.Vector(actorToFollow.pos.x, actorToFollow.pos.y);
            this._maximumDistance = (followDistance !== undefined) ? followDistance : this._current.distance(this._end);
            this._speed = 0;
        }
        Follow.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._distanceBetween = this._current.distance(this._end);
                this._dir = this._end.sub(this._current).normalize();
            }
            var actorToFollowSpeed = Math.sqrt(Math.pow(this._actorToFollow.vel.x, 2) + Math.pow(this._actorToFollow.vel.y, 2));
            if (actorToFollowSpeed !== 0) {
                this._speed = actorToFollowSpeed;
            }
            this._current.x = this._actor.pos.x;
            this._current.y = this._actor.pos.y;
            this._end.x = this._actorToFollow.pos.x;
            this._end.y = this._actorToFollow.pos.y;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
            if (this._distanceBetween >= this._maximumDistance) {
                var m = this._dir.scale(this._speed);
                this._actor.vel.x = m.x;
                this._actor.vel.y = m.y;
            }
            else {
                this._actor.vel.x = 0;
                this._actor.vel.y = 0;
            }
            if (this.isComplete()) {
                // TODO this should never occur
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        Follow.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        Follow.prototype.isComplete = function () {
            // the actor following should never stop unless specified to do so
            return this._stopped;
        };
        Follow.prototype.reset = function () {
            this._started = false;
        };
        return Follow;
    }());
    exports.Follow = Follow;
    var Meet = (function () {
        function Meet(actor, actorToMeet, speed) {
            this._started = false;
            this._stopped = false;
            this._speedWasSpecified = false;
            this._actor = actor;
            this._actorToMeet = actorToMeet;
            this._current = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
            this._end = new Algebra_25.Vector(actorToMeet.pos.x, actorToMeet.pos.y);
            this._speed = speed || 0;
            if (speed !== undefined) {
                this._speedWasSpecified = true;
            }
        }
        Meet.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._distanceBetween = this._current.distance(this._end);
                this._dir = this._end.sub(this._current).normalize();
            }
            var actorToMeetSpeed = Math.sqrt(Math.pow(this._actorToMeet.vel.x, 2) + Math.pow(this._actorToMeet.vel.y, 2));
            if ((actorToMeetSpeed !== 0) && (!this._speedWasSpecified)) {
                this._speed = actorToMeetSpeed;
            }
            this._current.x = this._actor.pos.x;
            this._current.y = this._actor.pos.y;
            this._end.x = this._actorToMeet.pos.x;
            this._end.y = this._actorToMeet.pos.y;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete()) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        Meet.prototype.isComplete = function () {
            return this._stopped || (this._distanceBetween <= 1);
        };
        Meet.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        Meet.prototype.reset = function () {
            this._started = false;
        };
        return Meet;
    }());
    exports.Meet = Meet;
    var RotateTo = (function () {
        function RotateTo(actor, angleRadians, speed, rotationType) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = angleRadians;
            this._speed = speed;
            this._rotationType = rotationType || RotationType_2.RotationType.ShortestPath;
        }
        RotateTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = this._actor.rotation;
                var distance1 = Math.abs(this._end - this._start);
                var distance2 = Util.TwoPI - distance1;
                if (distance1 > distance2) {
                    this._shortDistance = distance2;
                    this._longDistance = distance1;
                }
                else {
                    this._shortDistance = distance1;
                    this._longDistance = distance2;
                }
                this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;
                switch (this._rotationType) {
                    case RotationType_2.RotationType.ShortestPath:
                        this._distance = this._shortDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = 1;
                        }
                        else {
                            this._direction = -1;
                        }
                        break;
                    case RotationType_2.RotationType.LongestPath:
                        this._distance = this._longDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = -1;
                        }
                        else {
                            this._direction = 1;
                        }
                        break;
                    case RotationType_2.RotationType.Clockwise:
                        this._direction = 1;
                        if (this._shortestPathIsPositive) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                    case RotationType_2.RotationType.CounterClockwise:
                        this._direction = -1;
                        if (!this._shortestPathIsPositive) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                }
            }
            this._actor.rx = this._direction * this._speed;
            if (this.isComplete()) {
                this._actor.rotation = this._end;
                this._actor.rx = 0;
                this._stopped = true;
            }
        };
        RotateTo.prototype.isComplete = function () {
            var distanceTravelled = Math.abs(this._actor.rotation - this._start);
            return this._stopped || (distanceTravelled >= Math.abs(this._distance));
        };
        RotateTo.prototype.stop = function () {
            this._actor.rx = 0;
            this._stopped = true;
        };
        RotateTo.prototype.reset = function () {
            this._started = false;
        };
        return RotateTo;
    }());
    exports.RotateTo = RotateTo;
    var RotateBy = (function () {
        function RotateBy(actor, angleRadians, time, rotationType) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = angleRadians;
            this._time = time;
            this._rotationType = rotationType || RotationType_2.RotationType.ShortestPath;
        }
        RotateBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = this._actor.rotation;
                var distance1 = Math.abs(this._end - this._start);
                var distance2 = Util.TwoPI - distance1;
                if (distance1 > distance2) {
                    this._shortDistance = distance2;
                    this._longDistance = distance1;
                }
                else {
                    this._shortDistance = distance1;
                    this._longDistance = distance2;
                }
                this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;
                switch (this._rotationType) {
                    case RotationType_2.RotationType.ShortestPath:
                        this._distance = this._shortDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = 1;
                        }
                        else {
                            this._direction = -1;
                        }
                        break;
                    case RotationType_2.RotationType.LongestPath:
                        this._distance = this._longDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = -1;
                        }
                        else {
                            this._direction = 1;
                        }
                        break;
                    case RotationType_2.RotationType.Clockwise:
                        this._direction = 1;
                        if (this._shortDistance >= 0) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                    case RotationType_2.RotationType.CounterClockwise:
                        this._direction = -1;
                        if (this._shortDistance <= 0) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                }
                this._speed = Math.abs(this._distance / this._time * 1000);
            }
            this._actor.rx = this._direction * this._speed;
            if (this.isComplete()) {
                this._actor.rotation = this._end;
                this._actor.rx = 0;
                this._stopped = true;
            }
        };
        RotateBy.prototype.isComplete = function () {
            var distanceTravelled = Math.abs(this._actor.rotation - this._start);
            return this._stopped || (distanceTravelled >= Math.abs(this._distance));
        };
        RotateBy.prototype.stop = function () {
            this._actor.rx = 0;
            this._stopped = true;
        };
        RotateBy.prototype.reset = function () {
            this._started = false;
        };
        return RotateBy;
    }());
    exports.RotateBy = RotateBy;
    var ScaleTo = (function () {
        function ScaleTo(actor, scaleX, scaleY, speedX, speedY) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endX = scaleX;
            this._endY = scaleY;
            this._speedX = speedX;
            this._speedY = speedY;
        }
        ScaleTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._startX = this._actor.scale.x;
                this._startY = this._actor.scale.y;
                this._distanceX = Math.abs(this._endX - this._startX);
                this._distanceY = Math.abs(this._endY - this._startY);
            }
            if (!(Math.abs(this._actor.scale.x - this._startX) >= this._distanceX)) {
                var directionX = this._endY < this._startY ? -1 : 1;
                this._actor.sx = this._speedX * directionX;
            }
            else {
                this._actor.sx = 0;
            }
            if (!(Math.abs(this._actor.scale.y - this._startY) >= this._distanceY)) {
                var directionY = this._endY < this._startY ? -1 : 1;
                this._actor.sy = this._speedY * directionY;
            }
            else {
                this._actor.sy = 0;
            }
            if (this.isComplete()) {
                this._actor.scale.x = this._endX;
                this._actor.scale.y = this._endY;
                this._actor.sx = 0;
                this._actor.sy = 0;
            }
        };
        ScaleTo.prototype.isComplete = function () {
            return this._stopped || ((Math.abs(this._actor.scale.y - this._startX) >= this._distanceX) &&
                (Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));
        };
        ScaleTo.prototype.stop = function () {
            this._actor.sx = 0;
            this._actor.sy = 0;
            this._stopped = true;
        };
        ScaleTo.prototype.reset = function () {
            this._started = false;
        };
        return ScaleTo;
    }());
    exports.ScaleTo = ScaleTo;
    var ScaleBy = (function () {
        function ScaleBy(actor, scaleX, scaleY, time) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endX = scaleX;
            this._endY = scaleY;
            this._time = time;
            this._speedX = (this._endX - this._actor.scale.x) / time * 1000;
            this._speedY = (this._endY - this._actor.scale.y) / time * 1000;
        }
        ScaleBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._startX = this._actor.scale.x;
                this._startY = this._actor.scale.y;
                this._distanceX = Math.abs(this._endX - this._startX);
                this._distanceY = Math.abs(this._endY - this._startY);
            }
            var directionX = this._endX < this._startX ? -1 : 1;
            var directionY = this._endY < this._startY ? -1 : 1;
            this._actor.sx = this._speedX * directionX;
            this._actor.sy = this._speedY * directionY;
            if (this.isComplete()) {
                this._actor.scale.x = this._endX;
                this._actor.scale.y = this._endY;
                this._actor.sx = 0;
                this._actor.sy = 0;
            }
        };
        ScaleBy.prototype.isComplete = function () {
            return this._stopped || ((Math.abs(this._actor.scale.x - this._startX) >= this._distanceX) &&
                (Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));
        };
        ScaleBy.prototype.stop = function () {
            this._actor.sx = 0;
            this._actor.sy = 0;
            this._stopped = true;
        };
        ScaleBy.prototype.reset = function () {
            this._started = false;
        };
        return ScaleBy;
    }());
    exports.ScaleBy = ScaleBy;
    var Delay = (function () {
        function Delay(actor, delay) {
            this._elapsedTime = 0;
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._delay = delay;
        }
        Delay.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
            }
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            this._elapsedTime += delta;
        };
        Delay.prototype.isComplete = function () {
            return this._stopped || (this._elapsedTime >= this._delay);
        };
        Delay.prototype.stop = function () {
            this._stopped = true;
        };
        Delay.prototype.reset = function () {
            this._elapsedTime = 0;
            this._started = false;
        };
        return Delay;
    }());
    exports.Delay = Delay;
    var Blink = (function () {
        function Blink(actor, timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            this._timeVisible = 0;
            this._timeNotVisible = 0;
            this._elapsedTime = 0;
            this._totalTime = 0;
            this._stopped = false;
            this._started = false;
            this._actor = actor;
            this._timeVisible = timeVisible;
            this._timeNotVisible = timeNotVisible;
            this._duration = (timeVisible + timeNotVisible) * numBlinks;
        }
        Blink.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
            }
            this._elapsedTime += delta;
            this._totalTime += delta;
            if (this._actor.visible && this._elapsedTime >= this._timeVisible) {
                this._actor.visible = false;
                this._elapsedTime = 0;
            }
            if (!this._actor.visible && this._elapsedTime >= this._timeNotVisible) {
                this._actor.visible = true;
                this._elapsedTime = 0;
            }
            if (this.isComplete()) {
                this._actor.visible = true;
            }
        };
        Blink.prototype.isComplete = function () {
            return this._stopped || (this._totalTime >= this._duration);
        };
        Blink.prototype.stop = function () {
            this._actor.visible = true;
            this._stopped = true;
        };
        Blink.prototype.reset = function () {
            this._started = false;
            this._elapsedTime = 0;
            this._totalTime = 0;
        };
        return Blink;
    }());
    exports.Blink = Blink;
    var Fade = (function () {
        function Fade(actor, endOpacity, speed) {
            this._multiplier = 1;
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endOpacity = endOpacity;
            this._speed = speed;
        }
        Fade.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
                // determine direction when we start
                if (this._endOpacity < this._actor.opacity) {
                    this._multiplier = -1;
                }
                else {
                    this._multiplier = 1;
                }
            }
            if (this._speed > 0) {
                this._actor.opacity += this._multiplier * (Math.abs(this._actor.opacity - this._endOpacity) * delta) / this._speed;
            }
            this._speed -= delta;
            if (this.isComplete()) {
                this._actor.opacity = this._endOpacity;
            }
            Log_17.Logger.getInstance().debug('[Action fade] Actor opacity:', this._actor.opacity);
        };
        Fade.prototype.isComplete = function () {
            return this._stopped || (Math.abs(this._actor.opacity - this._endOpacity) < 0.05);
        };
        Fade.prototype.stop = function () {
            this._stopped = true;
        };
        Fade.prototype.reset = function () {
            this._started = false;
        };
        return Fade;
    }());
    exports.Fade = Fade;
    var Die = (function () {
        function Die(actor) {
            this._stopped = false;
            this._actor = actor;
        }
        Die.prototype.update = function (_delta) {
            this._actor.actionQueue.clearActions();
            this._actor.kill();
            this._stopped = true;
        };
        Die.prototype.isComplete = function () {
            return this._stopped;
        };
        Die.prototype.stop = function () { return; };
        Die.prototype.reset = function () { return; };
        return Die;
    }());
    exports.Die = Die;
    var CallMethod = (function () {
        function CallMethod(actor, method) {
            this._method = null;
            this._actor = null;
            this._hasBeenCalled = false;
            this._actor = actor;
            this._method = method;
        }
        CallMethod.prototype.update = function (_delta) {
            this._method.call(this._actor);
            this._hasBeenCalled = true;
        };
        CallMethod.prototype.isComplete = function () {
            return this._hasBeenCalled;
        };
        CallMethod.prototype.reset = function () {
            this._hasBeenCalled = false;
        };
        CallMethod.prototype.stop = function () {
            this._hasBeenCalled = true;
        };
        return CallMethod;
    }());
    exports.CallMethod = CallMethod;
    var Repeat = (function () {
        function Repeat(actor, repeat, actions) {
            this._stopped = false;
            this._actor = actor;
            this._actionQueue = new ActionQueue(actor);
            this._repeat = repeat;
            this._originalRepeat = repeat;
            var i = 0, len = actions.length;
            for (i; i < len; i++) {
                actions[i].reset();
                this._actionQueue.add(actions[i]);
            }
            ;
        }
        Repeat.prototype.update = function (delta) {
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            if (!this._actionQueue.hasNext()) {
                this._actionQueue.reset();
                this._repeat--;
            }
            this._actionQueue.update(delta);
        };
        Repeat.prototype.isComplete = function () {
            return this._stopped || (this._repeat <= 0);
        };
        Repeat.prototype.stop = function () {
            this._stopped = true;
        };
        Repeat.prototype.reset = function () {
            this._repeat = this._originalRepeat;
        };
        return Repeat;
    }());
    exports.Repeat = Repeat;
    var RepeatForever = (function () {
        function RepeatForever(actor, actions) {
            this._stopped = false;
            this._actor = actor;
            this._actionQueue = new ActionQueue(actor);
            var i = 0, len = actions.length;
            for (i; i < len; i++) {
                actions[i].reset();
                this._actionQueue.add(actions[i]);
            }
            ;
        }
        RepeatForever.prototype.update = function (delta) {
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            if (this._stopped) {
                return;
            }
            if (!this._actionQueue.hasNext()) {
                this._actionQueue.reset();
            }
            this._actionQueue.update(delta);
        };
        RepeatForever.prototype.isComplete = function () {
            return this._stopped;
        };
        RepeatForever.prototype.stop = function () {
            this._stopped = true;
            this._actionQueue.clearActions();
        };
        RepeatForever.prototype.reset = function () { return; };
        return RepeatForever;
    }());
    exports.RepeatForever = RepeatForever;
    /**
     * Action Queues
     *
     * Action queues are part of the [[ActionContext|Action API]] and
     * store the list of actions to be executed for an [[Actor]].
     *
     * Actors implement [[Actor.actions]] which can be manipulated by
     * advanced users to adjust the actions currently being executed in the
     * queue.
     */
    var ActionQueue = (function () {
        function ActionQueue(actor) {
            this._actions = [];
            this._completedActions = [];
            this._actor = actor;
        }
        ActionQueue.prototype.add = function (action) {
            this._actions.push(action);
        };
        ActionQueue.prototype.remove = function (action) {
            var index = this._actions.indexOf(action);
            this._actions.splice(index, 1);
        };
        ActionQueue.prototype.clearActions = function () {
            this._actions.length = 0;
            this._completedActions.length = 0;
            if (this._currentAction) {
                this._currentAction.stop();
            }
        };
        ActionQueue.prototype.getActions = function () {
            return this._actions.concat(this._completedActions);
        };
        ActionQueue.prototype.hasNext = function () {
            return this._actions.length > 0;
        };
        ActionQueue.prototype.reset = function () {
            this._actions = this.getActions();
            var i = 0, len = this._actions.length;
            for (i; i < len; i++) {
                this._actions[i].reset();
            }
            this._completedActions = [];
        };
        ActionQueue.prototype.update = function (delta) {
            if (this._actions.length > 0) {
                this._currentAction = this._actions[0];
                this._currentAction.update(delta);
                if (this._currentAction.isComplete(this._actor)) {
                    this._completedActions.push(this._actions.shift());
                }
            }
        };
        return ActionQueue;
    }());
    exports.ActionQueue = ActionQueue;
});
/* istanbul ignore next */
if (typeof window === 'undefined') {
    window = { audioContext: function () { return; } };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
    window.requestAnimationFrame =
        window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function (callback) { window.setInterval(callback, 1000 / 60); };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
    window.cancelAnimationFrame =
        window.webkitCancelAnimationFrame ||
            window.mozCancelAnimationFrame ||
            function () { return; };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.AudioContext) {
    window.AudioContext = window.AudioContext ||
        window.webkitAudioContext ||
        window.mozAudioContext ||
        window.msAudioContext ||
        window.oAudioContext;
}
if (typeof window !== 'undefined' && !window.devicePixelRatio) {
    window.devicePixelRatio = window.devicePixelRatio || 1;
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
/* istanbul ignore next */
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this == null) {
            throw new TypeError('this is null or not defined');
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument. 
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        // 7. Repeat, while k < len
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
/* istanbul ignore next */
if (!Array.prototype.some) {
    Array.prototype.some = function (fun /*, thisArg */) {
        'use strict';
        if (this === void 0 || this === null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(thisArg, t[i], i, t)) {
                return true;
            }
        }
        return false;
    };
}
// Polyfill from  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill
/* istanbul ignore next */
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== 'function') {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () { return; }, fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis
                ? this
                : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}
    //The modules for your project will be inlined above
    //this snippet. Ask almond to synchronously require the
    //module value for 'main' here and return it as the
    //value to use for the public API for the built file.
    return require('Index');
}));
//# sourceMappingURL=excalibur.js.map

/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excalibur_1 = __webpack_require__(0);
var MikelsonParts_1 = __webpack_require__(12);
var EslanParts_1 = __webpack_require__(36);
/**
 * These resources are loaded before GameBootstrap is initialised.
 */
exports.initialResources = [
    MikelsonParts_1.texture.src,
    MikelsonParts_1.textureDuck.src,
    MikelsonParts_1.textureBro.src,
    MikelsonParts_1.textureDuckBro.src,
    __webpack_require__(88),
    __webpack_require__(89)
];
var resources = {
    level1: {
        bg: new excalibur_1.Texture(__webpack_require__(90)),
        ground: new excalibur_1.Texture(__webpack_require__(91)),
        tree: new excalibur_1.Texture(__webpack_require__(92)),
        arrow: new excalibur_1.Texture(__webpack_require__(93)),
        vine: new excalibur_1.Texture(__webpack_require__(94))
    },
    level2: {
        crocodile: new excalibur_1.Texture(__webpack_require__(95)),
        ground: new excalibur_1.Texture(__webpack_require__(96)),
        bg: new excalibur_1.Texture(__webpack_require__(97)),
        bubble: new excalibur_1.Texture(__webpack_require__(98))
    },
    level3: {
        bg: new excalibur_1.Texture(__webpack_require__(99)),
        ground: new excalibur_1.Texture(__webpack_require__(100)),
        smallRock: new excalibur_1.Texture(__webpack_require__(101)),
        bigRock: new excalibur_1.Texture(__webpack_require__(102))
    },
    level4: {
        bg: new excalibur_1.Texture(__webpack_require__(103)),
        ground: new excalibur_1.Texture(__webpack_require__(104)),
        pot: new excalibur_1.Texture(__webpack_require__(105))
    },
    fonts: {
        fontO: new excalibur_1.Resource(__webpack_require__(106), "blob"),
        fontAO: new excalibur_1.Resource(__webpack_require__(107), "blob"),
        fontTS: new excalibur_1.Resource(__webpack_require__(108), "blob")
    },
    textures: {
        michealsonTexture: MikelsonParts_1.texture.exTexture(),
        textureDuck: MikelsonParts_1.textureDuck.exTexture(),
        textureBro: MikelsonParts_1.textureBro.exTexture(),
        textureDuckBro: MikelsonParts_1.textureDuckBro.exTexture(),
        eslanTexture: EslanParts_1.texture
    }
};
exports.default = resources;
function getLoadableResources() {
    var arr = Object.values(resources).filter(function (t) { return (t instanceof excalibur_1.Texture) || (t instanceof excalibur_1.Resource); });
    var objs = Object.values(resources)
        .filter(function (t) { return !((t instanceof excalibur_1.Texture) || (t instanceof excalibur_1.Resource)); })
        .map(function (t) { return Object.values(t); });
    var ret = arr.concat([].concat.apply([], objs));
    return ret;
}
exports.getLoadableResources = getLoadableResources;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Class_1 = __webpack_require__(17);
var Component = /** @class */ (function (_super) {
    __extends(Component, _super);
    function Component(attrs) {
        var _this = _super.call(this) || this;
        // @ts-ignore
        _this.attrs = attrs;
        return _this;
    }
    return Component;
}(Class_1.Class));
exports.Component = Component;
/**
 * CSS properties which get assigned the `px` suffix.
 */
exports.numericCSSProperties = [
    "borderBottomLeftRadius",
    "borderBottomRightRadius",
    "borderRadius",
    "borderTopLeftRadius",
    "borderTopRightRadius ",
    "borderWidth",
    "bottom",
    "fontSize",
    "height",
    "left",
    "margin",
    "marginBottom",
    "marginLeft",
    "marginRight",
    "marginTop",
    "padding",
    "paddingBottom",
    "paddingLeft",
    "paddingRight",
    "paddingTop",
    "right",
    "strokeWidth",
    "top",
    "width"
];
/**
 * Error to throw when requested DOM content is not yet loaded.
 */
var DOMContentNotLoaded = /** @class */ (function (_super) {
    __extends(DOMContentNotLoaded, _super);
    function DOMContentNotLoaded(message) {
        if (message === void 0) { message = "DOM content not loaded."; }
        return _super.call(this, message) || this;
    }
    return DOMContentNotLoaded;
}(Error));
exports.DOMContentNotLoaded = DOMContentNotLoaded;
/**
 * Error to throw when and invalid child object is given to a JSX element.
 */
var InvalidChildElement = /** @class */ (function (_super) {
    __extends(InvalidChildElement, _super);
    function InvalidChildElement(item, message) {
        var _this = _super.call(this, message
            || (item && "Invalid object passed as a child of an JSX element: \"" + item.toString() + "\".")
            || "Invalid object passed as a child of an JSX element.") || this;
        _this.item = item;
        return _this;
    }
    return InvalidChildElement;
}(Error));
exports.InvalidChildElement = InvalidChildElement;
/**
 * Provides functionalities for manupulating the DOM.
 */
var InterfaceBuilder;
(function (InterfaceBuilder) {
    function isTruthy(value) {
        return !isFalsy(value);
    }
    InterfaceBuilder.isTruthy = isTruthy;
    function isFalsy(value) {
        return value === false
            || value === null
            || value === undefined;
    }
    InterfaceBuilder.isFalsy = isFalsy;
    function filter(values) {
        if (!values)
            return [];
        else if (Array.isArray(values))
            return values.filter(isTruthy);
        else if (isTruthy(values))
            return [values];
        else
            return [];
    }
    InterfaceBuilder.filter = filter;
    /**
     * Flattens an array of node collections and filters it for truthy values only.
     * @param array Array of nodes collections to flatten.
     */
    function flatten(array) {
        var flattened = [];
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
            var value = array_1[_i];
            if (isTruthy(value)) {
                if (Array.isArray(value))
                    flattened.push.apply(flattened, value.filter(isTruthy));
                else
                    flattened.push(value);
            }
        }
        return flattened;
    }
    InterfaceBuilder.flatten = flatten;
    function assignStyle(given, actual) {
        for (var prop in given) {
            var value = given[prop];
            if (typeof value === "number" && exports.numericCSSProperties.includes(prop))
                value = value + "px";
            actual[prop] = given[prop];
        }
    }
    function assignAttributes(attrs, element) {
        if (!attrs)
            return;
        for (var attr in attrs) {
            if (attr === "ref")
                continue;
            var value = attrs[attr];
            if (value === null || value === undefined)
                continue;
            if (attr === "style")
                assignStyle(value, element.style);
            else
                element[attr] = value;
        }
    }
    /**
     * Creates DOM element from given tag name.
     * @param name DOM element tag.
     * @param attrs Attributes to assign.
     * @param children Children to append.
     */
    function createIntrinsicElement(name, attrs, children) {
        var elt = document.createElement(name);
        assignAttributes(attrs, elt);
        var str = ""; // optimisation
        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
            var collection = children_1[_i];
            var col = Array.isArray(collection) ? collection : [collection];
            for (var _a = 0, col_1 = col; _a < col_1.length; _a++) {
                var child = col_1[_a];
                if (isTruthy(child)) {
                    if (typeof child === "object") {
                        if (!(child instanceof Element))
                            throw new InvalidChildElement(child);
                        if (str) {
                            elt.insertAdjacentText("beforeend", str);
                            str = "";
                        }
                        elt.insertAdjacentElement("beforeend", child);
                    }
                    else
                        str += child.toString();
                }
            }
        }
        if (str)
            elt.insertAdjacentText("beforeend", str);
        if (attrs && attrs.ref)
            attrs.ref(elt);
        return elt;
    }
    InterfaceBuilder.createIntrinsicElement = createIntrinsicElement;
    /**
     * Retrievers element collection from given provider.
     * @param provider Provider to use.
     * @param attrs Attributes to assign.
     * @param children Children to append.
     */
    function createFunctionalElement(provider, attrs, children) {
        return provider(attrs, flatten(children));
    }
    InterfaceBuilder.createFunctionalElement = createFunctionalElement;
    /**
     * Instantiates given component class and renders it's content.
     * @param componentClass Component class to instantiate and use.
     * @param attrs Attributes to assign.
     * @param children Children to append.
     */
    function createComponentClassElement(componentClass, attrs, children) {
        var c = flatten(children);
        var instance;
        if (componentClass.instanceProvider)
            instance = componentClass.instanceProvider(attrs, c);
        if (!instance && componentClass.instance)
            instance = componentClass.instance;
        if (!instance) {
            instance = new componentClass(attrs);
            instance.attrs = attrs;
            if (componentClass.instanceCreated)
                componentClass.instanceCreated(instance);
        }
        return instance.render(attrs, c);
    }
    InterfaceBuilder.createComponentClassElement = createComponentClassElement;
    /**
     * Renders contents of a JSX component.
     * @param component Component to render.
     * @param attrs Attributes to assign.
     * @param children Children to append.
     */
    function createComponentInstanceElement(component, attrs, children) {
        if (component.componentWillReceiveAttrs)
            component.componentWillReceiveAttrs(attrs);
        component.attrs = attrs;
        return component.render(attrs, flatten(children));
    }
    InterfaceBuilder.createComponentInstanceElement = createComponentInstanceElement;
    function createElement(factory, attrs) {
        var children = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            children[_i - 2] = arguments[_i];
        }
        if (typeof factory === "string")
            return createIntrinsicElement(factory, attrs || {}, children);
        else if (typeof factory.prototype.render === "function")
            return createComponentClassElement(factory, attrs || {}, children);
        else
            return createFunctionalElement(factory, attrs || {}, children);
    }
    InterfaceBuilder.createElement = createElement;
    /**
     * Creates document fragment which inclueds given elements. Use this to apply multiple elements to the DOM.
     * @param elementCollection Elements to include.
     */
    function createFragment(elementCollection) {
        var fragment = document.createDocumentFragment();
        filter(elementCollection).forEach(function (elt) { return fragment.appendChild(elt); });
        return fragment;
    }
    InterfaceBuilder.createFragment = createFragment;
    /**
     * Appends element to DOM.
     * @param element Element to append to.
     * @param elementCollection Elements to append.
     */
    function append(element, elementCollection) {
        element.appendChild(createFragment(elementCollection));
    }
    InterfaceBuilder.append = append;
    /**
     * Clears all element's content.
     * @param element Element which's content to clear.
     */
    function clearContent(element) {
        /*
         * This is much faster than elment.innerHTML = "";
         * See https://stackoverflow.com/questions/3955229/remove-all-child-elements-of-a-dom-node-in-javascript
         */
        while (element.firstChild)
            element.removeChild(element.firstChild);
    }
    InterfaceBuilder.clearContent = clearContent;
    /**
     * Replaces element's content with given elements.
     * @param element Element which's content to replace.
     * @param elementCollection Elements to insert.
     */
    function replaceContent(element, elementCollection) {
        clearContent(element);
        append(element, elementCollection);
    }
    InterfaceBuilder.replaceContent = replaceContent;
    /**
     * Replaces element with other elements.
     * @param element Element to remove and replace.
     * @param elementCollection Elements to insert.
     */
    function replace(element, elementCollection) {
        var parent = element.parentElement;
        if (!parent)
            throw new Error("No parent element found.");
        parent.insertBefore(createFragment(elementCollection), element);
        element.remove();
    }
    InterfaceBuilder.replace = replace;
    function internalHideElement(element) {
        element.classList.add("hide");
    }
    function internalShowElement(element) {
        element.classList.remove("hide");
    }
})(InterfaceBuilder = exports.InterfaceBuilder || (exports.InterfaceBuilder = {}));


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var MikelsonParts_1 = __webpack_require__(12);
var Ground_1 = __webpack_require__(19);
var BasePlayer = /** @class */ (function (_super) {
    __extends(BasePlayer, _super);
    function BasePlayer(x, y, controlSet, state) {
        var _this = _super.call(this, x, y, BasePlayer.size.w, BasePlayer.size.h, ex.Color.Violet) || this;
        _this.dead = false;
        _this.won = false;
        _this.collisionArea.body.useBoxCollision();
        _this.collisionType = ex.CollisionType.Active;
        _this.controls = controlSet;
        _this.state = state;
        _this.cameraStrategy = new ex.LockCameraToActorAxisStrategy(_this, ex.Axis.X);
        return _this;
    }
    BasePlayer.prototype.die = function (info) {
        var _this = this;
        if (!this.dead) {
            if (this.state.lives > 1) {
                this.state.lives -= 1;
                this.dead = true;
                this.scene.camera.shake(10, 10, 100);
                setTimeout(function () { _this.dead = false; }, 800);
            }
            else {
                this.state.lives = 0;
                this.dead = true;
                this.scene.camera.shake(50, 50, 500);
                this.kill();
                this.x = -1000;
                this.emit("death");
            }
        }
    };
    BasePlayer.prototype.win = function (info) {
        if (!this.won) {
            this.won = true;
            this.emit("won");
        }
    };
    // check if the player is at ground level
    BasePlayer.prototype.isGround = function () {
        var groundLevel = this.scene.engine.getWorldBounds().bottom - Ground_1.default.height;
        return groundLevel - this.getBottom() <= 5;
    };
    BasePlayer.size = MikelsonParts_1.modelSize;
    return BasePlayer;
}(ex.Actor));
exports.default = BasePlayer;
var controls1 = {
    up: ex.Input.Keys.Up,
    down: ex.Input.Keys.Down,
    left: ex.Input.Keys.Left,
    right: ex.Input.Keys.Right
};
var controls2 = {
    up: ex.Input.Keys.W,
    down: ex.Input.Keys.S,
    left: ex.Input.Keys.A,
    right: ex.Input.Keys.D
};
exports.controlSets = {
    controls1: controls1,
    controls2: controls2
};


/***/ }),
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationHelpers_1 = __webpack_require__(35);
exports.image = __webpack_require__(83);
exports.imageBro = __webpack_require__(84);
exports.imageDuck = __webpack_require__(85);
exports.imageDuckBro = __webpack_require__(86);
exports.texture = new AnimationHelpers_1.CustomTexture(exports.image);
exports.textureBro = new AnimationHelpers_1.CustomTexture(exports.imageBro);
exports.textureDuck = new AnimationHelpers_1.CustomTexture(exports.imageDuck);
exports.textureDuckBro = new AnimationHelpers_1.CustomTexture(exports.imageDuckBro);
exports.modelSize = {
    w: 45,
    h: 135
};
exports.modelDuckSize = {
    w: 58,
    h: 100
};
exports.modelSwimSize = {
    w: 128,
    h: 42
};
var dh = exports.modelSize.h - exports.modelDuckSize.h;
var armSize = {
    w: 16,
    h: 58,
};
var armAnchor = {
    x: 9,
    y: 5
};
var legSize = {
    w: 31,
    h: 59
};
var legAnchor = {
    x: 31,
    y: 6
};
var headSize = {
    w: 45,
    h: 43
};
var headAnchor = {
    x: 45 / 2,
    y: 43 / 2
};
var torsoSize = {
    w: 30,
    h: 59
};
var torsoAnchor = {
    x: 15,
    y: 59 / 2
};
var legDuckSize = {
    w: 47,
    h: 45
};
var legDuckAnchor = {
    x: 40,
    y: 21
};
var armRight = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 172, y: 29 }, armSize),
    modelLocation: __assign({ x: 17, y: 47 }, armSize),
    anchor: __assign({}, armAnchor)
};
var armLeft = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 147, y: 29 }, armSize),
    modelLocation: __assign({ x: 17, y: 47 }, armSize),
    anchor: __assign({}, armAnchor)
};
var legRight = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 211, y: 28 }, legSize),
    modelLocation: __assign({ x: 4, y: 76 }, legSize),
    anchor: __assign({}, legAnchor)
};
var legLeft = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 252, y: 29 }, legSize),
    modelLocation: __assign({ x: 4, y: 76 }, legSize),
    anchor: __assign({}, legAnchor)
};
var headRight = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 19, y: 65 }, headSize),
    modelLocation: __assign({ x: 0, y: 0 }, headSize),
    anchor: __assign({}, headAnchor)
};
var headLeft = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 17, y: 10 }, headSize),
    modelLocation: __assign({ x: 0, y: 0 }, headSize),
    anchor: __assign({}, headAnchor)
};
var torso = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 86, y: 29 }, torsoSize),
    modelLocation: __assign({ x: 8, y: 39 }, torsoSize),
    anchor: __assign({}, torsoAnchor)
};
var legDuckRight = {
    texture: exports.textureDuck,
    sourceLocation: __assign({ x: 65, y: 16 }, legDuckSize),
    modelLocation: __assign({ x: -11, y: 66 + (dh / 2) }, legDuckSize),
    anchor: __assign({}, legDuckAnchor)
};
var legDuckLeft = {
    texture: exports.textureDuck,
    sourceLocation: __assign({ x: 9, y: 18 }, legDuckSize),
    modelLocation: __assign({ x: -11, y: 66 + (dh / 2) }, legDuckSize),
    anchor: __assign({}, legDuckAnchor)
};
var _sprites = {};
var _spritesBro = {};
var texturesBro = {
    armRight: exports.textureBro,
    armLeft: exports.textureBro,
    legRight: exports.textureBro,
    legLeft: exports.textureBro,
    legDuckRight: exports.textureDuckBro,
    legDuckLeft: exports.textureDuckBro,
    headRight: exports.textureBro,
    headLeft: exports.textureBro,
    torso: exports.textureBro,
};
var _bodyParts = {
    armRight: armRight,
    armLeft: armLeft,
    legRight: legRight,
    legLeft: legLeft,
    legDuckRight: legDuckRight,
    legDuckLeft: legDuckLeft,
    headRight: headRight,
    headLeft: headLeft,
    torso: torso
};
var allParts = [
    armRight,
    armLeft,
    legRight,
    legLeft,
    legDuckRight,
    legDuckLeft,
    headRight,
    headLeft,
    torso
];
var rightParts = [
    armRight,
    legRight,
    legDuckRight,
    headRight
];
var centerPart = function (part) {
    var ml = part.modelLocation;
    ml.x -= exports.modelSize.w / 2;
    // ml.y -= modelSize.h / 2;
    ml.y -= exports.modelSize.h;
    ml.x += part.anchor.x;
    ml.y += part.anchor.y;
};
var shiftRight = function (part) {
    part.modelLocation.x = -part.modelLocation.x;
    part.anchor.x = part.modelLocation.w - part.anchor.x;
};
allParts.forEach(centerPart);
rightParts.forEach(shiftRight);
Object.entries(_bodyParts).forEach(function (_a) {
    var key = _a[0], _b = _a[1], texture = _b.texture, loc = _b.sourceLocation;
    _sprites[key] = new AnimationHelpers_1.CustomSprite(texture, loc.x, loc.y, loc.w, loc.h);
    _spritesBro[key] = new AnimationHelpers_1.CustomSprite(texturesBro[key], loc.x, loc.y, loc.w, loc.h);
});
exports.bodyParts = _bodyParts;
exports.sprites = _sprites;
exports.spritesBro = _spritesBro;


/***/ }),
/* 13 */,
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var DrawAnimationFactory_1 = __webpack_require__(27);
var MikelsonParts_1 = __webpack_require__(12);
exports.playerAnimationTypes = [
    "idle-right",
    "idle-left",
    "walk-right",
    "walk-left",
    "jump-right",
    "jump-left",
    "duck-right",
    "duck-left",
    "walk-fast-right",
    "walk-fast-left",
    "walk-slow-right",
    "walk-slow-left",
    "grab-right",
    "swim-right",
    "swim-right-fast",
    "swim-right-slow",
];
var _states = {
    idleLeft: "idle-left",
    walkRight: "walk-right",
    walkLeft: "walk-left",
    jumpRight: "jump-right",
    jumpLeft: "jump-left",
    duckRight: "duck-right",
    duckLeft: "duck-left",
    walkFastRight: "walk-fast-right",
    walkFastLeft: "walk-fast-left",
    walkSlowRight: "walk-slow-right",
    walkSlowLeft: "walk-slow-left",
};
exports.states = _states;
var beforeDrawFactory = function (bodyPartRight, bodyPartLeft) { return function (sprites) {
    var bpr = MikelsonParts_1.bodyParts[bodyPartRight];
    var bpl = MikelsonParts_1.bodyParts[bodyPartLeft];
    return function (ctx, _, position, state) {
        if (state.includes("right"))
            return { translateX: bpr.modelLocation.x, translateY: bpr.modelLocation.y };
        else
            return { translateX: bpl.modelLocation.x, translateY: bpl.modelLocation.y };
    };
}; };
var drawBaseFactory = function (bodyPartRight, bodyPartLeft) { return function (sprites) {
    var spr = sprites[bodyPartRight];
    var spl = sprites[bodyPartLeft];
    var bpr = MikelsonParts_1.bodyParts[bodyPartRight].anchor;
    var bpl = MikelsonParts_1.bodyParts[bodyPartLeft].anchor;
    return function (ctx, _, __, state) {
        if (state.includes("right"))
            spr.draw(ctx, -bpr.x, -bpr.y);
        else
            spl.draw(ctx, -bpl.x, -bpl.y);
    };
}; };
exports.baseDataExtender = function (irlData, sprites) {
    var states = irlData.states, selectedState = irlData.selectedState;
    var itData = {
        states: states,
        selectedState: selectedState,
        beforeDraw: irlData.beforeDraw && irlData.beforeDraw(sprites),
        drawBase: irlData.drawBase(sprites)
    };
    if (irlData.baseStates)
        Object.entries(irlData.baseStates).forEach(function (_a) {
            var key = _a[0], state = _a[1];
            itData.states[key + "-right"] = state;
            itData.states[key + "-left"] = state;
        });
    return itData;
};
exports.selectedState = "idle-right";
var deg90 = Math.PI / 2;
var baseArmTransform = {
    translateX: 20,
    translateY: 82,
};
var baseLegTransform = {
    translateX: -7,
    translateY: 46,
};
var baseTorsoTransform = {
    rotate: deg90,
    translateY: 68
};
var baseHeadTransform = {
    translateX: 45,
    translateY: 114,
};
exports.armFront = {
    selectedState: exports.selectedState,
    drawBase: drawBaseFactory("armRight", "armLeft"),
    beforeDraw: beforeDrawFactory("armRight", "armLeft"),
    states: {
        "jump-right": {
            duration: 800,
            start: { rotate: -2.2, translateX: 5 },
            end: { rotate: -2.5, translateX: 5 },
            transitionDuration: 100
        },
        "jump-left": {
            duration: 800,
            start: { rotate: 2.2, translateX: -5 },
            end: { rotate: 2.5, translateX: -5 },
            transitionDuration: 100
        },
        "grab-right": {
            duration: 800,
            start: { rotate: -3 - .03, translateX: -5 },
            end: { rotate: -3 + .03, translateX: -5 },
            transitionDuration: 100
        },
        "swim-right": {
            duration: 500,
            start: __assign({ rotate: -deg90 + -0.5 }, baseArmTransform),
            end: __assign({ rotate: -deg90 + 0.5 }, baseArmTransform),
            transitionDuration: 200
        },
        "swim-right-fast": {
            duration: 300,
            start: __assign({ rotate: -deg90 + -0.5 }, baseArmTransform),
            end: __assign({ rotate: -deg90 + 0.5 }, baseArmTransform),
            transitionDuration: 200
        },
        "swim-right-slow": {
            duration: 700,
            start: __assign({ rotate: -deg90 + -0.5 }, baseArmTransform),
            end: __assign({ rotate: -deg90 + 0.5 }, baseArmTransform),
            transitionDuration: 200
        },
    },
    baseStates: {
        idle: {
            duration: 1000,
            start: { rotate: -0.1 },
            end: { rotate: 0.1 },
            transitionDuration: 200
        },
        walk: {
            duration: 400,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 250,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 600,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        duck: {
            duration: 1000,
            start: { rotate: -0.1, translateY: 20 },
            end: { rotate: 0.1, translateY: 20 },
            transitionDuration: 100
        }
    }
};
exports.armBack = {
    selectedState: exports.selectedState,
    drawBase: drawBaseFactory("armRight", "armLeft"),
    beforeDraw: beforeDrawFactory("armRight", "armLeft"),
    states: {
        "jump-right": {
            duration: 800,
            start: { rotate: -1.9, translateX: 5 },
            end: { rotate: -2.2, translateX: 5 },
            transitionDuration: 100
        },
        "jump-left": {
            duration: 800,
            start: { rotate: 1.9, translateX: -5 },
            end: { rotate: 2.2, translateX: -5 },
            transitionDuration: 100
        },
        "grab-right": {
            duration: 800,
            start: { rotate: -3 + .03, translateX: -5 },
            end: { rotate: -3 - .03, translateX: -5 },
            transitionDuration: 100
        },
        "swim-right": {
            duration: 500,
            start: __assign({ rotate: -deg90 + 0.5 }, baseArmTransform),
            end: __assign({ rotate: -deg90 + -0.5 }, baseArmTransform),
            transitionDuration: 200
        },
        "swim-right-fast": {
            duration: 300,
            start: __assign({ rotate: -deg90 + 0.5 }, baseArmTransform),
            end: __assign({ rotate: -deg90 + -0.5 }, baseArmTransform),
            transitionDuration: 200
        },
        "swim-right-slow": {
            duration: 700,
            start: __assign({ rotate: -deg90 + 0.5 }, baseArmTransform),
            end: __assign({ rotate: -deg90 + -0.5 }, baseArmTransform),
            transitionDuration: 200
        },
    },
    baseStates: {
        idle: {
            duration: 1000,
            start: { rotate: 0.1 },
            end: { rotate: -0.1 },
            transitionDuration: 200
        },
        walk: {
            duration: 400,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 250,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 600,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        duck: {
            duration: 1000,
            start: { rotate: 0.1, translateY: 20 },
            end: { rotate: -0.1, translateY: 20 },
            transitionDuration: 100
        }
    }
};
exports.legFront = {
    selectedState: exports.selectedState,
    drawBase: drawBaseFactory("legRight", "legLeft"),
    beforeDraw: beforeDrawFactory("legRight", "legLeft"),
    states: {
        "jump-right": {
            duration: 500,
            start: { rotate: 0.4, translateX: -5 },
            end: { rotate: 0.55, translateX: -5 },
            transitionDuration: 200
        },
        "jump-left": {
            duration: 500,
            start: { rotate: -0.4, translateX: 5 },
            end: { rotate: -0.55, translateX: 5 },
            transitionDuration: 200
        },
        "grab-right": {
            duration: 500,
            start: { rotate: 0.15 },
            end: { rotate: -0.15 },
            transitionDuration: 200
        },
        "swim-right": {
            duration: 500,
            start: __assign({ rotate: deg90 - 0.3 }, baseLegTransform),
            end: __assign({ rotate: deg90 + 0.3 }, baseLegTransform),
            transitionDuration: 200
        },
        "swim-right-fast": {
            duration: 300,
            start: __assign({ rotate: deg90 - 0.3 }, baseLegTransform),
            end: __assign({ rotate: deg90 + 0.3 }, baseLegTransform),
            transitionDuration: 200
        },
        "swim-right-slow": {
            duration: 700,
            start: __assign({ rotate: deg90 - 0.3 }, baseLegTransform),
            end: __assign({ rotate: deg90 + 0.3 }, baseLegTransform),
            transitionDuration: 200
        },
    },
    baseStates: {
        idle: {
            transitionDuration: 200,
            start: {},
            end: {},
            duration: 1000
        },
        walk: {
            duration: 400,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 250,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 600,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        }
    }
};
exports.legBack = {
    selectedState: exports.selectedState,
    drawBase: drawBaseFactory("legRight", "legLeft"),
    beforeDraw: beforeDrawFactory("legRight", "legLeft"),
    states: {
        "jump-right": {
            duration: 500,
            start: { rotate: -0.15, translateX: -5 },
            end: { rotate: -0.3, translateX: -5 },
            transitionDuration: 200
        },
        "jump-left": {
            duration: 500,
            start: { rotate: 0.15, translateX: 5 },
            end: { rotate: 0.3, translateX: 5 },
            transitionDuration: 200
        },
        "grab-right": {
            duration: 500,
            start: { rotate: -0.15 },
            end: { rotate: 0.15 },
            transitionDuration: 200
        },
        "swim-right": {
            duration: 500,
            start: __assign({ rotate: deg90 + 0.3 }, baseLegTransform),
            end: __assign({ rotate: deg90 - 0.3 }, baseLegTransform),
            transitionDuration: 200
        },
        "swim-right-fast": {
            duration: 300,
            start: __assign({ rotate: deg90 + 0.3 }, baseLegTransform),
            end: __assign({ rotate: deg90 - 0.3 }, baseLegTransform),
            transitionDuration: 200
        },
        "swim-right-slow": {
            duration: 700,
            start: __assign({ rotate: deg90 + 0.3 }, baseLegTransform),
            end: __assign({ rotate: deg90 - 0.3 }, baseLegTransform),
            transitionDuration: 200
        },
    },
    baseStates: {
        idle: {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        walk: {
            duration: 400,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 250,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 600,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        }
    }
};
exports.legDuckFront = {
    selectedState: exports.selectedState,
    drawBase: drawBaseFactory("legDuckRight", "legDuckLeft"),
    beforeDraw: beforeDrawFactory("legDuckRight", "legDuckLeft"),
    states: {},
    baseStates: {
        duck: {
            duration: 600,
            start: { rotate: 0.1 },
            end: { rotate: -0.1 },
            transitionDuration: 100
        }
    }
};
exports.legDuckBack = {
    selectedState: exports.selectedState,
    drawBase: drawBaseFactory("legDuckRight", "legDuckLeft"),
    beforeDraw: beforeDrawFactory("legDuckRight", "legDuckLeft"),
    states: {},
    baseStates: {
        duck: {
            duration: 600,
            start: { rotate: -0.1 },
            end: { rotate: 0.1 },
            transitionDuration: 100
        }
    }
};
exports.torso = {
    selectedState: exports.selectedState,
    beforeDraw: function () { return function () {
        return { translateX: MikelsonParts_1.bodyParts.torso.modelLocation.x, translateY: MikelsonParts_1.bodyParts.torso.modelLocation.y };
    }; },
    drawBase: function (sprites) { return function (ctx) {
        var _a = MikelsonParts_1.bodyParts.torso.anchor, x = _a.x, y = _a.y;
        sprites.torso.draw(ctx, -x, -y);
    }; },
    states: {
        "jump-right": {
            duration: 1000,
            start: { rotate: 0.2 },
            end: { rotate: 0.2 },
            transitionDuration: 200
        },
        "jump-left": {
            duration: 1000,
            start: { rotate: -0.2 },
            end: { rotate: -0.2 },
            transitionDuration: 200
        },
        "grab-right": {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        "swim-right": {
            start: __assign({}, baseTorsoTransform),
            end: __assign({}, baseTorsoTransform),
        },
        "swim-right-fast": {
            start: __assign({}, baseTorsoTransform),
            end: __assign({}, baseTorsoTransform),
        },
        "swim-right-slow": {
            start: __assign({}, baseTorsoTransform),
            end: __assign({}, baseTorsoTransform),
        }
    },
    baseStates: {
        idle: {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        walk: {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        duck: {
            duration: 1000,
            start: { rotate: 0, translateY: 18 },
            end: { rotate: 0, translateY: 18 },
            transitionDuration: 100
        }
    }
};
exports.head = {
    selectedState: exports.selectedState,
    beforeDraw: function () { return function (_, __, ___, state) {
        var _a = MikelsonParts_1.bodyParts.headRight.modelLocation, xr = _a.x, yr = _a.y;
        var _b = MikelsonParts_1.bodyParts.headLeft.modelLocation, xl = _b.x, yl = _b.y;
        if (state.includes("right"))
            return { translateX: xr, translateY: yr };
        else
            return { translateX: xl, translateY: yl };
    }; },
    drawBase: function (sprites) { return function (ctx, _, __, state) {
        var _a = MikelsonParts_1.bodyParts.headRight.anchor, xr = _a.x, yr = _a.y;
        var _b = MikelsonParts_1.bodyParts.headLeft.anchor, xl = _b.x, yl = _b.y;
        if (state.includes("right"))
            sprites.headRight.draw(ctx, -xr, -yr);
        else
            sprites.headLeft.draw(ctx, -xl, -yl);
    }; },
    states: {
        "jump-right": {
            duration: 500,
            start: { rotate: 0.1, translateX: 5 },
            end: { rotate: -0.1, translateX: 5 },
            transitionDuration: 200
        },
        "jump-left": {
            duration: 500,
            start: { rotate: -0.1, translateX: -5 },
            end: { rotate: 0.1, translateX: -5 },
            transitionDuration: 200
        },
        "grab-right": {
            duration: 500,
            start: { rotate: -0.1 },
            end: { rotate: 0.1 },
            transitionDuration: 200
        },
        "swim-right": {
            duration: 500,
            start: __assign({ rotate: deg90 + 0.2 }, baseHeadTransform),
            end: __assign({ rotate: deg90 - 0.2 }, baseHeadTransform),
            transitionDuration: 200
        },
        "swim-right-fast": {
            duration: 300,
            start: __assign({ rotate: deg90 + 0.2 }, baseHeadTransform),
            end: __assign({ rotate: deg90 - 0.2 }, baseHeadTransform),
            transitionDuration: 200
        },
        "swim-right-slow": {
            duration: 700,
            start: __assign({ rotate: deg90 + 0.2 }, baseHeadTransform),
            end: __assign({ rotate: deg90 - 0.2 }, baseHeadTransform),
            transitionDuration: 200
        },
    },
    baseStates: {
        idle: {
            duration: 1500,
            start: { rotate: 0.05 },
            end: { rotate: -0.05 },
            transitionDuration: 200
        },
        walk: {
            duration: 600,
            start: { rotate: -0.2 },
            end: { rotate: 0.2 },
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 400,
            start: { rotate: -0.2 },
            end: { rotate: 0.2 },
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 800,
            start: { rotate: -0.2 },
            end: { rotate: 0.2 },
            transitionDuration: 200
        },
        duck: {
            duration: 900,
            start: { rotate: -0.1, translateY: 25 },
            end: { rotate: 0.1, translateY: 25 },
            transitionDuration: 100
        }
    }
};
exports.allData = [
    exports.legBack,
    exports.legDuckBack,
    exports.armBack,
    exports.torso,
    exports.head,
    exports.legFront,
    exports.legDuckFront,
    exports.armFront,
];
exports.animationProviders = exports.allData
    .map(function (t) { return exports.baseDataExtender(t, MikelsonParts_1.sprites); })
    .map(function (t) { return DrawAnimationFactory_1.createTransformDrawSetProvider(t); });
exports.animationProvidersBro = exports.allData
    .map(function (t) { return exports.baseDataExtender(t, MikelsonParts_1.spritesBro); })
    .map(function (t) { return DrawAnimationFactory_1.createTransformDrawSetProvider(t); });
exports.playerAnimationFactory = new DrawAnimationFactory_1.TransformDrawAnimationFactory(exports.animationProviders);
exports.brotherAnimationFactory = new DrawAnimationFactory_1.TransformDrawAnimationFactory(exports.animationProvidersBro);


/***/ }),
/* 15 */,
/* 16 */,
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excalibur_1 = __webpack_require__(0);
/**
 * Base class which implements stronlgy-typed event handling. Preferd over Excalibur's.
 */
var Class = /** @class */ (function () {
    function Class() {
        this.eventDispatcher = new excalibur_1.EventDispatcher(this);
    }
    /**
     * Alias for `addEventListener`. You can listen for a variety of
     * events off of the engine; see the events section below for a complete list.
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    Class.prototype.on = function (eventName, handler) {
        this.eventDispatcher.on(eventName, handler);
    };
    /**
     * Alias for `removeEventListener`. If only the eventName is specified
     * it will remove all handlers registered for that specific event. If the eventName
     * and the handler instance are specified only that handler will be removed.
     *
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    Class.prototype.off = function (eventName, handler) {
        this.eventDispatcher.off(eventName, handler);
    };
    /**
     * Emits a new event
     * @param eventName   Name of the event to emit
     * @param eventObject Data associated with this event
     */
    Class.prototype.emit = function (eventName, event) {
        this.eventDispatcher.emit(eventName, event);
    };
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    Class.prototype.once = function (eventName, handler) {
        this.eventDispatcher.once(eventName, handler);
    };
    return Class;
}());
exports.Class = Class;


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["isObject"] = isObject;
/* harmony export (immutable) */ __webpack_exports__["isNumber"] = isNumber;
/* harmony export (immutable) */ __webpack_exports__["isString"] = isString;
/* harmony export (immutable) */ __webpack_exports__["isFunction"] = isFunction;
/* harmony export (immutable) */ __webpack_exports__["isArray"] = isArray;
/* harmony export (immutable) */ __webpack_exports__["isNull"] = isNull;
/* harmony export (immutable) */ __webpack_exports__["isUndefined"] = isUndefined;
/* harmony export (immutable) */ __webpack_exports__["extend"] = extend;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["randInt"] = randInt;
// Data type check

function isObject(value, ignoreArray) {
	return typeof value === 'object' && value !== null;
}

function isNumber(value) {
	return typeof value === 'number';
}

function isString(value) {
	return typeof value === 'string';
}

function isFunction(value) {
	return typeof value === 'function';
}

function isArray(value) {
	return Array.isArray(value);
	// return Object.prototype.toString.call(value) === '[object Array]';
}

function isNull(value) {
	return value === null;
}

function isUndefined(value) {
	return typeof value === 'undefined';
}

// global.isObject = isObject;
// global.isNumber = isNumber;
// global.isString = isString;
// global.isFunction = isFunction;
// global.isArray = isArray;
// global.isNull = isNull;
// global.isUndefined = isUndefined;

/**
 * extend
 */
function extend() {
	var target = arguments[0] || {},
	    o,
	    p;

	for (var i = 1, len = arguments.length; i < len; i++) {
		o = arguments[i];

		if (!isObject(o)) continue;

		for (p in o) {
			target[p] = o[p];
		}
	}

	return target;
}

// global.extend = extend;


// Random

function random(max, min) {
	if (isNaN(Number(max))) return Math.random();
	if (isNaN(Number(min))) min = 0;
	return Math.random() * (max - min) + min;
}

function randInt(max, min) {
	if (isNaN(Number(max))) return NaN;
	if (isNaN(Number(min))) min = 0;
	return Math.floor(Math.random() * (max - min + 1) + min);
}

// global.random = random;
// global.random = randInt;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
// import resources from "../Resources";
var Ground = /** @class */ (function (_super) {
    __extends(Ground, _super);
    function Ground(x, y, texture, width) {
        var _this = _super.call(this, x, y, width, Ground.height, ex.Color.Gray) || this;
        _this.collisionType = ex.CollisionType.Fixed;
        _this.sprite = texture.asSprite();
        _this.sprite.anchor.setTo(0, 1);
        _this.width = width;
        return _this;
    }
    Ground.prototype.draw = function (ctx, delta) {
        var offset = 0;
        while (offset < this.width) {
            this.sprite.draw(ctx, this.getLeft() + offset, this.getBottom());
            offset += this.sprite.width;
        }
    };
    Ground.height = 40;
    return Ground;
}(ex.Actor));
exports.default = Ground;


/***/ }),
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Class_1 = __webpack_require__(17);
var AnimationSequence = /** @class */ (function (_super) {
    __extends(AnimationSequence, _super);
    function AnimationSequence(states) {
        var _this = _super.call(this) || this;
        _this.states = states;
        _this.index = -1; // not running if less than 0
        _this.awaiting = 0;
        _this.animationFrames = {};
        _this.subSequences = [];
        _this.timeoutId = NaN;
        _this.timestamp = 0;
        return _this;
    }
    AnimationSequence.prototype.start = function () {
        if (this.index >= 0)
            return; // already running
        this.index = -1;
        this.performStep();
    };
    AnimationSequence.prototype.performStep = function () {
        var _this = this;
        this.index++;
        if (this.index >= this.states.length) {
            this.done();
            return;
        }
        var step = this.states[this.index];
        this.awaiting = 0;
        if (!step || step === true) {
            this.performStep();
        }
        else if (typeof step === "number") {
            this.doDelay(step);
        }
        else if (step instanceof Promise) {
            this.awaitPromise(step);
        }
        else {
            var _loop_1 = function (item) {
                if (typeof item === "function") {
                    var id_1 = Symbol();
                    this_1.awaiting++;
                    this_1.animationFrames[id_1] = requestAnimationFrame(function () {
                        delete _this.animationFrames[id_1];
                        item();
                        _this.checkProgress();
                    });
                }
                else if (item instanceof AnimationSequence) {
                    this_1.awaiting++;
                    this_1.subSequences.push(item);
                    item.start();
                    item.once("done", function (_a) {
                        var cancelled = _a.cancelled;
                        var index = _this.subSequences.indexOf(item);
                        _this.subSequences.splice(index, 1);
                        if (cancelled) {
                            _this.cancel();
                        }
                        else {
                            _this.checkProgress();
                        }
                    });
                }
                else {
                    this_1.doAnimation(item);
                }
            };
            var this_1 = this;
            for (var _i = 0, _a = Array.isArray(step) ? step : [step]; _i < _a.length; _i++) {
                var item = _a[_i];
                _loop_1(item);
            }
        }
    };
    AnimationSequence.prototype.doAnimation = function (animation) {
        var _this = this;
        this.awaiting++;
        var id = Symbol();
        var start = this.timestamp = performance.now();
        var end = start + animation.duration;
        var duration = end - start;
        var from = animation.from, to = animation.to, callback = animation.callback, easing = animation.easing;
        var diff = to - from;
        var render = function (delta) {
            if (delta > end) {
                callback(to);
                _this.checkProgress();
                delete _this.animationFrames[id];
            }
            else {
                var path = (delta - start) / duration;
                if (easing)
                    path = easing(path);
                var value = path * diff + from;
                callback(value);
                _this.animationFrames[id] = requestAnimationFrame(render);
            }
        };
        this.animationFrames[id] = requestAnimationFrame(render);
    };
    AnimationSequence.prototype.checkProgress = function () {
        if (--this.awaiting <= 0)
            this.performStep();
    };
    AnimationSequence.prototype.awaitPromise = function (promise) {
        var _this = this;
        promise
            .then(function () { return _this.performStep(); })
            .catch(function () { return _this.cancel(); });
    };
    AnimationSequence.prototype.doDelay = function (delay) {
        var _this = this;
        this.timeoutId = setTimeout(function () {
            _this.timeoutId = NaN;
            _this.performStep();
        }, delay);
    };
    AnimationSequence.prototype.done = function (cancelled) {
        if (cancelled === void 0) { cancelled = false; }
        this.index = -1;
        if (cancelled)
            this.emit("cancelled", this);
        else
            this.emit("finished", this);
        this.emit("done", {
            target: this,
            cancelled: cancelled
        });
    };
    AnimationSequence.prototype.cancel = function () {
        if (!Number.isNaN(this.timeoutId))
            clearTimeout(this.timeoutId);
        for (var _i = 0, _a = Object.getOwnPropertySymbols(this.animationFrames); _i < _a.length; _i++) {
            var symbol = _a[_i];
            cancelAnimationFrame(this.animationFrames[symbol]);
        }
        for (var _b = 0, _c = this.subSequences; _b < _c.length; _b++) {
            var subSequence = _c[_b];
            subSequence.cancel();
        }
        this.subSequences = [];
        this.animationFrames = {};
        this.timeoutId = NaN;
        this.done(true);
    };
    return AnimationSequence;
}(Class_1.Class));
exports.AnimationSequence = AnimationSequence;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var excalibur_1 = __webpack_require__(0);
var Class_1 = __webpack_require__(17);
var DrawAnimation_1 = __webpack_require__(124);
var TransformDrawPart_1 = __webpack_require__(125);
var TransformDrawSet_1 = __webpack_require__(126);
var TransformDrawAnimationFactory = /** @class */ (function (_super) {
    __extends(TransformDrawAnimationFactory, _super);
    function TransformDrawAnimationFactory(sets) {
        var _this = _super.call(this) || this;
        _this.sets = sets;
        return _this;
    }
    TransformDrawAnimationFactory.prototype.create = function () {
        var drawSets = this.sets.map(function (t) { return t(); });
        var a = new DrawAnimation_1.DrawAnimation(drawSets);
        this.emit("created", a);
        return a;
    };
    TransformDrawAnimationFactory.prototype.attachTo = function (actor) {
        var a = this.create();
        if (actor instanceof excalibur_1.Actor)
            actor.draw = function (ctx, delta) {
                a.draw(ctx, this.getWorldPos());
            };
        else
            actor.prototype.draw = function (ctx, delta) {
                a.draw(ctx, this.getWorldPos());
            };
        return a;
    };
    return TransformDrawAnimationFactory;
}(Class_1.Class));
exports.TransformDrawAnimationFactory = TransformDrawAnimationFactory;
function createTransformDrawSetProvider(data, anchor) {
    var states = data.states, selectedState = data.selectedState, drawBase = data.drawBase, beforeDraw = data.beforeDraw;
    return function () {
        var state = states[selectedState];
        var part = new TransformDrawPart_1.TransformDrawPart(state && state.start || {}, state && state.end || {}, state && state.duration || 0, state && state.easing, anchor);
        part.drawBase = drawBase;
        if (beforeDraw)
            part.beforeDraw = beforeDraw;
        return new TransformDrawSet_1.TransformDrawSet(states, selectedState, part);
    };
}
exports.createTransformDrawSetProvider = createTransformDrawSetProvider;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Class_1 = __webpack_require__(17);
var GameBootstrap_1 = __webpack_require__(34);
var Ground_1 = __webpack_require__(19);
var Background_1 = __webpack_require__(142);
var LockLevelCameraStrategy_1 = __webpack_require__(143);
var BaseLevel = /** @class */ (function (_super) {
    __extends(BaseLevel, _super);
    function BaseLevel(sceneKey, bootstrap, levelBounds, players, groundTexture, background, backgroundYSpeed) {
        var _this = _super.call(this) || this;
        _this.winners = 0;
        _this.win = function () {
            // count and only emit done if all players finished the game? // same for lose?? -> only in last level
            _this.winners++;
            if (_this.winners >= _this.players.length)
                _this.emit("done", {
                    target: _this,
                    type: GameBootstrap_1.GameElementDoneType.Finished
                });
        };
        _this.lose = function () {
            _this.emit("done", {
                target: _this,
                type: GameBootstrap_1.GameElementDoneType.Aborted
            });
        };
        _this.sceneKey = sceneKey;
        _this.engine = bootstrap.engine;
        _this.scene = new ex.Scene(_this.engine);
        _this.bounds = _this.engine.getWorldBounds();
        _this.loader = bootstrap.loader;
        _this.levelBounds = levelBounds;
        _this.state = bootstrap.state;
        _this.players = players;
        _this.followedPlayer = _this.players[0];
        _this.frontPlayer = _this.players[0];
        var baseUpdateMethod = _this.scene.update;
        var scene = _this.scene;
        _this.scene.camera.addStrategy(new LockLevelCameraStrategy_1.default(_this.bounds, _this.levelBounds));
        _this.scene.update = function (engine, delta) {
            for (var _i = 0, _a = _this.players; _i < _a.length; _i++) {
                var p = _a[_i];
                if (p.getWorldPos().x > _this.frontPlayer.getWorldPos().x) {
                    _this.frontPlayer = p;
                }
            }
            if (engine.input.keyboard.wasPressed(ex.Input.Keys.Space)) {
                for (var _b = 0, _c = _this.players; _b < _c.length; _b++) {
                    var p = _c[_b];
                    if (p !== _this.followedPlayer) {
                        scene.camera.removeStrategy(_this.followedPlayer.cameraStrategy);
                        scene.camera.addStrategy(p.cameraStrategy);
                        _this.followedPlayer = p;
                        _this.background.player = _this.followedPlayer;
                        _this.scene.camera.addStrategy(new LockLevelCameraStrategy_1.default(_this.bounds, _this.levelBounds));
                        break;
                    }
                }
            }
            baseUpdateMethod.apply(scene, [engine, delta]);
        };
        // end of extended update method
        // ground & background
        _this.ground = new Ground_1.default(_this.levelBounds.right / 2, _this.bounds.bottom - Ground_1.default.height / 2, groundTexture, levelBounds.getWidth());
        _this.background = new Background_1.default(background, _this.players[0], 0, 0, _this.engine.drawWidth / 2 + 100, _this.engine.drawWidth / 2 + 100, 5000, backgroundYSpeed);
        // further scene properties
        ex.Physics.acc.setTo(0, 2000);
        _this.scene.camera.addStrategy(_this.players[0].cameraStrategy);
        _this.scene.camera.addStrategy(new LockLevelCameraStrategy_1.default(_this.bounds, _this.levelBounds));
        // wiring general player events
        for (var _i = 0, _a = _this.players; _i < _a.length; _i++) {
            var p = _a[_i];
            p.on("death", function () { return _this.lose(); });
            p.on("won", function () { return _this.win(); });
        }
        return _this;
    }
    BaseLevel.prototype.buildScene = function () {
        // add base actors
        this.scene.add(this.ground);
        this.scene.add(this.background);
        this.background.z = -1;
        for (var _i = 0, _a = this.players; _i < _a.length; _i++) {
            var p = _a[_i];
            this.scene.add(p);
        }
        this.engine.addScene(this.sceneKey, this.scene);
        this.engine.goToScene(this.sceneKey);
    };
    BaseLevel.prototype.dispose = function () {
        this.engine.removeScene(this.sceneKey);
    };
    BaseLevel.prototype.randomIntFromInterval = function (min, max) {
        var t = Math.floor(Math.random() * (max - min + 1) + min);
        return t;
    };
    return BaseLevel;
}(Class_1.Class));
exports.default = BaseLevel;


/***/ }),
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var excalibur_1 = __webpack_require__(0);
var StateListener_1 = __webpack_require__(82);
var InterfaceBuilder_1 = __webpack_require__(5);
var Resources_1 = __webpack_require__(4);
var GameInterface_1 = __webpack_require__(109);
var stories = __webpack_require__(134);
var Level1_1 = __webpack_require__(135);
var Level2_1 = __webpack_require__(59);
var Level3_1 = __webpack_require__(60);
var Level4_1 = __webpack_require__(61);
/**
 * Determines the reason for GameElement to be done.
 */
var GameElementDoneType;
(function (GameElementDoneType) {
    /**
     * Everything is fine, proceed, or the player has won.
     */
    GameElementDoneType[GameElementDoneType["Finished"] = 0] = "Finished";
    /**
     * An error occurred, don't proceed, or the player has died.
     */
    GameElementDoneType[GameElementDoneType["Aborted"] = 1] = "Aborted";
})(GameElementDoneType = exports.GameElementDoneType || (exports.GameElementDoneType = {}));
var defaultGameBootstrapState = {
    title: null,
    lives: 5,
    score: 0,
    oxygen: [],
    showOxygen: false,
    names: ["Freddy", "Bro"],
    loaded: false,
    winner: null,
};
var INITIAL_LEVEL_INDEX = -1;
var levels = [Level1_1.default, Level2_1.default, Level3_1.default, Level4_1.default];
var transitionStories = [stories.level1, stories.level2, stories.level3, stories.level4];
/**
 * Game bootstrap object.
 *
 * Handles the logic behind switching levels and wiring everything up.
 */
var GameBootstrap = /** @class */ (function () {
    function GameBootstrap() {
        /**
         * Excaliburjs' game engine.
         */
        // @ts-ignore
        this.engine = null;
        /**
         * UI Interface.
         */
        // @ts-ignore
        this.interface = null;
        this.levelIndex = INITIAL_LEVEL_INDEX;
        this.currentGameElement = null;
        this.stateListener = new StateListener_1.default(__assign({}, defaultGameBootstrapState));
        this.state = this.stateListener.createListenableObject();
        this.loader = new excalibur_1.Loader();
        this.loader.addResources(Resources_1.getLoadableResources());
    }
    GameBootstrap.prototype.onLevelSelected = function (_a) {
        var level = _a.level, players = _a.players;
        this.levelIndex = level;
        var names = this.state.names;
        if (names.length !== players) {
            if (players === 2)
                this.state.names = [names[0], "Bro"];
            else
                this.state.names = [names[0]];
            this.state.title = this.state.names.join(" & ");
        }
        this.onShowContent();
    };
    GameBootstrap.prototype.onPlayClicked = function (names) {
        this.levelIndex = 0;
        this.state.names = names;
        this.state.title = names.join(" & ");
        this.state.lives = defaultGameBootstrapState.lives;
        this.state.score = defaultGameBootstrapState.score;
        this.state.oxygen = defaultGameBootstrapState.oxygen;
        this.state.showOxygen = defaultGameBootstrapState.showOxygen;
        this.state.winner = null;
        this.interface.showIntro();
    };
    GameBootstrap.prototype.onShowContent = function () {
        if (this.levelIndex === INITIAL_LEVEL_INDEX) {
            this.interface.setContentType("menu");
            return;
        }
        else {
            this.interface.setContentType("game");
            this.startScene();
        }
    };
    GameBootstrap.prototype.onHideContent = function () {
        this.stopCurrentElement();
    };
    GameBootstrap.prototype.stopCurrentElement = function () {
        var _a = this, engine = _a.engine, currentGameElement = _a.currentGameElement;
        if (currentGameElement) {
            if (currentGameElement.dispose)
                currentGameElement.dispose();
            this.currentGameElement = null;
        }
        engine.removeScene(engine.currentScene);
        engine.stop();
    };
    GameBootstrap.prototype.startScene = function () {
        var _this = this;
        this.engine.start();
        var LevelClass = levels[this.levelIndex];
        var level = new LevelClass(this);
        this.currentGameElement = level;
        level.once("done", function (_a) {
            var type = _a.type;
            return _this.onLevelDone(type);
        });
    };
    GameBootstrap.prototype.resetLevel = function (levelIndex) {
        var _this = this;
        if (levelIndex === void 0) { levelIndex = this.levelIndex; }
        this.levelIndex = levelIndex;
        var cl = this.currentGameElement;
        var LevelClass = levels[this.levelIndex];
        var level = new LevelClass(this);
        this.currentGameElement = level;
        if (cl && cl.dispose)
            cl.dispose();
        level.once("done", function (_a) {
            var type = _a.type;
            return _this.onLevelDone(type);
        });
    };
    GameBootstrap.prototype.onLevelDone = function (type) {
        if (type === GameElementDoneType.Finished)
            this.levelFinished();
        else if (this.levelIndex === 0 && this.state.lives > 0)
            this.resetLevel();
        else
            this.levelAborted();
    };
    GameBootstrap.prototype.levelFinished = function () {
        var transition = transitionStories[this.levelIndex](this.state);
        this.levelIndex++;
        if (this.levelIndex >= levels.length)
            this.levelIndex = INITIAL_LEVEL_INDEX;
        this.interface.showTransition(transition);
    };
    GameBootstrap.prototype.levelAborted = function () {
        this.levelIndex = INITIAL_LEVEL_INDEX;
        this.interface.showTransition(stories.death(this.state));
    };
    /**
     * Starts the game.
     */
    GameBootstrap.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loader.load()];
                    case 1:
                        _a.sent();
                        InterfaceBuilder_1.InterfaceBuilder.replaceContent(document.body, (InterfaceBuilder_1.InterfaceBuilder.createElement(GameInterface_1.default, { bootstrap: this, ref: function (i) {
                                // @ts-ignore
                                return _this.interface = i;
                            } })));
                        this.interface.on("levelSelected", this.onLevelSelected.bind(this));
                        this.interface.on("playClicked", this.onPlayClicked.bind(this));
                        this.interface.on("moveDown", this.onShowContent.bind(this)); // move
                        this.interface.on("movedUp", this.onHideContent.bind(this)); // moveD // note the D
                        // @ts-ignore
                        this.engine = new excalibur_1.Engine({
                            width: 1000,
                            height: 600,
                            canvasElementId: this.interface.canvas.id,
                            backgroundColor: excalibur_1.Color.Black,
                            pointerScope: excalibur_1.Input.PointerScope.Canvas
                        });
                        this.state.loaded = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    return GameBootstrap;
}());
exports.GameBootstrap = GameBootstrap;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var excalibur_1 = __webpack_require__(0);
var CustomTexture = /** @class */ (function () {
    function CustomTexture(src) {
        this.src = src;
    }
    CustomTexture.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var a, b, c;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fetch(this.src)];
                    case 1:
                        a = _a.sent();
                        return [4 /*yield*/, a.blob()];
                    case 2:
                        b = _a.sent();
                        c = new Image();
                        c.src = URL.createObjectURL(b);
                        this.image = c;
                        return [2 /*return*/, c];
                }
            });
        });
    };
    CustomTexture.prototype.exTexture = function () {
        return new excalibur_1.Texture(this.src);
    };
    return CustomTexture;
}());
exports.CustomTexture = CustomTexture;
var CustomSprite = /** @class */ (function () {
    function CustomSprite(texture, x, y, width, height) {
        this.texture = texture;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    CustomSprite.prototype.draw = function (ctx, x, y) {
        if (!this.texture.image)
            throw new Error("Image not loaded.");
        ctx.drawImage(this.texture.image, this.x, this.y, this.width, this.height, x, y, this.width, this.height);
    };
    CustomSprite.prototype.debugDraw = function (ctx, x, y) {
        ctx.save();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, this.height, this.width);
        ctx.restore();
    };
    return CustomSprite;
}());
exports.CustomSprite = CustomSprite;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var excalibur_1 = __webpack_require__(0);
var AnimationHelpers_1 = __webpack_require__(35);
exports.image = __webpack_require__(87);
exports.texture = new excalibur_1.Texture(exports.image);
exports.modelSize = {
    w: 38,
    h: 133
};
var armSize = {
    w: 11,
    h: 57,
};
var armAnchor = {
    x: 6,
    y: 6
};
var legSize = {
    w: 26,
    h: 56
};
var legAnchor = {
    x: 20,
    y: 7
};
var headSize = {
    w: 36,
    h: 49
};
var headAnchor = {
    x: 36 / 2,
    y: 49 / 2
};
var torsoSize = {
    w: 28,
    h: 57
};
var torsoAnchor = {
    x: 14,
    y: 57 / 2
};
var armRight = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 128, y: 86 }, armSize),
    modelLocation: __assign({ x: 17, y: 47 }, armSize),
    anchor: __assign({}, armAnchor)
};
var armLeft = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 103, y: 85 }, armSize),
    modelLocation: __assign({ x: 17, y: 47 }, armSize),
    anchor: __assign({}, armAnchor)
};
var legRight = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 177, y: 19 }, legSize),
    modelLocation: __assign({ x: 4, y: 76 }, legSize),
    anchor: __assign({}, legAnchor)
};
var legLeft = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 139, y: 19 }, legSize),
    modelLocation: __assign({ x: 4, y: 76 }, legSize),
    anchor: __assign({}, legAnchor)
};
var headRight = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 76, y: 14 }, headSize),
    modelLocation: __assign({ x: 0, y: 0 }, headSize),
    anchor: __assign({}, headAnchor)
};
var headLeft = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 24, y: 15 }, headSize),
    modelLocation: __assign({ x: 0, y: 0 }, headSize),
    anchor: __assign({}, headAnchor)
};
var torso = {
    texture: exports.texture,
    sourceLocation: __assign({ x: 27, y: 84 }, torsoSize),
    modelLocation: __assign({ x: 8, y: 39 }, torsoSize),
    anchor: __assign({}, torsoAnchor)
};
var _sprites = {};
var _bodyParts = {
    armRight: armRight,
    armLeft: armLeft,
    legRight: legRight,
    legLeft: legLeft,
    headRight: headRight,
    headLeft: headLeft,
    torso: torso
};
var allParts = [
    armRight,
    armLeft,
    legRight,
    legLeft,
    headRight,
    headLeft,
    torso
];
var rightParts = [
    armRight,
    legRight,
    headRight
];
var centerPart = function (part) {
    var ml = part.modelLocation;
    ml.x -= exports.modelSize.w / 2;
    ml.y -= exports.modelSize.h / 2;
    // ml.y -= modelSize.h;
    // ml.y += 16;
    ml.x += part.anchor.x;
    ml.y += part.anchor.y;
};
var shiftRight = function (part) {
    part.modelLocation.x = -part.modelLocation.x;
    part.anchor.x = part.modelLocation.w - part.anchor.x;
};
allParts.forEach(centerPart);
rightParts.forEach(shiftRight);
Object.entries(_bodyParts).forEach(function (_a) {
    var key = _a[0], _b = _a[1], texture = _b.texture, loc = _b.sourceLocation;
    return _sprites[key] = new AnimationHelpers_1.CustomSprite(texture, loc.x, loc.y, loc.w, loc.h);
});
exports.bodyParts = _bodyParts;
exports.sprites = _sprites;


/***/ }),
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.preloaded = [];
function load(src) {
    return __awaiter(this, void 0, void 0, function () {
        var a, b;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fetch(src)];
                case 1:
                    a = _a.sent();
                    return [4 /*yield*/, a.blob()];
                case 2:
                    b = _a.sent();
                    return [2 /*return*/, b];
            }
        });
    });
}
exports.load = load;
function preload(src) {
    return __awaiter(this, void 0, void 0, function () {
        var b;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, load(src)];
                case 1:
                    b = _a.sent();
                    exports.preloaded.push(b);
                    return [2 /*return*/, b];
            }
        });
    });
}
exports.default = preload;
function preloadImage(src) {
    var img = new Image();
    var promise = new Promise(function (resolve, reject) {
        img.addEventListener("error", reject);
        img.addEventListener("load", function (e) {
            exports.preloaded.push(img);
            resolve(img);
        });
        img.src = src;
    });
    return { img: img, promise: promise };
}
exports.preloadImage = preloadImage;
function preloadAudio(src) {
    var audio = new Audio();
    var promise = new Promise(function (resolve, reject) {
        audio.addEventListener("error", reject);
        audio.addEventListener("canplaythrough", function (e) {
            exports.preloaded.push(audio);
            resolve(audio);
        });
        audio.src = src;
        audio.load();
    });
    return { audio: audio, promise: promise };
}
exports.preloadAudio = preloadAudio;


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["rgbToHsl"] = rgbToHsl;
/* harmony export (immutable) */ __webpack_exports__["hslToRgb"] = hslToRgb;
/* harmony export (immutable) */ __webpack_exports__["hueToRgb"] = hueToRgb;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Static__ = __webpack_require__(18);


/**
 * Color
 */

/**
 * @see http://www.w3.org/TR/css3-color/
 */
var KEYWORDS = {
	aliceblue: 'rgb(240, 248, 255)',
	antiquewhite: 'rgb(250, 235, 215)',
	aqua: 'rgb(0, 255, 255)',
	aquamarine: 'rgb(127, 255, 212)',
	azure: 'rgb(240, 255, 255)',
	beige: 'rgb(245, 245, 220)',
	bisque: 'rgb(255, 228, 196)',
	black: 'rgb(0, 0, 0)',
	blanchedalmond: 'rgb(255, 235, 205)',
	blue: 'rgb(0, 0, 255)',
	blueviolet: 'rgb(138, 43, 226)',
	brown: 'rgb(165, 42, 42)',
	burlywood: 'rgb(222, 184, 135)',
	cadetblue: 'rgb(95, 158, 160)',
	chartreuse: 'rgb(127, 255, 0)',
	chocolate: 'rgb(210, 105, 30)',
	coral: 'rgb(255, 127, 80)',
	cornflowerblue: 'rgb(100, 149, 237)',
	cornsilk: 'rgb(255, 248, 220)',
	crimson: 'rgb(220, 20, 60)',
	cyan: 'rgb(0, 255, 255)',
	darkblue: 'rgb(0, 0, 139)',
	darkcyan: 'rgb(0, 139, 139)',
	darkgoldenrod: 'rgb(184, 134, 11)',
	darkgray: 'rgb(169, 169, 169)',
	darkgreen: 'rgb(0, 100, 0)',
	darkgrey: 'rgb(169, 169, 169)',
	darkkhaki: 'rgb(189, 183, 107)',
	darkmagenta: 'rgb(139, 0, 139)',
	darkolivegreen: 'rgb(85, 107, 47)',
	darkorange: 'rgb(255, 140, 0)',
	darkorchid: 'rgb(153, 50, 204)',
	darkred: 'rgb(139, 0, 0)',
	darksalmon: 'rgb(233, 150, 122)',
	darkseagreen: 'rgb(143, 188, 143)',
	darkslateblue: 'rgb(72, 61, 139)',
	darkslategray: 'rgb(47, 79, 79)',
	darkslategrey: 'rgb(47, 79, 79)',
	darkturquoise: 'rgb(0, 206, 209)',
	darkviolet: 'rgb(148, 0, 211)',
	deeppink: 'rgb(255, 20, 147)',
	deepskyblue: 'rgb(0, 191, 255)',
	dimgray: 'rgb(105, 105, 105)',
	dimgrey: 'rgb(105, 105, 105)',
	dodgerblue: 'rgb(30, 144, 255)',
	firebrick: 'rgb(178, 34, 34)',
	floralwhite: 'rgb(255, 250, 240)',
	forestgreen: 'rgb(34, 139, 34)',
	fuchsia: 'rgb(255, 0, 255)',
	gainsboro: 'rgb(220, 220, 220)',
	ghostwhite: 'rgb(248, 248, 255)',
	gold: 'rgb(255, 215, 0)',
	goldenrod: 'rgb(218, 165, 32)',
	gray: 'rgb(128, 128, 128)',
	green: 'rgb(0, 128, 0)',
	greenyellow: 'rgb(173, 255, 47)',
	grey: 'rgb(128, 128, 128)',
	honeydew: 'rgb(240, 255, 240)',
	hotpink: 'rgb(255, 105, 180)',
	indianred: 'rgb(205, 92, 92)',
	indigo: 'rgb(75, 0, 130)',
	ivory: 'rgb(255, 255, 240)',
	khaki: 'rgb(240, 230, 140)',
	lavender: 'rgb(230, 230, 250)',
	lavenderblush: 'rgb(255, 240, 245)',
	lawngreen: 'rgb(124, 252, 0)',
	lemonchiffon: 'rgb(255, 250, 205)',
	lightblue: 'rgb(173, 216, 230)',
	lightcoral: 'rgb(240, 128, 128)',
	lightcyan: 'rgb(224, 255, 255)',
	lightgoldenrodyellow: 'rgb(250, 250, 210)',
	lightgray: 'rgb(211, 211, 211)',
	lightgreen: 'rgb(144, 238, 144)',
	lightgrey: 'rgb(211, 211, 211)',
	lightpink: 'rgb(255, 182, 193)',
	lightsalmon: 'rgb(255, 160, 122)',
	lightseagreen: 'rgb(32, 178, 170)',
	lightskyblue: 'rgb(135, 206, 250)',
	lightslategray: 'rgb(119, 136, 153)',
	lightslategrey: 'rgb(119, 136, 153)',
	lightsteelblue: 'rgb(176, 196, 222)',
	lightyellow: 'rgb(255, 255, 224)',
	lime: 'rgb(0, 255, 0)',
	limegreen: 'rgb(50, 205, 50)',
	linen: 'rgb(250, 240, 230)',
	magenta: 'rgb(255, 0, 255)',
	maroon: 'rgb(128, 0, 0)',
	mediumaquamarine: 'rgb(102, 205, 170)',
	mediumblue: 'rgb(0, 0, 205)',
	mediumorchid: 'rgb(186, 85, 211)',
	mediumpurple: 'rgb(147, 112, 219)',
	mediumseagreen: 'rgb(60, 179, 113)',
	mediumslateblue: 'rgb(123, 104, 238)',
	mediumspringgreen: 'rgb(0, 250, 154)',
	mediumturquoise: 'rgb(72, 209, 204)',
	mediumvioletred: 'rgb(199, 21, 133)',
	midnightblue: 'rgb(25, 25, 112)',
	mintcream: 'rgb(245, 255, 250)',
	mistyrose: 'rgb(255, 228, 225)',
	moccasin: 'rgb(255, 228, 181)',
	navajowhite: 'rgb(255, 222, 173)',
	navy: 'rgb(0, 0, 128)',
	oldlace: 'rgb(253, 245, 230)',
	olive: 'rgb(128, 128, 0)',
	olivedrab: 'rgb(107, 142, 35)',
	orange: 'rgb(255, 165, 0)',
	orangered: 'rgb(255, 69, 0)',
	orchid: 'rgb(218, 112, 214)',
	palegoldenrod: 'rgb(238, 232, 170)',
	palegreen: 'rgb(152, 251, 152)',
	paleturquoise: 'rgb(175, 238, 238)',
	palevioletred: 'rgb(219, 112, 147)',
	papayawhip: 'rgb(255, 239, 213)',
	peachpuff: 'rgb(255, 218, 185)',
	peru: 'rgb(205, 133, 63)',
	pink: 'rgb(255, 192, 203)',
	plum: 'rgb(221, 160, 221)',
	powderblue: 'rgb(176, 224, 230)',
	purple: 'rgb(128, 0, 128)',
	red: 'rgb(255, 0, 0)',
	rosybrown: 'rgb(188, 143, 143)',
	royalblue: 'rgb(65, 105, 225)',
	saddlebrown: 'rgb(139, 69, 19)',
	salmon: 'rgb(250, 128, 114)',
	sandybrown: 'rgb(244, 164, 96)',
	seagreen: 'rgb(46, 139, 87)',
	seashell: 'rgb(255, 245, 238)',
	sienna: 'rgb(160, 82, 45)',
	silver: 'rgb(192, 192, 192)',
	skyblue: 'rgb(135, 206, 235)',
	slateblue: 'rgb(106, 90, 205)',
	slategray: 'rgb(112, 128, 144)',
	slategrey: 'rgb(112, 128, 144)',
	snow: 'rgb(255, 250, 250)',
	springgreen: 'rgb(0, 255, 127)',
	steelblue: 'rgb(70, 130, 180)',
	tan: 'rgb(210, 180, 140)',
	teal: 'rgb(0, 128, 128)',
	thistle: 'rgb(216, 191, 216)',
	tomato: 'rgb(255, 99, 71)',
	turquoise: 'rgb(64, 224, 208)',
	violet: 'rgb(238, 130, 238)',
	wheat: 'rgb(245, 222, 179)',
	white: 'rgb(255, 255, 255)',
	whitesmoke: 'rgb(245, 245, 245)',
	yellow: 'rgb(255, 255, 0)',
	yellowgreen: 'rgb(154, 205, 50)'
};

var RE_RGB = /^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/;
var RE_RGBA = /^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)$/;
var RE_HSL = /^hsl\(\s*([\d\.]+)\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*\)$/;
var RE_HSLA = /^hsla\(\s*([\d\.]+)\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)\s*\)$/;
var RE_HEX = /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/; // 6 digit


// Global object
var Color = {
	create: function (str) {
		str = str.replace(/^\s*#|\s*$/g, '');
		str = str.toLowerCase();
		if (KEYWORDS[str]) str = KEYWORDS[str];

		var match;

		// RGB(A)
		if (match = str.match(RE_RGB) || str.match(RE_RGBA)) {
			return new Color.RGBA(parseInt(match[1], 10), parseInt(match[2], 10), parseInt(match[3], 10), parseFloat(match.length === 4 ? 1 : match[4]));
		}

		// HSL(A)
		if (match = str.match(RE_HSL) || str.match(RE_HSLA)) {
			return new Color.HSLA(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]), parseFloat(match.length === 4 ? 1 : match[4]));
		}

		// Hex
		if (str.length === 3) {
			// Hex 3 digit -> 6 digit
			str = str.replace(/(.)/g, '$1$1');
		}
		if (match = str.match(RE_HEX)) {
			return new Color.RGBA(parseInt(match[1], 16), parseInt(match[2], 16), parseInt(match[3], 16), 1);
		}

		return null;
	},

	luminance: function (color) {
		if (color instanceof Color.HSLA) color = color.toRGBA();
		return 0.298912 * color.r + 0.586611 * color.g + 0.114478 * color.b;
	},

	greyscale: function (color) {
		var lum = Color.luminance(color);
		return new Color.RGBA(lum, lum, lum, this.a);
	},

	nagate: function (color) {
		if (color instanceof Color.HSLA) color = color.toRGBA();
		return new Color.RGBA(255 - color.r, 255 - color.g, 255 - color.b, color.a);
	},

	/**
  * @see http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html#mix-instance_method
  */
	mix: function (color1, color2, weight) {
		if (color1 instanceof Color.HSLA) color1 = color1.toRGBA();
		if (color2 instanceof Color.HSLA) color2 = color2.toRGBA();
		if (isNull(weight) || isUndefined(weight)) weight = 0.5;

		var w0 = 1 - weight;
		var w = w0 * 2 - 1;
		var a = color1.a - color2.a;
		var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
		var w2 = 1 - w1;

		return new Color.RGBA(Math.round(color1.r * w1 + color2.r * w2), Math.round(color1.g * w1 + color2.g * w2), Math.round(color1.b * w1 + color2.b * w2), Math.round(color1.a * w0 + color2.a * weight));
	}
};

/* harmony default export */ __webpack_exports__["default"] = (Color);

/**
 * Color.RGBA
 */
Color.RGBA = function (r, g, b, a) {
	if (Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isArray"])(r)) {
		g = r[1];
		b = r[2];
		a = r[3];
		r = r[0];
	} else if (Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isObject"])(r)) {
		g = r.g;
		b = r.b;
		a = r.a;
		r = r.r;
	}

	this.r = r || 0;
	this.g = g || 0;
	this.b = b || 0;
	this.a = !Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isNumber"])(a) ? 1 : a;
};

Color.RGBA.prototype = {
	toHSLA: function () {
		var hsl = rgbToHsl(Math.round(this.r), Math.round(this.g), Math.round(this.b));
		return new Color.HSLA(hsl[0], hsl[1], hsl[2], this.a);
	},

	toArray: function () {
		return [Math.round(this.r), Math.round(this.g), Math.round(this.b), this.a];
	},

	clone: function () {
		return new Color.RGBA(this);
	},

	toString: function () {
		return 'rgba(' + Math.round(this.r) + ', ' + Math.round(this.g) + ', ' + Math.round(this.b) + ', ' + this.a + ')';
	}
};

/**
 * Color.HSLA
 */
Color.HSLA = function (h, s, l, a) {
	if (Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isArray"])(h)) {
		s = h[1];
		l = h[2];
		a = h[3];
		h = h[0];
	} else if (Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isObject"])(h)) {
		s = h.s;
		l = h.l;
		a = h.a;
		h = h.h;
	}

	this.h = h || 0;
	this.s = s || 0;
	this.l = l || 0;
	this.a = !Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isNumber"])(a) ? 1 : a;
};

Color.HSLA.prototype = {
	toRGBA: function () {
		var rgb = hslToRgb(this.h, this.s, this.l);
		return new Rgba(rgb[0], rgb[1], rgb[2], this.a);
	},

	toArray: function () {
		return [this.h, this.s, this.l, this.a];
	},

	clone: function () {
		return new Color.HSLA(this);
	},

	toString: function () {
		return 'hsla(' + this.h + ', ' + this.s + '%, ' + this.l + '%, ' + this.a + ')';
	}
};

// Helpers

function rgbToHsl(r, g, b) {
	r /= 255;
	g /= 255;
	b /= 255;

	var max = Math.max(r, g, b);
	var min = Math.min(r, g, b);
	var h, s, l;

	l = (max + min) / 2;

	if (max === min) {
		h = s = 0;
	} else {
		var d = max - min;
		switch (max) {
			case r:
				h = ((g - b) / d * 60 + 360) % 360;
				break;
			case g:
				h = (b - r) / d * 60 + 120;
				break;
			case b:
				h = (r - g) / d * 60 + 240;
				break;
		}
		s = l <= 0.5 ? d / (max + min) : d / (2 - max - min);
	}

	return [h, s * 100, l * 100];
}

function hslToRgb(h, s, l) {
	s /= 100;
	l /= 100;

	var r, g, b;

	if (s === 0) {
		r = g = b = l * 255;
	} else {
		var v2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
		var v1 = 2 * l - v2;
		r = Math.round(hueToRgb(v1, v2, h + 120) * 255);
		g = Math.round(hueToRgb(v1, v2, h) * 255);
		b = Math.round(hueToRgb(v1, v2, h - 120) * 255);
	}

	return [r, g, b];
}

function hueToRgb(v1, v2, vh) {
	vh /= 360;
	if (vh < 0) vh++;
	if (vh > 1) vh--;
	if (vh < 1 / 6) return v1 + (v2 - v1) * 6 * vh;
	if (vh < 1 / 2) return v2;
	if (vh < 2 / 3) return v1 + (v2 - v1) * (2 / 3 - vh) * 6;
	return v1;
}

// global.Color = Color;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Color_1 = __webpack_require__(53);
var Point_1 = __webpack_require__(117);
var SimplexNoise_1 = __webpack_require__(55);
var Static_1 = __webpack_require__(18);
var InterfaceBuilder_1 = __webpack_require__(5);
var PARTICLE_NUM = 500;
var STEP = 3;
var Z_INC = 0.001;
exports.H = 0; // Hue
exports.S = 100; // Saturate
exports.L = 50; // Lightness
exports.A = 0; // Alpha
var defaultColor = new Color_1.default.HSLA(exports.H, exports.S, exports.L, exports.A);
var CanvasAbstraction = /** @class */ (function (_super) {
    __extends(CanvasAbstraction, _super);
    function CanvasAbstraction(attrs) {
        var _this = _super.call(this, attrs) || this;
        _this.canvas = InterfaceBuilder_1.InterfaceBuilder.createElement("canvas", { style: { height: "100%", width: "100%" } });
        _this.renderer = new Renderer(_this.canvas, attrs.baseColor);
        window.ca = _this;
        return _this;
    }
    CanvasAbstraction.prototype.render = function (attrs) {
        if (attrs && attrs.ref)
            attrs.ref(this);
        return this.canvas;
    };
    return CanvasAbstraction;
}(InterfaceBuilder_1.Component));
exports.default = CanvasAbstraction;
/**
 * Renderer class.
 *
 * Uses:
 * PerlinNoise class,
 * Point class,
 * Color class,
 * extend, random
 * @see http://jsdo.it/akm2/fhMC
 */
var Renderer = /** @class */ (function () {
    function Renderer(canvas, baseColor) {
        var _this = this;
        this.canvas = canvas;
        this.canvasWidth = 0;
        this.canvasHeight = 0;
        this.center = new Point_1.default();
        this.perlinNoise = new SimplexNoise_1.default();
        this.zoff = 0;
        this.animationFrame = NaN;
        this.resize = function () {
            var _a = _this, canvas = _a.canvas, center = _a.center;
            _this.canvasWidth = canvas.width = canvas.clientWidth;
            _this.canvasHeight = canvas.height = canvas.clientHeight;
            var context = _this.context = canvas.getContext("2d");
            context.lineWidth = 0.3;
            context.lineCap = context.lineJoin = "round";
            center.set(_this.canvasWidth / 2, _this.canvasHeight / 2);
        };
        this.context = canvas.getContext("2d");
        this.particles = new Array(PARTICLE_NUM);
        var color = baseColor
            ? (baseColor instanceof Color_1.default.RGBA ? baseColor.toHSLA() : baseColor)
            : defaultColor;
        for (var i = 0; i < PARTICLE_NUM; i++)
            this.particles[i] = new Particle(this, color, !baseColor);
    }
    Renderer.prototype.start = function () {
        var _this = this;
        this.resize();
        document.removeEventListener("resize", this.resize);
        if (!Number.isNaN(this.animationFrame))
            return;
        var loop = function () {
            _this.draw();
            _this.animationFrame = requestAnimationFrame(loop);
        };
        this.animationFrame = requestAnimationFrame(loop);
    };
    Renderer.prototype.stop = function () {
        if (!Number.isNaN(this.animationFrame)) {
            cancelAnimationFrame(this.animationFrame);
            document.removeEventListener("resize", this.resize);
            this.animationFrame = NaN;
        }
    };
    Renderer.prototype.clear = function () {
        this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    };
    Renderer.prototype.makeTransparent = function () {
        var _a = this, context = _a.context, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
        var imageData = context.getImageData(0, 0, canvasWidth, canvasHeight);
        var data = imageData.data;
        for (var i = 3; i < imageData.data.length; i += 4) {
            if (data[i] > 1)
                data[i]--;
        }
        context.putImageData(imageData, 0, 0);
    };
    Renderer.prototype.draw = function () {
        var _a = this, context = _a.context, particles = _a.particles, zoff = _a.zoff, perlinNoise = _a.perlinNoise, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
        var p, latest, color, angle;
        this.makeTransparent();
        for (var i = 0, len = particles.length; i < len; i++) {
            p = particles[i];
            latest = p.latest;
            color = p.color;
            context.beginPath();
            context.strokeStyle = color.toString();
            context.moveTo(latest.x, latest.y);
            context.lineTo(p.x, p.y);
            context.stroke();
            latest.set(p);
            angle = Math.PI * 6 * perlinNoise.noise(p.x / canvasWidth * 1.75, p.y / canvasHeight * 1.75, zoff);
            p.offset(Math.cos(angle) * STEP, Math.sin(angle) * STEP);
            if (color.a < 1)
                color.a += 0.01;
            if (p.x < 0 || p.x > canvasWidth || p.y < 0 || p.y > canvasHeight) {
                p.reborn();
            }
        }
        this.zoff += Z_INC;
    };
    return Renderer;
}());
exports.Renderer = Renderer;
var Particle = /** @class */ (function (_super) {
    __extends(Particle, _super);
    function Particle(ca, baseColor, changeHue) {
        if (changeHue === void 0) { changeHue = baseColor instanceof Color_1.default.HSLA; }
        var _this = _super.call(this) || this;
        _this.ca = ca;
        _this.age = 0;
        _this.changeHue = changeHue && baseColor instanceof Color_1.default.HSLA;
        _this.latest = new Point_1.default();
        _this.color = baseColor.clone();
        _this.reborn();
        return _this;
    }
    Particle.prototype.reborn = function () {
        this.set(Static_1.random(this.ca.canvasWidth), Static_1.random(this.ca.canvasHeight));
        this.latest.set(this);
        this.age = 0;
        if (this.changeHue)
            this.color.h = this.ca.center.subtract(this).angle() * 180 / Math.PI;
        this.color.a = 0;
    };
    return Particle;
}(Point_1.default));


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = SimplexNoise;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ClassicNoise__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Static__ = __webpack_require__(18);




/**
 * SimplexNoise
 * 
 * @super ClassicNoise
 */
function SimplexNoise(seed) {
	this.seed(seed);
}

SimplexNoise.prototype = Object(__WEBPACK_IMPORTED_MODULE_2__Static__["extend"])({}, __WEBPACK_IMPORTED_MODULE_1__ClassicNoise__["a" /* default */].prototype, {
	noise: function (x, y, z, w) {
		var result = 0;
		var noise;
		var f = 1;
		var oct = this._octaves;
		var amp = 0.5;
		var fallout = this._fallout;

		switch (arguments.length) {
			case 1:
				noise = function () {
					return this.noise2d(x * f, 0);
				};
				break;
			case 2:
				noise = function () {
					return this.noise2d(x * f, y * f);
				};
				break;
			case 3:
				noise = function () {
					return this.noise3d(x * f, y * f, z * f);
				};
				break;
			case 4:
				noise = function () {
					return this.noise4d(x * f, y * f, z * f, w * f);
				};
				break;
			default:
				return result;
		}

		for (var i = 0; i < oct; ++i) {
			result += (1 + noise.call(this)) * amp * 0.5;
			amp *= fallout;
			f *= 2;
		}

		return result;
	},

	noise2d: function (x, y) {
		var n0, n1, n2;

		var F2 = 0.5 * (Math.sqrt(3) - 1);
		var s = (x + y) * F2;
		var i = Math.floor(x + s);
		var j = Math.floor(y + s);

		var G2 = (3 - Math.sqrt(3)) / 6;
		var t = (i + j) * G2;
		var X0 = i - t;
		var Y0 = j - t;
		var x0 = x - X0;
		var y0 = y - Y0;

		var i1, j1;
		if (x0 > y0) {
			i1 = 1;
			j1 = 0;
		} else {
			i1 = 0;
			j1 = 1;
		}

		var x1 = x0 - i1 + G2;
		var y1 = y0 - j1 + G2;
		var x2 = x0 - 1 + 2 * G2;
		var y2 = y0 - 1 + 2 * G2;

		var perm = this._perm;

		var ii = i & 255;
		var jj = j & 255;
		var gi0 = perm[ii + perm[jj]] % 12;
		var gi1 = perm[ii + i1 + perm[jj + j1]] % 12;
		var gi2 = perm[ii + 1 + perm[jj + 1]] % 12;

		var t0 = 0.5 - x0 * x0 - y0 * y0;
		if (t0 < 0) {
			n0 = 0;
		} else {
			t0 *= t0;
			n0 = t0 * t0 * dot2d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["a" /* GRAD3 */][gi0], x0, y0);
		}

		var t1 = 0.5 - x1 * x1 - y1 * y1;
		if (t1 < 0) {
			n1 = 0;
		} else {
			t1 *= t1;
			n1 = t1 * t1 * dot2d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["a" /* GRAD3 */][gi1], x1, y1);
		}

		var t2 = 0.5 - x2 * x2 - y2 * y2;
		if (t2 < 0) {
			n2 = 0;
		} else {
			t2 *= t2;
			n2 = t2 * t2 * dot2d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["a" /* GRAD3 */][gi2], x2, y2);
		}

		return 70 * (n0 + n1 + n2);
	},

	noise3d: function (x, y, z) {
		var n0, n1, n2, n3;

		var F3 = 1 / 3;
		var s = (x + y + z) * F3;
		var i = Math.floor(x + s),
		    j = Math.floor(y + s),
		    k = Math.floor(z + s);

		var G3 = 1 / 6;
		var t = (i + j + k) * G3;
		var X0 = i - t;
		var Y0 = j - t;
		var Z0 = k - t;
		var x0 = x - X0;
		var y0 = y - Y0;
		var z0 = z - Z0;

		var i1, j1, k1;
		var i2, j2, k2;
		if (x0 >= y0) {
			if (y0 >= z0) {
				i1 = 1;
				j1 = 0;
				k1 = 0;
				i2 = 1;
				j2 = 1;
				k2 = 0;
			} else if (x0 >= z0) {
				i1 = 1;
				j1 = 0;
				k1 = 0;
				i2 = 1;
				j2 = 0;
				k2 = 1;
			} else {
				i1 = 0;
				j1 = 0;
				k1 = 1;
				i2 = 1;
				j2 = 0;
				k2 = 1;
			}
		} else {
			if (y0 < z0) {
				i1 = 0;
				j1 = 0;
				k1 = 1;
				i2 = 0;
				j2 = 1;
				k2 = 1;
			} else if (x0 < z0) {
				i1 = 0;
				j1 = 1;
				k1 = 0;
				i2 = 0;
				j2 = 1;
				k2 = 1;
			} else {
				i1 = 0;
				j1 = 1;
				k1 = 0;
				i2 = 1;
				j2 = 1;
				k2 = 0;
			}
		}

		var x1 = x0 - i1 + G3;
		var y1 = y0 - j1 + G3;
		var z1 = z0 - k1 + G3;
		var x2 = x0 - i2 + 2 * G3;
		var y2 = y0 - j2 + 2 * G3;
		var z2 = z0 - k2 + 2 * G3;
		var x3 = x0 - 1 + 3 * G3;
		var y3 = y0 - 1 + 3 * G3;
		var z3 = z0 - 1 + 3 * G3;

		var perm = this._perm;

		var ii = i & 255;
		var jj = j & 255;
		var kk = k & 255;
		var gi0 = perm[ii + perm[jj + perm[kk]]] % 12;
		var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]] % 12;
		var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]] % 12;
		var gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]] % 12;

		var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
		if (t0 < 0) {
			n0 = 0;
		} else {
			t0 *= t0;
			n0 = t0 * t0 * dot3d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["a" /* GRAD3 */][gi0], x0, y0, z0);
		}

		var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
		if (t1 < 0) {
			n1 = 0;
		} else {
			t1 *= t1;
			n1 = t1 * t1 * dot3d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["a" /* GRAD3 */][gi1], x1, y1, z1);
		}

		var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
		if (t2 < 0) {
			n2 = 0;
		} else {
			t2 *= t2;
			n2 = t2 * t2 * dot3d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["a" /* GRAD3 */][gi2], x2, y2, z2);
		}

		var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
		if (t3 < 0) {
			n3 = 0;
		} else {
			t3 *= t3;
			n3 = t3 * t3 * dot3d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["a" /* GRAD3 */][gi3], x3, y3, z3);
		}

		return 32 * (n0 + n1 + n2 + n3);
	},

	noise4d: function (x, y, z, w) {
		var F4 = (Math.sqrt(5) - 1) / 4;
		var G4 = (5 - Math.sqrt(5)) / 20;
		var n0, n1, n2, n3, n4;

		var s = (x + y + z + w) * F4;
		var i = Math.floor(x + s);
		var j = Math.floor(y + s);
		var k = Math.floor(z + s);
		var l = Math.floor(w + s);
		var t = (i + j + k + l) * G4;
		var X0 = i - t;
		var Y0 = j - t;
		var Z0 = k - t;
		var W0 = l - t;
		var x0 = x - X0;
		var y0 = y - Y0;
		var z0 = z - Z0;
		var w0 = w - W0;

		var c1 = x0 > y0 ? 32 : 0;
		var c2 = x0 > z0 ? 16 : 0;
		var c3 = y0 > z0 ? 8 : 0;
		var c4 = x0 > w0 ? 4 : 0;
		var c5 = y0 > w0 ? 2 : 0;
		var c6 = z0 > w0 ? 1 : 0;
		var c = c1 + c2 + c3 + c4 + c5 + c6;

		var i1 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][0] >= 3 ? 1 : 0;
		var j1 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][1] >= 3 ? 1 : 0;
		var k1 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][2] >= 3 ? 1 : 0;
		var l1 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][3] >= 3 ? 1 : 0;

		var i2 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][0] >= 2 ? 1 : 0;
		var j2 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][1] >= 2 ? 1 : 0;
		var k2 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][2] >= 2 ? 1 : 0;
		var l2 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][3] >= 2 ? 1 : 0;

		var i3 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][0] >= 1 ? 1 : 0;
		var j3 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][1] >= 1 ? 1 : 0;
		var k3 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][2] >= 1 ? 1 : 0;
		var l3 = __WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["c" /* SIMPLEX */][c][3] >= 1 ? 1 : 0;

		var x1 = x0 - i1 + G4;
		var y1 = y0 - j1 + G4;
		var z1 = z0 - k1 + G4;
		var w1 = w0 - l1 + G4;
		var x2 = x0 - i2 + 2 * G4;
		var y2 = y0 - j2 + 2 * G4;
		var z2 = z0 - k2 + 2 * G4;
		var w2 = w0 - l2 + 2 * G4;
		var x3 = x0 - i3 + 3 * G4;
		var y3 = y0 - j3 + 3 * G4;
		var z3 = z0 - k3 + 3 * G4;
		var w3 = w0 - l3 + 3 * G4;
		var x4 = x0 - 1 + 4 * G4;
		var y4 = y0 - 1 + 4 * G4;
		var z4 = z0 - 1 + 4 * G4;
		var w4 = w0 - 1 + 4 * G4;

		var perm = this._perm;

		var ii = i & 255;
		var jj = j & 255;
		var kk = k & 255;
		var ll = l & 255;
		var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
		var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
		var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
		var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
		var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;

		var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
		if (t0 < 0) {
			n0 = 0;
		} else {
			t0 *= t0;
			n0 = t0 * t0 * dot4d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["b" /* GRAD4 */][gi0], x0, y0, z0, w0);
		}

		var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
		if (t1 < 0) {
			n1 = 0;
		} else {
			t1 *= t1;
			n1 = t1 * t1 * dot4d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["b" /* GRAD4 */][gi1], x1, y1, z1, w1);
		}

		var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
		if (t2 < 0) {
			n2 = 0;
		} else {
			t2 *= t2;
			n2 = t2 * t2 * dot4d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["b" /* GRAD4 */][gi2], x2, y2, z2, w2);
		}

		var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
		if (t3 < 0) {
			n3 = 0;
		} else {
			t3 *= t3;
			n3 = t3 * t3 * dot4d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["b" /* GRAD4 */][gi3], x3, y3, z3, w3);
		}

		var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
		if (t4 < 0) {
			n4 = 0;
		} else {
			t4 *= t4;
			n4 = t4 * t4 * dot4d(__WEBPACK_IMPORTED_MODULE_0__PerlinNoise__["b" /* GRAD4 */][gi4], x4, y4, z4, w4);
		}

		return 27 * (n0 + n1 + n2 + n3 + n4);
	}
});

// Common helpers

function dot2d(g, x, y) {
	return g[0] * x + g[1] * y;
}

function dot3d(g, x, y, z) {
	return g[0] * x + g[1] * y + g[2] * z;
}

// Simplex helper

function dot4d(g, x, y, z, w) {
	return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
}

// Classic helpers

function mix(a, b, t) {
	return (1 - t) * a + t * b;
}

function fade(t) {
	return t * t * t * (t * (t * 6 - 15) + 10);
}

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ClassicNoise;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Xorshift__ = __webpack_require__(119);


/**
 * ClassicNoise
 */
function ClassicNoise(seed) {
	this.seed(seed);
}

ClassicNoise.prototype = {
	_octaves: 4,
	_fallout: 0.5,

	seed: function (seed) {
		var random = new __WEBPACK_IMPORTED_MODULE_0__Xorshift__["a" /* default */](seed || new Date().getTime()).random;

		var i;
		var p = [];
		for (i = 0; i < 256; i++) {
			p[i] = Math.floor(random() * 256);
		}

		var perm = [];
		for (i = 0; i < 512; i++) {
			perm[i] = p[i & 255];
		}

		this._perm = perm;
	},

	octaves: function (octaves) {
		if (!arguments.length) return this._octaves;
		return this._octaves = octaves;
	},

	fallout: function (fallout) {
		if (!arguments.length) return this._fallout;
		return this._fallout = fallout;
	},

	noise: function (x, y, z) {
		var result = 0;
		var noise;
		var f = 1;
		var oct = this._octaves;
		var amp = 0.5;
		var fallout = this._fallout;

		switch (arguments.length) {
			case 1:
				noise = function () {
					return this.noise2d(x * f, 0);
				};
				break;
			case 2:
				noise = function () {
					return this.noise2d(x * f, y * f);
				};
				break;
			case 3:
				noise = function () {
					return this.noise3d(x * f, y * f, z * f);
				};
				break;
			default:
				return result;
		}

		for (var i = 0; i < oct; ++i) {
			result += (1 + noise.call(this)) * amp * 0.5;
			amp *= fallout;
			f *= 2;
		}

		return result;
	},

	noise2d: function (x, y) {
		var X = Math.floor(x);
		var Y = Math.floor(y);
		x = x - X;
		y = y - Y;
		X = X & 255;
		Y = Y & 255;

		var perm = this._perm;

		var gi00 = perm[X + perm[Y]] % 12;
		var gi01 = perm[X + perm[Y + 1]] % 12;
		var gi10 = perm[X + 1 + perm[Y]] % 12;
		var gi11 = perm[X + 1 + perm[Y + 1]] % 12;

		var n00 = dot2d(GRAD3[gi00], x, y);
		var n10 = dot2d(GRAD3[gi10], x - 1, y);
		var n01 = dot2d(GRAD3[gi01], x, y - 1);
		var n11 = dot2d(GRAD3[gi11], x - 1, y - 1);

		var u = fade(x);
		var v = fade(y);

		var nx0 = mix(n00, n10, u);
		var nx1 = mix(n01, n11, u);

		var nxy = mix(nx0, nx1, v);

		return nxy;
	},

	noise3d: function (x, y, z) {
		var X = Math.floor(x);
		var Y = Math.floor(y);
		var Z = Math.floor(z);
		x = x - X;
		y = y - Y;
		z = z - Z;
		X = X & 255;
		Y = Y & 255;
		Z = Z & 255;

		var perm = this._perm;

		var gi000 = perm[X + perm[Y + perm[Z]]] % 12;
		var gi001 = perm[X + perm[Y + perm[Z + 1]]] % 12;
		var gi010 = perm[X + perm[Y + 1 + perm[Z]]] % 12;
		var gi011 = perm[X + perm[Y + 1 + perm[Z + 1]]] % 12;
		var gi100 = perm[X + 1 + perm[Y + perm[Z]]] % 12;
		var gi101 = perm[X + 1 + perm[Y + perm[Z + 1]]] % 12;
		var gi110 = perm[X + 1 + perm[Y + 1 + perm[Z]]] % 12;
		var gi111 = perm[X + 1 + perm[Y + 1 + perm[Z + 1]]] % 12;

		var n000 = dot3d(GRAD3[gi000], x, y, z);
		var n100 = dot3d(GRAD3[gi100], x - 1, y, z);
		var n010 = dot3d(GRAD3[gi010], x, y - 1, z);
		var n110 = dot3d(GRAD3[gi110], x - 1, y - 1, z);
		var n001 = dot3d(GRAD3[gi001], x, y, z - 1);
		var n101 = dot3d(GRAD3[gi101], x - 1, y, z - 1);
		var n011 = dot3d(GRAD3[gi011], x, y - 1, z - 1);
		var n111 = dot3d(GRAD3[gi111], x - 1, y - 1, z - 1);

		var u = fade(x);
		var v = fade(y);
		var w = fade(z);

		var nx00 = mix(n000, n100, u);
		var nx01 = mix(n001, n101, u);
		var nx10 = mix(n010, n110, u);
		var nx11 = mix(n011, n111, u);

		var nxy0 = mix(nx00, nx10, v);
		var nxy1 = mix(nx01, nx11, v);

		var nxyz = mix(nxy0, nxy1, w);

		return nxyz;
	}
};

// Common helpers

function dot2d(g, x, y) {
	return g[0] * x + g[1] * y;
}

function dot3d(g, x, y, z) {
	return g[0] * x + g[1] * y + g[2] * z;
}

// Simplex helper

function dot4d(g, x, y, z, w) {
	return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
}

// Classic helpers

function mix(a, b, t) {
	return (1 - t) * a + t * b;
}

function fade(t) {
	return t * t * t * (t * (t * 6 - 15) + 10);
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/e98a0264584cc80949753f9a577e9466.mp3";

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Resources_1 = __webpack_require__(4);
var Vine = /** @class */ (function (_super) {
    __extends(Vine, _super);
    function Vine(x, y, length, speed, maxRotation) {
        var _this = _super.call(this, x, y, Vine.partWidth, Vine.partLength) || this;
        _this.time = 0;
        _this.alreadyCollidedWith = [];
        _this.nextPart = null;
        _this.prevPart = null;
        _this.collisionType = ex.CollisionType.Passive;
        _this.anchor.setTo(1, 0.5);
        _this.body.useCircleCollision(4, new ex.Vector(0, 7));
        _this.speed = speed;
        _this.maxRotation = maxRotation / 10;
        _this.sprite = Vine.sprites[Math.floor(Math.random() * Vine.sprites.length)];
        if (length - 1 > 0) {
            _this.nextPart = new Vine(_this.x, Vine.partLength - 3 + _this.y, length - 1, speed, maxRotation);
            _this.nextPart.prevPart = _this;
        }
        return _this;
    }
    Vine.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta);
        this.rotation = Math.sin(this.time * this.speed) * this.maxRotation;
        this.isOffScreen = this.prevPart ? !(!this.prevPart.isOffScreen || !this.isOffScreen) : this.isOffScreen;
        this.rotation += this.prevPart ? this.prevPart.rotation : 0;
        this.time += delta / 1000;
        if (this.prevPart) {
            var posDiff = new ex.Vector(0, Vine.partLength - 3);
            posDiff = posDiff.rotate(this.prevPart.rotation, new ex.Vector(1, 1));
            this.pos.x = this.prevPart.x + posDiff.x;
            this.pos.y = this.prevPart.y + posDiff.y - 1;
        }
    };
    Vine.prototype.draw = function (ctx, delta) {
        this.sprite.rotation = this.rotation;
        this.sprite.draw(ctx, this.getLeft(), this.getTop());
        _super.prototype.draw.call(this, ctx, delta);
    };
    Vine.prototype.getAllParts = function () {
        var root = this;
        var vineParts = [root];
        while (root.nextPart) {
            root = root.nextPart;
            vineParts.push(root);
        }
        return vineParts;
    };
    Vine.prototype.getRoot = function () {
        var root = this;
        while (root.prevPart) {
            root = root.prevPart;
        }
        return root;
    };
    Vine.partLength = 20;
    Vine.partWidth = 10;
    Vine.sprites = [
        new ex.Sprite(Resources_1.default.level1.vine, 0, 0, 10, 20),
        new ex.Sprite(Resources_1.default.level1.vine, 10, 0, 10, 20),
        new ex.Sprite(Resources_1.default.level1.vine, 20, 0, 10, 20),
        new ex.Sprite(Resources_1.default.level1.vine, 30, 0, 10, 20),
    ];
    return Vine;
}(ex.Actor));
exports.default = Vine;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Sky_1 = __webpack_require__(144);
var Level2Player_1 = __webpack_require__(145);
var BubbleCreator_1 = __webpack_require__(146);
var CrocodileCreator_1 = __webpack_require__(148);
var BasePlayer_1 = __webpack_require__(6);
var BaseLevel_1 = __webpack_require__(28);
var Resources_1 = __webpack_require__(4);
var Level2 = /** @class */ (function (_super) {
    __extends(Level2, _super);
    function Level2(bootstrap) {
        var _this = _super.call(this, Level2.sceneKey, bootstrap, Level2.levelBounds, 
        // players[]
        (bootstrap.state.names.length === 2
            ? ([new Level2Player_1.default(100, 400, BasePlayer_1.controlSets.controls1, new ex.Label("Oxygen Level: 100/100", Level2.levelBounds.left + 30, Level2.levelBounds.top + 50), bootstrap.state, true), new Level2Player_1.default(30, 250, BasePlayer_1.controlSets.controls2, new ex.Label("Oxygen Level: 100/100", Level2.levelBounds.left + 530, Level2.levelBounds.top + 50), bootstrap.state, false)]) // two players required
            : ([new Level2Player_1.default(100, 400, BasePlayer_1.controlSets.controls1, new ex.Label("Oxygen Level: 100/100", Level2.levelBounds.left + 30, Level2.levelBounds.top + 50), bootstrap.state, true)])), // just one player required
        Level2.groundTexture, Resources_1.default.level2.bg.asSprite(), 0.001 // background y movement speed
        ) || this;
        // reset physics
        ex.Physics.acc.setTo(0, 0);
        _this.level2Players = _this.players;
        for (var _i = 0, _a = _this.level2Players; _i < _a.length; _i++) {
            var p = _a[_i];
            // p.initAnimations();
        }
        _this.state = bootstrap.state;
        // Actor creation
        _this.sky = new Sky_1.default(_this.levelBounds.right / 2, _this.levelBounds.top + 62, _this.levelBounds.right, 124);
        _this.bubbles = [];
        _this.crocodiles = [];
        // BubbleCreator for cyclic generation of new bubbles
        _this.bubbleCreator = new BubbleCreator_1.default(_this.engine, _this.scene, _this.bounds, _this.level2Players, _this.bubbles);
        // CrocodileCreator for generation of new crocodiles
        _this.crocodileCreator = new CrocodileCreator_1.default(bootstrap, _this.scene, _this.bounds, _this, _this.crocodiles);
        _this.buildScene();
        return _this;
    }
    Level2.prototype.buildScene = function () {
        _super.prototype.buildScene.call(this);
        // add actors
        this.scene.add(this.sky);
        for (var _i = 0, _a = this.level2Players; _i < _a.length; _i++) {
            var p = _a[_i];
            this.scene.addUIActor(p.oxygenMeter);
        }
        this.ground.z = 1;
        // start bubbleCreator and crocodileCreator
        this.bubbleCreator.start();
        this.crocodileCreator.start();
    };
    Level2.prototype.dispose = function () {
        this.bubbleCreator.stop();
        this.crocodileCreator.stop();
        _super.prototype.dispose.call(this);
    };
    Level2.sceneKey = "level2";
    Level2.levelBounds = new ex.BoundingBox(0, 0, 5000, 600);
    Level2.groundTexture = Resources_1.default.level2.ground;
    return Level2;
}(BaseLevel_1.default));
exports.default = Level2;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Level3Player_1 = __webpack_require__(150);
var RockCreator_1 = __webpack_require__(151);
var BasePlayer_1 = __webpack_require__(6);
var BaseLevel_1 = __webpack_require__(28);
var Resources_1 = __webpack_require__(4);
var Level3 = /** @class */ (function (_super) {
    __extends(Level3, _super);
    function Level3(bootstrap) {
        var _this = _super.call(this, Level3.sceneKey, bootstrap, Level3.levelBounds, 
        // players[]
        (bootstrap.state.names.length === 2
            ? ([new Level3Player_1.default(100, 400, BasePlayer_1.controlSets.controls1, bootstrap.state, true), new Level3Player_1.default(30, 250, BasePlayer_1.controlSets.controls2, bootstrap.state, false)]) // two players required
            : ([new Level3Player_1.default(100, 400, BasePlayer_1.controlSets.controls1, bootstrap.state, true)])), // just one player required
        Level3.groundTexture, Resources_1.default.level3.bg.asSprite()) || this;
        // rocks
        _this.rocks = [];
        _this.state = bootstrap.state;
        _this.pubPlayers = _this.players;
        // RockCreator for cyclic generation of new rocks
        _this.rockCreator = new RockCreator_1.default(_this.engine, _this.scene, _this.bounds, _this, _this.rocks);
        _this.buildScene();
        return _this;
    }
    Level3.prototype.dispose = function () {
        this.rockCreator.stop();
        _super.prototype.dispose.call(this);
    };
    Level3.prototype.buildScene = function () {
        _super.prototype.buildScene.call(this);
        // start rockCreator
        this.rockCreator.start();
    };
    Level3.sceneKey = "level3";
    Level3.levelBounds = new ex.BoundingBox(0, 0, 5000, 600);
    Level3.groundTexture = Resources_1.default.level3.ground;
    return Level3;
}(BaseLevel_1.default));
exports.default = Level3;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var GameBootstrap_1 = __webpack_require__(34);
var Level4Player_1 = __webpack_require__(62);
var Cannibal_1 = __webpack_require__(153);
var Vine_1 = __webpack_require__(58);
var Princess_1 = __webpack_require__(155);
var Pot_1 = __webpack_require__(157);
var EslanParts_1 = __webpack_require__(36);
var BasePlayer_1 = __webpack_require__(6);
var BaseLevel_1 = __webpack_require__(28);
var Resources_1 = __webpack_require__(4);
var Ground_1 = __webpack_require__(19);
var Level4 = /** @class */ (function (_super) {
    __extends(Level4, _super);
    function Level4(bootstrap) {
        var _this = _super.call(this, Level4.sceneKey, bootstrap, Level4.levelBounds, (bootstrap.state.names.length === 2
            ? ([new Level4Player_1.default(100, 400, BasePlayer_1.controlSets.controls1, bootstrap.state, true), new Level4Player_1.default(30, 250, BasePlayer_1.controlSets.controls2, bootstrap.state, false)]) // two players required
            : ([new Level4Player_1.default(100, 400, BasePlayer_1.controlSets.controls1, bootstrap.state, true)])), // just one player required
        Level4.groundTexture, Resources_1.default.level4.bg.asSprite()) || this;
        _this.numCannibals = 5;
        _this.cannibals = [];
        // modify multiplayer winning / losing: it's sufficient if one player reaches the princess here
        _this.losers = 0;
        _this.lose = function () {
            if (_this.state.lives > 1) {
                _this.state.lives -= 1;
            }
            else {
                _this.losers++;
                if (_this.losers >= _this.players.length)
                    _this.emit("done", {
                        target: _this,
                        type: GameBootstrap_1.GameElementDoneType.Aborted
                    });
            }
        };
        _this.win = function () {
            _this.emit("done", {
                target: _this,
                type: GameBootstrap_1.GameElementDoneType.Finished
            });
        };
        // vine + wife + pot
        _this.vine = new Vine_1.default(4800, 0, 28, 2, 0.05);
        _this.princess = new Princess_1.default(_this.vine);
        _this.pot = new Pot_1.default(4800, 550, 150, 150);
        // cannibals
        for (var i = 0; i < _this.numCannibals; i++) {
            var xStart = _this.randomIntFromInterval(500, 4500);
            var speedX = _this.randomIntFromInterval(100, 200);
            var w = EslanParts_1.modelSize.w, h = EslanParts_1.modelSize.h;
            _this.cannibals.push(new Cannibal_1.default(xStart, _this.bounds.bottom - Ground_1.default.height - h / 2, w, h, speedX, 400, 4600, _this.players));
        }
        // player handling - init level-specific animations
        _this.level4Players = _this.players;
        // add actors to scene
        _this.buildScene();
        return _this;
    }
    Level4.prototype.buildScene = function () {
        _super.prototype.buildScene.call(this);
        // add scene specific actors
        for (var _i = 0, _a = this.vine.getAllParts(); _i < _a.length; _i++) {
            var vinePart = _a[_i];
            this.scene.add(vinePart);
        }
        this.scene.add(this.princess);
        this.scene.add(this.pot);
        for (var _b = 0, _c = this.cannibals; _b < _c.length; _b++) {
            var b = _c[_b];
            this.scene.add(b);
        }
    };
    Level4.sceneKey = "level4";
    Level4.levelBounds = new ex.BoundingBox(0, 0, 5000, 600);
    Level4.groundTexture = Resources_1.default.level4.ground;
    return Level4;
}(BaseLevel_1.default));
exports.default = Level4;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BasePlayer_1 = __webpack_require__(6);
var Level4_1 = __webpack_require__(61);
var MikelsonAnimation_1 = __webpack_require__(14);
var Ground_1 = __webpack_require__(19);
var Level4Player = /** @class */ (function (_super) {
    __extends(Level4Player, _super);
    function Level4Player(x, y, controlSet, state, isFirst) {
        var _this = _super.call(this, x, y, controlSet, state) || this;
        _this.isFirst = isFirst;
        _this.moveDir = 0;
        _this.stateX = "right";
        _this.stateY = "walk";
        _this.isJumping = false;
        _this.minX = Level4_1.default.levelBounds.left + Level4Player.size.w / 2;
        _this.maxX = Level4_1.default.levelBounds.right - Level4Player.size.w / 2;
        _this.anchor.setTo(0.5, 1);
        _this.body.useBoxCollision();
        _this.y += _this.getHeight() / 2;
        _this.posYold = _this.pos.y;
        if (isFirst)
            _this.animation = MikelsonAnimation_1.playerAnimationFactory.attachTo(_this);
        else
            _this.animation = MikelsonAnimation_1.brotherAnimationFactory.attachTo(_this);
        return _this;
    }
    Level4Player.prototype.update = function (engine, delta) {
        var _this = this;
        var stateChanged = false;
        var updateStateX = function (x) {
            stateChanged = true;
            _this.stateX = x;
        };
        var updateStateY = function (y) {
            stateChanged = true;
            _this.stateY = y;
        };
        _super.prototype.update.call(this, engine, delta);
        // change movement if not currently in the air
        if (this.isGround()) {
            // just landed
            var groundLevel = this.scene.engine.getWorldBounds().bottom - Ground_1.default.height;
            if (this.stateY === "jump" && this.posYold < (groundLevel - 5)) {
                // just landed
                // console.log("just landed");
                updateStateY("walk");
            }
            if (engine.input.keyboard.wasPressed(this.controls.up) && this.stateY !== "jump") {
                if (this.jump()) {
                    updateStateY("jump");
                }
            }
            if (this.stateY !== "jump") {
                if (engine.input.keyboard.isHeld(this.controls.left)) {
                    this.moveDir = 1;
                    if (this.stateX !== "left") {
                        updateStateX("left");
                        // console.log("just turned left");
                    }
                    if (this.stateY !== "walk") {
                        updateStateY("walk");
                        // console.log("just started walking");
                    }
                }
                else {
                    if (engine.input.keyboard.isHeld(this.controls.right)) {
                        this.moveDir = -1;
                        if (this.stateX !== "right") {
                            updateStateX("right");
                            // console.log("just turned right");
                        }
                        if (this.stateY !== "walk") {
                            updateStateY("walk");
                            // console.log("just started walking");
                        }
                    }
                    else {
                        this.moveDir = 0;
                        if (this.stateY !== "idle") {
                            updateStateY("idle");
                            // console.log("just entered idle");
                        }
                    }
                }
            }
            // check if state changed and update animation accordingly
            if (stateChanged)
                this.changeAnimationState(this.stateX, this.stateY);
        }
        // move according to direction of movement
        this.pos.x -= Level4Player.speed * this.moveDir;
        this.pos.x = this.pos.x < this.minX ? this.minX : this.pos.x;
        this.pos.x = this.pos.x > this.maxX ? this.maxX : this.pos.x;
        this.posYold = this.pos.y;
    };
    Level4Player.prototype.jump = function () {
        if (this.isGround()) {
            this.vel.setTo(this.vel.x, Level4Player.jumpingVelocity);
            if (!this.isJumping && this.animation) {
                this.isJumping = true;
            }
            return true; // returns true to signalise that this.stateY has changed
        }
        return false;
    };
    Level4Player.prototype.goLeft = function () {
        this.pos.x -= Level4Player.speed;
        this.pos.x = this.pos.x < this.minX ? this.minX : this.pos.x;
    };
    Level4Player.prototype.goRight = function () {
        this.pos.x += Level4Player.speed;
        this.pos.x = this.pos.x > this.maxX ? this.maxX : this.pos.x;
    };
    Level4Player.prototype.declareWinner = function () {
        this.state.winner = this.isFirst ? this.state.names[0] : this.state.names[1];
    };
    // convert separated states to animation state
    Level4Player.prototype.changeAnimationState = function (stateX, stateY) {
        if (stateX === void 0) { stateX = this.stateX; }
        if (stateY === void 0) { stateY = this.stateY; }
        var state = stateY + "-" + stateX;
        // console.log(state);
        this.animation.changeState(state);
    };
    Level4Player.jumpingVelocity = -900;
    Level4Player.speed = 8;
    return Level4Player;
}(BasePlayer_1.default));
exports.default = Level4Player;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationHelpers_1 = __webpack_require__(35);
var MikelsonParts_1 = __webpack_require__(12);
exports.modelSize = {
    w: 43,
    h: 119
};
var armSize = {
    w: 16,
    h: 59,
};
var legSize = {
    w: 13,
    h: 47
};
var headSize = {
    w: 43,
    h: 42
};
var torsoSize = {
    w: 30,
    h: 59
};
var armRight = {
    texture: MikelsonParts_1.texture,
    sourceLocation: __assign({ x: 167, y: 110 }, armSize),
    modelLocation: __assign({ x: 24, y: 38 }, armSize),
    anchor: {
        x: 5,
        y: 5
    }
};
var armLeft = {
    texture: MikelsonParts_1.texture,
    sourceLocation: __assign({ x: 142, y: 110 }, armSize),
    modelLocation: __assign({ x: 6, y: 38 }, armSize),
    anchor: {
        x: 9,
        y: 5
    }
};
var legRight = {
    texture: MikelsonParts_1.texture,
    sourceLocation: __assign({ x: 216, y: 121 }, legSize),
    modelLocation: __assign({ x: 24, y: 72 }, legSize),
    anchor: {
        x: legSize.w / 2,
        y: 5
    }
};
var legLeft = {
    texture: MikelsonParts_1.texture,
    sourceLocation: __assign({ x: 199, y: 121 }, legSize),
    modelLocation: __assign({ x: 7, y: 72 }, legSize),
    anchor: {
        x: legSize.w / 2,
        y: 5
    }
};
var head = {
    texture: MikelsonParts_1.texture,
    sourceLocation: __assign({ x: 22, y: 120 }, headSize),
    modelLocation: __assign({ x: 0, y: 0 }, headSize),
    anchor: {
        x: 23,
        y: 43
    }
};
var torso = {
    texture: MikelsonParts_1.texture,
    sourceLocation: __assign({ x: 86, y: 111 }, torsoSize),
    modelLocation: __assign({ x: 7, y: 30 }, torsoSize),
    anchor: {
        x: torsoSize.w / 2,
        y: torsoSize.h / 2
    }
};
var _sprites = {};
var _bodyParts = {
    armRight: armRight,
    armLeft: armLeft,
    legRight: legRight,
    legLeft: legLeft,
    head: head,
    torso: torso
};
var allParts = [
    armRight,
    armLeft,
    legRight,
    legLeft,
    head,
    torso
];
var centerPart = function (part) {
    var ml = part.modelLocation;
    ml.x -= exports.modelSize.w / 2;
    ml.y -= exports.modelSize.h / 2;
    // ml.y -= modelSize.h;
    ml.x += part.anchor.x;
    ml.y += part.anchor.y;
};
allParts.forEach(centerPart);
Object.entries(_bodyParts).forEach(function (_a) {
    var key = _a[0], _b = _a[1], texture = _b.texture, loc = _b.sourceLocation;
    return _sprites[key] = new AnimationHelpers_1.CustomSprite(texture, loc.x, loc.y, loc.w, loc.h);
});
exports.bodyParts = _bodyParts;
exports.sprites = _sprites;


/***/ }),
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// environment declarations
__webpack_require__(77);
// base assets
__webpack_require__(78);


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// @ts-ignore
window.ENV = "prod";


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// base assets
__webpack_require__(79);
// main application
__webpack_require__(80);


/***/ }),
/* 79 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function init() {
    /**
     * Check whether the user is using Internet Explorer.
     */
    if (navigator.userAgent.match(/MSIE|Trident/)) {
        /**
         * Criticise the user.
         */
        document.getElementById("init-message").innerText = "Internet Explorer is currently not supported.";
    }
    else if (navigator.userAgent.indexOf("Edge") > -1) {
        /**
         * Nope, even Edge can't handle our game.
         */
        document.getElementById("init-message").innerText = "Edge isn't good enough to be able to run our game. Sorry.";
    }
    else {
        /**
         * Do NOT import this method in the beginning of this file, as
         * some older browser *khm* IE *khm* may not throw syntax errors
         * that are thrown when imports are loaded. Instead, we want to
         * display the browser support message as shown above.
         */
        var gameInit = __webpack_require__(81).default;
        gameInit();
    }
}
if (document.readyState !== "loading")
    init();
else
    document.addEventListener("DOMContentLoaded", init);


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Preloader_1 = __webpack_require__(52);
var GameBootstrap_1 = __webpack_require__(34);
var Resources_1 = __webpack_require__(4);
var excalibur_1 = __webpack_require__(0);
/**
 * Subscribing two events via the `once` method and emitting that event won't work (bug).
 * This is a nasty workaround.
 */
var off = excalibur_1.EventDispatcher.prototype.off;
excalibur_1.EventDispatcher.prototype.off = function () {
    var _this = this;
    var args = arguments;
    setTimeout(function () { return off.apply(_this, args); });
};
/**
 * This function is located in a separate file other tan index.ts as some
 * old browsers *khm* IE *khm* may have trouble loading resources and throw
 * parsing errors, blocking the whole script execution. See `index.ts` for
 * more information.
 */
function initGame() {
    return __awaiter(this, void 0, void 0, function () {
        var resources, gb;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resources = Resources_1.initialResources.map(Preloader_1.preloadImage);
                    return [4 /*yield*/, Promise.all(resources.map(function (t) { return t.promise; }))];
                case 1:
                    _a.sent();
                    gb = new GameBootstrap_1.GameBootstrap();
                    initEnv(window.ENV, gb);
                    gb.start();
                    return [2 /*return*/];
            }
        });
    });
}
exports.default = initGame;
function initEnv(env, gb) {
    if (env === "dev") {
        window.bootstrap = gb;
        window.debug = function () { return gb.engine.isDebug = !gb.engine.isDebug; };
    }
}


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Class_1 = __webpack_require__(17);
var StateListener = /** @class */ (function (_super) {
    __extends(StateListener, _super);
    function StateListener(initialState) {
        var _this = _super.call(this) || this;
        _this.internalState = initialState;
        return _this;
    }
    StateListener.prototype.emitEvent = function (e) {
        this.emit(e.key, e);
        this.emit("$all", e);
    };
    StateListener.prototype.createListenableObject = function () {
        var _this = this;
        var state = {};
        Object.keys(this.internalState).forEach(function (t) {
            var key = t;
            Object.defineProperty(state, key, {
                get: function () { return _this.internalState[key]; },
                set: function (newValue) {
                    var oldValue = _this.internalState[key];
                    _this.internalState[key] = newValue;
                    _this.emitEvent({
                        target: state,
                        oldValue: oldValue,
                        newValue: newValue,
                        key: key
                    });
                },
                enumerable: true,
                configurable: false,
            });
        });
        return state;
    };
    return StateListener;
}(Class_1.Class));
exports.default = StateListener;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/c93e79fa12641dd0cab9642acdfc920a.png";

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/b91b53261dea0034a21860f3ed748cb1.png";

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/c72077d857fd5a0a1e467624e5c58d21.png";

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/5e5a7df7f6c3b51aeb3da1d64aacec39.png";

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/9a37bd9933e31961757d5ee089633d6b.png";

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/a3197fccf6426e16064ab848ac2045cd.png";

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/c93180ff50d3c1cbfcb8f7df37ca26be.png";

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/4e5d8a9452c3fb69b88ecf87d6ba4e93.png";

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/147551d6942cc2c2ac58a98ef8d0fc4d.png";

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/866b0d8936e4082a7855aed704c4b1df.png";

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/b73ad6b58bcb76ac9ed0cb378cc3cefd.png";

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/6c097bf454a5dc86f25c327acc980679.png";

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/b1af393cf814f70d9e5917d79ed61809.png";

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/3e08ac19633622f3ab350e3436fd8882.jpg";

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/6a1a406e9476b3f2a6ff2979be7cd83f.png";

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/d7c94c6941a8bc38329178482db8f022.png";

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/f4245afa5a3faada255d6dd88c3127be.png";

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/cd93e0d00d9c3b2b931016a5db0b3c84.png";

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/d5adaf8bfeff5c4d467f4902c0f07a53.png";

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/ad49e26b8d8e76112d09995c7279e693.png";

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/1fa5e767ffc5e48cb63213865edc19e1.png";

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/2db8817258f7b94cf3077578425c036e.png";

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/0bfb33b643ebbe3348c0024f9ffdfb25.png";

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/ef8c152a55ec13d9b008b1788938b1c1.ttf";

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/f0b6ea67ba06de3f6770e5d93555fef7.ttf";

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/a8e5f4531051cc0cb621d51e875775c0.TTF";

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationSequence_1 = __webpack_require__(26);
var ParticlesJS_1 = __webpack_require__(110);
var InterfaceBuilder_1 = __webpack_require__(5);
var GameBar_1 = __webpack_require__(112);
var Modal_1 = __webpack_require__(116);
var NameEnquiry_1 = __webpack_require__(121);
var StarWarsIntro_1 = __webpack_require__(130);
__webpack_require__(132);
var particlesJSConfig = __webpack_require__(133);
var audioURL = __webpack_require__(57);
var transitionDuration = 2000;
var homeParticlesID = "home-particles";
var GameInterface = /** @class */ (function (_super) {
    __extends(GameInterface, _super);
    function GameInterface(attrs) {
        var _this = _super.call(this, attrs) || this;
        _this.canvas = InterfaceBuilder_1.InterfaceBuilder.createElement("canvas", { id: "canvas", height: "600", width: "800" });
        _this.particles = null;
        _this.introAudio = new Audio(audioURL);
        _this.isUp = false;
        _this.type = "menu";
        _this.introAudio.load();
        _this.upAnimation = new AnimationSequence_1.AnimationSequence([
            function () { return _this.displayAbove.style.display = "block"; },
            function () { return _this.viewportWrapper.classList.add("up"); },
            function () { return _this.displayAboveShown(); },
            transitionDuration,
            function () { return _this.displayBelow.style.display = "none"; },
            function () { return _this.displayBelowHidden(); },
        ]);
        _this.downAnimation = new AnimationSequence_1.AnimationSequence([
            function () { return _this.displayBelow.style.display = "block"; },
            function () { return _this.viewportWrapper.classList.remove("up"); },
            function () { return _this.displayBelowShown(); },
            transitionDuration,
            function () { return _this.displayAbove.style.display = "none"; },
            function () { return _this.displayAboveHidden(); },
        ]);
        return _this;
    }
    GameInterface.prototype.moveUp = function () {
        if (this.isUp)
            return;
        this.isUp = true;
        this.downAnimation.cancel();
        this.upAnimation.start();
    };
    GameInterface.prototype.moveDown = function () {
        if (!this.isUp)
            return;
        this.isUp = false;
        this.upAnimation.cancel();
        this.downAnimation.start();
    };
    GameInterface.prototype.showIntro = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.starWarsIntro.showIntro()];
                    case 1:
                        _a.sent();
                        this.moveUp();
                        return [2 /*return*/, new Promise(function (resolve) {
                                _this.starWarsIntro.once("done", function () {
                                    _this.moveDown();
                                    resolve();
                                });
                            })];
                }
            });
        });
    };
    GameInterface.prototype.showTransition = function (text) {
        var _this = this;
        this.starWarsIntro.showText(text);
        this.moveUp();
        return new Promise(function (resolve) {
            _this.starWarsIntro.once("done", function () {
                _this.moveDown();
                resolve();
            });
        });
    };
    GameInterface.prototype.setContentType = function (type) {
        if (type === this.type)
            return;
        this.type = type;
        if (type === "menu") {
            this.menu.style.display = "block";
            this.canvasHolder.style.display = "none";
            this.startAnimations();
        }
        else {
            if (!this.isUp)
                this.stopAnimations();
            this.menu.style.display = "none";
            this.canvasHolder.style.display = "flex";
        }
    };
    GameInterface.prototype.displayBelowHidden = function () {
        this.stopAnimations();
        this.emit("movedUp", void (0));
    };
    GameInterface.prototype.displayBelowShown = function () {
        if (this.type === "menu")
            this.startAnimations();
        this.emit("moveDown", void (0));
    };
    GameInterface.prototype.displayAboveHidden = function () {
        this.emit("movedDown", void (0));
    };
    GameInterface.prototype.displayAboveShown = function () {
        this.emit("moveUp", void (0));
    };
    GameInterface.prototype.stopAnimations = function () {
        this.nameEnquiry.stopListening();
        if (this.particles) {
            this.particles.destroy();
            this.particles = null;
        }
    };
    GameInterface.prototype.startAnimations = function () {
        this.nameEnquiry.startListening();
        if (this.particles)
            this.particles.destroy();
        else
            this.particles = new ParticlesJS_1.default(homeParticlesID, particlesJSConfig);
    };
    GameInterface.prototype.onStart = function (name1, name2) {
        var names = name2 ? [name1, name2] : [name1];
        this.emit("playClicked", names);
    };
    GameInterface.prototype.showModal = function () {
        this.modal.show();
    };
    GameInterface.prototype.menuClick = function (level, players) {
        this.emit("levelSelected", { level: level, players: players });
    };
    GameInterface.prototype.render = function (attrs) {
        var _this = this;
        var bootstrap = attrs.bootstrap, ref = attrs.ref;
        var canvas = this.canvas;
        var ret = (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "viewport-wrapper", ref: function (e) { return _this.viewportWrapper = e; } },
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "display-above bg-stars", ref: function (e) { return _this.displayAbove = e; }, style: { display: "none" } },
                InterfaceBuilder_1.InterfaceBuilder.createElement(StarWarsIntro_1.default, { bootstrap: attrs.bootstrap, ref: function (swi) { return _this.starWarsIntro = swi; } })),
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "display-below", ref: function (e) { return _this.displayBelow = e; } },
                InterfaceBuilder_1.InterfaceBuilder.createElement(Modal_1.default, { ref: function (m) { return _this.modal = m; } },
                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", { style: { height: "100%" } },
                        InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "background saturn-bg-holder" },
                            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "abstract-canvas-holder", id: homeParticlesID }),
                            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "saturn" }),
                            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "bg" })),
                        InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "canvas-holder", ref: function (e) { return _this.canvasHolder = e; }, style: { display: "none" } },
                            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "canvas-wrapper" },
                                InterfaceBuilder_1.InterfaceBuilder.createElement(GameBar_1.default, { bootstrap: bootstrap }),
                                canvas)),
                        InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "name-enquiry-wrapper", ref: function (e) { return _this.menu = e; } },
                            InterfaceBuilder_1.InterfaceBuilder.createElement(NameEnquiry_1.default, { ref: function (ne) { return _this.nameEnquiry = ne; }, bootstrap: bootstrap, info: this.showModal.bind(this), start: this.onStart.bind(this) }),
                            window.ENV === "dev" && (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "menu" }, [1, 2, 3, 4].map(function (t, i) { return (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "menu-item" },
                                InterfaceBuilder_1.InterfaceBuilder.createElement("span", null,
                                    "Level ",
                                    t),
                                InterfaceBuilder_1.InterfaceBuilder.createElement("button", { className: "control small", onclick: function () { return _this.menuClick(i, 1); } }, "1p"),
                                InterfaceBuilder_1.InterfaceBuilder.createElement("button", { className: "control small", onclick: function () { return _this.menuClick(i, 2); } }, "2p"))); }))))),
                    InterfaceBuilder_1.InterfaceBuilder.createElement(Modal_1.ModalContentWrapper, null,
                        InterfaceBuilder_1.InterfaceBuilder.createElement("div", null,
                            InterfaceBuilder_1.InterfaceBuilder.createElement("h1", null, "SpaceHunt"),
                            InterfaceBuilder_1.InterfaceBuilder.createElement("p", null, "This game was developed as an assignment in spring 2018, within course Software Engineering Methodologies in TUT, by:"),
                            InterfaceBuilder_1.InterfaceBuilder.createElement("ul", null,
                                InterfaceBuilder_1.InterfaceBuilder.createElement("li", null, "Nejc Ma\u010Dek"),
                                InterfaceBuilder_1.InterfaceBuilder.createElement("li", null, "Milo\u0161 \u0160va\u0148a"),
                                InterfaceBuilder_1.InterfaceBuilder.createElement("li", null, "Wladimir Hofmann"),
                                InterfaceBuilder_1.InterfaceBuilder.createElement("li", null, "Ali Doruk Gezici"),
                                InterfaceBuilder_1.InterfaceBuilder.createElement("li", null, "Anna Va\u0148kov\u00E1")),
                            InterfaceBuilder_1.InterfaceBuilder.createElement("p", { style: { textAlign: "right" } },
                                InterfaceBuilder_1.InterfaceBuilder.createElement("button", { className: "control", onclick: function () { return _this.modal.hide(); } }, "\u2B05"))))))));
        window.requestAnimationFrame(function () {
            return _this.displayBelowShown();
        });
        if (attrs.ref)
            attrs.ref(this);
        return ret;
    };
    return GameInterface;
}(InterfaceBuilder_1.Component));
exports.default = GameInterface;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(111);
var ParticlesJS = /** @class */ (function () {
    function ParticlesJS(holderID, config) {
        if (window.pJSDom === null)
            window.pJSDom = [];
        var index = window.pJSDom
            ? window.pJSDom.length
            : 0;
        particlesJS(holderID, config);
        if (!window.pJSDom)
            throw new Error("Particles not created.");
        var pJS = window.pJSDom[index].pJS;
        this.destroy = function () {
            pJS.fn.vendors.destroypJS();
        };
    }
    ParticlesJS.prototype.destroy = function () { };
    return ParticlesJS;
}());
exports.default = ParticlesJS;


/***/ }),
/* 111 */
/***/ (function(module, exports) {

/* -----------------------------------------------
/* Author : Vincent Garreau  - vincentgarreau.com
/* MIT license: http://opensource.org/licenses/MIT
/* Demo / Generator : vincentgarreau.com/particles.js
/* GitHub : github.com/VincentGarreau/particles.js
/* How to use? : Check the GitHub README
/* v2.0.0
/* ----------------------------------------------- */

var pJS = function(tag_id, params){

  var canvas_el = document.querySelector('#'+tag_id+' > .particles-js-canvas-el');

  /* particles.js variables with default values */
  this.pJS = {
    canvas: {
      el: canvas_el,
      w: canvas_el.offsetWidth,
      h: canvas_el.offsetHeight
    },
    particles: {
      number: {
        value: 400,
        density: {
          enable: true,
          value_area: 800
        }
      },
      color: {
        value: '#fff'
      },
      shape: {
        type: 'circle',
        stroke: {
          width: 0,
          color: '#ff0000'
        },
        polygon: {
          nb_sides: 5
        },
        image: {
          src: '',
          width: 100,
          height: 100
        }
      },
      opacity: {
        value: 1,
        random: false,
        anim: {
          enable: false,
          speed: 2,
          opacity_min: 0,
          sync: false
        }
      },
      size: {
        value: 20,
        random: false,
        anim: {
          enable: false,
          speed: 20,
          size_min: 0,
          sync: false
        }
      },
      line_linked: {
        enable: true,
        distance: 100,
        color: '#fff',
        opacity: 1,
        width: 1
      },
      move: {
        enable: true,
        speed: 2,
        direction: 'none',
        random: false,
        straight: false,
        out_mode: 'out',
        bounce: false,
        attract: {
          enable: false,
          rotateX: 3000,
          rotateY: 3000
        }
      },
      array: []
    },
    interactivity: {
      detect_on: 'canvas',
      events: {
        onhover: {
          enable: true,
          mode: 'grab'
        },
        onclick: {
          enable: true,
          mode: 'push'
        },
        resize: true
      },
      modes: {
        grab:{
          distance: 100,
          line_linked:{
            opacity: 1
          }
        },
        bubble:{
          distance: 200,
          size: 80,
          duration: 0.4
        },
        repulse:{
          distance: 200,
          duration: 0.4
        },
        push:{
          particles_nb: 4
        },
        remove:{
          particles_nb: 2
        }
      },
      mouse:{}
    },
    retina_detect: false,
    fn: {
      interact: {},
      modes: {},
      vendors:{}
    },
    tmp: {}
  };

  var pJS = this.pJS;

  /* params settings */
  if(params){
    Object.deepExtend(pJS, params);
  }

  pJS.tmp.obj = {
    size_value: pJS.particles.size.value,
    size_anim_speed: pJS.particles.size.anim.speed,
    move_speed: pJS.particles.move.speed,
    line_linked_distance: pJS.particles.line_linked.distance,
    line_linked_width: pJS.particles.line_linked.width,
    mode_grab_distance: pJS.interactivity.modes.grab.distance,
    mode_bubble_distance: pJS.interactivity.modes.bubble.distance,
    mode_bubble_size: pJS.interactivity.modes.bubble.size,
    mode_repulse_distance: pJS.interactivity.modes.repulse.distance
  };


  pJS.fn.retinaInit = function(){

    if(pJS.retina_detect && window.devicePixelRatio > 1){
      pJS.canvas.pxratio = window.devicePixelRatio; 
      pJS.tmp.retina = true;
    } 
    else{
      pJS.canvas.pxratio = 1;
      pJS.tmp.retina = false;
    }

    pJS.canvas.w = pJS.canvas.el.offsetWidth * pJS.canvas.pxratio;
    pJS.canvas.h = pJS.canvas.el.offsetHeight * pJS.canvas.pxratio;

    pJS.particles.size.value = pJS.tmp.obj.size_value * pJS.canvas.pxratio;
    pJS.particles.size.anim.speed = pJS.tmp.obj.size_anim_speed * pJS.canvas.pxratio;
    pJS.particles.move.speed = pJS.tmp.obj.move_speed * pJS.canvas.pxratio;
    pJS.particles.line_linked.distance = pJS.tmp.obj.line_linked_distance * pJS.canvas.pxratio;
    pJS.interactivity.modes.grab.distance = pJS.tmp.obj.mode_grab_distance * pJS.canvas.pxratio;
    pJS.interactivity.modes.bubble.distance = pJS.tmp.obj.mode_bubble_distance * pJS.canvas.pxratio;
    pJS.particles.line_linked.width = pJS.tmp.obj.line_linked_width * pJS.canvas.pxratio;
    pJS.interactivity.modes.bubble.size = pJS.tmp.obj.mode_bubble_size * pJS.canvas.pxratio;
    pJS.interactivity.modes.repulse.distance = pJS.tmp.obj.mode_repulse_distance * pJS.canvas.pxratio;

  };



  /* ---------- pJS functions - canvas ------------ */

  pJS.fn.canvasInit = function(){
    pJS.canvas.ctx = pJS.canvas.el.getContext('2d');
  };

  pJS.fn.canvasSize = function(){

    pJS.canvas.el.width = pJS.canvas.w;
    pJS.canvas.el.height = pJS.canvas.h;

    if(pJS && pJS.interactivity.events.resize){

      window.addEventListener('resize', function(){

          pJS.canvas.w = pJS.canvas.el.offsetWidth;
          pJS.canvas.h = pJS.canvas.el.offsetHeight;

          /* resize canvas */
          if(pJS.tmp.retina){
            pJS.canvas.w *= pJS.canvas.pxratio;
            pJS.canvas.h *= pJS.canvas.pxratio;
          }

          pJS.canvas.el.width = pJS.canvas.w;
          pJS.canvas.el.height = pJS.canvas.h;

          /* repaint canvas on anim disabled */
          if(!pJS.particles.move.enable){
            pJS.fn.particlesEmpty();
            pJS.fn.particlesCreate();
            pJS.fn.particlesDraw();
            pJS.fn.vendors.densityAutoParticles();
          }

        /* density particles enabled */
        pJS.fn.vendors.densityAutoParticles();

      });

    }

  };


  pJS.fn.canvasPaint = function(){
    pJS.canvas.ctx.fillRect(0, 0, pJS.canvas.w, pJS.canvas.h);
  };

  pJS.fn.canvasClear = function(){
    pJS.canvas.ctx.clearRect(0, 0, pJS.canvas.w, pJS.canvas.h);
  };


  /* --------- pJS functions - particles ----------- */

  pJS.fn.particle = function(color, opacity, position){

    /* size */
    this.radius = (pJS.particles.size.random ? Math.random() : 1) * pJS.particles.size.value;
    if(pJS.particles.size.anim.enable){
      this.size_status = false;
      this.vs = pJS.particles.size.anim.speed / 100;
      if(!pJS.particles.size.anim.sync){
        this.vs = this.vs * Math.random();
      }
    }

    /* position */
    this.x = position ? position.x : Math.random() * pJS.canvas.w;
    this.y = position ? position.y : Math.random() * pJS.canvas.h;

    /* check position  - into the canvas */
    if(this.x > pJS.canvas.w - this.radius*2) this.x = this.x - this.radius;
    else if(this.x < this.radius*2) this.x = this.x + this.radius;
    if(this.y > pJS.canvas.h - this.radius*2) this.y = this.y - this.radius;
    else if(this.y < this.radius*2) this.y = this.y + this.radius;

    /* check position - avoid overlap */
    if(pJS.particles.move.bounce){
      pJS.fn.vendors.checkOverlap(this, position);
    }

    /* color */
    this.color = {};
    if(typeof(color.value) == 'object'){

      if(color.value instanceof Array){
        var color_selected = color.value[Math.floor(Math.random() * pJS.particles.color.value.length)];
        this.color.rgb = hexToRgb(color_selected);
      }else{
        if(color.value.r != undefined && color.value.g != undefined && color.value.b != undefined){
          this.color.rgb = {
            r: color.value.r,
            g: color.value.g,
            b: color.value.b
          }
        }
        if(color.value.h != undefined && color.value.s != undefined && color.value.l != undefined){
          this.color.hsl = {
            h: color.value.h,
            s: color.value.s,
            l: color.value.l
          }
        }
      }

    }
    else if(color.value == 'random'){
      this.color.rgb = {
        r: (Math.floor(Math.random() * (255 - 0 + 1)) + 0),
        g: (Math.floor(Math.random() * (255 - 0 + 1)) + 0),
        b: (Math.floor(Math.random() * (255 - 0 + 1)) + 0)
      }
    }
    else if(typeof(color.value) == 'string'){
      this.color = color;
      this.color.rgb = hexToRgb(this.color.value);
    }

    /* opacity */
    this.opacity = (pJS.particles.opacity.random ? Math.random() : 1) * pJS.particles.opacity.value;
    if(pJS.particles.opacity.anim.enable){
      this.opacity_status = false;
      this.vo = pJS.particles.opacity.anim.speed / 100;
      if(!pJS.particles.opacity.anim.sync){
        this.vo = this.vo * Math.random();
      }
    }

    /* animation - velocity for speed */
    var velbase = {}
    switch(pJS.particles.move.direction){
      case 'top':
        velbase = { x:0, y:-1 };
      break;
      case 'top-right':
        velbase = { x:0.5, y:-0.5 };
      break;
      case 'right':
        velbase = { x:1, y:-0 };
      break;
      case 'bottom-right':
        velbase = { x:0.5, y:0.5 };
      break;
      case 'bottom':
        velbase = { x:0, y:1 };
      break;
      case 'bottom-left':
        velbase = { x:-0.5, y:1 };
      break;
      case 'left':
        velbase = { x:-1, y:0 };
      break;
      case 'top-left':
        velbase = { x:-0.5, y:-0.5 };
      break;
      default:
        velbase = { x:0, y:0 };
      break;
    }

    if(pJS.particles.move.straight){
      this.vx = velbase.x;
      this.vy = velbase.y;
      if(pJS.particles.move.random){
        this.vx = this.vx * (Math.random());
        this.vy = this.vy * (Math.random());
      }
    }else{
      this.vx = velbase.x + Math.random()-0.5;
      this.vy = velbase.y + Math.random()-0.5;
    }

    // var theta = 2.0 * Math.PI * Math.random();
    // this.vx = Math.cos(theta);
    // this.vy = Math.sin(theta);

    this.vx_i = this.vx;
    this.vy_i = this.vy;

    

    /* if shape is image */

    var shape_type = pJS.particles.shape.type;
    if(typeof(shape_type) == 'object'){
      if(shape_type instanceof Array){
        var shape_selected = shape_type[Math.floor(Math.random() * shape_type.length)];
        this.shape = shape_selected;
      }
    }else{
      this.shape = shape_type;
    }

    if(this.shape == 'image'){
      var sh = pJS.particles.shape;
      this.img = {
        src: sh.image.src,
        ratio: sh.image.width / sh.image.height
      }
      if(!this.img.ratio) this.img.ratio = 1;
      if(pJS.tmp.img_type == 'svg' && pJS.tmp.source_svg != undefined){
        pJS.fn.vendors.createSvgImg(this);
        if(pJS.tmp.pushing){
          this.img.loaded = false;
        }
      }
    }

    

  };


  pJS.fn.particle.prototype.draw = function() {

    var p = this;

    if(p.radius_bubble != undefined){
      var radius = p.radius_bubble; 
    }else{
      var radius = p.radius;
    }

    if(p.opacity_bubble != undefined){
      var opacity = p.opacity_bubble;
    }else{
      var opacity = p.opacity;
    }

    if(p.color.rgb){
      var color_value = 'rgba('+p.color.rgb.r+','+p.color.rgb.g+','+p.color.rgb.b+','+opacity+')';
    }else{
      var color_value = 'hsla('+p.color.hsl.h+','+p.color.hsl.s+'%,'+p.color.hsl.l+'%,'+opacity+')';
    }

    pJS.canvas.ctx.fillStyle = color_value;
    pJS.canvas.ctx.beginPath();

    switch(p.shape){

      case 'circle':
        pJS.canvas.ctx.arc(p.x, p.y, radius, 0, Math.PI * 2, false);
      break;

      case 'edge':
        pJS.canvas.ctx.rect(p.x-radius, p.y-radius, radius*2, radius*2);
      break;

      case 'triangle':
        pJS.fn.vendors.drawShape(pJS.canvas.ctx, p.x-radius, p.y+radius / 1.66, radius*2, 3, 2);
      break;

      case 'polygon':
        pJS.fn.vendors.drawShape(
          pJS.canvas.ctx,
          p.x - radius / (pJS.particles.shape.polygon.nb_sides/3.5), // startX
          p.y - radius / (2.66/3.5), // startY
          radius*2.66 / (pJS.particles.shape.polygon.nb_sides/3), // sideLength
          pJS.particles.shape.polygon.nb_sides, // sideCountNumerator
          1 // sideCountDenominator
        );
      break;

      case 'star':
        pJS.fn.vendors.drawShape(
          pJS.canvas.ctx,
          p.x - radius*2 / (pJS.particles.shape.polygon.nb_sides/4), // startX
          p.y - radius / (2*2.66/3.5), // startY
          radius*2*2.66 / (pJS.particles.shape.polygon.nb_sides/3), // sideLength
          pJS.particles.shape.polygon.nb_sides, // sideCountNumerator
          2 // sideCountDenominator
        );
      break;

      case 'image':

        function draw(){
          pJS.canvas.ctx.drawImage(
            img_obj,
            p.x-radius,
            p.y-radius,
            radius*2,
            radius*2 / p.img.ratio
          );
        }

        if(pJS.tmp.img_type == 'svg'){
          var img_obj = p.img.obj;
        }else{
          var img_obj = pJS.tmp.img_obj;
        }

        if(img_obj){
          draw();
        }

      break;

    }

    pJS.canvas.ctx.closePath();

    if(pJS.particles.shape.stroke.width > 0){
      pJS.canvas.ctx.strokeStyle = pJS.particles.shape.stroke.color;
      pJS.canvas.ctx.lineWidth = pJS.particles.shape.stroke.width;
      pJS.canvas.ctx.stroke();
    }
    
    pJS.canvas.ctx.fill();
    
  };


  pJS.fn.particlesCreate = function(){
    for(var i = 0; i < pJS.particles.number.value; i++) {
      pJS.particles.array.push(new pJS.fn.particle(pJS.particles.color, pJS.particles.opacity.value));
    }
  };

  pJS.fn.particlesUpdate = function(){

    for(var i = 0; i < pJS.particles.array.length; i++){

      /* the particle */
      var p = pJS.particles.array[i];

      // var d = ( dx = pJS.interactivity.mouse.click_pos_x - p.x ) * dx + ( dy = pJS.interactivity.mouse.click_pos_y - p.y ) * dy;
      // var f = -BANG_SIZE / d;
      // if ( d < BANG_SIZE ) {
      //     var t = Math.atan2( dy, dx );
      //     p.vx = f * Math.cos(t);
      //     p.vy = f * Math.sin(t);
      // }

      /* move the particle */
      if(pJS.particles.move.enable){
        var ms = pJS.particles.move.speed/2;
        p.x += p.vx * ms;
        p.y += p.vy * ms;
      }

      /* change opacity status */
      if(pJS.particles.opacity.anim.enable) {
        if(p.opacity_status == true) {
          if(p.opacity >= pJS.particles.opacity.value) p.opacity_status = false;
          p.opacity += p.vo;
        }else {
          if(p.opacity <= pJS.particles.opacity.anim.opacity_min) p.opacity_status = true;
          p.opacity -= p.vo;
        }
        if(p.opacity < 0) p.opacity = 0;
      }

      /* change size */
      if(pJS.particles.size.anim.enable){
        if(p.size_status == true){
          if(p.radius >= pJS.particles.size.value) p.size_status = false;
          p.radius += p.vs;
        }else{
          if(p.radius <= pJS.particles.size.anim.size_min) p.size_status = true;
          p.radius -= p.vs;
        }
        if(p.radius < 0) p.radius = 0;
      }

      /* change particle position if it is out of canvas */
      if(pJS.particles.move.out_mode == 'bounce'){
        var new_pos = {
          x_left: p.radius,
          x_right:  pJS.canvas.w,
          y_top: p.radius,
          y_bottom: pJS.canvas.h
        }
      }else{
        var new_pos = {
          x_left: -p.radius,
          x_right: pJS.canvas.w + p.radius,
          y_top: -p.radius,
          y_bottom: pJS.canvas.h + p.radius
        }
      }

      if(p.x - p.radius > pJS.canvas.w){
        p.x = new_pos.x_left;
        p.y = Math.random() * pJS.canvas.h;
      }
      else if(p.x + p.radius < 0){
        p.x = new_pos.x_right;
        p.y = Math.random() * pJS.canvas.h;
      }
      if(p.y - p.radius > pJS.canvas.h){
        p.y = new_pos.y_top;
        p.x = Math.random() * pJS.canvas.w;
      }
      else if(p.y + p.radius < 0){
        p.y = new_pos.y_bottom;
        p.x = Math.random() * pJS.canvas.w;
      }

      /* out of canvas modes */
      switch(pJS.particles.move.out_mode){
        case 'bounce':
          if (p.x + p.radius > pJS.canvas.w) p.vx = -p.vx;
          else if (p.x - p.radius < 0) p.vx = -p.vx;
          if (p.y + p.radius > pJS.canvas.h) p.vy = -p.vy;
          else if (p.y - p.radius < 0) p.vy = -p.vy;
        break;
      }

      /* events */
      if(isInArray('grab', pJS.interactivity.events.onhover.mode)){
        pJS.fn.modes.grabParticle(p);
      }

      if(isInArray('bubble', pJS.interactivity.events.onhover.mode) || isInArray('bubble', pJS.interactivity.events.onclick.mode)){
        pJS.fn.modes.bubbleParticle(p);
      }

      if(isInArray('repulse', pJS.interactivity.events.onhover.mode) || isInArray('repulse', pJS.interactivity.events.onclick.mode)){
        pJS.fn.modes.repulseParticle(p);
      }

      /* interaction auto between particles */
      if(pJS.particles.line_linked.enable || pJS.particles.move.attract.enable){
        for(var j = i + 1; j < pJS.particles.array.length; j++){
          var p2 = pJS.particles.array[j];

          /* link particles */
          if(pJS.particles.line_linked.enable){
            pJS.fn.interact.linkParticles(p,p2);
          }

          /* attract particles */
          if(pJS.particles.move.attract.enable){
            pJS.fn.interact.attractParticles(p,p2);
          }

          /* bounce particles */
          if(pJS.particles.move.bounce){
            pJS.fn.interact.bounceParticles(p,p2);
          }

        }
      }


    }

  };

  pJS.fn.particlesDraw = function(){

    /* clear canvas */
    pJS.canvas.ctx.clearRect(0, 0, pJS.canvas.w, pJS.canvas.h);

    /* update each particles param */
    pJS.fn.particlesUpdate();

    /* draw each particle */
    for(var i = 0; i < pJS.particles.array.length; i++){
      var p = pJS.particles.array[i];
      p.draw();
    }

  };

  pJS.fn.particlesEmpty = function(){
    pJS.particles.array = [];
  };

  pJS.fn.particlesRefresh = function(){

    /* init all */
    cancelRequestAnimFrame(pJS.fn.checkAnimFrame);
    cancelRequestAnimFrame(pJS.fn.drawAnimFrame);
    pJS.tmp.source_svg = undefined;
    pJS.tmp.img_obj = undefined;
    pJS.tmp.count_svg = 0;
    pJS.fn.particlesEmpty();
    pJS.fn.canvasClear();
    
    /* restart */
    pJS.fn.vendors.start();

  };


  /* ---------- pJS functions - particles interaction ------------ */

  pJS.fn.interact.linkParticles = function(p1, p2){

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y,
        dist = Math.sqrt(dx*dx + dy*dy);

    /* draw a line between p1 and p2 if the distance between them is under the config distance */
    if(dist <= pJS.particles.line_linked.distance){

      var opacity_line = pJS.particles.line_linked.opacity - (dist / (1/pJS.particles.line_linked.opacity)) / pJS.particles.line_linked.distance;

      if(opacity_line > 0){        
        
        /* style */
        var color_line = pJS.particles.line_linked.color_rgb_line;
        pJS.canvas.ctx.strokeStyle = 'rgba('+color_line.r+','+color_line.g+','+color_line.b+','+opacity_line+')';
        pJS.canvas.ctx.lineWidth = pJS.particles.line_linked.width;
        //pJS.canvas.ctx.lineCap = 'round'; /* performance issue */
        
        /* path */
        pJS.canvas.ctx.beginPath();
        pJS.canvas.ctx.moveTo(p1.x, p1.y);
        pJS.canvas.ctx.lineTo(p2.x, p2.y);
        pJS.canvas.ctx.stroke();
        pJS.canvas.ctx.closePath();

      }

    }

  };


  pJS.fn.interact.attractParticles  = function(p1, p2){

    /* condensed particles */
    var dx = p1.x - p2.x,
        dy = p1.y - p2.y,
        dist = Math.sqrt(dx*dx + dy*dy);

    if(dist <= pJS.particles.line_linked.distance){

      var ax = dx/(pJS.particles.move.attract.rotateX*1000),
          ay = dy/(pJS.particles.move.attract.rotateY*1000);

      p1.vx -= ax;
      p1.vy -= ay;

      p2.vx += ax;
      p2.vy += ay;

    }
    

  }


  pJS.fn.interact.bounceParticles = function(p1, p2){

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y,
        dist = Math.sqrt(dx*dx + dy*dy),
        dist_p = p1.radius+p2.radius;

    if(dist <= dist_p){
      p1.vx = -p1.vx;
      p1.vy = -p1.vy;

      p2.vx = -p2.vx;
      p2.vy = -p2.vy;
    }

  }


  /* ---------- pJS functions - modes events ------------ */

  pJS.fn.modes.pushParticles = function(nb, pos){

    pJS.tmp.pushing = true;

    for(var i = 0; i < nb; i++){
      pJS.particles.array.push(
        new pJS.fn.particle(
          pJS.particles.color,
          pJS.particles.opacity.value,
          {
            'x': pos ? pos.pos_x : Math.random() * pJS.canvas.w,
            'y': pos ? pos.pos_y : Math.random() * pJS.canvas.h
          }
        )
      )
      if(i == nb-1){
        if(!pJS.particles.move.enable){
          pJS.fn.particlesDraw();
        }
        pJS.tmp.pushing = false;
      }
    }

  };


  pJS.fn.modes.removeParticles = function(nb){

    pJS.particles.array.splice(0, nb);
    if(!pJS.particles.move.enable){
      pJS.fn.particlesDraw();
    }

  };


  pJS.fn.modes.bubbleParticle = function(p){

    /* on hover event */
    if(pJS.interactivity.events.onhover.enable && isInArray('bubble', pJS.interactivity.events.onhover.mode)){

      var dx_mouse = p.x - pJS.interactivity.mouse.pos_x,
          dy_mouse = p.y - pJS.interactivity.mouse.pos_y,
          dist_mouse = Math.sqrt(dx_mouse*dx_mouse + dy_mouse*dy_mouse),
          ratio = 1 - dist_mouse / pJS.interactivity.modes.bubble.distance;

      function init(){
        p.opacity_bubble = p.opacity;
        p.radius_bubble = p.radius;
      }

      /* mousemove - check ratio */
      if(dist_mouse <= pJS.interactivity.modes.bubble.distance){

        if(ratio >= 0 && pJS.interactivity.status == 'mousemove'){
          
          /* size */
          if(pJS.interactivity.modes.bubble.size != pJS.particles.size.value){

            if(pJS.interactivity.modes.bubble.size > pJS.particles.size.value){
              var size = p.radius + (pJS.interactivity.modes.bubble.size*ratio);
              if(size >= 0){
                p.radius_bubble = size;
              }
            }else{
              var dif = p.radius - pJS.interactivity.modes.bubble.size,
                  size = p.radius - (dif*ratio);
              if(size > 0){
                p.radius_bubble = size;
              }else{
                p.radius_bubble = 0;
              }
            }

          }

          /* opacity */
          if(pJS.interactivity.modes.bubble.opacity != pJS.particles.opacity.value){

            if(pJS.interactivity.modes.bubble.opacity > pJS.particles.opacity.value){
              var opacity = pJS.interactivity.modes.bubble.opacity*ratio;
              if(opacity > p.opacity && opacity <= pJS.interactivity.modes.bubble.opacity){
                p.opacity_bubble = opacity;
              }
            }else{
              var opacity = p.opacity - (pJS.particles.opacity.value-pJS.interactivity.modes.bubble.opacity)*ratio;
              if(opacity < p.opacity && opacity >= pJS.interactivity.modes.bubble.opacity){
                p.opacity_bubble = opacity;
              }
            }

          }

        }

      }else{
        init();
      }


      /* mouseleave */
      if(pJS.interactivity.status == 'mouseleave'){
        init();
      }
    
    }

    /* on click event */
    else if(pJS.interactivity.events.onclick.enable && isInArray('bubble', pJS.interactivity.events.onclick.mode)){


      if(pJS.tmp.bubble_clicking){
        var dx_mouse = p.x - pJS.interactivity.mouse.click_pos_x,
            dy_mouse = p.y - pJS.interactivity.mouse.click_pos_y,
            dist_mouse = Math.sqrt(dx_mouse*dx_mouse + dy_mouse*dy_mouse),
            time_spent = (new Date().getTime() - pJS.interactivity.mouse.click_time)/1000;

        if(time_spent > pJS.interactivity.modes.bubble.duration){
          pJS.tmp.bubble_duration_end = true;
        }

        if(time_spent > pJS.interactivity.modes.bubble.duration*2){
          pJS.tmp.bubble_clicking = false;
          pJS.tmp.bubble_duration_end = false;
        }
      }


      function process(bubble_param, particles_param, p_obj_bubble, p_obj, id){

        if(bubble_param != particles_param){

          if(!pJS.tmp.bubble_duration_end){
            if(dist_mouse <= pJS.interactivity.modes.bubble.distance){
              if(p_obj_bubble != undefined) var obj = p_obj_bubble;
              else var obj = p_obj;
              if(obj != bubble_param){
                var value = p_obj - (time_spent * (p_obj - bubble_param) / pJS.interactivity.modes.bubble.duration);
                if(id == 'size') p.radius_bubble = value;
                if(id == 'opacity') p.opacity_bubble = value;
              }
            }else{
              if(id == 'size') p.radius_bubble = undefined;
              if(id == 'opacity') p.opacity_bubble = undefined;
            }
          }else{
            if(p_obj_bubble != undefined){
              var value_tmp = p_obj - (time_spent * (p_obj - bubble_param) / pJS.interactivity.modes.bubble.duration),
                  dif = bubble_param - value_tmp;
                  value = bubble_param + dif;
              if(id == 'size') p.radius_bubble = value;
              if(id == 'opacity') p.opacity_bubble = value;
            }
          }

        }

      }

      if(pJS.tmp.bubble_clicking){
        /* size */
        process(pJS.interactivity.modes.bubble.size, pJS.particles.size.value, p.radius_bubble, p.radius, 'size');
        /* opacity */
        process(pJS.interactivity.modes.bubble.opacity, pJS.particles.opacity.value, p.opacity_bubble, p.opacity, 'opacity');
      }

    }

  };


  pJS.fn.modes.repulseParticle = function(p){

    if(pJS.interactivity.events.onhover.enable && isInArray('repulse', pJS.interactivity.events.onhover.mode) && pJS.interactivity.status == 'mousemove') {

      var dx_mouse = p.x - pJS.interactivity.mouse.pos_x,
          dy_mouse = p.y - pJS.interactivity.mouse.pos_y,
          dist_mouse = Math.sqrt(dx_mouse*dx_mouse + dy_mouse*dy_mouse);

      var normVec = {x: dx_mouse/dist_mouse, y: dy_mouse/dist_mouse},
          repulseRadius = pJS.interactivity.modes.repulse.distance,
          velocity = 100,
          repulseFactor = clamp((1/repulseRadius)*(-1*Math.pow(dist_mouse/repulseRadius,2)+1)*repulseRadius*velocity, 0, 50);
      
      var pos = {
        x: p.x + normVec.x * repulseFactor,
        y: p.y + normVec.y * repulseFactor
      }

      if(pJS.particles.move.out_mode == 'bounce'){
        if(pos.x - p.radius > 0 && pos.x + p.radius < pJS.canvas.w) p.x = pos.x;
        if(pos.y - p.radius > 0 && pos.y + p.radius < pJS.canvas.h) p.y = pos.y;
      }else{
        p.x = pos.x;
        p.y = pos.y;
      }
    
    }


    else if(pJS.interactivity.events.onclick.enable && isInArray('repulse', pJS.interactivity.events.onclick.mode)) {

      if(!pJS.tmp.repulse_finish){
        pJS.tmp.repulse_count++;
        if(pJS.tmp.repulse_count == pJS.particles.array.length){
          pJS.tmp.repulse_finish = true;
        }
      }

      if(pJS.tmp.repulse_clicking){

        var repulseRadius = Math.pow(pJS.interactivity.modes.repulse.distance/6, 3);

        var dx = pJS.interactivity.mouse.click_pos_x - p.x,
            dy = pJS.interactivity.mouse.click_pos_y - p.y,
            d = dx*dx + dy*dy;

        var force = -repulseRadius / d * 1;

        function process(){

          var f = Math.atan2(dy,dx);
          p.vx = force * Math.cos(f);
          p.vy = force * Math.sin(f);

          if(pJS.particles.move.out_mode == 'bounce'){
            var pos = {
              x: p.x + p.vx,
              y: p.y + p.vy
            }
            if (pos.x + p.radius > pJS.canvas.w) p.vx = -p.vx;
            else if (pos.x - p.radius < 0) p.vx = -p.vx;
            if (pos.y + p.radius > pJS.canvas.h) p.vy = -p.vy;
            else if (pos.y - p.radius < 0) p.vy = -p.vy;
          }

        }

        // default
        if(d <= repulseRadius){
          process();
        }

        // bang - slow motion mode
        // if(!pJS.tmp.repulse_finish){
        //   if(d <= repulseRadius){
        //     process();
        //   }
        // }else{
        //   process();
        // }
        

      }else{

        if(pJS.tmp.repulse_clicking == false){

          p.vx = p.vx_i;
          p.vy = p.vy_i;
        
        }

      }

    }

  }


  pJS.fn.modes.grabParticle = function(p){

    if(pJS.interactivity.events.onhover.enable && pJS.interactivity.status == 'mousemove'){

      var dx_mouse = p.x - pJS.interactivity.mouse.pos_x,
          dy_mouse = p.y - pJS.interactivity.mouse.pos_y,
          dist_mouse = Math.sqrt(dx_mouse*dx_mouse + dy_mouse*dy_mouse);

      /* draw a line between the cursor and the particle if the distance between them is under the config distance */
      if(dist_mouse <= pJS.interactivity.modes.grab.distance){

        var opacity_line = pJS.interactivity.modes.grab.line_linked.opacity - (dist_mouse / (1/pJS.interactivity.modes.grab.line_linked.opacity)) / pJS.interactivity.modes.grab.distance;

        if(opacity_line > 0){

          /* style */
          var color_line = pJS.particles.line_linked.color_rgb_line;
          pJS.canvas.ctx.strokeStyle = 'rgba('+color_line.r+','+color_line.g+','+color_line.b+','+opacity_line+')';
          pJS.canvas.ctx.lineWidth = pJS.particles.line_linked.width;
          //pJS.canvas.ctx.lineCap = 'round'; /* performance issue */
          
          /* path */
          pJS.canvas.ctx.beginPath();
          pJS.canvas.ctx.moveTo(p.x, p.y);
          pJS.canvas.ctx.lineTo(pJS.interactivity.mouse.pos_x, pJS.interactivity.mouse.pos_y);
          pJS.canvas.ctx.stroke();
          pJS.canvas.ctx.closePath();

        }

      }

    }

  };



  /* ---------- pJS functions - vendors ------------ */

  pJS.fn.vendors.eventsListeners = function(){

    /* events target element */
    if(pJS.interactivity.detect_on == 'window'){
      pJS.interactivity.el = window;
    }else{
      pJS.interactivity.el = pJS.canvas.el;
    }


    /* detect mouse pos - on hover / click event */
    if(pJS.interactivity.events.onhover.enable || pJS.interactivity.events.onclick.enable){

      /* el on mousemove */
      pJS.interactivity.el.addEventListener('mousemove', function(e){

        if(pJS.interactivity.el == window){
          var pos_x = e.clientX,
              pos_y = e.clientY;
        }
        else{
          var pos_x = e.offsetX || e.clientX,
              pos_y = e.offsetY || e.clientY;
        }

        pJS.interactivity.mouse.pos_x = pos_x;
        pJS.interactivity.mouse.pos_y = pos_y;

        if(pJS.tmp.retina){
          pJS.interactivity.mouse.pos_x *= pJS.canvas.pxratio;
          pJS.interactivity.mouse.pos_y *= pJS.canvas.pxratio;
        }

        pJS.interactivity.status = 'mousemove';

      });

      /* el on onmouseleave */
      pJS.interactivity.el.addEventListener('mouseleave', function(e){

        pJS.interactivity.mouse.pos_x = null;
        pJS.interactivity.mouse.pos_y = null;
        pJS.interactivity.status = 'mouseleave';

      });

    }

    /* on click event */
    if(pJS.interactivity.events.onclick.enable){

      pJS.interactivity.el.addEventListener('click', function(){

        pJS.interactivity.mouse.click_pos_x = pJS.interactivity.mouse.pos_x;
        pJS.interactivity.mouse.click_pos_y = pJS.interactivity.mouse.pos_y;
        pJS.interactivity.mouse.click_time = new Date().getTime();

        if(pJS.interactivity.events.onclick.enable){

          switch(pJS.interactivity.events.onclick.mode){

            case 'push':
              if(pJS.particles.move.enable){
                pJS.fn.modes.pushParticles(pJS.interactivity.modes.push.particles_nb, pJS.interactivity.mouse);
              }else{
                if(pJS.interactivity.modes.push.particles_nb == 1){
                  pJS.fn.modes.pushParticles(pJS.interactivity.modes.push.particles_nb, pJS.interactivity.mouse);
                }
                else if(pJS.interactivity.modes.push.particles_nb > 1){
                  pJS.fn.modes.pushParticles(pJS.interactivity.modes.push.particles_nb);
                }
              }
            break;

            case 'remove':
              pJS.fn.modes.removeParticles(pJS.interactivity.modes.remove.particles_nb);
            break;

            case 'bubble':
              pJS.tmp.bubble_clicking = true;
            break;

            case 'repulse':
              pJS.tmp.repulse_clicking = true;
              pJS.tmp.repulse_count = 0;
              pJS.tmp.repulse_finish = false;
              setTimeout(function(){
                pJS.tmp.repulse_clicking = false;
              }, pJS.interactivity.modes.repulse.duration*1000)
            break;

          }

        }

      });
        
    }


  };

  pJS.fn.vendors.densityAutoParticles = function(){

    if(pJS.particles.number.density.enable){

      /* calc area */
      var area = pJS.canvas.el.width * pJS.canvas.el.height / 1000;
      if(pJS.tmp.retina){
        area = area/(pJS.canvas.pxratio*2);
      }

      /* calc number of particles based on density area */
      var nb_particles = area * pJS.particles.number.value / pJS.particles.number.density.value_area;

      /* add or remove X particles */
      var missing_particles = pJS.particles.array.length - nb_particles;
      if(missing_particles < 0) pJS.fn.modes.pushParticles(Math.abs(missing_particles));
      else pJS.fn.modes.removeParticles(missing_particles);

    }

  };


  pJS.fn.vendors.checkOverlap = function(p1, position){
    for(var i = 0; i < pJS.particles.array.length; i++){
      var p2 = pJS.particles.array[i];

      var dx = p1.x - p2.x,
          dy = p1.y - p2.y,
          dist = Math.sqrt(dx*dx + dy*dy);

      if(dist <= p1.radius + p2.radius){
        p1.x = position ? position.x : Math.random() * pJS.canvas.w;
        p1.y = position ? position.y : Math.random() * pJS.canvas.h;
        pJS.fn.vendors.checkOverlap(p1);
      }
    }
  };


  pJS.fn.vendors.createSvgImg = function(p){

    /* set color to svg element */
    var svgXml = pJS.tmp.source_svg,
        rgbHex = /#([0-9A-F]{3,6})/gi,
        coloredSvgXml = svgXml.replace(rgbHex, function (m, r, g, b) {
          if(p.color.rgb){
            var color_value = 'rgba('+p.color.rgb.r+','+p.color.rgb.g+','+p.color.rgb.b+','+p.opacity+')';
          }else{
            var color_value = 'hsla('+p.color.hsl.h+','+p.color.hsl.s+'%,'+p.color.hsl.l+'%,'+p.opacity+')';
          }
          return color_value;
        });

    /* prepare to create img with colored svg */
    var svg = new Blob([coloredSvgXml], {type: 'image/svg+xml;charset=utf-8'}),
        DOMURL = window.URL || window.webkitURL || window,
        url = DOMURL.createObjectURL(svg);

    /* create particle img obj */
    var img = new Image();
    img.addEventListener('load', function(){
      p.img.obj = img;
      p.img.loaded = true;
      DOMURL.revokeObjectURL(url);
      pJS.tmp.count_svg++;
    });
    img.src = url;

  };


  pJS.fn.vendors.destroypJS = function(){
    cancelAnimationFrame(pJS.fn.drawAnimFrame);
    canvas_el.remove();
    pJSDom = null;
  };


  pJS.fn.vendors.drawShape = function(c, startX, startY, sideLength, sideCountNumerator, sideCountDenominator){

    // By Programming Thomas - https://programmingthomas.wordpress.com/2013/04/03/n-sided-shapes/
    var sideCount = sideCountNumerator * sideCountDenominator;
    var decimalSides = sideCountNumerator / sideCountDenominator;
    var interiorAngleDegrees = (180 * (decimalSides - 2)) / decimalSides;
    var interiorAngle = Math.PI - Math.PI * interiorAngleDegrees / 180; // convert to radians
    c.save();
    c.beginPath();
    c.translate(startX, startY);
    c.moveTo(0,0);
    for (var i = 0; i < sideCount; i++) {
      c.lineTo(sideLength,0);
      c.translate(sideLength,0);
      c.rotate(interiorAngle);
    }
    //c.stroke();
    c.fill();
    c.restore();

  };

  pJS.fn.vendors.exportImg = function(){
    window.open(pJS.canvas.el.toDataURL('image/png'), '_blank');
  };


  pJS.fn.vendors.loadImg = function(type){

    pJS.tmp.img_error = undefined;

    if(pJS.particles.shape.image.src != ''){

      if(type == 'svg'){

        var xhr = new XMLHttpRequest();
        xhr.open('GET', pJS.particles.shape.image.src);
        xhr.onreadystatechange = function (data) {
          if(xhr.readyState == 4){
            if(xhr.status == 200){
              pJS.tmp.source_svg = data.currentTarget.response;
              pJS.fn.vendors.checkBeforeDraw();
            }else{
              console.log('Error pJS - Image not found');
              pJS.tmp.img_error = true;
            }
          }
        }
        xhr.send();

      }else{

        var img = new Image();
        img.addEventListener('load', function(){
          pJS.tmp.img_obj = img;
          pJS.fn.vendors.checkBeforeDraw();
        });
        img.src = pJS.particles.shape.image.src;

      }

    }else{
      console.log('Error pJS - No image.src');
      pJS.tmp.img_error = true;
    }

  };


  pJS.fn.vendors.draw = function(){

    if(pJS.particles.shape.type == 'image'){

      if(pJS.tmp.img_type == 'svg'){

        if(pJS.tmp.count_svg >= pJS.particles.number.value){
          pJS.fn.particlesDraw();
          if(!pJS.particles.move.enable) cancelRequestAnimFrame(pJS.fn.drawAnimFrame);
          else pJS.fn.drawAnimFrame = requestAnimFrame(pJS.fn.vendors.draw);
        }else{
          //console.log('still loading...');
          if(!pJS.tmp.img_error) pJS.fn.drawAnimFrame = requestAnimFrame(pJS.fn.vendors.draw);
        }

      }else{

        if(pJS.tmp.img_obj != undefined){
          pJS.fn.particlesDraw();
          if(!pJS.particles.move.enable) cancelRequestAnimFrame(pJS.fn.drawAnimFrame);
          else pJS.fn.drawAnimFrame = requestAnimFrame(pJS.fn.vendors.draw);
        }else{
          if(!pJS.tmp.img_error) pJS.fn.drawAnimFrame = requestAnimFrame(pJS.fn.vendors.draw);
        }

      }

    }else{
      pJS.fn.particlesDraw();
      if(!pJS.particles.move.enable) cancelRequestAnimFrame(pJS.fn.drawAnimFrame);
      else pJS.fn.drawAnimFrame = requestAnimFrame(pJS.fn.vendors.draw);
    }

  };


  pJS.fn.vendors.checkBeforeDraw = function(){

    // if shape is image
    if(pJS.particles.shape.type == 'image'){

      if(pJS.tmp.img_type == 'svg' && pJS.tmp.source_svg == undefined){
        pJS.tmp.checkAnimFrame = requestAnimFrame(check);
      }else{
        //console.log('images loaded! cancel check');
        cancelRequestAnimFrame(pJS.tmp.checkAnimFrame);
        if(!pJS.tmp.img_error){
          pJS.fn.vendors.init();
          pJS.fn.vendors.draw();
        }
        
      }

    }else{
      pJS.fn.vendors.init();
      pJS.fn.vendors.draw();
    }

  };


  pJS.fn.vendors.init = function(){

    /* init canvas + particles */
    pJS.fn.retinaInit();
    pJS.fn.canvasInit();
    pJS.fn.canvasSize();
    pJS.fn.canvasPaint();
    pJS.fn.particlesCreate();
    pJS.fn.vendors.densityAutoParticles();

    /* particles.line_linked - convert hex colors to rgb */
    pJS.particles.line_linked.color_rgb_line = hexToRgb(pJS.particles.line_linked.color);

  };


  pJS.fn.vendors.start = function(){

    if(isInArray('image', pJS.particles.shape.type)){
      pJS.tmp.img_type = pJS.particles.shape.image.src.substr(pJS.particles.shape.image.src.length - 3);
      pJS.fn.vendors.loadImg(pJS.tmp.img_type);
    }else{
      pJS.fn.vendors.checkBeforeDraw();
    }

  };




  /* ---------- pJS - start ------------ */


  pJS.fn.vendors.eventsListeners();

  pJS.fn.vendors.start();
  


};

/* ---------- global functions - vendors ------------ */

Object.deepExtend = function(destination, source) {
  for (var property in source) {
    if (source[property] && source[property].constructor &&
     source[property].constructor === Object) {
      destination[property] = destination[property] || {};
      arguments.callee(destination[property], source[property]);
    } else {
      destination[property] = source[property];
    }
  }
  return destination;
};

window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame    ||
    window.oRequestAnimationFrame      ||
    window.msRequestAnimationFrame     ||
    function(callback){
      window.setTimeout(callback, 1000 / 60);
    };
})();

window.cancelRequestAnimFrame = ( function() {
  return window.cancelAnimationFrame         ||
    window.webkitCancelRequestAnimationFrame ||
    window.mozCancelRequestAnimationFrame    ||
    window.oCancelRequestAnimationFrame      ||
    window.msCancelRequestAnimationFrame     ||
    clearTimeout
} )();

function hexToRgb(hex){
  // By Tim Down - http://stackoverflow.com/a/5624139/3493650
  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, function(m, r, g, b) {
     return r + r + g + g + b + b;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
  } : null;
};

function clamp(number, min, max) {
  return Math.min(Math.max(number, min), max);
};

function isInArray(value, array) {
  return array.indexOf(value) > -1;
}


/* ---------- particles.js functions - start ------------ */

window.pJSDom = [];

window.particlesJS = function(tag_id, params){

  //console.log(params);

  /* no string id? so it's object params, and set the id with default id */
  if(typeof(tag_id) != 'string'){
    params = tag_id;
    tag_id = 'particles-js';
  }

  /* no id? set the id to default id */
  if(!tag_id){
    tag_id = 'particles-js';
  }

  /* pJS elements */
  var pJS_tag = document.getElementById(tag_id),
      pJS_canvas_class = 'particles-js-canvas-el',
      exist_canvas = pJS_tag.getElementsByClassName(pJS_canvas_class);

  /* remove canvas if exists into the pJS target tag */
  if(exist_canvas.length){
    while(exist_canvas.length > 0){
      pJS_tag.removeChild(exist_canvas[0]);
    }
  }

  /* create canvas element */
  var canvas_el = document.createElement('canvas');
  canvas_el.className = pJS_canvas_class;

  /* set size canvas */
  canvas_el.style.width = "100%";
  canvas_el.style.height = "100%";

  /* append canvas */
  var canvas = document.getElementById(tag_id).appendChild(canvas_el);

  /* launch particle.js */
  if(canvas != null){
    pJSDom.push(new pJS(tag_id, params));
  }

};

window.particlesJS.load = function(tag_id, path_config_json, callback){

  /* load json config */
  var xhr = new XMLHttpRequest();
  xhr.open('GET', path_config_json);
  xhr.onreadystatechange = function (data) {
    if(xhr.readyState == 4){
      if(xhr.status == 200){
        var params = JSON.parse(data.currentTarget.response);
        window.particlesJS(tag_id, params);
        if(callback) callback();
      }else{
        console.log('Error pJS - XMLHttpRequest status: '+xhr.status);
        console.log('Error pJS - File config not found');
      }
    }
  };
  xhr.send();

};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var RerendererComponent_1 = __webpack_require__(113);
var InterfaceBuilder_1 = __webpack_require__(5);
__webpack_require__(115);
function range(n) {
    var arr = new Array(n);
    for (var i = 0; i < n; i++)
        arr[i] = i;
    return arr;
}
var GameBar = /** @class */ (function (_super) {
    __extends(GameBar, _super);
    function GameBar(attrs) {
        var _this = _super.call(this, InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "game-bar-holder" })) || this;
        _this.livesElement = null;
        _this.oxygenElements = [];
        _this.scoreElement = null;
        _this.livesChanged = function () {
            if (!_this.livesElement)
                return;
            var lives = _this.attrs.bootstrap.state.lives;
            var children = _this.livesElement.children;
            if (children.length < lives) {
                while (children.length < lives)
                    InterfaceBuilder_1.InterfaceBuilder.append(_this.livesElement, InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "live" }));
            }
            else if (lives < children.length) {
                while (children.length > lives)
                    children[children.length - 1].remove();
            }
        };
        _this.oxygenChanged = function () {
            var oxygen = _this.attrs.bootstrap.state.oxygen;
            if (oxygen.length !== _this.oxygenElements.length)
                _this.rerender();
            else
                _this.oxygenElements.forEach(function (t, i) {
                    t.style.left = "-" + (1 - oxygen[i]) * 100 + "%";
                });
        };
        _this.scoreChanged = function () {
            var scoreElement = _this.scoreElement;
            var score = _this.attrs.bootstrap.state.score;
            if (!_this.scoreElement)
                return;
            if (score === undefined || score === null)
                _this.scoreElement.style.display = "none";
            else {
                _this.scoreElement.style.display = "block";
                _this.scoreElement.innerText = score.toString();
            }
        };
        _this.rerender = _this.rerender.bind(_this);
        var stateListener = attrs.bootstrap.stateListener;
        stateListener.on("lives", _this.livesChanged);
        stateListener.on("oxygen", _this.oxygenChanged);
        stateListener.on("score", _this.scoreChanged);
        stateListener.on("showOxygen", _this.rerender);
        stateListener.on("title", _this.rerender);
        return _this;
    }
    GameBar.prototype.dispose = function () {
        var stateListener = this.attrs.bootstrap.stateListener;
        stateListener.off("lives", this.livesChanged);
        stateListener.off("oxygen", this.oxygenChanged);
        stateListener.off("score", this.scoreChanged);
        stateListener.off("showOxygen", this.rerender);
        stateListener.off("title", this.rerender);
        this.emit("dispose", this);
    };
    GameBar.prototype.render = function () {
        var _this = this;
        var _a = this.attrs.bootstrap, stateListener = _a.stateListener, state = _a.state;
        var lives = state.lives, oxygen = state.oxygen, title = state.title, showOxygen = state.showOxygen, score = state.score;
        this.oxygenElements = [];
        return (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "game-bar" },
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { ref: function (e) { return _this.livesElement = e; }, className: "lives" }, range(lives).map(function () { return (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "live" })); })),
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "score", ref: function (e) { return _this.scoreElement = e; }, style: { display: (score === null || score === undefined ? "none" : "block") } }, score),
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "title" }, title),
            (showOxygen && oxygen.length || false) && (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "oxygen-wrapper" }, (this.oxygenElements = oxygen.map(function (t) { return (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "oxygen-level", style: { left: "-" + (1 - t) * 100 + "%" } })); })).map(function (t) { return (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "oxygen-holder" }, t)); })))));
    };
    return GameBar;
}(RerendererComponent_1.default));
exports.default = GameBar;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var InterfaceBuilder_1 = __webpack_require__(5);
var Rerenderer_1 = __webpack_require__(114);
var RerendererComponent = /** @class */ (function (_super) {
    __extends(RerendererComponent, _super);
    function RerendererComponent(baseElement, attrs) {
        var _this = _super.call(this, attrs) || this;
        _this.baseElement = baseElement;
        var that = _this;
        var render = _this.baseRender = _this.render;
        _this.render = function () {
            var _this = this;
            var args = arguments;
            render.apply(that, args);
            return (InterfaceBuilder_1.InterfaceBuilder.createElement(Rerenderer_1.default, { element: function () { return that.baseElement; }, render: function () { return render.apply(that, args); }, ref: function (r) { return _this.rerenderer = r; } }));
        };
        return _this;
    }
    RerendererComponent.prototype.rerender = function () {
        if (this.rerenderer) {
            this.rerenderer.rerender();
            this.emit("rerendered", this);
        }
    };
    return RerendererComponent;
}(InterfaceBuilder_1.Component));
exports.default = RerendererComponent;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var InterfaceBuilder_1 = __webpack_require__(5);
var Rerenderer = /** @class */ (function (_super) {
    __extends(Rerenderer, _super);
    function Rerenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rerenderer.prototype.rerender = function () {
        var _a = this, attrs = _a.attrs, elt = _a.elt;
        if (!elt)
            return;
        InterfaceBuilder_1.InterfaceBuilder.replaceContent(elt, attrs.render());
    };
    Rerenderer.prototype.render = function (attrs) {
        if (!attrs)
            return;
        if (attrs.ref)
            attrs.ref(this);
        var elt = this.elt = attrs.element();
        if (!elt)
            throw new Error("Expected an element.");
        InterfaceBuilder_1.InterfaceBuilder.replaceContent(elt, attrs.render());
        return elt;
    };
    return Rerenderer;
}(InterfaceBuilder_1.Component));
exports.default = Rerenderer;


/***/ }),
/* 115 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationSequence_1 = __webpack_require__(26);
var Color_1 = __webpack_require__(53);
var InterfaceBuilder_1 = __webpack_require__(5);
var CanvasAbstraction_1 = __webpack_require__(54);
__webpack_require__(120);
var modalSize = 400;
exports.ModalContentWrapper = function (attrs, children) { return (InterfaceBuilder_1.InterfaceBuilder.createElement("div", __assign({}, attrs, { className: (attrs.className || "") + " modal-content-wrapper" }), children)); };
/**
 * Modal box display.
 *
 * First child is the content, second child is the dialog.
 */
var Modal = /** @class */ (function (_super) {
    __extends(Modal, _super);
    function Modal(attrs) {
        var _this = _super.call(this, attrs) || this;
        _this.modalInAnimation = new AnimationSequence_1.AnimationSequence([
            function () { return _this.modalDialog.style.display = "block"; },
            function () {
                _this.modalWrapper.classList.add("toggled");
                _this.canvasAbstraction.renderer.start();
            }
        ]);
        _this.modalOutAnimation = new AnimationSequence_1.AnimationSequence([
            function () { return _this.modalWrapper.classList.remove("toggled"); },
            1000,
            function () {
                _this.canvasAbstraction.renderer.stop();
                _this.modalDialog.style.display = "none";
            }
        ]);
        return _this;
    }
    Modal.prototype.show = function () {
        this.modalOutAnimation.cancel();
        this.modalInAnimation.start();
    };
    Modal.prototype.hide = function () {
        this.modalInAnimation.cancel();
        this.modalOutAnimation.start();
    };
    Modal.prototype.render = function (attrs, children) {
        var _this = this;
        var ret = (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "modal-wrapper", ref: function (e) { return _this.modalWrapper = e; } },
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "modal-content" }, children && children[0]),
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "modal-overlay", onclick: this.hide.bind(this) }),
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "modal-dialog", ref: function (e) { return _this.modalDialog = e; } },
                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "container" },
                    InterfaceBuilder_1.InterfaceBuilder.createElement(CanvasAbstraction_1.default, { baseColor: new Color_1.default.RGBA(229, 177, 58, CanvasAbstraction_1.A), ref: function (ca) {
                            _this.canvasAbstraction = ca;
                            ca.canvas.style.opacity = "0.4";
                        } }),
                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "content" }, children && children[1])),
                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "svg", ref: function (e) {
                        var svg = function (className) { return "\n\t\t\t\t\t\t\t<svg\n\t\t\t\t\t\t\t\twidth=\"" + modalSize * 2 + "\"\n\t\t\t\t\t\t\t\theight=\"" + modalSize * 2 + "\"\n\t\t\t\t\t\t\t\tclass=\"modal-dialog-box " + className + "\"\n\t\t\t\t\t\t\t\tviewBox=\"0 0 " + modalSize * 2 + " " + modalSize * 2 + "\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<circle\n\t\t\t\t\t\t\t\t\tr=\"" + modalSize + "\"\n\t\t\t\t\t\t\t\t\tcx=\"" + modalSize + "\"\n\t\t\t\t\t\t\t\t\tcy=\"" + modalSize + "\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</svg>"; };
                        e.innerHTML = svg("first") + svg("second");
                    } }))));
        if (attrs.ref)
            attrs.ref(this);
        return ret;
    };
    return Modal;
}(InterfaceBuilder_1.Component));
exports.default = Modal;


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = Point;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Static__ = __webpack_require__(18);


/**
 * Point
 */
function Point(x, y) {
	this.x = x || 0;
	this.y = y || 0;
}

Point.create = function (o, y) {
	if (Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isArray"])(o)) return new Point(o[0], o[1]);
	if (Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isObject"])(o)) return new Point(o.x, o.y);
	return new Point(o, y);
};

Point.add = function (p1, p2) {
	return new Point(p1.x + p2.x, p1.y + p2.y);
};

Point.subtract = function (p1, p2) {
	return new Point(p1.x - p2.x, p1.y - p2.y);
};

Point.scale = function (p, scaleX, scaleY) {
	if (Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isObject"])(scaleX)) {
		scaleY = scaleX.y;
		scaleX = scaleX.x;
	} else if (!Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isNumber"])(scaleY)) {
		scaleY = scaleX;
	}
	return new Point(p.x * scaleX, p.y * scaleY);
};

Point.equals = function (p1, p2) {
	return p1.x == p2.x && p1.y == p2.y;
};

Point.angle = function (p) {
	return Math.atan2(p.y, p.x);
};

Point.distance = function (p1, p2) {
	var a = p1.x - p2.x;
	var b = p1.y - p2.y;
	return Math.sqrt(a * a + b * b);
};

Point.dot = function (p1, p2) {
	return p1.x * p2.x + p1.y * p2.y;
};

Point.cross = function (p1, p2) {
	return p1.x * p2.y - p1.y * p2.x;
};

Point.interpolate = function (p1, p2, f) {
	var dx = p2.x - p1.x;
	var dy = p2.y - p1.y;
	return new Point(p1.x + dx * f, p1.y + dy * f);
};

// Test
Point.polar = function (length, radian) {
	return new Point(length * Math.sin(radian), length * Math.cos(radian));
};

Point.prototype = {
	add: function (p) {
		return Point.add(this, p);
	},

	subtract: function (p) {
		return Point.subtract(this, p);
	},

	scale: function (scaleX, scaleY) {
		return Point.scale(this, scaleX, scaleY);
	},

	equals: function (p) {
		return Point.equals(this, p);
	},

	angle: function () {
		return Point.angle(this);
	},

	distance: function (p) {
		return Point.distance(this, p);
	},

	length: function () {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	set: function (x, y) {
		if (Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isObject"])(x)) {
			y = x.y;
			x = x.x;
		}

		this.x = x || 0;
		this.y = y || 0;

		return this;
	},

	offset: function (x, y) {
		if (Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isObject"])(x)) {
			y = x.y;
			x = x.x;
		}

		this.x += x || 0;
		this.y += y || 0;

		return this;
	},

	normalize: function (thickness) {
		if (Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isNull"])(thickness) || Object(__WEBPACK_IMPORTED_MODULE_0__Static__["isUndefined"])(thickness)) {
			thickness = 1;
		}

		var length = this.length();

		if (length > 0) {
			this.x = this.x / length * thickness;
			this.y = this.y / length * thickness;
		}

		return this;
	},

	negate: function () {
		this.x *= -1;
		this.y *= -1;

		return this;
	},

	perp: function () {
		this.x = -y;
		this.y = x;

		return this;
	},

	clone: function () {
		return Point.create(this);
	},

	toArray: function () {
		return [this.x, this.y];
	},

	toString: function () {
		return '(x:' + this.x + ', y:' + this.y + ')';
	}
};

// global.Point = Point;

/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GRAD3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return GRAD4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return SIMPLEX; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ClassicNoise__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SimplexNoise__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Static__ = __webpack_require__(18);




/**
 * Perlin Noise
 * 
 * @see http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
 * 
 * Tiling Example (heavy...)
 * 
 * var perlinNoise = new PerlinNoise();
 * 
 * function tilingNoise2d(x, y, w, h) {
 *     return (perlinNoise.noise(x, y) * (w - x) * (h - y) +
 *         perlinNoise.noise(x - w, y) * x * (h - y) +
 *         perlinNoise.noise(x - w, y - h) * x * y +
 *         perlinNoise.noise(x, y - h) * (w - x) * y) / (w * h);
 * }
 * 
 * function tilingNoise3d(x, y, z, w, h) {
 *     return (perlinNoise.noise(x, y, z) * (w - x) * (h - y) +
 *         perlinNoise.noise(x - w, y, z) * x * (h - y) +
 *         perlinNoise.noise(x - w, y - h, z) * x * y +
 *         perlinNoise.noise(x, y - h, z) * (w - x) * y) / (w * h);
 * }
 */
function PerlinNoise(seed) {
	this.isClassic = PerlinNoise.useClassic;
	Object(__WEBPACK_IMPORTED_MODULE_2__Static__["extend"])(this, this.isClassic ? new __WEBPACK_IMPORTED_MODULE_0__ClassicNoise__["a" /* default */](seed) : new __WEBPACK_IMPORTED_MODULE_1__SimplexNoise__["default"](seed));
}

PerlinNoise.useClassic = false;

var GRAD3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];

var GRAD4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];

var SIMPLEX = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];

/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Xorshift;
/**
 * Random numbers generator
 * 
 * @see http://baagoe.com/en/RandomMusings/javascript/
 */

function Xorshift() {
	var self = this;
	var seeds = arguments.length ? Array.prototype.slice.call(arguments) : [new Date().getTime()];

	var x = 123456789;
	var y = 362436069;
	var z = 521288629;
	var w = 88675123;
	var v = 886756453;

	self.uint32 = function () {
		var t = (x ^ x >>> 7) >>> 0;
		x = y;
		y = z;
		z = w;
		w = v;
		v = v ^ v << 6 ^ (t ^ t << 13) >>> 0;
		return (y + y + 1) * v >>> 0;
	};

	self.random = function () {
		return self.uint32() * 2.3283064365386963e-10;
	};

	self.fract53 = function () {
		return self.random() + (self.uint32() & 0x1fffff) * 1.1102230246251565e-16;
	};

	for (var i = 0, len = seeds.length, seed; i < len; i++) {
		seed = seeds[i];
		x ^= mash(seed) * 0x100000000;
		y ^= mash(seed) * 0x100000000;
		z ^= mash(seed) * 0x100000000;
		v ^= mash(seed) * 0x100000000;
		w ^= mash(seed) * 0x100000000;
	}
}

// Helper

function mash(data) {
	data = data.toString();
	var n = 0xefc8249d;
	for (var i = 0, len = data.length; i < len; i++) {
		n += data.charCodeAt(i);
		var h = 0.02519603282416938 * n;
		n = h >>> 0;
		h -= n;
		h *= n;
		n = h >>> 0;
		h -= n;
		n += h * 0x100000000;
	}
	return (n >>> 0) * 2.3283064365386963e-10;
}

// global.Xorshift = Xorshift;

/***/ }),
/* 120 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationSequence_1 = __webpack_require__(26);
var MikelsonParts_1 = __webpack_require__(12);
var BasePlayer_1 = __webpack_require__(6);
var InterfaceBuilder_1 = __webpack_require__(5);
var PlayerBox_1 = __webpack_require__(122);
__webpack_require__(129);
var NameEnquiry = /** @class */ (function (_super) {
    __extends(NameEnquiry, _super);
    function NameEnquiry() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.secondPlayer = false;
        _this.inited = false;
        return _this;
    }
    NameEnquiry.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            var p1, p2, p3, p4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.ca1.canvas.style.opacity = "0.4";
                        this.ca2.canvas.style.opacity = "0.4";
                        this.ca1.renderer.start();
                        this.pc1.startListening();
                        p1 = MikelsonParts_1.texture.load();
                        p2 = MikelsonParts_1.textureDuck.load();
                        p3 = MikelsonParts_1.textureBro.load();
                        p4 = MikelsonParts_1.textureDuckBro.load();
                        return [4 /*yield*/, p1];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, p2];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, p3];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, p4];
                    case 4:
                        _a.sent();
                        this.inited = true;
                        this.pamc1.startListening();
                        this.pamc1.start();
                        return [2 /*return*/];
                }
            });
        });
    };
    NameEnquiry.prototype.addPlayer = function () {
        var _this = this;
        if (this.animationSequence)
            this.animationSequence.cancel();
        this.animationSequence = new AnimationSequence_1.AnimationSequence([
            function () {
                _this.secondPlayerHolder.style.width = "0";
                _this.secondPlayerWrapper.classList.add("absolute");
                _this.pb2.toggleDisplay(true);
            },
            function () {
                _this.secondPlayerHolder.style.width = _this.pb2.holder.offsetWidth + "px";
                _this.pb2.toggleHidden(false);
                _this.separator.classList.add("right");
                _this.p2AddedHandler();
            },
            1000,
            function () {
                _this.secondPlayerHolder.style.width = null;
                _this.secondPlayerWrapper.classList.remove("absolute");
            }
        ]);
        this.animationSequence.start();
    };
    NameEnquiry.prototype.removePlayer = function () {
        var _this = this;
        if (this.animationSequence)
            this.animationSequence.cancel();
        this.animationSequence = new AnimationSequence_1.AnimationSequence([
            function () {
                _this.secondPlayerHolder.style.width = _this.pb2.holder.offsetWidth + "px";
                _this.secondPlayerWrapper.classList.add("absolute");
                _this.separator.classList.remove("right");
            },
            function () {
                _this.secondPlayerHolder.style.width = "0";
                _this.pb2.toggleHidden(true);
            },
            1000,
            function () {
                _this.pb2.toggleDisplay(false);
                _this.p2RemovedHandler();
            }
        ]);
        this.animationSequence.start();
    };
    NameEnquiry.prototype.p2AddedHandler = function () {
        this.pc2.startListening();
        this.pamc2.start();
        this.pamc2.startListening();
        this.ca2.renderer.start();
    };
    NameEnquiry.prototype.p1AddedHandler = function () {
        this.pc1.startListening();
        this.pamc1.start();
        this.pamc1.startListening();
        this.ca1.renderer.start();
    };
    NameEnquiry.prototype.p2RemovedHandler = function () {
        this.pc2.stopListening();
        this.pamc2.stop();
        this.pamc2.stopListening();
        this.ca2.renderer.clear();
        this.ca2.renderer.stop();
    };
    NameEnquiry.prototype.p1RemovedHandler = function () {
        this.pc1.stopListening();
        this.pamc1.stop();
        this.pamc1.stopListening();
        this.ca1.renderer.clear();
        this.ca1.renderer.stop();
    };
    NameEnquiry.prototype.secondPlayerClick = function () {
        if (this.secondPlayer) {
            this.addButton.classList.add("rotate");
            this.secondPlayer = false;
            this.removePlayer();
        }
        else {
            this.addButton.classList.remove("rotate");
            this.secondPlayer = true;
            this.addPlayer();
        }
    };
    NameEnquiry.prototype.stopListening = function () {
        if (!this.inited)
            return;
        this.p1RemovedHandler();
        if (this.secondPlayer)
            this.p2RemovedHandler();
    };
    NameEnquiry.prototype.startListening = function () {
        if (!this.inited)
            return;
        this.p1AddedHandler();
        if (this.secondPlayer)
            this.p2AddedHandler();
    };
    NameEnquiry.prototype.render = function (attrs) {
        var _this = this;
        setTimeout(this.start.bind(this));
        var ret = (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "name-enquiry" },
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "container" },
                InterfaceBuilder_1.InterfaceBuilder.createElement(PlayerBox_1.default, { position: "left", isBro: false, keys: BasePlayer_1.controlSets.controls1, keyNames: { left: "⬅", right: "➡", up: "⬆", down: "⬇" }, value: attrs.bootstrap.state.names[0], ref: function (pb) { return _this.pb1 = pb; }, refCA: function (ca) { return _this.ca1 = ca; }, refPC: function (pc) { return _this.pc1 = pc; }, refPAMC: function (pamc) { return _this.pamc1 = pamc; }, refInput: function (input) { return _this.input1 = input; }, onBlur: function () { return _this.blurInputP1(); }, onFocus: function () { return _this.focusInputP1(); } }, "Player #1"),
                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "separator", ref: function (e) { return _this.separator = e; } },
                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", null),
                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "start", onmousedown: function (e) { return e.currentTarget.classList.add("toggled"); }, onmouseleave: function (e) { return e.currentTarget.classList.remove("toggled"); }, onclick: this.onStart.bind(this) },
                        InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "html-circle", ref: function (e) { return _this.htmlCircle = e; } }),
                        InterfaceBuilder_1.InterfaceBuilder.createElement("div", { ref: function (e) { return e.innerHTML = "\n\t\t\t\t\t\t\t\t<svg width=\"120\" height=\"120\" class=\"play-icon\" viewBox=\"0 0 120 120\">\n\t\t\t\t\t\t\t\t\t<circle class=\"circle\" r=\"56\" cx=\"60\" cy=\"60\"></circle>\n\t\t\t\t\t\t\t\t\t<polygon points=\"44,40 84,60 44,80\" class=\"play\"></polygon>\n\t\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t\t\t"; } })),
                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "controls" },
                        InterfaceBuilder_1.InterfaceBuilder.createElement("button", { className: "control", onclick: function () { return attrs.info && attrs.info(); } }, "?"),
                        InterfaceBuilder_1.InterfaceBuilder.createElement("button", { className: "control rotate", ref: function (e) { return _this.addButton = e; }, onclick: this.secondPlayerClick.bind(this) },
                            InterfaceBuilder_1.InterfaceBuilder.createElement("span", null, "\u00D7")))),
                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "player-box-holder", ref: function (e) { return _this.secondPlayerHolder = e; } },
                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "player-box-wrapper", ref: function (e) { return _this.secondPlayerWrapper = e; } },
                        InterfaceBuilder_1.InterfaceBuilder.createElement(PlayerBox_1.default, { position: "right", isBro: true, keys: BasePlayer_1.controlSets.controls2, value: attrs.bootstrap.state.names[1], hidden: true, ref: function (pb) { return _this.pb2 = pb; }, refCA: function (ca) { return _this.ca2 = ca; }, refPC: function (pc) { return _this.pc2 = pc; }, refPAMC: function (pamc) { return _this.pamc2 = pamc; }, refInput: function (input) { return _this.input2 = input; }, onBlur: function () { return _this.blurInputP2(); }, onFocus: function () { return _this.focusInputP2(); } }, "Player #2"))))));
        if (attrs.ref)
            attrs.ref(this);
        return ret;
    };
    NameEnquiry.prototype.blinkError = function () {
        this.htmlCircle.animate([{
                background: "rgba(34, 117, 185, 0.8)",
                boxShadow: "0 0 4px 4px rgba(34, 117, 185, 0.8)"
            }, {
                background: "rgba(197, 62, 62, 0.8)",
                boxShadow: "0 0 4px 4px rgba(197, 62, 62, 0.8)"
            }, {
                background: "rgba(34, 117, 185, 0.8)",
                boxShadow: "0 0 4px 4px rgba(34, 117, 185, 0.8)"
            }], {
            duration: 500
        });
    };
    NameEnquiry.prototype.onStart = function () {
        var _a = this.attrs, start = _a.start, info = _a.info;
        if (!start)
            return;
        var name1 = this.input1.value.trim();
        var name2 = this.secondPlayer ? this.input2.value.trim() : undefined;
        var name1ok = !!name1;
        var name2ok = this.secondPlayer ? (name2 && name2 !== name1) : true;
        if (name1ok && name2ok) {
            if (start)
                start(name1, name2);
        }
        else {
            this.blinkError();
            if (!name1ok)
                this.pb1.blinkError();
            if (!name2ok)
                this.pb2.blinkError();
        }
    };
    NameEnquiry.prototype.focusInputP1 = function () {
        this.pc1.stopListening();
        this.pamc1.stopListening();
    };
    NameEnquiry.prototype.blurInputP1 = function () {
        this.pc1.startListening();
        this.pamc1.startListening();
    };
    NameEnquiry.prototype.focusInputP2 = function () {
        this.pc2.stopListening();
        this.pamc2.stopListening();
    };
    NameEnquiry.prototype.blurInputP2 = function () {
        this.pc2.startListening();
        this.pamc2.startListening();
    };
    return NameEnquiry;
}(InterfaceBuilder_1.Component));
exports.default = NameEnquiry;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var excalibur_1 = __webpack_require__(0);
var InterfaceBuilder_1 = __webpack_require__(5);
var CanvasAbstraction_1 = __webpack_require__(54);
var PlayerAnimationMovementCanvas_1 = __webpack_require__(123);
var PlayerControls_1 = __webpack_require__(128);
var PlayerBox = /** @class */ (function (_super) {
    __extends(PlayerBox, _super);
    function PlayerBox() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PlayerBox.prototype.blinkError = function () {
        this.input.animate([{
                // background: "#c53e3e00",
                borderBottomColor: "#c53e3e00"
            }, {
                // background: "#c53e3e55",
                borderBottomColor: "#c53e3e"
            }, {
                // background: "#c53e3e00",
                borderBottomColor: "#c53e3e00"
            }], {
            duration: 500
        });
    };
    PlayerBox.prototype.toggleDisplay = function (visible) {
        if (visible === void 0) { visible = this.holder.style.display === "none"; }
        this.holder.style.display = visible ? "block" : "none";
    };
    PlayerBox.prototype.toggleHidden = function (hidden) {
        if (hidden === void 0) { hidden = !this.holder.classList.contains("hide"); }
        if (hidden)
            this.holder.classList.add("hide");
        else
            this.holder.classList.remove("hide");
    };
    PlayerBox.prototype.render = function (attrs, children) {
        var _this = this;
        var ret = (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "display-box player-box " + (attrs.position + (attrs.hidden ? " hide" : "")), style: { display: attrs.hidden ? "none" : "block" }, ref: function (e) { return _this.holder = e; } },
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "canvas-holder" },
                InterfaceBuilder_1.InterfaceBuilder.createElement(CanvasAbstraction_1.default, { ref: attrs.refCA })),
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "container" },
                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "player-split" },
                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "player-info" },
                        InterfaceBuilder_1.InterfaceBuilder.createElement("h1", null, children),
                        InterfaceBuilder_1.InterfaceBuilder.createElement("input", { value: attrs.value, ref: function (e) { return (_this.input = e, attrs.refInput && attrs.refInput(e)); }, type: "text", maxLength: 24, placeholder: "Name", onfocus: attrs.onFocus, onblur: attrs.onBlur }),
                        InterfaceBuilder_1.InterfaceBuilder.createElement(PlayerControls_1.default, { keys: attrs.keys, keyNames: attrs.keyNames, ref: attrs.refPC })),
                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "player-model" },
                        InterfaceBuilder_1.InterfaceBuilder.createElement("canvas", { width: "110", height: "150", ref: function (e) {
                                var pamc = new PlayerAnimationMovementCanvas_1.default(e, attrs.keys, attrs.isBro, new excalibur_1.Vector(e.width / 2, e.height - 10));
                                if (attrs.refPAMC)
                                    attrs.refPAMC(pamc);
                            } }))))));
        if (attrs.ref)
            attrs.ref(this);
        return ret;
    };
    return PlayerBox;
}(InterfaceBuilder_1.Component));
exports.default = PlayerBox;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MikelsonAnimation_1 = __webpack_require__(14);
var PlayerAnimationCanvas_1 = __webpack_require__(127);
var PlayerAnimationMovementCanvas = /** @class */ (function (_super) {
    __extends(PlayerAnimationMovementCanvas, _super);
    function PlayerAnimationMovementCanvas(canvas, keys, isBro, location) {
        var _this = _super.call(this, canvas, location) || this;
        _this.canvas = canvas;
        _this.keys = keys;
        _this.location = location;
        _this.listening = false;
        _this.dir = "right";
        _this.state = "idle";
        _this.keyStates = {
            down: false,
            up: false,
            left: false,
            right: false
        };
        _this.onKeyDown = function (e) {
            _this.updateKey(e.keyCode, true);
        };
        _this.onKeyUp = function (e) {
            _this.updateKey(e.keyCode, false);
        };
        if (isBro)
            _this.drawSets = MikelsonAnimation_1.animationProvidersBro.map(function (t) { return t(); });
        else
            _this.drawSets = MikelsonAnimation_1.animationProviders.map(function (t) { return t(); });
        _this.context = canvas.getContext("2d");
        return _this;
    }
    Object.defineProperty(PlayerAnimationMovementCanvas.prototype, "isListening", {
        get: function () { return this.listening; },
        enumerable: true,
        configurable: true
    });
    PlayerAnimationMovementCanvas.prototype.updateState = function (state, dir) {
        if (state === void 0) { state = this.state; }
        if (dir === void 0) { dir = this.dir; }
        if (state !== this.state || dir !== this.dir) {
            this.state = state;
            this.dir = dir;
            _super.prototype.changeState.call(this, state + "-" + dir);
        }
    };
    PlayerAnimationMovementCanvas.prototype.updateKey = function (k, pressed) {
        var keyStates = this.keyStates;
        var key = Object.entries(this.keys).find(function (t) { return t[1] === k; });
        if (!key)
            return;
        var keyName = key[0];
        keyStates[keyName] = pressed;
        var state = this.state;
        var dir = this.dir;
        if (keyStates.right && !keyStates.left)
            dir = "right";
        else if (keyStates.left && !keyStates.right)
            dir = "left";
        if (keyStates.up)
            state = "jump";
        else if (keyStates.down)
            state = "duck";
        else if (keyStates.right || keyStates.left)
            state = "walk";
        else
            state = "idle";
        this.updateState(state, dir);
    };
    PlayerAnimationMovementCanvas.prototype.startListening = function () {
        if (this.listening)
            return;
        document.addEventListener("keydown", this.onKeyDown);
        document.addEventListener("keyup", this.onKeyUp);
        this.listening = true;
    };
    PlayerAnimationMovementCanvas.prototype.stopListening = function () {
        if (!this.listening)
            return;
        document.removeEventListener("keydown", this.onKeyDown);
        document.removeEventListener("keyup", this.onKeyUp);
        this.updateState("idle");
        this.listening = false;
    };
    return PlayerAnimationMovementCanvas;
}(PlayerAnimationCanvas_1.default));
exports.default = PlayerAnimationMovementCanvas;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DrawAnimation = /** @class */ (function () {
    function DrawAnimation(drawSets) {
        this.drawSets = drawSets;
        this.timestamp = performance.now();
    }
    Object.defineProperty(DrawAnimation.prototype, "delta", {
        get: function () {
            return performance.now() - this.timestamp;
        },
        enumerable: true,
        configurable: true
    });
    DrawAnimation.prototype.updateDelta = function () {
        this.timestamp = performance.now();
    };
    DrawAnimation.prototype.draw = function (ctx, position) {
        var _this = this;
        performance.now();
        this.drawSets.forEach(function (t) { return t.draw(ctx, _this.delta, position); });
    };
    DrawAnimation.prototype.changeState = function (state, delta) {
        if (delta === void 0) { delta = this.delta; }
        // console.log("Animation state changed:", state);
        this.drawSets.forEach(function (t) { return t.changeState(state, delta); });
    };
    return DrawAnimation;
}());
exports.DrawAnimation = DrawAnimation;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.linearEasing = function (delta) { return delta; };
exports.cubicEasing = function (delta) { return Math.pow(delta, 3); };
var TransformDrawPart = /** @class */ (function () {
    function TransformDrawPart(startTransformation, endTransformation, duration, easing, anchor) {
        this.startTransformation = startTransformation;
        this.endTransformation = endTransformation;
        this.duration = duration;
        this.easing = easing;
        this.anchor = anchor;
        this.tmpDuration = 0;
        this.tmpEasing = null;
        this.tmpTransformation = null;
        this.timestamp = 0;
    }
    TransformDrawPart.getTransformValue = function (start, end, path, defaultValue) {
        // if (typeof start !== "number" || typeof end !== "number") // this results in no transition for unspecified fields
        // 	return;
        start = start || defaultValue;
        end = end || defaultValue;
        return (end - start) * path + start;
    };
    /**
     * Number from interval [0, 1] indicating state of the animation.
     * @param delta Milliseconds since the animation has started.
     */
    TransformDrawPart.prototype.getPath = function (delta) {
        var _a = this, duration = _a.duration, timestamp = _a.timestamp, easing = _a.easing;
        var path = (duration - Math.abs((delta - timestamp) % (2 * duration) - duration)) / duration;
        if (easing)
            return easing(path);
        return path;
    };
    /**
     * Number from interval [0, 1] indicating state of the animation transition.
     * @param delta Milliseconds since the animation has started.
     */
    TransformDrawPart.prototype.getTmpPath = function (delta) {
        var _a = this, d = _a.tmpDuration, timestamp = _a.timestamp, tmpEasing = _a.tmpEasing;
        if (!d)
            return 0;
        var p = Math.max(0, Math.min(1, (delta - timestamp) / d));
        if (tmpEasing)
            return tmpEasing(p);
        return p;
    };
    /**
     * Gets transformation of the two given objects.
     * @param start Starting transformation.
     * @param end Ending transformation.
     * @param path Number from interval [0, 1] indicating state of the animation.
     */
    TransformDrawPart.getTransformation = function (start, end, path) {
        var rotate = TransformDrawPart.getTransformValue(start.rotate, end.rotate, path, 0);
        var scaleX = TransformDrawPart.getTransformValue(start.scaleX, end.scaleX, path, 1);
        var scaleY = TransformDrawPart.getTransformValue(start.scaleY, end.scaleY, path, 1);
        var translateX = TransformDrawPart.getTransformValue(start.translateX, end.translateX, path, 0);
        var translateY = TransformDrawPart.getTransformValue(start.translateY, end.translateY, path, 0);
        return {
            translateX: translateX,
            translateY: translateY,
            scaleX: scaleX,
            scaleY: scaleY,
            rotate: rotate
        };
    };
    /**
     * Gets current transformation based on given path.
     * @param path Number from interval [0, 1] indicating state of the animation.
     * @param tmpPath Number from interval [0, 1] indicating state of the animation transition.
     */
    TransformDrawPart.prototype.getTransformation = function (path, tmpPath) {
        var t = TransformDrawPart.getTransformation(this.startTransformation, this.endTransformation, path);
        if (this.tmpTransformation && tmpPath !== undefined)
            t = TransformDrawPart.getTransformation(this.tmpTransformation, t, tmpPath);
        return t;
    };
    /**
     * Gets current transformation based on given delta time.
     * @param delta Milliseconds since the animation has started.
     */
    TransformDrawPart.prototype.getTransformationByTime = function (delta) {
        if (this.tmpTransformation)
            return this.getTransformation(this.getPath(delta), this.getTmpPath(delta));
        else
            return this.getTransformation(this.getPath(delta));
    };
    TransformDrawPart.prototype.resetDelta = function (delta) {
        this.timestamp = delta === undefined ? performance.now() : delta;
    };
    TransformDrawPart.prototype.makeTransition = function (startTransformation, endTransformation, delta, duration, easing) {
        this.tmpTransformation = this.getTransformationByTime(delta);
        this.tmpDuration = duration || 0;
        this.tmpEasing = easing || null;
        this.resetDelta(delta);
        this.startTransformation = startTransformation;
        this.endTransformation = endTransformation;
    };
    TransformDrawPart.prototype.clearTmp = function () {
        this.tmpDuration = 0;
        this.tmpEasing = null;
        this.tmpTransformation = null;
    };
    /**
     * Should draw the base shape at coordinate system origin (0, 0).
     * @param ctx Canvas drawing context.
     * @param path Number from interval [0, 1] indicating state of the animation.
     * @param position Position at which the drawing will take place.
     * @param state State of the animation.
     * @param delta Milliseconds since the animation has started.
     * @param transformation Transformation already applied.
     */
    TransformDrawPart.prototype.drawBase = function (ctx, path, position, state, delta, transformation) {
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, 50, 50);
    };
    /**
     * Handles transformations and calls `drawBase()`.
     * @param ctx Canvas drawing context.
     * @param delta Milliseconds since the animation has started.
     */
    TransformDrawPart.prototype.draw = function (ctx, delta, position, state) {
        var path = this.getPath(delta);
        var t = this.getTransformationByTime(delta);
        var customTransformation = null;
        ctx.save();
        if (this.beforeDraw)
            customTransformation = this.beforeDraw(ctx, path, position, state, delta, t) || null;
        if (position || this.anchor || t.translateX || t.translateY || (customTransformation && (customTransformation.translateX || customTransformation.translateY))) {
            var x = t.translateX || 0;
            var y = t.translateY || 0;
            if (customTransformation) {
                x += customTransformation.translateX || 0;
                y += customTransformation.translateY || 0;
            }
            if (this.anchor) {
                x += this.anchor.x;
                y += this.anchor.y;
            }
            if (position) {
                x += position.x;
                y += position.y;
            }
            ctx.translate(x, y);
        }
        if (t.rotate || (customTransformation && customTransformation.rotate))
            ctx.rotate((t.rotate || 0) + ((customTransformation && customTransformation.rotate) || 0));
        if (typeof t.scaleX === "number" || typeof t.scaleY === "number" || (customTransformation && (typeof customTransformation.scaleX === "number" || typeof customTransformation.scaleY === "number")))
            ctx.scale((customTransformation && customTransformation.scaleX) || t.scaleX || 1, (customTransformation && customTransformation.scaleY) || t.scaleY || 1);
        this.drawBase(ctx, path, position, state, delta, t);
        ctx.restore();
    };
    return TransformDrawPart;
}());
exports.TransformDrawPart = TransformDrawPart;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TransformDrawSet = /** @class */ (function () {
    function TransformDrawSet(states, selectedState, transformDrawPart) {
        this.states = states;
        this.transformDrawPart = transformDrawPart;
        this._enabled = false;
        this._selectedState = selectedState;
        var state = states[selectedState];
        this._enabled = state && state.enabled !== false;
    }
    Object.defineProperty(TransformDrawSet.prototype, "selectedState", {
        get: function () {
            return this._selectedState;
        },
        enumerable: true,
        configurable: true
    });
    TransformDrawSet.prototype.changeState = function (state, delta) {
        if (state === this._selectedState)
            return;
        this._selectedState = state;
        var st = this.states[state];
        var wasEnabled = this._enabled;
        this._enabled = !!(st && st.enabled !== false);
        if (this._enabled) {
            if (st.transitionDuration && wasEnabled) {
                this.transformDrawPart.makeTransition(st.start, st.end, delta, st.transitionDuration, st.transitionEasing);
            }
            else {
                this.transformDrawPart.startTransformation = st.start;
                this.transformDrawPart.endTransformation = st.end;
            }
            if (st.easing)
                this.transformDrawPart.easing = st.easing;
            if (st.duration)
                this.transformDrawPart.duration = st.duration;
        }
    };
    TransformDrawSet.prototype.draw = function (ctx, delta, position) {
        if (this._enabled)
            this.transformDrawPart.draw(ctx, delta, position, this._selectedState);
    };
    return TransformDrawSet;
}());
exports.TransformDrawSet = TransformDrawSet;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MikelsonAnimation_1 = __webpack_require__(14);
var PlayerAnimationCanvas = /** @class */ (function () {
    function PlayerAnimationCanvas(canvas, location) {
        this.canvas = canvas;
        this.location = location;
        this.animationFrame = NaN;
        this.drawSets = MikelsonAnimation_1.animationProviders.map(function (t) { return t(); });
        this.context = canvas.getContext("2d");
    }
    PlayerAnimationCanvas.prototype.changeState = function (state) {
        this.drawSets.forEach(function (t) { return t.changeState(state, performance.now()); });
    };
    PlayerAnimationCanvas.prototype.draw = function (delta) {
        var _a = this, context = _a.context, canvas = _a.canvas, location = _a.location;
        context.clearRect(0, 0, canvas.width, canvas.height);
        this.drawSets.forEach(function (t) {
            return t.draw(context, delta, location);
        });
    };
    PlayerAnimationCanvas.prototype.start = function () {
        var _this = this;
        if (Number.isNaN(this.animationFrame)) {
            var loop_1 = function (delta) {
                _this.draw(delta);
                _this.animationFrame = requestAnimationFrame(loop_1);
            };
            this.animationFrame = requestAnimationFrame(loop_1);
        }
    };
    PlayerAnimationCanvas.prototype.stop = function () {
        if (!Number.isNaN(this.animationFrame)) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = NaN;
        }
    };
    return PlayerAnimationCanvas;
}());
exports.default = PlayerAnimationCanvas;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var excalibur_1 = __webpack_require__(0);
var InterfaceBuilder_1 = __webpack_require__(5);
var PlayerControls = /** @class */ (function (_super) {
    __extends(PlayerControls, _super);
    function PlayerControls() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.listening = false;
        // @ts-ignore
        _this.controls = {
            up: null,
            down: null,
            left: null,
            right: null
        };
        _this.onKeyDown = function (e) {
            _this.keyChanged(e.keyCode, true);
        };
        _this.onKeyUp = function (e) {
            _this.keyChanged(e.keyCode, false);
        };
        return _this;
    }
    PlayerControls.prototype.isListening = function () { return this.listening; };
    PlayerControls.prototype.render = function (attrs) {
        var controls = this.controls;
        var keys = attrs.keys, keyNames = attrs.keyNames, ref = attrs.ref;
        var getKey = function (s) {
            if (keyNames && s in keyNames)
                return keyNames[s];
            else
                return excalibur_1.Input.Keys[keys[s]];
        };
        var Control = function (_a) {
            var key = _a.key;
            return (InterfaceBuilder_1.InterfaceBuilder.createElement("button", { className: "control", ref: function (e) { return controls[key] = e; }, onkeydown: function (e) { return e.preventDefault(); } }, getKey(key)));
        };
        var ret = (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "controls" },
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "row" },
                InterfaceBuilder_1.InterfaceBuilder.createElement(Control, { key: "left" }),
                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "col" },
                    InterfaceBuilder_1.InterfaceBuilder.createElement(Control, { key: "up" }),
                    InterfaceBuilder_1.InterfaceBuilder.createElement(Control, { key: "down" })),
                InterfaceBuilder_1.InterfaceBuilder.createElement(Control, { key: "right" }))));
        if (ref)
            ref(this);
        return ret;
    };
    PlayerControls.prototype.keyChanged = function (keyCode, toggled) {
        var _a = this, keys = _a.attrs.keys, controls = _a.controls;
        var a = Object.entries(keys).find(function (t) { return t[1] === keyCode; });
        if (!a)
            return;
        var key = a[0];
        if (toggled)
            controls[key].classList.add("toggled");
        else
            controls[key].classList.remove("toggled");
    };
    PlayerControls.prototype.unToggleAll = function () {
        Object.values(this.controls).forEach(function (t) {
            t.classList.remove("toggled");
        });
    };
    PlayerControls.prototype.startListening = function () {
        if (this.listening)
            return;
        document.addEventListener("keydown", this.onKeyDown);
        document.addEventListener("keyup", this.onKeyUp);
        this.listening = true;
    };
    PlayerControls.prototype.stopListening = function () {
        if (!this.listening)
            return;
        document.removeEventListener("keydown", this.onKeyDown);
        document.removeEventListener("keyup", this.onKeyUp);
        this.unToggleAll();
        this.listening = false;
    };
    return PlayerControls;
}(InterfaceBuilder_1.Component));
exports.default = PlayerControls;


/***/ }),
/* 129 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationSequence_1 = __webpack_require__(26);
var Preloader_1 = __webpack_require__(52);
var InterfaceBuilder_1 = __webpack_require__(5);
var audioURL = __webpack_require__(57);
__webpack_require__(131);
var preludeText = "Let me tell you a story from our distant future...";
var episodeText = "Episode 1";
var titleText = "Unexpected kidnap";
var storyText = function (_a) {
    var names = _a.state.names;
    return [
        "The year 3020 is written, and travel between planets and galaxies is finally becoming common, but this fact carries some pitfalls. The technological war between the Earth and the planet Eslan from a nearby galaxy broke out.",
        "During this battle, one of the respected biologists, Lucy Mikelson was abducted for unknown reasons. However, the government refuses to take part in any rescue action. Thus, everything remains in the hands of " + (names[1]
            ? names[0] + " and " + names[1] + "."
            : names[0] + "."),
        "After a long intergalactic flight, " + (names[1] ? names[0] + " and " + names[1] + " finally arrive" : names[0] + " finally arrives") + " to the planet Eslan, which, except for the absence of animals, does not differ from Earth. The landing was not smooth and the first task is to get away from the crowns of huge trees in the jungle."
    ];
};
var timing = {
    beforePrelude: 6500,
    prelude: 12300,
    afterPrelude: 6150,
    logoFlow: 16000,
    crawlDelay: 3000,
    crawlDuration: 67200,
    after: 1000
};
function createCrawlHandler(crawl, endCallback) {
    return new AnimationSequence_1.AnimationSequence([
        [
            function () { return crawl.style.display = "flex"; },
            function () { return crawl.style.opacity = "1"; },
            {
                from: 100,
                to: 0,
                duration: 20000,
                callback: function (e) { return crawl.style.transform = "rotateX(50deg) translateY(" + e + "vh) translateZ(20vh)"; }
            },
            new AnimationSequence_1.AnimationSequence([
                8500,
                function () { return crawl.style.opacity = "0"; },
            ]),
            new AnimationSequence_1.AnimationSequence([
                9000,
                endCallback
            ])
        ],
        function () { return crawl.style.display = "none"; }
    ]);
}
function createHandlers(prelude, logo, crawl, doneFn, awaitLoading, showLoading) {
    var crawlAH = new AnimationSequence_1.AnimationSequence([
        timing.crawlDelay,
        [
            function () { return crawl.style.display = "flex"; },
            function () { return crawl.style.opacity = "1"; },
            {
                from: 100,
                to: -30,
                duration: timing.crawlDuration,
                callback: function (e) { return crawl.style.transform = "rotateX(50deg) translateY(" + e + "vh) translateZ(20vh)"; }
            },
            new AnimationSequence_1.AnimationSequence([
                timing.crawlDuration - 1000,
                function () { return crawl.style.opacity = "0"; }
            ]),
            new AnimationSequence_1.AnimationSequence([
                timing.crawlDuration - 2000,
                showLoading,
                awaitLoading,
                function () { return doneFn(); },
            ])
        ],
        function () { return crawl.style.display = "none"; }
    ]);
    var logoAH = new AnimationSequence_1.AnimationSequence([
        [
            function () { return logo.style.display = "block"; },
            function () { return logo.style.opacity = "1"; },
            {
                from: 1,
                to: 0,
                duration: timing.logoFlow,
                callback: function (e) { return logo.style.transform = "scale(" + ((Math.pow(e, 2)) * 20 + 0.5) + ")"; }
            },
            new AnimationSequence_1.AnimationSequence([
                timing.logoFlow - 1000,
                function () { return logo.style.opacity = "0"; }
            ])
        ],
        function () { return logo.style.display = "none"; }
    ]);
    var preludeAH = new AnimationSequence_1.AnimationSequence([
        timing.beforePrelude,
        function () { return prelude.style.transform = "scale(0.6)"; },
        function () { return prelude.style.opacity = "1"; },
        function () { return prelude.style.display = "block"; },
        function () { return prelude.style.transform = "scale(1)"; },
        timing.prelude,
        function () { return prelude.style.opacity = "0"; },
        1000,
        function () { return prelude.style.display = "none"; },
        timing.afterPrelude,
        [logoAH, crawlAH],
        timing.after
    ]);
    return preludeAH;
}
var StarWarsIntro = /** @class */ (function (_super) {
    __extends(StarWarsIntro, _super);
    function StarWarsIntro(attrs) {
        var _this = _super.call(this, attrs) || this;
        _this.animation = null;
        _this.isDone = true;
        _this.running = false;
        _this.fadeAudioId = NaN;
        _this.audioEnabled = true;
        _this.onKey = function (e) {
            var code = e.which || e.charCode || e.keyCode || 0;
            if (code === 32 || code === 27)
                _this.skip();
        };
        _this.audio = Preloader_1.preloadAudio(audioURL).audio;
        _this.audio.currentTime = 0.5;
        return _this;
    }
    StarWarsIntro.prototype.showIntro = function () {
        var _this = this;
        var _a = this, running = _a.running, prelude = _a.prelude, logo = _a.logo, crawl = _a.crawl, storyElement = _a.storyElement, audio = _a.audio, audioEnabled = _a.audioEnabled, attrs = _a.attrs;
        if (!prelude || !logo || !crawl || !storyElement)
            throw new Error("Component not rendered.");
        this.start();
        InterfaceBuilder_1.InterfaceBuilder.replaceContent(storyElement, storyText(attrs.bootstrap).map(function (t) { return InterfaceBuilder_1.InterfaceBuilder.createElement("p", null, t); }));
        var awaitLoading = attrs.bootstrap.state.loaded || new Promise(function (resolve) { return attrs.bootstrap.stateListener.once("loaded", resolve); });
        var showLoading = function () {
            if (!attrs.bootstrap.state.loaded)
                _this.toggleLoading(true);
        };
        var animation = createHandlers(prelude, logo, crawl, this.done.bind(this), awaitLoading, showLoading);
        var promise = Promise.race([
            new Promise(function (resolve) { return setTimeout(resolve, 300); }),
            new Promise(function (resolve) {
                var callback = function () {
                    resolve();
                    audio.removeEventListener("playing", callback);
                };
                audio.addEventListener("playing", callback);
            })
        ]);
        this.animation = new AnimationSequence_1.AnimationSequence([
            promise,
            animation
        ]);
        if (audioEnabled) {
            audio.currentTime = 0.5;
            audio.volume = 1;
            audio.play();
        }
        this.animation.once("finished", this.end.bind(this));
        promise.then(function () { return _this.animation && _this.animation.start(); });
        return new Promise(function (resolve) { return promise.then(function () { return setTimeout(resolve, 100); }); });
    };
    StarWarsIntro.prototype.showText = function (text) {
        if (!this.crawlText)
            throw new Error("Component not rendered.");
        this.start();
        var p = this.crawlText.children[0].children[0];
        p.innerText = text;
        var animation = this.animation = createCrawlHandler(this.crawlText, this.done.bind(this));
        animation.once("finished", this.end.bind(this));
        animation.start();
    };
    StarWarsIntro.prototype.fadeAudio = function (time) {
        var _this = this;
        if (time === void 0) { time = 2000; }
        var start = performance.now();
        var end = start + Math.abs(time);
        var initValue = this.audio.volume;
        if (!Number.isNaN(this.fadeAudioId) || this.audio.paused || this.audio.volume === 0)
            return;
        this.fadeAudioId = setInterval(function () {
            var t = performance.now();
            var vol = Math.max(0, Math.min(1, initValue * (end - t) / (end - start)));
            vol = Math.pow(vol, 2);
            _this.audio.volume = vol;
            if (vol === 0) {
                _this.audio.pause();
                _this.cancelFadeAudio();
            }
        }, 10);
    };
    StarWarsIntro.prototype.cancelFadeAudio = function () {
        if (!Number.isNaN(this.fadeAudioId)) {
            clearTimeout(this.fadeAudioId);
            this.fadeAudioId = NaN;
        }
    };
    /**
     * Sets listeners and running state.
     */
    StarWarsIntro.prototype.start = function () {
        if (this.running)
            this.stop();
        this.toggleLoading(false);
        this.running = true;
        this.isDone = false;
        window.addEventListener("keypress", this.onKey);
    };
    /**
     * Ends the animation.
     */
    StarWarsIntro.prototype.end = function () {
        document.removeEventListener("keypress", this.onKey);
        if (!this.isDone)
            this.done();
        if (this.running)
            this.emit("finished", void (0));
        this.running = false;
        if (!this.audio.paused)
            this.fadeAudio();
    };
    /**
     * Cancels all pending animations.
     */
    StarWarsIntro.prototype.cancel = function () {
        if (this.animation)
            this.animation.cancel();
    };
    /**
     * Emits the `done` event and fades audio away.
     *
     * Represents the event when all animations are done, but haven't finished.
     */
    StarWarsIntro.prototype.done = function () {
        if (!this.isDone && this.running) {
            this.emit("done", void (0));
            this.isDone = true;
            this.fadeAudio();
        }
    };
    /**
     * Puts an immediate stop to pending animations.
     */
    StarWarsIntro.prototype.stop = function () {
        this.cancel();
        this.end();
        if (!this.audio.paused)
            this.audio.pause();
        [this.prelude, this.logo, this.crawl, this.crawlText].forEach(function (t) { return t && (t.style.display = "none"); });
    };
    StarWarsIntro.prototype.toggleLoading = function (show) {
        if (show === void 0) { show = this.attrs.bootstrap.state.loaded; }
        if (!this.loading)
            throw new Error("Component not rendered.");
        if (show)
            this.loading.classList.add("show");
        else
            this.loading.classList.remove("show");
    };
    StarWarsIntro.prototype.skip = function () {
        var bootstrap = this.attrs.bootstrap;
        if (bootstrap.state.loaded)
            this.done();
        else {
            this.toggleLoading(true);
            bootstrap.stateListener.once("loaded", this.skip.bind(this));
        }
    };
    StarWarsIntro.prototype.dispose = function () {
        this.cancel();
        this.end();
    };
    StarWarsIntro.prototype.fillSvg = function (elt) {
        elt.innerHTML = "\n\t\t\t<svg id=\"spacehunt-logo\" height=\"38\" width=\"100\">\n\t\t\t\t<text x=\"50\" y=\"18\">\n\t\t\t\t\t<tspan style=\"letter-spacing: -2px;\">sP</tspan><tspan class=\"no-ligature\" style=\"letter-spacing: -1.5px;\">A</tspan>cE\n\t\t\t\t</text>\n\t\t\t\t<text x=\"50\" y=\"36\">\n\t\t\t\t\t{&gt;H<tspan class=\"no-ligature\">U</tspan>nT\n\t\t\t\t</text>\n\t\t\t</svg>";
        return elt.children[0];
    };
    StarWarsIntro.prototype.render = function (attrs) {
        var _this = this;
        var ret = (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "swintro" },
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "hidden" },
                InterfaceBuilder_1.InterfaceBuilder.createElement("span", { className: "o" }, "o"),
                InterfaceBuilder_1.InterfaceBuilder.createElement("span", { className: "oa" }, "oa")),
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "blue-text loading", ref: function (e) { return _this.loading = e; } }, "Loading..."),
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "center-wrapper" },
                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { ref: function (e) { return _this.prelude = e; }, className: "prelude blue-text" }, preludeText)),
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "center-wrapper", ref: function (e) { return _this.logo = _this.fillSvg(e); } }),
            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "perspective-wrapper" },
                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "perspective-holder", ref: function (e) { return _this.crawl = e; } },
                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "perspective-content" },
                        InterfaceBuilder_1.InterfaceBuilder.createElement("p", { className: "episode" }, episodeText),
                        InterfaceBuilder_1.InterfaceBuilder.createElement("p", { className: "title" }, titleText),
                        InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "story-text", ref: function (e) { return _this.storyElement = e; } }))),
                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "perspective-holder", ref: function (e) { return _this.crawlText = e; } },
                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "perspective-content" },
                        InterfaceBuilder_1.InterfaceBuilder.createElement("p", null))))));
        if (attrs.ref)
            attrs.ref(this);
        return ret;
    };
    return StarWarsIntro;
}(InterfaceBuilder_1.Component));
exports.default = StarWarsIntro;


/***/ }),
/* 131 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 132 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = {"particles":{"number":{"value":120,"density":{"enable":true,"value_area":473.4885849793636}},"color":{"value":"#ffffff"},"shape":{"type":"circle","stroke":{"width":0,"color":"#000000"},"polygon":{"nb_sides":5},"image":{"src":"img/github.svg","width":100,"height":100}},"opacity":{"value":0.5,"random":false,"anim":{"enable":false,"speed":1,"opacity_min":0.1,"sync":false}},"size":{"value":0,"random":false,"anim":{"enable":false,"speed":40,"size_min":0.1,"sync":false}},"line_linked":{"enable":true,"distance":150,"color":"#ffffff","opacity":0.4,"width":1},"move":{"enable":true,"speed":1,"direction":"top","random":false,"straight":false,"out_mode":"out","bounce":false,"attract":{"enable":false,"rotateX":600,"rotateY":1200}}},"interactivity":{"detect_on":"canvas","events":{"onhover":{"enable":false,"mode":"repulse"},"onclick":{"enable":true,"mode":"repulse"},"resize":true},"modes":{"grab":{"distance":400,"line_linked":{"opacity":1}},"bubble":{"distance":400,"size":40,"duration":2,"opacity":8,"speed":3},"repulse":{"distance":200,"duration":0.4},"push":{"particles_nb":4},"remove":{"particles_nb":2}}},"retina_detect":true}

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var addS = function (name) { return name.toLowerCase().endsWith("s") ? name + "'" : name + "'s"; };
var nameText = function (names) { return names[1] ? names[0] + " and " + names[1] : names[0]; };
exports.level1 = function (_a) {
    var names = _a.names;
    return "It seems " + nameText(names) + " mastered the jungle easily, but a river, which stands on the way, is full of crocodiles, robotic crocodiles. The kidnapping of Lucy suddenly starts to make sense.";
};
exports.level2 = function (_a) {
    var names = _a.names;
    return "Local inhabitants detect presence of our " + (names[1] ? "heroes" : "hero") + " and they are now rolling and bouncing boulders.";
};
exports.level3 = function (_a) {
    var names = _a.names;
    return "Exhausted " + (names[1] ? names[0] + " and " + names[1] : names[0]) + " eventually " + (names[1] ? "meet" : "meets") + " a few Eslans who hold Lucy and use her knowledge of animals to create their own. The Eslans are not very friendly, and " + (names[1] ? names[0] + " and " + names[1] + " confront" : names[0] + " confronts") + " them in the struggle for life and death.";
};
exports.level4 = function (_a) {
    var names = _a.names, winner = _a.winner, score = _a.score;
    return "After a long fight, " + winner + " has managed to save Lucy. Then they stole Eslans' spaceship to get back to Earth, where they live happily ever after.\n\nSCORE: " + score.toString();
};
exports.death = function (_a) {
    var names = _a.names, score = _a.score;
    return "Such a tragedy! Poor " + nameText(names) + " lost " + (names[1] ? "lives" : "life") + " trying to set Lucy free from the hands of the evil Eslans.\n\nSCORE: " + score.toString();
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Arrow_1 = __webpack_require__(136);
var Level1Player_1 = __webpack_require__(137);
var TreeBranch_1 = __webpack_require__(140);
var VineCreator_1 = __webpack_require__(141);
var Resources_1 = __webpack_require__(4);
var BasePlayer_1 = __webpack_require__(6);
var BaseLevel_1 = __webpack_require__(28);
var Level1 = /** @class */ (function (_super) {
    __extends(Level1, _super);
    function Level1(bootstrap) {
        var _this = _super.call(this, Level1.sceneKey, bootstrap, Level1.levelBounds, 
        // players[]
        (bootstrap.state.names.length === 2
            ? ([new Level1Player_1.default(100, 0, Level1.levelBounds.right, BasePlayer_1.controlSets.controls1, bootstrap.state, true),
                new Level1Player_1.default(30, 0, Level1.levelBounds.right, BasePlayer_1.controlSets.controls2, bootstrap.state, false)]) // two players required
            : ([new Level1Player_1.default(100, 0, Level1.levelBounds.right, BasePlayer_1.controlSets.controls1, bootstrap.state, true)])), // just one player required
        Level1.groundTexture, Resources_1.default.level1.bg.asSprite()) || this;
        _this.vines = [];
        _this.vineCreator = new VineCreator_1.default(_this.levelBounds.left + 400, _this.levelBounds.right - 80);
        _this.treeBranch = new TreeBranch_1.default(_this.levelBounds.left + TreeBranch_1.default.BRANCH_LENGTH / 2, _this.levelBounds.top + 250);
        _this.arrow = new Arrow_1.default(_this.levelBounds.right - 200, _this.levelBounds.top + 200);
        _this.players.map(function (p) { p.on("reset", _this.onPlayerReset.bind(_this)); });
        _this.buildScene();
        return _this;
    }
    Level1.prototype.buildScene = function () {
        _super.prototype.buildScene.call(this);
        this.vines = this.vineCreator.createVines();
        for (var _i = 0, _a = this.vines; _i < _a.length; _i++) {
            var vine = _a[_i];
            for (var _b = 0, _c = vine.getAllParts(); _b < _c.length; _b++) {
                var vinePart = _c[_b];
                this.scene.add(vinePart);
            }
        }
        this.ground.z = 2;
        this.scene.add(this.treeBranch);
        this.scene.add(this.arrow);
        this.arrow.z = -1;
        this.background.z = -2;
    };
    Level1.prototype.onPlayerReset = function (e) {
        for (var _i = 0, _a = this.vines; _i < _a.length; _i++) {
            var vine = _a[_i];
            var indexInCollidedList = vine.alreadyCollidedWith.indexOf(e.target);
            if (indexInCollidedList !== -1) {
                vine.alreadyCollidedWith.splice(indexInCollidedList, 1);
            }
        }
        this.state.score = Math.round(this.state.score / 2);
    };
    Level1.sceneKey = "level1";
    Level1.levelBounds = new ex.BoundingBox(0, 0, 5000, 800);
    Level1.groundTexture = Resources_1.default.level1.ground;
    return Level1;
}(BaseLevel_1.default));
exports.default = Level1;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Resources_1 = __webpack_require__(4);
var Arrow = /** @class */ (function (_super) {
    __extends(Arrow, _super);
    function Arrow(x, y) {
        var _this = _super.call(this, x, y, Arrow.size.w, Arrow.size.h) || this;
        _this.collisionType = ex.CollisionType.PreventCollision;
        _this.sprite = Resources_1.default.level1.arrow.asSprite();
        return _this;
    }
    Arrow.prototype.draw = function (ctx, delta) {
        this.sprite.draw(ctx, this.getLeft(), this.getTop());
    };
    Arrow.size = { w: 210, h: 200 };
    return Arrow;
}(ex.Actor));
exports.default = Arrow;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var BasePlayer_1 = __webpack_require__(6);
var PlayerAnimations_1 = __webpack_require__(138);
var MikelsonAnimation_1 = __webpack_require__(14);
var AnimationStateHandler_1 = __webpack_require__(139);
var Level1Player = /** @class */ (function (_super) {
    __extends(Level1Player, _super);
    function Level1Player(x, y, levelLength, controlSet, state, isFirst) {
        var _this = _super.call(this, x, y, controlSet, state) || this;
        _this.inJump = false;
        _this.onBranch = true;
        _this.onVine = false;
        _this.timeOnVine = 500;
        _this.on("precollision", _this.onPrecollision);
        _this.on("postcollision", _this.onPostcollision);
        var animation = PlayerAnimations_1.attachPlayerAnimations(_this, !isFirst);
        _this.animationStateHandler = new AnimationStateHandler_1.default(MikelsonAnimation_1.selectedState, animation);
        _this.levelLength = levelLength;
        _this.originalPosition = { left: x, top: y };
        return _this;
    }
    Level1Player.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta);
        var ash = this.animationStateHandler;
        if (engine.input.keyboard.wasPressed(this.controls.up)) {
            this.jump();
            ash.changeState("jump-right");
        }
        if (!this.onVine && engine.input.keyboard.wasReleased(this.controls.left)) {
            if (this.onBranch) {
                ash.changeState("idle-left");
            }
        }
        if (!this.onVine && engine.input.keyboard.wasReleased(this.controls.right)) {
            if (this.onBranch) {
                ash.changeState("idle-right");
            }
        }
        if (engine.input.keyboard.isHeld(this.controls.left)) {
            this.moveLeft();
            if (this.onBranch) {
                ash.changeState("walk-left");
            }
        }
        if (engine.input.keyboard.isHeld(this.controls.right)) {
            this.moveRight();
            if (this.onBranch) {
                ash.changeState("walk-right");
            }
        }
        if (this.getWorldPos().x > this.levelLength + 10) {
            this.win("won by reaching the level ending");
        }
    };
    Level1Player.prototype.jump = function () {
        this.onBranch = false;
        if (!this.inJump) {
            if (this.onVine) {
                var parent_1 = this.parent;
                this.parent.remove(this);
                this.scene.add(this);
                this.pos.setTo(parent_1.pos.x, parent_1.pos.y);
                this.collisionType = ex.CollisionType.Active;
                this.cameraStrategy.target = this;
            }
            this.vel.setTo(600, -500);
            this.rotation = -Math.PI / 6;
            this.inJump = true;
            this.onVine = false;
        }
    };
    Level1Player.prototype.onPrecollision = function (e) {
        if (e.other.constructor.name === "Vine" && !this.onVine) {
            this.attachToVine(e.other);
        }
    };
    Level1Player.prototype.onPostcollision = function (e) {
        if (e.other.constructor.name === "Ground") {
            this.die("died by falling on the ground");
        }
    };
    Level1Player.prototype.attachToVine = function (vine) {
        var vineRoot = vine.getRoot();
        if (vineRoot.alreadyCollidedWith.indexOf(this) !== -1) {
            return;
        }
        this.state.score += Math.round(50000 / this.timeOnVine); // Max 100, min 10 points
        console.log(this.timeOnVine);
        this.timeOnVine = 500;
        if (this.timer)
            clearInterval(this.timer);
        this.timer = setInterval(this.addTimeOnVine.bind(this), 500);
        this.inJump = false;
        vineRoot.alreadyCollidedWith.push(this);
        this.scene.remove(this);
        vine.add(this);
        this.onVine = true;
        this.pos.y = 20 + Level1Player.size.h / 2;
        this.pos.x = 0;
        this.vel.setTo(0, 0);
        this.rotation = 0;
        this.cameraStrategy.target = vine;
        this.animationStateHandler.changeState("grab-right");
    };
    Level1Player.prototype.moveLeft = function () {
        if (this.onBranch) {
            var newPos = this.pos.x - Level1Player.MOVEMENT_SPEED;
            newPos = newPos < Level1Player.SCREEN_END_X ? Level1Player.SCREEN_END_X : newPos;
            this.pos.x = newPos;
        }
    };
    Level1Player.prototype.moveRight = function () {
        if (this.onBranch) {
            this.pos.x += Level1Player.MOVEMENT_SPEED;
        }
    };
    Level1Player.prototype.addTimeOnVine = function () {
        this.timeOnVine += 150;
        if (this.timeOnVine > 5000)
            this.timeOnVine = 5000;
        console.log(this.timeOnVine);
    };
    Level1Player.prototype.die = function (info) {
        if (!this.dead && this.state.lives > 1) {
            this.reset();
        }
        _super.prototype.die.call(this, info);
    };
    Level1Player.prototype.reset = function () {
        this.inJump = false;
        this.onVine = false;
        this.onBranch = true;
        this.x = this.originalPosition.left;
        this.y = this.originalPosition.top;
        this.vel.setTo(0, 0);
        this.animationStateHandler.changeState("idle-right");
        var event = new ex.GameEvent();
        event.target = this;
        this.emit("reset", event);
    };
    Level1Player.MOVEMENT_SPEED = 8;
    Level1Player.SCREEN_END_X = 5;
    return Level1Player;
}(BasePlayer_1.default));
exports.default = Level1Player;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DrawAnimationFactory_1 = __webpack_require__(27);
var MikelsonParts_1 = __webpack_require__(12);
var MikelsonAnimation_1 = __webpack_require__(14);
function attachPlayerAnimations(player, isBrother) {
    if (isBrother === void 0) { isBrother = false; }
    var sprs = isBrother ? MikelsonParts_1.spritesBro : MikelsonParts_1.sprites;
    var data = MikelsonAnimation_1.allData.map(function (data) {
        var states = data.states, selectedState = data.selectedState;
        var bd = data.beforeDraw && data.beforeDraw(sprs);
        var beforeDraw = function (_, __, position) {
            var t = bd && bd.apply(this, arguments);
            var translateX = (t && t.translateX) || 0;
            var translateY = (t && t.translateY) || 0;
            translateY += MikelsonParts_1.modelSize.h / 2;
            if (position && player.onVine) {
                translateX -= position.x;
                translateY -= position.y;
            }
            return { translateX: translateX, translateY: translateY };
        };
        return {
            states: states,
            selectedState: selectedState,
            beforeDraw: beforeDraw,
            drawBase: data.drawBase(sprs)
        };
    });
    var animationProviders = data.map(function (t) { return DrawAnimationFactory_1.createTransformDrawSetProvider(t); });
    var playerAnimationFactory = new DrawAnimationFactory_1.TransformDrawAnimationFactory(animationProviders);
    return playerAnimationFactory.attachTo(player);
}
exports.attachPlayerAnimations = attachPlayerAnimations;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AnimationStateHandler = /** @class */ (function () {
    function AnimationStateHandler(defaultState, animation) {
        this.changeMode = false;
        this._state = defaultState;
        this._intermediateState = defaultState;
        this._animation = animation;
    }
    Object.defineProperty(AnimationStateHandler.prototype, "state", {
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationStateHandler.prototype, "intermediateState", {
        get: function () {
            return this._intermediateState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationStateHandler.prototype, "animation", {
        get: function () {
            return this._animation;
        },
        set: function (animation) {
            this._animation = animation || undefined;
            if (animation)
                animation.changeState(this._state);
        },
        enumerable: true,
        configurable: true
    });
    AnimationStateHandler.prototype.enableChangeMode = function () {
        this.changeMode = true;
    };
    AnimationStateHandler.prototype.changeState = function (state) {
        if (this.changeMode)
            this._intermediateState = state;
        else
            this.applyState(state);
    };
    AnimationStateHandler.prototype.apply = function () {
        if (this.changeMode) {
            this.changeMode = false;
            this.applyState(this._intermediateState);
        }
    };
    AnimationStateHandler.prototype.applyState = function (state) {
        if (this._state === state)
            return;
        this._state = state;
        if (this.animation)
            this.animation.changeState(state);
    };
    return AnimationStateHandler;
}());
exports.default = AnimationStateHandler;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Resources_1 = __webpack_require__(4);
var TreeBranch = /** @class */ (function (_super) {
    __extends(TreeBranch, _super);
    function TreeBranch(x, y) {
        var _this = _super.call(this, x, y, TreeBranch.BRANCH_LENGTH, TreeBranch.BRANCH_WIDTH, ex.Color.Green) || this;
        _this.collisionType = ex.CollisionType.Fixed;
        return _this;
    }
    TreeBranch.prototype.draw = function (ctx, delta) {
        TreeBranch.IMAGE.draw(ctx, this.getLeft(), this.getTop() - 10);
    };
    TreeBranch.BRANCH_WIDTH = 20;
    TreeBranch.BRANCH_LENGTH = 170;
    TreeBranch.IMAGE = Resources_1.default.level1.tree.asSprite();
    return TreeBranch;
}(ex.Actor));
exports.default = TreeBranch;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Vine_1 = __webpack_require__(58);
var VineCreator = /** @class */ (function () {
    function VineCreator(start, end) {
        this.rightToLeft = false;
        this.start = start;
        this.end = end;
        this.rightToLeft = start > end;
    }
    VineCreator.prototype.createVines = function () {
        var vines = [];
        var position = this.start;
        while (true) {
            var distance = VineCreator.randomNumber(VineCreator.distRange.min, VineCreator.distRange.max);
            var vineLength = Math.round(VineCreator.randomNumber(VineCreator.lenRange.min, VineCreator.lenRange.max));
            var speed = VineCreator.randomNumber(VineCreator.speedRange.min, VineCreator.speedRange.max);
            var maxRotation = VineCreator.randomNumber(VineCreator.rotRange.min, VineCreator.rotRange.max);
            var vine = new Vine_1.default(position, 0, vineLength, speed, maxRotation);
            vines.push(vine);
            position = this.rightToLeft ? position - distance : position + distance;
            var endCond = this.rightToLeft ? position <= this.end : position >= this.end;
            if (endCond) {
                break;
            }
        }
        return vines;
    };
    VineCreator.randomNumber = function (from, to) {
        var diff = to - from;
        return Math.random() * diff + from;
    };
    VineCreator.distRange = { min: 330, max: 370 };
    VineCreator.lenRange = { min: 14, max: 18 };
    VineCreator.speedRange = { min: 0.8, max: 1.8 };
    VineCreator.rotRange = { min: 0.6, max: 1 };
    return VineCreator;
}());
exports.default = VineCreator;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
/**
 * Dynamic background which moves with the player but on slower pace
 * creating sort of a 2.5D effect
 */
var Background = /** @class */ (function (_super) {
    __extends(Background, _super);
    function Background(image, player, x, y, minLeft, minRight, lvlLen, ySpeed) {
        var _this = _super.call(this, x, y, Background.bgWidth, Background.bgHeight) || this;
        _this.time = 0;
        _this.anchor.setTo(0, 0);
        _this.bgToLvlRatio = (Background.bgWidth - minLeft - minRight) / (lvlLen - minLeft - minRight);
        _this.image = image;
        _this.lvlLength = lvlLen;
        _this.minLeft = minLeft;
        _this.player = player;
        if (ySpeed)
            _this.ySpeed = ySpeed;
        return _this;
    }
    Background.prototype.update = function (engine, delta) {
        this.time += delta;
        var bgToPlayerPos = -this.bgToLvlRatio * (this.player.getWorldPos().x - 400);
        this.x = this.player.getWorldPos().x + bgToPlayerPos - this.minLeft;
        this.x = this.x < 0 ? 0 : this.x;
        this.x = this.x + Background.bgWidth > this.lvlLength ? this.lvlLength - Background.bgWidth : this.x;
        if (this.ySpeed)
            this.y = -Math.abs(Math.sin(this.time * this.ySpeed)) * Background.maxYMovement;
    };
    Background.prototype.draw = function (ctx, delta) {
        this.image.draw(ctx, this.getLeft(), this.getTop());
    };
    Background.bgWidth = 1600;
    Background.bgHeight = 600;
    Background.maxYMovement = 10;
    return Background;
}(ex.Actor));
exports.default = Background;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LockLevelCameraStrategy = /** @class */ (function () {
    function LockLevelCameraStrategy(screenBounds, levelBounds) {
        this.minX = levelBounds.left + screenBounds.getWidth() / 2;
        this.maxX = levelBounds.right - screenBounds.getWidth() / 2;
    }
    LockLevelCameraStrategy.prototype.action = function (target, cam, _eng, _delta) {
        this.target = target;
        var newPosition = cam.pos;
        newPosition.x = newPosition.x < this.minX ? this.minX : newPosition.x;
        newPosition.x = newPosition.x > this.maxX ? this.maxX : newPosition.x;
        return newPosition;
    };
    return LockLevelCameraStrategy;
}());
exports.default = LockLevelCameraStrategy;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Sky = /** @class */ (function (_super) {
    __extends(Sky, _super);
    function Sky(x, y, width, height) {
        var _this = _super.call(this, x, y, width, height) || this;
        _this.collisionType = ex.CollisionType.Passive;
        return _this;
    }
    return Sky;
}(ex.Actor));
exports.default = Sky;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var MikelsonParts_1 = __webpack_require__(12);
var MikelsonAnimation_1 = __webpack_require__(14);
var BasePlayer_1 = __webpack_require__(6);
var Level2_1 = __webpack_require__(59);
var Level2Player = /** @class */ (function (_super) {
    __extends(Level2Player, _super);
    function Level2Player(x, y, controlSet, oxygenMeter, state, isFirst) {
        var _this = _super.call(this, x, y, controlSet, state) || this;
        _this.speedX = Level2Player.speedNormal;
        _this.trapped = false; // for disabling controls in case of being trapped by a bubble
        _this.dead = false;
        _this.oxygenLevel = 100;
        _this.timeInDeep = 0;
        _this.minX = Level2_1.default.levelBounds.left + MikelsonParts_1.modelSwimSize.w / 2;
        _this.maxX = Level2_1.default.levelBounds.right - MikelsonParts_1.modelSwimSize.w / 2;
        _this.minY = Level2_1.default.levelBounds.top + MikelsonParts_1.modelSwimSize.h / 2;
        _this.maxY = Level2_1.default.levelBounds.bottom - MikelsonParts_1.modelSwimSize.h / 2;
        _this.deepestWaterPosY = _this.maxY - 135;
        _this.mediumDeepWaterPosY = _this.maxY - 185;
        _this.oxygenMeter = oxygenMeter;
        _this.oxygenMeter.fontSize = 30;
        _this.setWidth(MikelsonParts_1.modelSwimSize.w);
        _this.setHeight(MikelsonParts_1.modelSwimSize.h);
        // Anchor
        _this.anchor.setTo(0.5, 0.5); // set anchor to the center
        _this.collisionArea.body.useBoxCollision();
        _this.collisionType = ex.CollisionType.Active;
        _this.on("precollision", _this.onPrecollision);
        if (isFirst)
            _this.animation = MikelsonAnimation_1.playerAnimationFactory.attachTo(_this);
        else
            _this.animation = MikelsonAnimation_1.brotherAnimationFactory.attachTo(_this);
        _this.animation.changeState("swim-right");
        return _this;
    }
    Level2Player.prototype.onPrecollision = function (ev) {
        // Reset Oxygen Level to 100
        if (ev.other.constructor.name === "Sky") {
            // refill oxygen
            this.oxygenLevel = 100;
        }
        else if (ev.other.constructor.name === "Bubble" && !this.trapped) {
            this.oxygenLevel = (this.oxygenLevel + 20) < 100 ? this.oxygenLevel + 20 : 100;
        }
    };
    Level2Player.prototype.update = function (engine, delta) {
        var _this = this;
        _super.prototype.update.call(this, engine, delta);
        var oldSpeedX = this.speedX;
        // Decrease Oxygen Level and drown if no oxygen is left
        this.oxygenLevel -= 0.12;
        this.oxygenMeter.text = "Oxygen Level: " + Math.round(this.oxygenLevel) + "/100";
        if (this.oxygenLevel <= 0) {
            this.die("You drowned!");
        }
        if (!this.trapped) {
            // X movement
            if (engine.input.keyboard.wasPressed(this.controls.left)) {
                this.speedX = Level2Player.speedDec;
            }
            if (engine.input.keyboard.wasPressed(this.controls.right)) {
                this.speedX = Level2Player.speedAcc;
            }
            if (engine.input.keyboard.wasReleased(this.controls.left)) {
                if (engine.input.keyboard.isHeld(this.controls.right)) {
                    this.speedX = Level2Player.speedAcc;
                }
                else {
                    this.speedX = Level2Player.speedNormal;
                }
            }
            if (engine.input.keyboard.wasReleased(this.controls.right)) {
                if (engine.input.keyboard.isHeld(this.controls.left)) {
                    this.speedX = Level2Player.speedDec;
                }
                else {
                    this.speedX = Level2Player.speedNormal;
                }
            }
            if (engine.input.keyboard.isHeld(this.controls.left) && engine.input.keyboard.isHeld(this.controls.right)) {
                this.speedX = Level2Player.speedNormal;
            }
            this.vel.x = this.speedX;
            if (this.pos.x > this.maxX)
                this.emit("win");
            // Y movement
            if (engine.input.keyboard.isHeld(this.controls.up)) {
                this.moveUp();
            }
            if (engine.input.keyboard.isHeld(this.controls.down)) {
                this.moveDown();
            }
        }
        if (this.speedX !== oldSpeedX) {
            if (this.speedX === Level2Player.speedNormal)
                this.animation.changeState("swim-right");
            else if (this.speedX === Level2Player.speedAcc)
                this.animation.changeState("swim-right-fast");
            else if (this.speedX === Level2Player.speedDec)
                this.animation.changeState("swim-right-slow");
        }
        if (this.getWorldPos().x > 4950) {
            this.win("won by reaching the level end");
        }
        if (this.pos.y > this.deepestWaterPosY) {
            if (!this.timer)
                this.timer = setInterval(function () {
                    if (_this.pos.y > _this.deepestWaterPosY)
                        _this.state.score += 65;
                    clearInterval(_this.timer);
                    _this.timer = null;
                }, 500);
        }
        else if (this.pos.y > this.mediumDeepWaterPosY) {
            if (!this.timer)
                this.timer = setInterval(function () {
                    if (_this.pos.y > _this.mediumDeepWaterPosY)
                        _this.state.score += 25;
                    clearInterval(_this.timer);
                    _this.timer = null;
                }, 750);
        }
        else {
            if (!this.timer)
                this.timer = setInterval(function () {
                    _this.state.score += 5;
                    clearInterval(_this.timer);
                    _this.timer = null;
                }, 1000);
        }
    };
    Level2Player.prototype.moveUp = function () {
        // to not move too far into the sky
        if (this.pos.y > (this.minY + 100)) {
            this.pos.y -= Level2Player.speedY;
        }
    };
    Level2Player.prototype.moveDown = function () {
        if (this.pos.y < this.maxY) {
            this.pos.y += Level2Player.speedY;
        }
    };
    // static speed: number = 8; //to be changed for normal/slower/faster swimming movement
    Level2Player.speedY = 2;
    Level2Player.speedAcc = 200;
    Level2Player.speedNormal = 100;
    Level2Player.speedDec = 50;
    return Level2Player;
}(BasePlayer_1.default));
exports.default = Level2Player;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Bubble_1 = __webpack_require__(147);
// class for cyclically creating new bubbles and adding them to the scene, in front of the player
var BubbleCreator = /** @class */ (function () {
    function BubbleCreator(engine, scene, bounds, players, bubbles) {
        this.timer = [-1]; // to be passed by reference
        this.engine = engine;
        this.scene = scene;
        this.bounds = bounds;
        this.players = players;
        this.bubbles = bubbles;
    }
    BubbleCreator.prototype.start = function () {
        console.log("bubbleCreator started! (Level2 - BubbleCreator - start())");
        // start timer scheduling new bubble creations
        var that = this;
        this.timer[0] = setTimeout(function () {
            that.createNewBubbleRT(that.scene, that.bounds, that.players, that.bubbles, that.timer);
        }, 3000);
    };
    BubbleCreator.prototype.stop = function () {
        // cancel timer
        console.log("bubbleCreator stopped! (Level2 - BubbleCreator - stop())");
        if (this.timer[0] !== -1) {
            clearInterval(this.timer[0]);
        }
    };
    // TODO: random position(hitting the player based on it's current speed and y-distance?) & intervals
    BubbleCreator.prototype.createNewBubbleRT = function (scene, bounds, players, bubbles, timer) {
        console.log("creating new bubble... (Level2 - BubbleCreator - createNewBubbleRT()");
        for (var _i = 0, players_1 = players; _i < players_1.length; _i++) {
            var player = players_1[_i];
            // determining speed of the next bubble
            var speedXB = this.randomIntFromInterval(20, 100);
            var speedYB = this.randomIntFromInterval(-100, -200);
            // time until collision = y distance of bubble starting point (at the bottom) and player / y-speed of the bubble
            var t = -1 * (bounds.bottom - player.y) / speedYB;
            // console.log("t =    " + t);
            // x of possible collision point = x position of player in t seconds
            var xC = player.x + (t * player.vel.x);
            // create new bubble in front of the player
            // let x = player.x + 300;
            var x = xC - speedXB * t;
            var newBubbleIndex = bubbles.push(new Bubble_1.default(x, bounds.bottom, speedXB, speedYB)) - 1;
            scene.add(bubbles[newBubbleIndex]);
        }
        // create new timeout for next bubble
        var nextBubbleInMS = this.randomIntFromInterval(1000, 3000);
        var that = this;
        timer[0] = setTimeout(function () {
            that.createNewBubbleRT(scene, bounds, players, bubbles, timer);
        }, nextBubbleInMS);
    };
    BubbleCreator.prototype.randomIntFromInterval = function (min, max) {
        var t = Math.floor(Math.random() * (max - min + 1) + min);
        return t;
    };
    return BubbleCreator;
}());
exports.default = BubbleCreator;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Resources_1 = __webpack_require__(4);
var Bubble = /** @class */ (function (_super) {
    __extends(Bubble, _super);
    function Bubble(x, y, speedX, speedY) {
        var _this = _super.call(this, x, y, Bubble.size.w, Bubble.size.h, ex.Color.White) || this;
        _this.playerCollision = false;
        _this.playerTrapped = false;
        _this.timer = -1;
        // Anchor
        _this.anchor.setTo(0.5, 0.5); // set anchor to the center
        Bubble.sprite.anchor.setTo(0.5, 0.5);
        _this.collisionArea.body.useBoxCollision();
        _this.collisionType = ex.CollisionType.Passive;
        _this.vel = new ex.Vector(speedX, speedY);
        // On collision check if Level2Player and trap if true
        _this.on("precollision", _this.onPrecollision);
        return _this;
    }
    // raised every frame while colliding
    Bubble.prototype.onPrecollision = function (ev) {
        // console.log("precollision event raised");
        // trap player if collided
        // only if player not already in the sky
        if (!this.playerCollision && ev.other.constructor.name === "Level2Player" && !ev.other.trapped && this.y > Bubble.MINCOLLISIONY) {
            console.log("1st-time PLAYER precollision event raised (Level2 - Bubble - onPrecollision())");
            this.playerCollision = true;
            this.playerTrapped = true;
            this.collidedPlayer = ev.other;
            if (this.collidedPlayer) {
                this.collidedPlayer.trapped = true;
                this.collidedPlayer.vel = this.vel;
                this.collidedPlayer.state.score += 50;
                // player position: to be moved towards the center of the bubble within tImbibe seconds
                // extra velocity for tImbibe seconds
                var dX = (this.x - this.collidedPlayer.x);
                var dY = (this.y - this.collidedPlayer.y);
                this.collidedPlayer.vel.x = this.collidedPlayer.vel.x + dX / Bubble.tImbibe;
                this.collidedPlayer.vel.y = this.collidedPlayer.vel.y + dY / Bubble.tImbibe;
                var that_1 = this;
                this.timer = setTimeout(function () {
                    if (that_1.collidedPlayer) {
                        that_1.collidedPlayer.vel = that_1.vel;
                    }
                    that_1.timer = -1;
                }, Bubble.tImbibe * 1000);
            }
        }
        // kill bubble when reaching sky
        if (ev.other.constructor.name === "Sky") {
            this.kill();
        }
    };
    Bubble.prototype.draw = function (ctx, delta) {
        Bubble.sprite.draw(ctx, this.getCenter().x, this.getCenter().y);
    };
    Bubble.prototype.kill = function () {
        // clear timeout if necessary and free player
        if (this.timer !== -1) {
            clearTimeout(this.timer);
        }
        this.playerTrapped = false;
        if (this.collidedPlayer) {
            this.collidedPlayer.trapped = false;
            this.collidedPlayer.vel = new ex.Vector(0, 0);
        }
        _super.prototype.kill.call(this);
    };
    Bubble.size = { w: 20, h: 20 };
    Bubble.sprite = Resources_1.default.level2.bubble.asSprite();
    // no influence on player if over a certain height -> depending on sky height and own size
    Bubble.MINCOLLISIONY = Bubble.size.h / 2 + 145 + 1;
    Bubble.speedY = -100;
    Bubble.speedX = 50;
    Bubble.tImbibe = 0.5;
    return Bubble;
}(ex.Actor));
exports.default = Bubble;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Crocodile_1 = __webpack_require__(149);
// class for cyclically creating new crocodiles and adding them to the scene, in front of the player
var CrocodileCreator = /** @class */ (function () {
    function CrocodileCreator(bootstrap, scene, bounds, level, crocodiles) {
        this.timer = [-1]; // to be passed by reference
        this.engine = bootstrap.engine;
        this.scene = scene;
        this.bounds = bounds;
        this.level = level;
        this.crocodiles = crocodiles;
        this.bootstrap = bootstrap;
    }
    CrocodileCreator.prototype.start = function () {
        var _this = this;
        console.log("crocodileCreator started! (Level2 - CrocodileCreator - start())");
        // start timer scheduling new crocodile creations
        this.timer[0] = setTimeout(function () {
            _this.createNewCrocodileRT(_this.scene, _this.bounds, _this.level, _this.crocodiles, _this.timer);
        }, 1500);
    };
    CrocodileCreator.prototype.stop = function () {
        // cancel timer // kill bubbles ?
        console.log("crocodileCreator stopped! (Level2 - CrocodileCreator - stop())");
        if (this.timer[0] !== -1) {
            clearInterval(this.timer[0]);
        }
    };
    CrocodileCreator.prototype.createNewCrocodileRT = function (scene, bounds, level, crocodiles, timer) {
        console.log("creating new bubble... (Level2 - CrocodileCreator - createNewCrocodileRT()");
        // determining speed of the next bubble
        var speedXB = this.randomIntFromInterval(-20, -100);
        var speedYB = this.randomIntFromInterval(0, 0);
        // time until collision = y distance of bubble starting point (at the bottom) and player / y-speed of the bubble
        var t = -1 * (bounds.bottom - level.frontPlayer.y) / speedYB;
        // console.log("t =    " + t);
        // x of possible collision point = x position of player in t seconds
        var xC = level.frontPlayer.x + (t * level.frontPlayer.vel.x);
        // starting x of the bubble = collision x - x distance travelled by the bubble until collision
        var xBStart = xC - speedXB * t;
        // create new bubble in front of the player
        var x = level.frontPlayer.x + 1000;
        // let x = xBStart;
        var newCrocodileIndex = crocodiles.push(new Crocodile_1.default(this.bootstrap, x, this.randomIntFromInterval(120, bounds.bottom - 60), speedXB, speedYB)) - 1;
        scene.add(crocodiles[newCrocodileIndex]);
        // create new timeout for next bubble
        var nextCrocodileInMS = this.randomIntFromInterval(1500, 3000);
        var that = this;
        timer[0] = setTimeout(function () {
            that.createNewCrocodileRT(scene, bounds, level, crocodiles, timer);
        }, nextCrocodileInMS);
    };
    CrocodileCreator.prototype.randomIntFromInterval = function (min, max) {
        var t = Math.floor(Math.random() * (max - min + 1) + min);
        return t;
    };
    return CrocodileCreator;
}());
exports.default = CrocodileCreator;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Resources_1 = __webpack_require__(4);
var Crocodile = /** @class */ (function (_super) {
    __extends(Crocodile, _super);
    function Crocodile(bootstrap, x, y, speedX, speedY) {
        var _this = _super.call(this, x, y, Crocodile.size.w, Crocodile.size.h, ex.Color.Green) || this;
        _this.bootstrap = bootstrap;
        // Anchor
        _this.anchor.setTo(0.5, 0.5); // set anchor to the center of the right edge (?)
        _this.collisionArea.body.useBoxCollision();
        _this.collisionType = ex.CollisionType.Active;
        _this.vel = new ex.Vector(speedX, speedY);
        // On collision check if Level2Player and trapp if true
        _this.on("precollision", _this.onPrecollision);
        // Sprite drawings
        var spriteSheet = new ex.SpriteSheet(Resources_1.default.level2.crocodile, 1, 8, Crocodile.size.w, Crocodile.size.h);
        var animation = spriteSheet.getAnimationForAll(bootstrap.engine, 100);
        _this.addDrawing("idle", animation);
        return _this;
    }
    // raised every frame while colliding
    Crocodile.prototype.onPrecollision = function (ev) {
        // Trap player if collided
        if (ev.other.constructor.name === "Level2Player") {
            var player = ev.other;
            player.die("You got eaten by a crocodile!");
        }
    };
    Crocodile.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta);
    };
    Crocodile.size = { w: 202, h: 50 };
    Crocodile.speedY = -30;
    Crocodile.speedX = 10;
    return Crocodile;
}(ex.Actor));
exports.default = Crocodile;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BasePlayer_1 = __webpack_require__(6);
var MikelsonAnimation_1 = __webpack_require__(14);
var Level3_1 = __webpack_require__(60);
var Ground_1 = __webpack_require__(19);
var MikelsonParts_1 = __webpack_require__(12);
var states = {
    default: MikelsonAnimation_1.states.walkRight,
    slow: MikelsonAnimation_1.states.walkSlowRight,
    fast: MikelsonAnimation_1.states.walkFastRight,
    jump: MikelsonAnimation_1.states.jumpRight,
    duck: MikelsonAnimation_1.states.duckRight
};
var Level3Player = /** @class */ (function (_super) {
    __extends(Level3Player, _super);
    function Level3Player(x, y, controlSet, state, isFirst) {
        var _this = _super.call(this, x, y, controlSet, state) || this;
        _this.ducked = false;
        _this.jumpFlag = false;
        _this.jumpingVelocity = -600;
        _this.speedAcc = 300;
        _this.speedNormal = 200;
        _this.speedDec = 100;
        _this.speedDucked = 50;
        _this.animationState = states.default;
        _this.$a = controlSet === BasePlayer_1.controlSets.controls1 ? "first p" : "second p";
        _this.anchor.setTo(0.5, 1); // set anchor to the center of the bottom edge
        _this.collisionArea.body.useBoxCollision();
        _this.minX = Level3_1.default.levelBounds.left + BasePlayer_1.default.size.w / 2;
        _this.maxX = Level3_1.default.levelBounds.right - BasePlayer_1.default.size.w / 2;
        _this.speed = _this.speedNormal;
        _this.posYold = _this.pos.y;
        if (isFirst)
            _this.animation = MikelsonAnimation_1.playerAnimationFactory.attachTo(_this);
        else
            _this.animation = MikelsonAnimation_1.brotherAnimationFactory.attachTo(_this);
        _this.animation.changeState("walk-right");
        return _this;
    }
    Level3Player.prototype.update = function (engine, delta) {
        var _this = this;
        _super.prototype.update.call(this, engine, delta);
        var stateChanged = false;
        var updateState = function (animationState) {
            stateChanged = true;
            _this.animationState = animationState;
        };
        // change movement if not currently in the air
        if (this.isGround()) {
            // just landed
            var groundLevel = this.scene.engine.getWorldBounds().bottom - Ground_1.default.height;
            if (this.animationState === states.jump && this.posYold < (groundLevel - 5)) {
                console.log("just landed");
                updateState(states.default);
            }
            if (engine.input.keyboard.wasPressed(this.controls.up) && this.animationState !== states.jump) {
                this.jump();
                this.ducked = false;
                updateState(states.jump);
            }
            if (this.animationState !== states.jump) {
                if (engine.input.keyboard.isHeld(this.controls.down)) {
                    this.duck();
                    updateState(states.duck);
                }
                if (engine.input.keyboard.wasReleased(this.controls.down)) {
                    this.unDuck();
                    updateState(states.default);
                }
            }
            if (this.animationState !== states.jump && this.animationState !== states.duck) {
                // X movement
                if (engine.input.keyboard.isHeld(this.controls.left)) {
                    this.speed = this.speedDec;
                    updateState(states.slow);
                }
                if (engine.input.keyboard.isHeld(this.controls.right)) {
                    this.speed = this.speedAcc;
                    updateState(states.fast);
                }
                if (engine.input.keyboard.wasReleased(this.controls.left)) {
                    if (engine.input.keyboard.isHeld(this.controls.right)) {
                        this.speed = this.speedAcc;
                        updateState(states.fast);
                    }
                    else {
                        this.speed = this.speedNormal;
                        updateState(states.default);
                    }
                }
                if (engine.input.keyboard.wasReleased(this.controls.right)) {
                    if (engine.input.keyboard.isHeld(this.controls.left)) {
                        this.speed = this.speedDec;
                        updateState(states.slow);
                    }
                    else {
                        this.speed = this.speedNormal;
                        updateState(states.default);
                    }
                }
                if (engine.input.keyboard.isHeld(this.controls.left) && engine.input.keyboard.isHeld(this.controls.right)) {
                    this.speed = this.speedNormal;
                    updateState(states.default);
                }
            }
        }
        if (!this.ducked) {
            this.pos.x += this.speed * delta / 1000;
        }
        else {
            this.pos.x += this.speedDucked * delta / 1000;
        }
        if (this.getWorldPos().x > 4950) {
            this.win("won level3 by reaching the end");
        }
        this.posYold = this.pos.y;
        if (stateChanged)
            this.animation.changeState(this.animationState);
    };
    Level3Player.prototype.jump = function () {
        this.vel.y = this.jumpingVelocity;
    };
    Level3Player.prototype.duck = function () {
        if (this.ducked)
            return; // already ducked
        this.ducked = true;
        this.setHeight(MikelsonParts_1.modelDuckSize.h);
        this.collisionArea.body.useBoxCollision();
    };
    Level3Player.prototype.unDuck = function () {
        if (!this.ducked)
            return; // already unducked
        this.ducked = false;
        this.setHeight(MikelsonParts_1.modelSize.h);
        this.collisionArea.body.useBoxCollision();
    };
    return Level3Player;
}(BasePlayer_1.default));
exports.default = Level3Player;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Rock_1 = __webpack_require__(152);
// class for cyclically creating new rocks and adding them to the scene, in front of the player
var RockCreator = /** @class */ (function () {
    function RockCreator(engine, scene, bounds, level, rocks) {
        this.timer = [-1]; // to be passed by reference
        this.engine = engine;
        this.scene = scene;
        this.bounds = bounds;
        this.level = level;
        this.rocks = rocks;
    }
    RockCreator.prototype.start = function () {
        console.log("rockCreator started! (Level2 - RockCreator - start())");
        // start timer scheduling new rock creations
        var that = this;
        this.timer[0] = setTimeout(function () {
            that.createNewRockRT(that.scene, that.bounds, that.level, that.rocks, that.timer);
        }, 1500);
    };
    RockCreator.prototype.stop = function () {
        // cancel timer // kill rocks ? 
        console.log("rockCreator stopped! (Level2 - RockCreator - stop())");
        if (this.timer[0] !== -1) {
            clearInterval(this.timer[0]);
        }
    };
    RockCreator.prototype.createNewRockRT = function (scene, bounds, level, rocks, timer) {
        console.log("creating new rock... (Level2 - RockCreator - createNewRockRT()");
        // determining type of the next rock
        var rock;
        if (this.randomIntFromInterval(1, 2) > 1) {
            // big rock
            rock = new Rock_1.default(level.frontPlayer.x + 800, 500, 50, -250, 1000, -550, Rock_1.Rocktypes.big, this.level.pubPlayers); // big rock bouncing towards the player		
        }
        else {
            // small rock
            rock = new Rock_1.default(level.frontPlayer.x + 800, 500, 20, -250, 1000, -250, Rock_1.Rocktypes.small, this.level.pubPlayers); // small rock "rolling" on the ground
        }
        // create new rock
        var newRockIndex = rocks.push(rock) - 1;
        scene.add(rocks[newRockIndex]);
        // create new timeout for next rock
        var nextRockInMS = this.randomIntFromInterval(1500, 2000); // (100000, 200000); // (1000, 1500);
        var that = this;
        timer[0] = setTimeout(function () {
            that.createNewRockRT(scene, bounds, level, rocks, timer);
        }, nextRockInMS);
    };
    RockCreator.prototype.randomIntFromInterval = function (min, max) {
        var t = Math.floor(Math.random() * (max - min + 1) + min);
        return t;
    };
    return RockCreator;
}());
exports.default = RockCreator;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var BasePlayer_1 = __webpack_require__(6);
var Resources_1 = __webpack_require__(4);
exports.Rocktypes = { "small": 1, "big": 2 };
var Rock = /** @class */ (function (_super) {
    __extends(Rock, _super);
    function Rock(x, y, d, speedX, accY, yVelBounce, typ, players) {
        var _this = _super.call(this, x, y, d, d, ex.Color.White) || this;
        _this.rotationTime = 0;
        _this.players = players;
        _this.d = d;
        _this.anchor.setTo(0.5, 0.5); // set anchor to the center
        _this.collisionArea.body.useBoxCollision();
        _this.collisionType = ex.CollisionType.Passive;
        _this.acc.y = accY;
        _this.vel.x = speedX;
        _this.numberOfRotationsPerSecond = speedX / (2 * Math.PI * d / Math.sqrt(2));
        _this.yVelBounce = yVelBounce;
        _this.typ = typ;
        if (typ === exports.Rocktypes.small) {
            _this.sprite = Resources_1.default.level3.smallRock.asSprite();
        }
        else {
            _this.sprite = Resources_1.default.level3.bigRock.asSprite();
        }
        _this.sprite.anchor.setTo(0.5, 0.5);
        // On collision check if Player and trap if true
        _this.on("precollision", _this.onPrecollision);
        return _this;
    }
    // raised every frame while colliding
    Rock.prototype.onPrecollision = function (ev) {
        // console.log("precollision event raised");
        if (ev.other.constructor.name === "Ground") {
            this.vel.y = this.yVelBounce;
            // alternatively more random bouncing for big rocks?
            if (this.typ === exports.Rocktypes.big) {
                this.vel.y = this.yVelBounce * (this.randomIntFromInterval(90, 110) / 100);
            }
        }
        else {
            if (ev.other instanceof BasePlayer_1.default) {
                var player = ev.other;
                player.die("You got hit by the rock!");
            }
        }
    };
    Rock.prototype.draw = function (ctx, delta) {
        this.rotationTime += delta / 1000;
        this.rotation = ((this.rotationTime * this.numberOfRotationsPerSecond) % 1) * 2 * Math.PI;
        this.sprite.rotation = this.rotation;
        this.sprite.draw(ctx, this.getCenter().x, this.getCenter().y);
    };
    Rock.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta);
        for (var _i = 0, _a = this.players; _i < _a.length; _i++) {
            var player = _a[_i];
            if (Math.abs(player.getWorldPos().x - this.getWorldPos().x) < 5 && !player.dead) {
                if (this.typ == exports.Rocktypes.big)
                    player.state.score += 50;
                else
                    player.state.score += 25;
            }
        }
        // TODO: kill when far behind player ?
    };
    Rock.prototype.randomIntFromInterval = function (min, max) {
        var t = Math.floor(Math.random() * (max - min + 1) + min);
        return t;
    };
    return Rock;
}(ex.Actor));
exports.default = Rock;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var BasePlayer_1 = __webpack_require__(6);
var EslanAnimation_1 = __webpack_require__(154);
var Cannibal = /** @class */ (function (_super) {
    __extends(Cannibal, _super);
    function Cannibal(x, y, w, h, speedX, minX, maxX, players) {
        var _this = _super.call(this, x, y, w, h, ex.Color.White) || this;
        _this.minX = minX;
        _this.maxX = maxX;
        _this.speedX = speedX;
        _this.players = players;
        // Anchor
        _this.anchor.setTo(0.5, 0.5); // set anchor to the center
        _this.collisionArea.body.useBoxCollision();
        _this.collisionType = ex.CollisionType.Passive;
        _this.animation = EslanAnimation_1.eslanAnimationFactory.attachTo(_this);
        if (_this.randomIntFromInterval(1, 2) > 1) {
            _this.vel.x = speedX;
            _this.animation.changeState("walk-right");
        }
        else {
            _this.vel.x = -speedX;
            _this.animation.changeState("walk-left");
        }
        // On collision check if Player and kill if true
        _this.on("precollision", _this.onPrecollision);
        return _this;
    }
    // raised every frame while colliding
    Cannibal.prototype.onPrecollision = function (ev) {
        if (ev.other instanceof BasePlayer_1.default) {
            var player = ev.other;
            player.die("You got hit by a cannibal!");
        }
    };
    Cannibal.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta);
        // check for minX/maxX
        if (this.pos.x - this.getWidth() < this.minX) {
            this.vel.x = this.speedX;
            this.animation.changeState("walk-right");
        }
        if (this.pos.x + this.getWidth() > this.maxX) {
            this.vel.x = -this.speedX;
            this.animation.changeState("walk-left");
        }
        for (var _i = 0, _a = this.players; _i < _a.length; _i++) {
            var player = _a[_i];
            if (Math.abs(player.getWorldPos().x - this.getWorldPos().x) < 5 && !player.dead) {
                player.state.score += 100;
            }
        }
    };
    Cannibal.prototype.randomIntFromInterval = function (min, max) {
        var t = Math.floor(Math.random() * (max - min + 1) + min);
        return t;
    };
    return Cannibal;
}(ex.Actor));
exports.default = Cannibal;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DrawAnimationFactory_1 = __webpack_require__(27);
var EslanParts_1 = __webpack_require__(36);
exports.eslanAnimationTypes = [
    "idle-right",
    "idle-left",
    "walk-right",
    "walk-left",
    "jump-right",
    "jump-left",
    "duck-right",
    "duck-left",
    "walk-fast-right",
    "walk-fast-left",
    "walk-slow-right",
    "walk-slow-left"
];
var _states = {
    idleLeft: "idle-left",
    walkRight: "walk-right",
    walkLeft: "walk-left",
    jumpRight: "jump-right",
    jumpLeft: "jump-left",
    duckRight: "duck-right",
    duckLeft: "duck-left",
    walkFastRight: "walk-fast-right",
    walkFastLeft: "walk-fast-left",
    walkSlowRight: "walk-slow-right",
    walkSlowLeft: "walk-slow-left",
};
exports.states = _states;
var beforeDrawFactory = function (bodyPartRight, bodyPartLeft) {
    var bpr = EslanParts_1.bodyParts[bodyPartRight];
    var bpl = EslanParts_1.bodyParts[bodyPartLeft];
    return function (ctx, _, position, state) {
        if (state.includes("right"))
            return { translateX: bpr.modelLocation.x, translateY: bpr.modelLocation.y };
        else
            return { translateX: bpl.modelLocation.x, translateY: bpl.modelLocation.y };
    };
};
var drawBaseFactory = function (bodyPartRight, bodyPartLeft) {
    var spr = EslanParts_1.sprites[bodyPartRight];
    var spl = EslanParts_1.sprites[bodyPartLeft];
    var bpr = EslanParts_1.bodyParts[bodyPartRight].anchor;
    var bpl = EslanParts_1.bodyParts[bodyPartLeft].anchor;
    return function (ctx, _, __, state) {
        if (state.includes("right"))
            spr.draw(ctx, -bpr.x, -bpr.y);
        else
            spl.draw(ctx, -bpl.x, -bpl.y);
    };
};
var baseDataExtender = function (irlData) {
    if (irlData.baseStates)
        Object.entries(irlData.baseStates).forEach(function (_a) {
            var key = _a[0], state = _a[1];
            irlData.states[key + "-right"] = state;
            irlData.states[key + "-left"] = state;
        });
    return irlData;
};
var selectedState = "walk-right";
var armFront = {
    selectedState: selectedState,
    drawBase: drawBaseFactory("armRight", "armLeft"),
    beforeDraw: beforeDrawFactory("armRight", "armLeft"),
    states: {},
    baseStates: {
        idle: {
            duration: 1000,
            start: { rotate: -0.1 },
            end: { rotate: 0.1 },
            transitionDuration: 200
        },
        walk: {
            duration: 400,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 250,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 600,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        duck: {
            duration: 1000,
            start: { rotate: -0.1, translateY: 20 },
            end: { rotate: 0.1, translateY: 20 },
            transitionDuration: 200
        }
    }
};
var armBack = {
    selectedState: selectedState,
    drawBase: drawBaseFactory("armRight", "armLeft"),
    beforeDraw: beforeDrawFactory("armRight", "armLeft"),
    states: {
        "jump-right": {
            duration: 800,
            start: { rotate: -1.9, translateX: 5 },
            end: { rotate: -2.2, translateX: 5 },
            transitionDuration: 100
        },
        "jump-left": {
            duration: 800,
            start: { rotate: 1.9, translateX: -5 },
            end: { rotate: 2.2, translateX: -5 },
            transitionDuration: 100
        },
    },
    baseStates: {
        idle: {
            duration: 1000,
            start: { rotate: 0.1 },
            end: { rotate: -0.1 },
            transitionDuration: 200
        },
        walk: {
            duration: 400,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 250,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 600,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        duck: {
            duration: 1000,
            start: { rotate: 0.1, translateY: 20 },
            end: { rotate: -0.1, translateY: 20 },
            transitionDuration: 200
        }
    }
};
var legFront = {
    selectedState: selectedState,
    drawBase: drawBaseFactory("legRight", "legLeft"),
    beforeDraw: beforeDrawFactory("legRight", "legLeft"),
    states: {
        "jump-right": {
            duration: 500,
            start: { rotate: 0.4, translateX: -5 },
            end: { rotate: 0.55, translateX: -5 },
            transitionDuration: 200
        },
        "jump-left": {
            duration: 500,
            start: { rotate: -0.4, translateX: 5 },
            end: { rotate: -0.55, translateX: 5 },
            transitionDuration: 200
        }
    },
    baseStates: {
        idle: {
            transitionDuration: 200,
            start: {},
            end: {},
            duration: 1000
        },
        walk: {
            duration: 400,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 250,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 600,
            start: { rotate: 0.3 },
            end: { rotate: -0.3 },
            transitionDuration: 200
        },
        duck: {
            duration: 1000,
            start: { rotate: 0 },
            end: { rotate: 0 },
            transitionDuration: 200
        }
    }
};
var legBack = {
    selectedState: selectedState,
    drawBase: drawBaseFactory("legRight", "legLeft"),
    beforeDraw: beforeDrawFactory("legRight", "legLeft"),
    states: {
        "jump-right": {
            duration: 500,
            start: { rotate: -0.15, translateX: -5 },
            end: { rotate: -0.3, translateX: -5 },
            transitionDuration: 200
        },
        "jump-left": {
            duration: 500,
            start: { rotate: 0.15, translateX: 5 },
            end: { rotate: 0.3, translateX: 5 },
            transitionDuration: 200
        }
    },
    baseStates: {
        idle: {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        walk: {
            duration: 400,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 250,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 600,
            start: { rotate: -0.3 },
            end: { rotate: 0.3 },
            transitionDuration: 200
        },
        duck: {
            duration: 1000,
            start: { rotate: 0 },
            end: { rotate: 0 },
            transitionDuration: 200
        }
    }
};
var torso = {
    selectedState: selectedState,
    beforeDraw: function () {
        return { translateX: EslanParts_1.bodyParts.torso.modelLocation.x, translateY: EslanParts_1.bodyParts.torso.modelLocation.y };
    },
    drawBase: function (ctx) {
        var _a = EslanParts_1.bodyParts.torso.anchor, x = _a.x, y = _a.y;
        EslanParts_1.sprites.torso.draw(ctx, -x, -y);
    },
    states: {
        "jump-right": {
            duration: 1000,
            start: { rotate: 0.2 },
            end: { rotate: 0.2 },
            transitionDuration: 200
        },
        "jump-left": {
            duration: 1000,
            start: { rotate: -0.2 },
            end: { rotate: -0.2 },
            transitionDuration: 200
        }
    },
    baseStates: {
        idle: {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        walk: {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 1000,
            start: {},
            end: {},
            transitionDuration: 200
        },
        duck: {
            duration: 1000,
            start: { rotate: 0, translateY: 18 },
            end: { rotate: 0, translateY: 18 },
            transitionDuration: 200
        }
    }
};
var head = {
    selectedState: selectedState,
    beforeDraw: function (_, __, ___, state) {
        var _a = EslanParts_1.bodyParts.headRight.modelLocation, xr = _a.x, yr = _a.y;
        var _b = EslanParts_1.bodyParts.headLeft.modelLocation, xl = _b.x, yl = _b.y;
        if (state.includes("right"))
            return { translateX: xr, translateY: yr };
        else
            return { translateX: xl, translateY: yl };
    },
    drawBase: function (ctx, _, __, state) {
        var _a = EslanParts_1.bodyParts.headRight.anchor, xr = _a.x, yr = _a.y;
        var _b = EslanParts_1.bodyParts.headLeft.anchor, xl = _b.x, yl = _b.y;
        if (state.includes("right"))
            EslanParts_1.sprites.headRight.draw(ctx, -xr, -yr);
        else
            EslanParts_1.sprites.headLeft.draw(ctx, -xl, -yl);
    },
    states: {
        "jump-right": {
            duration: 500,
            start: { rotate: 0.1, translateX: 5 },
            end: { rotate: -0.1, translateX: 5 },
            transitionDuration: 200
        },
        "jump-left": {
            duration: 500,
            start: { rotate: -0.1, translateX: -5 },
            end: { rotate: 0.1, translateX: -5 },
            transitionDuration: 200
        }
    },
    baseStates: {
        idle: {
            duration: 1500,
            start: { rotate: 0.05 },
            end: { rotate: -0.05 },
            transitionDuration: 200
        },
        walk: {
            duration: 600,
            start: { rotate: -0.2 },
            end: { rotate: 0.2 },
            transitionDuration: 200
        },
        "walk-fast": {
            duration: 400,
            start: { rotate: -0.2 },
            end: { rotate: 0.2 },
            transitionDuration: 200
        },
        "walk-slow": {
            duration: 800,
            start: { rotate: -0.2 },
            end: { rotate: 0.2 },
            transitionDuration: 200
        },
        duck: {
            duration: 900,
            start: { rotate: -0.1, translateY: 25 },
            end: { rotate: 0.1, translateY: 25 },
            transitionDuration: 200
        }
    }
};
var allData = [
    legBack,
    armBack,
    torso,
    head,
    legFront,
    armFront,
];
var animationProviders = allData
    .map(baseDataExtender)
    .map(function (t) { return DrawAnimationFactory_1.createTransformDrawSetProvider(t); });
exports.eslanAnimationFactory = new DrawAnimationFactory_1.TransformDrawAnimationFactory(animationProviders);


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var PrincessParts_1 = __webpack_require__(63);
var PrincessAnimation_1 = __webpack_require__(156);
var Level4Player_1 = __webpack_require__(62);
var Princess = /** @class */ (function (_super) {
    __extends(Princess, _super);
    function Princess(vine) {
        var _this = _super.call(this, 0, 0, 50, 50, ex.Color.Chartreuse) || this;
        _this.hasWinner = false;
        _this.anchor.setTo(0.5, 0.5);
        _this.vine = vine;
        _this.vLast = _this.vine.getAllParts()[_this.vine.getAllParts().length - 1];
        _this.collisionType = ex.CollisionType.Passive;
        PrincessAnimation_1.princessAnimationFactory.attachTo(_this);
        _this.on("precollision", _this.onPrecollision);
        return _this;
    }
    Princess.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta);
        this.x = this.vLast.x;
        this.y = this.vLast.y;
        this.rotation = this.vLast.rotation;
    };
    Princess.prototype.onPrecollision = function (ev) {
        if (ev.other instanceof Level4Player_1.default) {
            var player = ev.other;
            player.state.score += 200;
            player.state.score += player.state.lives * 100;
            if (!this.hasWinner) {
                this.hasWinner = true;
                player.declareWinner();
            }
            player.win("you won by saving the princess");
        }
    };
    Princess.size = PrincessParts_1.modelSize;
    return Princess;
}(ex.Actor));
exports.default = Princess;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DrawAnimationFactory_1 = __webpack_require__(27);
var PrincessParts_1 = __webpack_require__(63);
var drawBaseFactory = function (part) { return function (ctx) {
    var _a = PrincessParts_1.bodyParts[part].anchor, x = _a.x, y = _a.y;
    PrincessParts_1.sprites[part].draw(ctx, -x, -y);
}; };
var beforeDrawFactory = function (part) { return function (ctx, _, pos) { return ({
    translateX: PrincessParts_1.bodyParts[part].modelLocation.x,
    translateY: PrincessParts_1.bodyParts[part].modelLocation.y
}); }; };
var selectedState = "idle";
var rad = function (deg) { return deg / 180 * Math.PI; };
var armRight = {
    selectedState: selectedState,
    drawBase: drawBaseFactory("armRight"),
    beforeDraw: beforeDrawFactory("armRight"),
    states: {
        idle: {
            duration: 200,
            start: { rotate: rad(-100) },
            end: { rotate: rad(-140) }
        }
    }
};
var armLeft = {
    selectedState: selectedState,
    drawBase: drawBaseFactory("armLeft"),
    beforeDraw: beforeDrawFactory("armLeft"),
    states: {
        idle: {
            duration: 200,
            start: { rotate: rad(100) },
            end: { rotate: rad(140) }
        }
    }
};
var legRight = {
    selectedState: selectedState,
    drawBase: drawBaseFactory("legRight"),
    beforeDraw: beforeDrawFactory("legRight"),
    states: {
        idle: {
            duration: 400,
            start: { rotate: rad(-10) },
            end: { rotate: 0 }
        }
    }
};
var legLeft = {
    selectedState: selectedState,
    drawBase: drawBaseFactory("legLeft"),
    beforeDraw: beforeDrawFactory("legLeft"),
    states: {
        idle: {
            duration: 400,
            start: { rotate: rad(10) },
            end: { rotate: 0 }
        }
    }
};
var torso = {
    selectedState: selectedState,
    drawBase: drawBaseFactory("torso"),
    beforeDraw: beforeDrawFactory("torso"),
    states: {
        idle: {
            start: {},
            end: {}
        }
    }
};
var head = {
    selectedState: selectedState,
    drawBase: drawBaseFactory("head"),
    beforeDraw: beforeDrawFactory("head"),
    states: {
        idle: {
            duration: 300,
            start: { rotate: rad(10) },
            end: { rotate: rad(-10) }
        }
    }
};
var allData = [
    torso,
    head,
    legLeft,
    legRight,
    armLeft,
    armRight,
];
var animationProviders = allData.map(function (t) { return DrawAnimationFactory_1.createTransformDrawSetProvider(t); });
exports.princessAnimationFactory = new DrawAnimationFactory_1.TransformDrawAnimationFactory(animationProviders);


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(0);
var Resources_1 = __webpack_require__(4);
var Pot = /** @class */ (function (_super) {
    __extends(Pot, _super);
    function Pot(x, y, w, l) {
        var _this = _super.call(this, x, y, w, l, ex.Color.Black) || this;
        _this.anchor.setTo(0.5, 1);
        _this.y = y;
        _this.collisionType = ex.CollisionType.PreventCollision;
        _this.sprite = Resources_1.default.level4.pot.asSprite();
        _this.sprite.anchor.setTo(0.5, 1);
        return _this;
    }
    Pot.prototype.draw = function (ctx, delta) {
        this.sprite.draw(ctx, this.getCenter().x, this.getBottom());
    };
    return Pot;
}(ex.Actor));
exports.default = Pot;


/***/ })
/******/ ]);