!function(g){function I(A){if(C[A])return C[A].exports;var c=C[A]={i:A,l:!1,exports:{}};return g[A].call(c.exports,c,c.exports,I),c.l=!0,c.exports}var C={};I.m=g,I.c=C,I.d=function(g,C,A){I.o(g,C)||Object.defineProperty(g,C,{configurable:!1,enumerable:!0,get:A})},I.n=function(g){var C=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(C,"a",C),C},I.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},I.p="",I(I.s=57)}([,function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/*! excalibur - v0.14.0 - 2017-12-02\r\n* https://github.com/excaliburjs/Excalibur\r\n* Copyright (c) 2017 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>; Licensed BSD-2-Clause\r\n* @preserve */\r\n(function (root, factory) {\r\n    if (true) {\r\n        // AMD. Register as an anonymous module.\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function (b) {\r\n            return (root.ex = factory(b));\r\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    } else if (typeof module === \'object\' && module.exports) {\r\n        // Node. Does not work with strict CommonJS, but\r\n        // only CommonJS-like environments that support module.exports,\r\n        // like Node.\r\n        module.exports = factory();\r\n    } else {\r\n        // Browser globals\r\n        root.ex = factory();\r\n    }\r\n}(this, function () {\r\n    //almond, and your modules will be inlined here\r\n/**\r\n * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.\r\n * Released under MIT license, http://github.com/requirejs/almond/LICENSE\r\n */\r\n//Going sloppy to avoid \'use strict\' string cost, but strict practices should\r\n//be followed.\r\n/*global setTimeout: false */\r\n\r\nvar requirejs, require, define;\r\n(function (undef) {\r\n    var main, req, makeMap, handlers,\r\n        defined = {},\r\n        waiting = {},\r\n        config = {},\r\n        defining = {},\r\n        hasOwn = Object.prototype.hasOwnProperty,\r\n        aps = [].slice,\r\n        jsSuffixRegExp = /\\.js$/;\r\n\r\n    function hasProp(obj, prop) {\r\n        return hasOwn.call(obj, prop);\r\n    }\r\n\r\n    /**\r\n     * Given a relative module name, like ./something, normalize it to\r\n     * a real name that can be mapped to a path.\r\n     * @param {String} name the relative name\r\n     * @param {String} baseName a real name that the name arg is relative\r\n     * to.\r\n     * @returns {String} normalized name\r\n     */\r\n    function normalize(name, baseName) {\r\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\r\n            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,\r\n            baseParts = baseName && baseName.split("/"),\r\n            map = config.map,\r\n            starMap = (map && map[\'*\']) || {};\r\n\r\n        //Adjust any relative paths.\r\n        if (name) {\r\n            name = name.split(\'/\');\r\n            lastIndex = name.length - 1;\r\n\r\n            // If wanting node ID compatibility, strip .js from end\r\n            // of IDs. Have to do this here, and not in nameToUrl\r\n            // because node allows either .js or non .js to map\r\n            // to same file.\r\n            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\r\n                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, \'\');\r\n            }\r\n\r\n            // Starts with a \'.\' so need the baseName\r\n            if (name[0].charAt(0) === \'.\' && baseParts) {\r\n                //Convert baseName to array, and lop off the last part,\r\n                //so that . matches that \'directory\' and not name of the baseName\'s\r\n                //module. For instance, baseName of \'one/two/three\', maps to\r\n                //\'one/two/three.js\', but we want the directory, \'one/two\' for\r\n                //this normalization.\r\n                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\r\n                name = normalizedBaseParts.concat(name);\r\n            }\r\n\r\n            //start trimDots\r\n            for (i = 0; i < name.length; i++) {\r\n                part = name[i];\r\n                if (part === \'.\') {\r\n                    name.splice(i, 1);\r\n                    i -= 1;\r\n                } else if (part === \'..\') {\r\n                    // If at the start, or previous value is still ..,\r\n                    // keep them so that when converted to a path it may\r\n                    // still work when converted to a path, even though\r\n                    // as an ID it is less than ideal. In larger point\r\n                    // releases, may be better to just kick out an error.\r\n                    if (i === 0 || (i === 1 && name[2] === \'..\') || name[i - 1] === \'..\') {\r\n                        continue;\r\n                    } else if (i > 0) {\r\n                        name.splice(i - 1, 2);\r\n                        i -= 2;\r\n                    }\r\n                }\r\n            }\r\n            //end trimDots\r\n\r\n            name = name.join(\'/\');\r\n        }\r\n\r\n        //Apply map config if available.\r\n        if ((baseParts || starMap) && map) {\r\n            nameParts = name.split(\'/\');\r\n\r\n            for (i = nameParts.length; i > 0; i -= 1) {\r\n                nameSegment = nameParts.slice(0, i).join("/");\r\n\r\n                if (baseParts) {\r\n                    //Find the longest baseName segment match in the config.\r\n                    //So, do joins on the biggest to smallest lengths of baseParts.\r\n                    for (j = baseParts.length; j > 0; j -= 1) {\r\n                        mapValue = map[baseParts.slice(0, j).join(\'/\')];\r\n\r\n                        //baseName segment has  config, find if it has one for\r\n                        //this name.\r\n                        if (mapValue) {\r\n                            mapValue = mapValue[nameSegment];\r\n                            if (mapValue) {\r\n                                //Match, update name to the new value.\r\n                                foundMap = mapValue;\r\n                                foundI = i;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (foundMap) {\r\n                    break;\r\n                }\r\n\r\n                //Check for a star map match, but just hold on to it,\r\n                //if there is a shorter segment match later in a matching\r\n                //config, then favor over this star map.\r\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\r\n                    foundStarMap = starMap[nameSegment];\r\n                    starI = i;\r\n                }\r\n            }\r\n\r\n            if (!foundMap && foundStarMap) {\r\n                foundMap = foundStarMap;\r\n                foundI = starI;\r\n            }\r\n\r\n            if (foundMap) {\r\n                nameParts.splice(0, foundI, foundMap);\r\n                name = nameParts.join(\'/\');\r\n            }\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n    function makeRequire(relName, forceSync) {\r\n        return function () {\r\n            //A version of a require function that passes a moduleName\r\n            //value for items that may need to\r\n            //look up paths relative to the moduleName\r\n            var args = aps.call(arguments, 0);\r\n\r\n            //If first arg is not require(\'string\'), and there is only\r\n            //one arg, it is the array form without a callback. Insert\r\n            //a null so that the following concat is correct.\r\n            if (typeof args[0] !== \'string\' && args.length === 1) {\r\n                args.push(null);\r\n            }\r\n            return req.apply(undef, args.concat([relName, forceSync]));\r\n        };\r\n    }\r\n\r\n    function makeNormalize(relName) {\r\n        return function (name) {\r\n            return normalize(name, relName);\r\n        };\r\n    }\r\n\r\n    function makeLoad(depName) {\r\n        return function (value) {\r\n            defined[depName] = value;\r\n        };\r\n    }\r\n\r\n    function callDep(name) {\r\n        if (hasProp(waiting, name)) {\r\n            var args = waiting[name];\r\n            delete waiting[name];\r\n            defining[name] = true;\r\n            main.apply(undef, args);\r\n        }\r\n\r\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\r\n            throw new Error(\'No \' + name);\r\n        }\r\n        return defined[name];\r\n    }\r\n\r\n    //Turns a plugin!resource to [plugin, resource]\r\n    //with the plugin being undefined if the name\r\n    //did not have a plugin prefix.\r\n    function splitPrefix(name) {\r\n        var prefix,\r\n            index = name ? name.indexOf(\'!\') : -1;\r\n        if (index > -1) {\r\n            prefix = name.substring(0, index);\r\n            name = name.substring(index + 1, name.length);\r\n        }\r\n        return [prefix, name];\r\n    }\r\n\r\n    //Creates a parts array for a relName where first part is plugin ID,\r\n    //second part is resource ID. Assumes relName has already been normalized.\r\n    function makeRelParts(relName) {\r\n        return relName ? splitPrefix(relName) : [];\r\n    }\r\n\r\n    /**\r\n     * Makes a name map, normalizing the name, and using a plugin\r\n     * for normalization if necessary. Grabs a ref to plugin\r\n     * too, as an optimization.\r\n     */\r\n    makeMap = function (name, relParts) {\r\n        var plugin,\r\n            parts = splitPrefix(name),\r\n            prefix = parts[0],\r\n            relResourceName = relParts[1];\r\n\r\n        name = parts[1];\r\n\r\n        if (prefix) {\r\n            prefix = normalize(prefix, relResourceName);\r\n            plugin = callDep(prefix);\r\n        }\r\n\r\n        //Normalize according\r\n        if (prefix) {\r\n            if (plugin && plugin.normalize) {\r\n                name = plugin.normalize(name, makeNormalize(relResourceName));\r\n            } else {\r\n                name = normalize(name, relResourceName);\r\n            }\r\n        } else {\r\n            name = normalize(name, relResourceName);\r\n            parts = splitPrefix(name);\r\n            prefix = parts[0];\r\n            name = parts[1];\r\n            if (prefix) {\r\n                plugin = callDep(prefix);\r\n            }\r\n        }\r\n\r\n        //Using ridiculous property names for space reasons\r\n        return {\r\n            f: prefix ? prefix + \'!\' + name : name, //fullName\r\n            n: name,\r\n            pr: prefix,\r\n            p: plugin\r\n        };\r\n    };\r\n\r\n    function makeConfig(name) {\r\n        return function () {\r\n            return (config && config.config && config.config[name]) || {};\r\n        };\r\n    }\r\n\r\n    handlers = {\r\n        require: function (name) {\r\n            return makeRequire(name);\r\n        },\r\n        exports: function (name) {\r\n            var e = defined[name];\r\n            if (typeof e !== \'undefined\') {\r\n                return e;\r\n            } else {\r\n                return (defined[name] = {});\r\n            }\r\n        },\r\n        module: function (name) {\r\n            return {\r\n                id: name,\r\n                uri: \'\',\r\n                exports: defined[name],\r\n                config: makeConfig(name)\r\n            };\r\n        }\r\n    };\r\n\r\n    main = function (name, deps, callback, relName) {\r\n        var cjsModule, depName, ret, map, i, relParts,\r\n            args = [],\r\n            callbackType = typeof callback,\r\n            usingExports;\r\n\r\n        //Use name if no relName\r\n        relName = relName || name;\r\n        relParts = makeRelParts(relName);\r\n\r\n        //Call the callback to define the module, if necessary.\r\n        if (callbackType === \'undefined\' || callbackType === \'function\') {\r\n            //Pull out the defined dependencies and pass the ordered\r\n            //values to the callback.\r\n            //Default to [require, exports, module] if no deps\r\n            deps = !deps.length && callback.length ? [\'require\', \'exports\', \'module\'] : deps;\r\n            for (i = 0; i < deps.length; i += 1) {\r\n                map = makeMap(deps[i], relParts);\r\n                depName = map.f;\r\n\r\n                //Fast path CommonJS standard dependencies.\r\n                if (depName === "require") {\r\n                    args[i] = handlers.require(name);\r\n                } else if (depName === "exports") {\r\n                    //CommonJS module spec 1.1\r\n                    args[i] = handlers.exports(name);\r\n                    usingExports = true;\r\n                } else if (depName === "module") {\r\n                    //CommonJS module spec 1.1\r\n                    cjsModule = args[i] = handlers.module(name);\r\n                } else if (hasProp(defined, depName) ||\r\n                           hasProp(waiting, depName) ||\r\n                           hasProp(defining, depName)) {\r\n                    args[i] = callDep(depName);\r\n                } else if (map.p) {\r\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\r\n                    args[i] = defined[depName];\r\n                } else {\r\n                    throw new Error(name + \' missing \' + depName);\r\n                }\r\n            }\r\n\r\n            ret = callback ? callback.apply(defined[name], args) : undefined;\r\n\r\n            if (name) {\r\n                //If setting exports via "module" is in play,\r\n                //favor that over return value and exports. After that,\r\n                //favor a non-undefined return value over exports use.\r\n                if (cjsModule && cjsModule.exports !== undef &&\r\n                        cjsModule.exports !== defined[name]) {\r\n                    defined[name] = cjsModule.exports;\r\n                } else if (ret !== undef || !usingExports) {\r\n                    //Use the return value from the function.\r\n                    defined[name] = ret;\r\n                }\r\n            }\r\n        } else if (name) {\r\n            //May just be an object definition for the module. Only\r\n            //worry about defining if have a module name.\r\n            defined[name] = callback;\r\n        }\r\n    };\r\n\r\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\r\n        if (typeof deps === "string") {\r\n            if (handlers[deps]) {\r\n                //callback in this case is really relName\r\n                return handlers[deps](callback);\r\n            }\r\n            //Just return the module wanted. In this scenario, the\r\n            //deps arg is the module name, and second arg (if passed)\r\n            //is just the relName.\r\n            //Normalize module name, if it contains . or ..\r\n            return callDep(makeMap(deps, makeRelParts(callback)).f);\r\n        } else if (!deps.splice) {\r\n            //deps is a config object, not an array.\r\n            config = deps;\r\n            if (config.deps) {\r\n                req(config.deps, config.callback);\r\n            }\r\n            if (!callback) {\r\n                return;\r\n            }\r\n\r\n            if (callback.splice) {\r\n                //callback is an array, which means it is a dependency list.\r\n                //Adjust args if there are dependencies\r\n                deps = callback;\r\n                callback = relName;\r\n                relName = null;\r\n            } else {\r\n                deps = undef;\r\n            }\r\n        }\r\n\r\n        //Support require([\'a\'])\r\n        callback = callback || function () {};\r\n\r\n        //If relName is a function, it is an errback handler,\r\n        //so remove it.\r\n        if (typeof relName === \'function\') {\r\n            relName = forceSync;\r\n            forceSync = alt;\r\n        }\r\n\r\n        //Simulate async callback;\r\n        if (forceSync) {\r\n            main(undef, deps, callback, relName);\r\n        } else {\r\n            //Using a non-zero value because of concern for what old browsers\r\n            //do, and latest browsers "upgrade" to 4 if lower value is used:\r\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\r\n            //If want a value immediately, use require(\'id\') instead -- something\r\n            //that works in almond on the global level, but not guaranteed and\r\n            //unlikely to work in other AMD implementations.\r\n            setTimeout(function () {\r\n                main(undef, deps, callback, relName);\r\n            }, 4);\r\n        }\r\n\r\n        return req;\r\n    };\r\n\r\n    /**\r\n     * Just drops the config on the floor, but returns req in case\r\n     * the config return value is used.\r\n     */\r\n    req.config = function (cfg) {\r\n        return req(cfg);\r\n    };\r\n\r\n    /**\r\n     * Expose module registry for debugging and tooling\r\n     */\r\n    requirejs._defined = defined;\r\n\r\n    define = function (name, deps, callback) {\r\n        if (typeof name !== \'string\') {\r\n            throw new Error(\'See almond README: incorrect module build, no module name\');\r\n        }\r\n\r\n        //This module may not have dependencies\r\n        if (!deps.splice) {\r\n            //deps is not an array, so probably means\r\n            //an object literal or factory function for\r\n            //the value. Adjust args.\r\n            callback = deps;\r\n            deps = [];\r\n        }\r\n\r\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\r\n            waiting[name] = [name, deps, callback];\r\n        }\r\n    };\r\n\r\n    define.amd = {\r\n        jQuery: true\r\n    };\r\n}());\r\n/*! excalibur - v0.14.0 - 2017-12-02\r\n* https://github.com/excaliburjs/Excalibur\r\n* Copyright (c) 2017 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>; Licensed BSD-2-Clause\r\n* @preserve */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\ndefine("Actions/RotationType", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * An enum that describes the strategies that rotation actions can use\r\n     */\r\n    var RotationType;\r\n    (function (RotationType) {\r\n        /**\r\n         * Rotation via `ShortestPath` will use the smallest angle\r\n         * between the starting and ending points. This strategy is the default behavior.\r\n         */\r\n        RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";\r\n        /**\r\n         * Rotation via `LongestPath` will use the largest angle\r\n         * between the starting and ending points.\r\n         */\r\n        RotationType[RotationType["LongestPath"] = 1] = "LongestPath";\r\n        /**\r\n         * Rotation via `Clockwise` will travel in a clockwise direction,\r\n         * regardless of the starting and ending points.\r\n         */\r\n        RotationType[RotationType["Clockwise"] = 2] = "Clockwise";\r\n        /**\r\n         * Rotation via `CounterClockwise` will travel in a counterclockwise direction,\r\n         * regardless of the starting and ending points.\r\n         */\r\n        RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";\r\n    })(RotationType = exports.RotationType || (exports.RotationType = {}));\r\n});\r\ndefine("Algebra", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * A 2D vector on a plane.\r\n     */\r\n    var Vector = (function () {\r\n        /**\r\n         * @param x  X component of the Vector\r\n         * @param y  Y component of the Vector\r\n         */\r\n        function Vector(x, y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n        /**\r\n         * Returns a vector of unit length in the direction of the specified angle in Radians.\r\n         * @param angle The angle to generate the vector\r\n         */\r\n        Vector.fromAngle = function (angle) {\r\n            return new Vector(Math.cos(angle), Math.sin(angle));\r\n        };\r\n        /**\r\n         * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.\r\n         */\r\n        Vector.isValid = function (vec) {\r\n            if (vec === null || vec === undefined) {\r\n                return false;\r\n            }\r\n            if (isNaN(vec.x) || isNaN(vec.y)) {\r\n                return false;\r\n            }\r\n            if (vec.x === Infinity ||\r\n                vec.y === Infinity ||\r\n                vec.x === -Infinity ||\r\n                vec.y === Infinity) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        /**\r\n         * Calculates distance between two Vectors\r\n         * @param vec1\r\n         * @param vec2\r\n         */\r\n        Vector.distance = function (vec1, vec2) {\r\n            return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));\r\n        };\r\n        /**\r\n         * Sets the x and y components at once\r\n         */\r\n        Vector.prototype.setTo = function (x, y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        };\r\n        /**\r\n         * Compares this point against another and tests for equality\r\n         * @param point  The other point to compare to\r\n         */\r\n        Vector.prototype.equals = function (vector, tolerance) {\r\n            if (tolerance === void 0) { tolerance = .001; }\r\n            return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;\r\n        };\r\n        /**\r\n         * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].\r\n         * @param v  The other vector. Leave blank to use origin vector.\r\n         */\r\n        Vector.prototype.distance = function (v) {\r\n            if (!v) {\r\n                v = Vector.Zero;\r\n            }\r\n            return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));\r\n        };\r\n        /**\r\n         * The magnitude (size) of the Vector\r\n         */\r\n        Vector.prototype.magnitude = function () {\r\n            return this.distance();\r\n        };\r\n        /**\r\n         * Normalizes a vector to have a magnitude of 1.\r\n         */\r\n        Vector.prototype.normalize = function () {\r\n            var d = this.distance();\r\n            if (d > 0) {\r\n                return new Vector(this.x / d, this.y / d);\r\n            }\r\n            else {\r\n                return new Vector(0, 1);\r\n            }\r\n        };\r\n        /**\r\n         * Returns the average (midpoint) between the current point and the specified\r\n         */\r\n        Vector.prototype.average = function (vec) {\r\n            return this.add(vec).scale(.5);\r\n        };\r\n        /**\r\n         * Scales a vector\'s by a factor of size\r\n         * @param size  The factor to scale the magnitude by\r\n         */\r\n        Vector.prototype.scale = function (size) {\r\n            return new Vector(this.x * size, this.y * size);\r\n        };\r\n        /**\r\n         * Adds one vector to another\r\n         * @param v The vector to add\r\n         */\r\n        Vector.prototype.add = function (v) {\r\n            return new Vector(this.x + v.x, this.y + v.y);\r\n        };\r\n        /**\r\n         * Subtracts a vector from another, if you subract vector `B.sub(A)` the resulting vector points from A -> B\r\n         * @param v The vector to subtract\r\n         */\r\n        Vector.prototype.sub = function (v) {\r\n            return new Vector(this.x - v.x, this.y - v.y);\r\n        };\r\n        /**\r\n         * Adds one vector to this one modifying the original\r\n         * @param v The vector to add\r\n         */\r\n        Vector.prototype.addEqual = function (v) {\r\n            this.x += v.x;\r\n            this.y += v.y;\r\n            return this;\r\n        };\r\n        /**\r\n         * Subtracts a vector from this one modifying the original\r\n         * @parallel v The vector to subtract\r\n         */\r\n        Vector.prototype.subEqual = function (v) {\r\n            this.x -= v.x;\r\n            this.y -= v.y;\r\n            return this;\r\n        };\r\n        /**\r\n         * Scales this vector by a factor of size and modifies the original\r\n         */\r\n        Vector.prototype.scaleEqual = function (size) {\r\n            this.x *= size;\r\n            this.y *= size;\r\n            return this;\r\n        };\r\n        /**\r\n         * Performs a dot product with another vector\r\n         * @param v  The vector to dot\r\n         */\r\n        Vector.prototype.dot = function (v) {\r\n            return this.x * v.x + this.y * v.y;\r\n        };\r\n        Vector.prototype.cross = function (v) {\r\n            if (v instanceof Vector) {\r\n                return this.x * v.y - this.y * v.x;\r\n            }\r\n            else if (typeof v === \'number\') {\r\n                return new Vector(v * this.y, -v * this.x);\r\n            }\r\n        };\r\n        /**\r\n         * Returns the perpendicular vector to this one\r\n         */\r\n        Vector.prototype.perpendicular = function () {\r\n            return new Vector(this.y, -this.x);\r\n        };\r\n        /**\r\n         * Returns the normal vector to this one, same as the perpendicular of length 1\r\n         */\r\n        Vector.prototype.normal = function () {\r\n            return this.perpendicular().normalize();\r\n        };\r\n        /**\r\n         * Negate the current vector\r\n         */\r\n        Vector.prototype.negate = function () {\r\n            return this.scale(-1);\r\n        };\r\n        /**\r\n         * Returns the angle of this vector.\r\n         */\r\n        Vector.prototype.toAngle = function () {\r\n            return Math.atan2(this.y, this.x);\r\n        };\r\n        /**\r\n         * Rotates the current vector around a point by a certain number of\r\n         * degrees in radians\r\n         */\r\n        Vector.prototype.rotate = function (angle, anchor) {\r\n            if (!anchor) {\r\n                anchor = new Vector(0, 0);\r\n            }\r\n            var sinAngle = Math.sin(angle);\r\n            var cosAngle = Math.cos(angle);\r\n            var x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;\r\n            var y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;\r\n            return new Vector(x, y);\r\n        };\r\n        /**\r\n         * Creates new vector that has the same values as the previous.\r\n         */\r\n        Vector.prototype.clone = function () {\r\n            return new Vector(this.x, this.y);\r\n        };\r\n        /**\r\n         * Returns a string repesentation of the vector.\r\n         */\r\n        Vector.prototype.toString = function () {\r\n            return "(" + this.x + ", " + this.y + ")";\r\n        };\r\n        return Vector;\r\n    }());\r\n    /**\r\n     * A (0, 0) vector\r\n     */\r\n    Vector.Zero = new Vector(0, 0);\r\n    /**\r\n     * A (1, 1) vector\r\n     */\r\n    Vector.One = new Vector(1, 1);\r\n    /**\r\n     * A (0.5, 0.5) vector\r\n     */\r\n    Vector.Half = new Vector(0.5, 0.5);\r\n    /**\r\n     * A unit vector pointing up (0, -1)\r\n     */\r\n    Vector.Up = new Vector(0, -1);\r\n    /**\r\n     * A unit vector pointing down (0, 1)\r\n     */\r\n    Vector.Down = new Vector(0, 1);\r\n    /**\r\n     * A unit vector pointing left (-1, 0)\r\n     */\r\n    Vector.Left = new Vector(-1, 0);\r\n    /**\r\n     * A unit vector pointing right (1, 0)\r\n     */\r\n    Vector.Right = new Vector(1, 0);\r\n    exports.Vector = Vector;\r\n    /**\r\n     * A 2D ray that can be cast into the scene to do collision detection\r\n     */\r\n    var Ray = (function () {\r\n        /**\r\n         * @param pos The starting position for the ray\r\n         * @param dir The vector indicating the direction of the ray\r\n         */\r\n        function Ray(pos, dir) {\r\n            this.pos = pos;\r\n            this.dir = dir.normalize();\r\n        }\r\n        /**\r\n         * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.\r\n         * This number indicates the mathematical intersection time.\r\n         * @param line  The line to test\r\n         */\r\n        Ray.prototype.intersect = function (line) {\r\n            var numerator = line.begin.sub(this.pos);\r\n            // Test is line and ray are parallel and non intersecting\r\n            if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {\r\n                return -1;\r\n            }\r\n            // Lines are parallel\r\n            var divisor = (this.dir.cross(line.getSlope()));\r\n            if (divisor === 0) {\r\n                return -1;\r\n            }\r\n            var t = numerator.cross(line.getSlope()) / divisor;\r\n            if (t >= 0) {\r\n                var u = (numerator.cross(this.dir) / divisor) / line.getLength();\r\n                if (u >= 0 && u <= 1) {\r\n                    return t;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        /**\r\n         * Returns the point of intersection given the intersection time\r\n         */\r\n        Ray.prototype.getPoint = function (time) {\r\n            return this.pos.add(this.dir.scale(time));\r\n        };\r\n        return Ray;\r\n    }());\r\n    exports.Ray = Ray;\r\n    /**\r\n     * A 2D line segment\r\n     */\r\n    var Line = (function () {\r\n        /**\r\n         * @param begin  The starting point of the line segment\r\n         * @param end  The ending point of the line segment\r\n         */\r\n        function Line(begin, end) {\r\n            this.begin = begin;\r\n            this.end = end;\r\n        }\r\n        Object.defineProperty(Line.prototype, "slope", {\r\n            /**\r\n             * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.\r\n             */\r\n            get: function () {\r\n                return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Line.prototype, "intercept", {\r\n            /**\r\n             * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.\r\n             */\r\n            get: function () {\r\n                return this.begin.y - (this.slope * this.begin.x);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Gets the normal of the line\r\n         */\r\n        Line.prototype.normal = function () {\r\n            return this.end.sub(this.begin).normal();\r\n        };\r\n        /**\r\n         * Returns the slope of the line in the form of a vector\r\n         */\r\n        Line.prototype.getSlope = function () {\r\n            var begin = this.begin;\r\n            var end = this.end;\r\n            var distance = begin.distance(end);\r\n            return end.sub(begin).scale(1 / distance);\r\n        };\r\n        /**\r\n         * Returns the length of the line segment in pixels\r\n         */\r\n        Line.prototype.getLength = function () {\r\n            var begin = this.begin;\r\n            var end = this.end;\r\n            var distance = begin.distance(end);\r\n            return distance;\r\n        };\r\n        /**\r\n         * Find the perpendicular distance from the line to a point\r\n         * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n         * @param point\r\n         */\r\n        Line.prototype.distanceToPoint = function (point) {\r\n            var x0 = point.x;\r\n            var y0 = point.y;\r\n            var l = this.getLength();\r\n            var dy = this.end.y - this.begin.y;\r\n            var dx = this.end.x - this.begin.x;\r\n            var distance = Math.abs(dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;\r\n            return distance;\r\n        };\r\n        /**\r\n         * Finds a point on the line given only an X or a Y value. Given an X value, the function returns\r\n         * a new point with the calculated Y value and vice-versa.\r\n         *\r\n         * @param x The known X value of the target point\r\n         * @param y The known Y value of the target point\r\n         * @returns A new point with the other calculated axis value\r\n         */\r\n        Line.prototype.findPoint = function (x, y) {\r\n            if (x === void 0) { x = null; }\r\n            if (y === void 0) { y = null; }\r\n            var m = this.slope;\r\n            var b = this.intercept;\r\n            if (x !== null) {\r\n                return new Vector(x, (m * x) + b);\r\n            }\r\n            else if (y !== null) {\r\n                return new Vector((y - b) / m, y);\r\n            }\r\n            else {\r\n                throw new Error(\'You must provide an X or a Y value\');\r\n            }\r\n        };\r\n        /**\r\n         * @see http://stackoverflow.com/a/11908158/109458\r\n         */\r\n        Line.prototype.hasPoint = function () {\r\n            var currPoint;\r\n            var threshold = 0;\r\n            if (typeof arguments[0] === \'number\' &&\r\n                typeof arguments[1] === \'number\') {\r\n                currPoint = new Vector(arguments[0], arguments[1]);\r\n                threshold = arguments[2] || 0;\r\n            }\r\n            else if (arguments[0] instanceof Vector) {\r\n                currPoint = arguments[0];\r\n                threshold = arguments[1] || 0;\r\n            }\r\n            else {\r\n                throw \'Could not determine the arguments for Vector.hasPoint\';\r\n            }\r\n            var dxc = currPoint.x - this.begin.x;\r\n            var dyc = currPoint.y - this.begin.y;\r\n            var dx1 = this.end.x - this.begin.x;\r\n            var dy1 = this.end.y - this.begin.y;\r\n            var cross = dxc * dy1 - dyc * dx1;\r\n            // check whether point lines on the line\r\n            if (Math.abs(cross) > threshold) {\r\n                return false;\r\n            }\r\n            // check whether point lies in-between start and end\r\n            if (Math.abs(dx1) >= Math.abs(dy1)) {\r\n                return dx1 > 0\r\n                    ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x\r\n                    : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;\r\n            }\r\n            else {\r\n                return dy1 > 0\r\n                    ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y\r\n                    : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;\r\n            }\r\n        };\r\n        return Line;\r\n    }());\r\n    exports.Line = Line;\r\n    /**\r\n     * A 1 dimensional projection on an axis, used to test overlaps\r\n     */\r\n    var Projection = (function () {\r\n        function Projection(min, max) {\r\n            this.min = min;\r\n            this.max = max;\r\n        }\r\n        Projection.prototype.overlaps = function (projection) {\r\n            return this.max > projection.min && projection.max > this.min;\r\n        };\r\n        Projection.prototype.getOverlap = function (projection) {\r\n            if (this.overlaps(projection)) {\r\n                if (this.max > projection.max) {\r\n                    return projection.max - this.min;\r\n                }\r\n                else {\r\n                    return this.max - projection.min;\r\n                }\r\n            }\r\n            return 0;\r\n        };\r\n        return Projection;\r\n    }());\r\n    exports.Projection = Projection;\r\n});\r\ndefine("Physics", ["require", "exports", "Algebra"], function (require, exports, Algebra_1) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Possible collision resolution strategies\r\n     *\r\n     * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.\r\n     *\r\n     * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated\r\n     * simulated physical interactions.\r\n     */\r\n    var CollisionResolutionStrategy;\r\n    (function (CollisionResolutionStrategy) {\r\n        CollisionResolutionStrategy[CollisionResolutionStrategy["Box"] = 0] = "Box";\r\n        CollisionResolutionStrategy[CollisionResolutionStrategy["RigidBody"] = 1] = "RigidBody";\r\n    })(CollisionResolutionStrategy = exports.CollisionResolutionStrategy || (exports.CollisionResolutionStrategy = {}));\r\n    /**\r\n     * Possible broadphase collision pair identification strategies\r\n     *\r\n     * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n     * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy\r\n     * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.\r\n     */\r\n    var BroadphaseStrategy;\r\n    (function (BroadphaseStrategy) {\r\n        BroadphaseStrategy[BroadphaseStrategy["Naive"] = 0] = "Naive";\r\n        BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 1] = "DynamicAABBTree";\r\n    })(BroadphaseStrategy = exports.BroadphaseStrategy || (exports.BroadphaseStrategy = {}));\r\n    /**\r\n     * Possible numerical integrators for position and velocity\r\n     */\r\n    var Integrator;\r\n    (function (Integrator) {\r\n        Integrator[Integrator["Euler"] = 0] = "Euler";\r\n    })(Integrator = exports.Integrator || (exports.Integrator = {}));\r\n    /**\r\n     * The [[Physics]] object is the global configuration object for all Excalibur physics.\r\n     *\r\n     * [[include:Physics.md]]\r\n     */\r\n    /* istanbul ignore next */\r\n    var Physics = (function () {\r\n        function Physics() {\r\n        }\r\n        /**\r\n         * Configures Excalibur to use box physics. Box physics which performs simple axis aligned arcade style physics.\r\n         */\r\n        Physics.useBoxPhysics = function () {\r\n            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;\r\n        };\r\n        /**\r\n         * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated\r\n         * simulated physical interactions.\r\n         */\r\n        Physics.useRigidBodyPhysics = function () {\r\n            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.RigidBody;\r\n        };\r\n        return Physics;\r\n    }());\r\n    /**\r\n     * Global acceleration that is applied to all vanilla actors (it wont effect [[Label|labels]], [[UIActor|ui actors]], or\r\n     * [[Trigger|triggers]] in Excalibur that have an [[CollisionType.Active|active]] collision type).\r\n     *\r\n     *\r\n     * This is a great way to globally simulate effects like gravity.\r\n     */\r\n    Physics.acc = new Algebra_1.Vector(0, 0);\r\n    /**\r\n     * Globally switches all Excalibur physics behavior on or off.\r\n     */\r\n    Physics.enabled = true;\r\n    /**\r\n     * Gets or sets the number of collision passes for Excalibur to perform on physics bodies.\r\n     *\r\n     * Reducing collision passes may cause things not to collide as expected in your game, but may increase performance.\r\n     *\r\n     * More passes can improve the visual quality of collisions when many objects are on the screen. This can reduce jitter, improve the\r\n     * collision resolution of fast move objects, or the stability of large numbers of objects stacked together.\r\n     *\r\n     * Fewer passes will improve the performance of the game at the cost of collision quality, more passes will improve quality at the\r\n     * cost of performance.\r\n     *\r\n     * The default is set to 5 passes which is a good start.\r\n     */\r\n    Physics.collisionPasses = 5;\r\n    /**\r\n     * Gets or sets the broadphase pair identification strategy.\r\n     *\r\n     * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n     * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy\r\n     * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.\r\n     */\r\n    Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;\r\n    /**\r\n     * Globally switches the debug information for the broadphase strategy\r\n     */\r\n    Physics.broadphaseDebug = false;\r\n    /**\r\n     * Show the normals as a result of collision on the screen.\r\n     */\r\n    Physics.showCollisionNormals = false;\r\n    /**\r\n     * Show the position, velocity, and acceleration as graphical vectors.\r\n     */\r\n    Physics.showMotionVectors = false;\r\n    /**\r\n     * Show the axis-aligned bounding boxes of the collision bodies on the screen.\r\n     */\r\n    Physics.showBounds = false;\r\n    /**\r\n     * Show the bounding collision area shapes\r\n     */\r\n    Physics.showArea = false;\r\n    /**\r\n     * Show points of collision interpreted by excalibur as a result of collision.\r\n     */\r\n    Physics.showContacts = false;\r\n    /**\r\n     * Show the surface normals of the collision areas.\r\n     */\r\n    Physics.showNormals = false;\r\n    /**\r\n     * Gets or sets the global collision resolution strategy (narrowphase).\r\n     *\r\n     * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.\r\n     *\r\n     * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated\r\n     * simulated physical interactions.\r\n     */\r\n    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;\r\n    /**\r\n     * The default mass to use if none is specified\r\n     */\r\n    Physics.defaultMass = 10;\r\n    /**\r\n     * Gets or sets the position and velocity positional integrator, currently only Euler is supported.\r\n     */\r\n    Physics.integrator = Integrator.Euler;\r\n    /**\r\n     * Number of steps to use in integration. A higher number improves the positional accuracy over time. This can be useful to increase\r\n     * if you have fast moving objects in your simulation or you have a large number of objects and need to increase stability.\r\n     */\r\n    Physics.integrationSteps = 1;\r\n    /**\r\n     * Gets or sets whether rotation is allowed in a RigidBody collision resolution\r\n     */\r\n    Physics.allowRigidBodyRotation = true;\r\n    /**\r\n     * Small value to help collision passes settle themselves after the narrowphase.\r\n     */\r\n    Physics.collisionShift = .001;\r\n    /**\r\n     * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplyer);\r\n     */\r\n    Physics.dynamicTreeVelocityMultiplyer = 2;\r\n    /**\r\n     * Pad RigidBody BoundingBox by a constant amount\r\n     */\r\n    Physics.boundsPadding = 5;\r\n    /**\r\n     * Surface epsilon is used to help deal with surface penatration\r\n     */\r\n    Physics.surfaceEpsilon = .1;\r\n    /**\r\n     * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent\r\n     * bodies from tunneling through one another.\r\n     */\r\n    Physics.checkForFastBodies = true;\r\n    /**\r\n     * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the\r\n     * body is moving at least half of its minimum diminension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,\r\n     * Excalibur will always perform the fast body raycast regardless of speed.\r\n     */\r\n    Physics.disableMinimumSpeedForFastBody = false;\r\n    exports.Physics = Physics;\r\n});\r\ndefine("Util/EasingFunctions", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]\r\n     * Given a time, the function will return a value from positive startValue to positive endValue.\r\n     *\r\n     * ```js\r\n     * function Linear (t) {\r\n     *    return t * t;\r\n     * }\r\n     *\r\n     * // accelerating from zero velocity\r\n     * function EaseInQuad (t) {\r\n     *    return t * t;\r\n     * }\r\n     *\r\n     * // decelerating to zero velocity\r\n     * function EaseOutQuad (t) {\r\n     *    return t * (2 - t);\r\n     * }\r\n     *\r\n     * // acceleration until halfway, then deceleration\r\n     * function EaseInOutQuad (t) {\r\n     *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n     * }\r\n     *\r\n     * // accelerating from zero velocity\r\n     * function EaseInCubic (t) {\r\n     *    return t * t * t;\r\n     * }\r\n     *\r\n     * // decelerating to zero velocity\r\n     * function EaseOutCubic (t) {\r\n     *    return (--t) * t * t + 1;\r\n     * }\r\n     *\r\n     * // acceleration until halfway, then deceleration\r\n     * function EaseInOutCubic (t) {\r\n     *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n     * }\r\n     * ```\r\n     */\r\n    var EasingFunctions = (function () {\r\n        function EasingFunctions() {\r\n        }\r\n        return EasingFunctions;\r\n    }());\r\n    EasingFunctions.Linear = function (currentTime, startValue, endValue, duration) {\r\n        endValue = (endValue - startValue);\r\n        return endValue * currentTime / duration + startValue;\r\n    };\r\n    EasingFunctions.EaseInQuad = function (currentTime, startValue, endValue, duration) {\r\n        endValue = (endValue - startValue);\r\n        currentTime /= duration;\r\n        return endValue * currentTime * currentTime + startValue;\r\n    };\r\n    EasingFunctions.EaseOutQuad = function (currentTime, startValue, endValue, duration) {\r\n        endValue = (endValue - startValue);\r\n        currentTime /= duration;\r\n        return -endValue * currentTime * (currentTime - 2) + startValue;\r\n    };\r\n    EasingFunctions.EaseInOutQuad = function (currentTime, startValue, endValue, duration) {\r\n        endValue = (endValue - startValue);\r\n        currentTime /= duration / 2;\r\n        if (currentTime < 1) {\r\n            return endValue / 2 * currentTime * currentTime + startValue;\r\n        }\r\n        currentTime--;\r\n        return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;\r\n    };\r\n    EasingFunctions.EaseInCubic = function (currentTime, startValue, endValue, duration) {\r\n        endValue = (endValue - startValue);\r\n        currentTime /= duration;\r\n        return endValue * currentTime * currentTime * currentTime + startValue;\r\n    };\r\n    EasingFunctions.EaseOutCubic = function (currentTime, startValue, endValue, duration) {\r\n        endValue = (endValue - startValue);\r\n        currentTime /= duration;\r\n        currentTime--;\r\n        return endValue * (currentTime * currentTime * currentTime + 1) + startValue;\r\n    };\r\n    EasingFunctions.EaseInOutCubic = function (currentTime, startValue, endValue, duration) {\r\n        endValue = (endValue - startValue);\r\n        currentTime /= duration / 2;\r\n        if (currentTime < 1) {\r\n            return endValue / 2 * currentTime * currentTime * currentTime + startValue;\r\n        }\r\n        currentTime -= 2;\r\n        return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;\r\n    };\r\n    exports.EasingFunctions = EasingFunctions;\r\n});\r\n// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/\r\ndefine("Promises", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Valid states for a promise to be in\r\n     */\r\n    var PromiseState;\r\n    (function (PromiseState) {\r\n        PromiseState[PromiseState["Resolved"] = 0] = "Resolved";\r\n        PromiseState[PromiseState["Rejected"] = 1] = "Rejected";\r\n        PromiseState[PromiseState["Pending"] = 2] = "Pending";\r\n    })(PromiseState = exports.PromiseState || (exports.PromiseState = {}));\r\n    /**\r\n     * Promises are used to do asynchronous work and they are useful for\r\n     * creating a chain of actions. In Excalibur they are used for loading,\r\n     * sounds, animation, actions, and more.\r\n     *\r\n     * [[include:Promises.md]]\r\n     */\r\n    var Promise = (function () {\r\n        function Promise() {\r\n            this._state = PromiseState.Pending;\r\n            this._successCallbacks = [];\r\n            this._rejectCallback = function () { return; };\r\n        }\r\n        /**\r\n         * Create and resolve a Promise with an optional value\r\n         * @param value  An optional value to wrap in a resolved promise\r\n         */\r\n        Promise.resolve = function (value) {\r\n            var promise = (new Promise()).resolve(value);\r\n            return promise;\r\n        };\r\n        /**\r\n         * Create and reject a Promise with an optional value\r\n         * @param value  An optional value to wrap in a rejected promise\r\n         */\r\n        Promise.reject = function (value) {\r\n            var promise = (new Promise()).reject(value);\r\n            return promise;\r\n        };\r\n        Promise.join = function () {\r\n            var promises = [];\r\n            if (arguments.length > 0 && !Array.isArray(arguments[0])) {\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    promises[_i - 0] = arguments[_i];\r\n                }\r\n            }\r\n            else if (arguments.length === 1 && Array.isArray(arguments[0])) {\r\n                promises = arguments[0];\r\n            }\r\n            var joinedPromise = new Promise();\r\n            if (!promises || !promises.length) {\r\n                return joinedPromise.resolve();\r\n            }\r\n            var total = promises.length;\r\n            var successes = 0;\r\n            var rejects = 0;\r\n            var errors = [];\r\n            promises.forEach(function (p) {\r\n                p.then(function () {\r\n                    successes += 1;\r\n                    if (successes === total) {\r\n                        joinedPromise.resolve();\r\n                    }\r\n                    else if (successes + rejects + errors.length === total) {\r\n                        joinedPromise.reject(errors);\r\n                    }\r\n                }, function () {\r\n                    rejects += 1;\r\n                    if (successes + rejects + errors.length === total) {\r\n                        joinedPromise.reject(errors);\r\n                    }\r\n                }).error(function (e) {\r\n                    errors.push(e);\r\n                    if ((errors.length + successes + rejects) === total) {\r\n                        joinedPromise.reject(errors);\r\n                    }\r\n                });\r\n            });\r\n            return joinedPromise;\r\n        };\r\n        /**\r\n         * Chain success and reject callbacks after the promise is resolved\r\n         * @param successCallback  Call on resolution of promise\r\n         * @param rejectCallback   Call on rejection of promise\r\n         */\r\n        Promise.prototype.then = function (successCallback, rejectCallback) {\r\n            if (successCallback) {\r\n                this._successCallbacks.push(successCallback);\r\n                // If the promise is already resovled call immediately\r\n                if (this.state() === PromiseState.Resolved) {\r\n                    try {\r\n                        successCallback.call(this, this._value);\r\n                    }\r\n                    catch (e) {\r\n                        this._handleError(e);\r\n                    }\r\n                }\r\n            }\r\n            if (rejectCallback) {\r\n                this._rejectCallback = rejectCallback;\r\n                // If the promise is already rejected call immediately\r\n                if (this.state() === PromiseState.Rejected) {\r\n                    try {\r\n                        rejectCallback.call(this, this._value);\r\n                    }\r\n                    catch (e) {\r\n                        this._handleError(e);\r\n                    }\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Add an error callback to the promise\r\n         * @param errorCallback  Call if there was an error in a callback\r\n         */\r\n        Promise.prototype.error = function (errorCallback) {\r\n            if (errorCallback) {\r\n                this._errorCallback = errorCallback;\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Resolve the promise and pass an option value to the success callbacks\r\n         * @param value  Value to pass to the success callbacks\r\n         */\r\n        Promise.prototype.resolve = function (value) {\r\n            var _this = this;\r\n            if (this._state === PromiseState.Pending) {\r\n                this._value = value;\r\n                try {\r\n                    this._state = PromiseState.Resolved;\r\n                    this._successCallbacks.forEach(function (cb) {\r\n                        cb.call(_this, _this._value);\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    this._handleError(e);\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\'Cannot resolve a promise that is not in a pending state!\');\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Reject the promise and pass an option value to the reject callbacks\r\n         * @param value  Value to pass to the reject callbacks\r\n         */\r\n        Promise.prototype.reject = function (value) {\r\n            if (this._state === PromiseState.Pending) {\r\n                this._value = value;\r\n                try {\r\n                    this._state = PromiseState.Rejected;\r\n                    this._rejectCallback.call(this, this._value);\r\n                }\r\n                catch (e) {\r\n                    this._handleError(e);\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\'Cannot reject a promise that is not in a pending state!\');\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Inspect the current state of a promise\r\n         */\r\n        Promise.prototype.state = function () {\r\n            return this._state;\r\n        };\r\n        Promise.prototype._handleError = function (e) {\r\n            if (this._errorCallback) {\r\n                this._errorCallback.call(this, e);\r\n            }\r\n            else {\r\n                // rethrow error\r\n                throw e;\r\n            }\r\n        };\r\n        return Promise;\r\n    }());\r\n    exports.Promise = Promise;\r\n});\r\ndefine("Collision/Side", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * An enum that describes the sides of an Actor for collision\r\n     */\r\n    var Side;\r\n    (function (Side) {\r\n        Side[Side["None"] = 0] = "None";\r\n        Side[Side["Top"] = 1] = "Top";\r\n        Side[Side["Bottom"] = 2] = "Bottom";\r\n        Side[Side["Left"] = 3] = "Left";\r\n        Side[Side["Right"] = 4] = "Right";\r\n    })(Side = exports.Side || (exports.Side = {}));\r\n});\r\ndefine("Util/Util", ["require", "exports", "Algebra", "Collision/Side"], function (require, exports, Algebra_2, Side_1) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Two PI constant\r\n     */\r\n    exports.TwoPI = Math.PI * 2;\r\n    /**\r\n     * Merges one or more objects into a single target object\r\n     *\r\n     * @returns Merged object with properties from other objects\r\n     * @credit https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/\r\n     */\r\n    function extend() {\r\n        var extended = {};\r\n        var deep = false;\r\n        var i = 0;\r\n        var length = arguments.length;\r\n        // Check if a deep merge\r\n        if (Object.prototype.toString.call(arguments[0]) === \'[object Boolean]\') {\r\n            deep = arguments[0];\r\n            i++;\r\n        }\r\n        // Merge the object into the extended object\r\n        var assignExists = typeof Object.assign === \'function\';\r\n        var merge = null;\r\n        if (!assignExists) {\r\n            merge = function (obj) {\r\n                for (var prop in obj) {\r\n                    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\r\n                        // If deep merge and property is an object, merge properties\r\n                        if (deep && Object.prototype.toString.call(obj[prop]) === \'[object Object]\') {\r\n                            extended[prop] = extend(true, extended[prop], obj[prop]);\r\n                        }\r\n                        else {\r\n                            extended[prop] = obj[prop];\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            merge = Object.assign;\r\n        }\r\n        // Loop through each object and conduct a merge\r\n        for (; i < length; i++) {\r\n            var obj = arguments[i];\r\n            if (!assignExists) {\r\n                merge(obj);\r\n            }\r\n            else {\r\n                merge(extended, obj);\r\n            }\r\n        }\r\n        return extended;\r\n    }\r\n    exports.extend = extend;\r\n    function base64Encode(inputStr) {\r\n        var b64 = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\';\r\n        var outputStr = \'\';\r\n        var i = 0;\r\n        while (i < inputStr.length) {\r\n            //all three "& 0xff" added below are there to fix a known bug\r\n            //with bytes returned by xhr.responseText\r\n            var byte1 = inputStr.charCodeAt(i++) & 0xff;\r\n            var byte2 = inputStr.charCodeAt(i++) & 0xff;\r\n            var byte3 = inputStr.charCodeAt(i++) & 0xff;\r\n            var enc1 = byte1 >> 2;\r\n            var enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);\r\n            var enc3, enc4;\r\n            if (isNaN(byte2)) {\r\n                enc3 = enc4 = 64;\r\n            }\r\n            else {\r\n                enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);\r\n                if (isNaN(byte3)) {\r\n                    enc4 = 64;\r\n                }\r\n                else {\r\n                    enc4 = byte3 & 63;\r\n                }\r\n            }\r\n            outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);\r\n        }\r\n        return outputStr;\r\n    }\r\n    exports.base64Encode = base64Encode;\r\n    /**\r\n     * Clamps a value between a min and max inclusive\r\n     */\r\n    function clamp(val, min, max) {\r\n        return Math.min(Math.max(min, val), max);\r\n    }\r\n    exports.clamp = clamp;\r\n    function randomInRange(min, max) {\r\n        return min + Math.random() * (max - min);\r\n    }\r\n    exports.randomInRange = randomInRange;\r\n    function randomIntInRange(min, max) {\r\n        return Math.round(randomInRange(min, max));\r\n    }\r\n    exports.randomIntInRange = randomIntInRange;\r\n    function canonicalizeAngle(angle) {\r\n        var tmpAngle = angle;\r\n        if (angle > exports.TwoPI) {\r\n            while (tmpAngle > exports.TwoPI) {\r\n                tmpAngle -= exports.TwoPI;\r\n            }\r\n        }\r\n        if (angle < 0) {\r\n            while (tmpAngle < 0) {\r\n                tmpAngle += exports.TwoPI;\r\n            }\r\n        }\r\n        return tmpAngle;\r\n    }\r\n    exports.canonicalizeAngle = canonicalizeAngle;\r\n    function toDegrees(radians) {\r\n        return 180 / Math.PI * radians;\r\n    }\r\n    exports.toDegrees = toDegrees;\r\n    function toRadians(degrees) {\r\n        return degrees / 180 * Math.PI;\r\n    }\r\n    exports.toRadians = toRadians;\r\n    function getPosition(el) {\r\n        var oLeft = 0, oTop = 0;\r\n        var calcOffsetLeft = function (parent) {\r\n            oLeft += parent.offsetLeft;\r\n            if (parent.offsetParent) {\r\n                calcOffsetLeft(parent.offsetParent);\r\n            }\r\n        };\r\n        var calcOffsetTop = function (parent) {\r\n            oTop += parent.offsetTop;\r\n            if (parent.offsetParent) {\r\n                calcOffsetTop(parent.offsetParent);\r\n            }\r\n        };\r\n        calcOffsetLeft(el);\r\n        calcOffsetTop(el);\r\n        return new Algebra_2.Vector(oLeft, oTop);\r\n    }\r\n    exports.getPosition = getPosition;\r\n    function addItemToArray(item, array) {\r\n        if (array.indexOf(item) === -1) {\r\n            array.push(item);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    exports.addItemToArray = addItemToArray;\r\n    function removeItemFromArray(item, array) {\r\n        var index = -1;\r\n        if ((index = array.indexOf(item)) > -1) {\r\n            array.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    exports.removeItemFromArray = removeItemFromArray;\r\n    function contains(array, obj) {\r\n        for (var i = 0; i < array.length; i++) {\r\n            if (array[i] === obj) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    exports.contains = contains;\r\n    function getOppositeSide(side) {\r\n        if (side === Side_1.Side.Top) {\r\n            return Side_1.Side.Bottom;\r\n        }\r\n        if (side === Side_1.Side.Bottom) {\r\n            return Side_1.Side.Top;\r\n        }\r\n        if (side === Side_1.Side.Left) {\r\n            return Side_1.Side.Right;\r\n        }\r\n        if (side === Side_1.Side.Right) {\r\n            return Side_1.Side.Left;\r\n        }\r\n        return Side_1.Side.None;\r\n    }\r\n    exports.getOppositeSide = getOppositeSide;\r\n    function getSideFromVector(direction) {\r\n        var directions = [Algebra_2.Vector.Left, Algebra_2.Vector.Right, Algebra_2.Vector.Up, Algebra_2.Vector.Down];\r\n        var directionEnum = [Side_1.Side.Left, Side_1.Side.Right, Side_1.Side.Top, Side_1.Side.Bottom];\r\n        var max = -Number.MAX_VALUE;\r\n        var maxIndex = -1;\r\n        for (var i = 0; i < directions.length; i++) {\r\n            if (directions[i].dot(direction) > max) {\r\n                max = directions[i].dot(direction);\r\n                maxIndex = i;\r\n            }\r\n        }\r\n        return directionEnum[maxIndex];\r\n    }\r\n    exports.getSideFromVector = getSideFromVector;\r\n    /**\r\n     * Excalibur\'s dynamically resizing collection\r\n     */\r\n    var Collection = (function () {\r\n        /**\r\n         * @param initialSize  Initial size of the internal backing array\r\n         */\r\n        function Collection(initialSize) {\r\n            if (initialSize === void 0) { initialSize = Collection.DefaultSize; }\r\n            this._internalArray = null;\r\n            this._endPointer = 0;\r\n            this._internalArray = new Array(initialSize);\r\n        }\r\n        Collection.prototype._resize = function () {\r\n            var newSize = this._internalArray.length * 2;\r\n            var newArray = new Array(newSize);\r\n            var count = this.count();\r\n            for (var i = 0; i < count; i++) {\r\n                newArray[i] = this._internalArray[i];\r\n            }\r\n            delete this._internalArray;\r\n            this._internalArray = newArray;\r\n        };\r\n        /**\r\n         * Push elements to the end of the collection\r\n         */\r\n        Collection.prototype.push = function (element) {\r\n            if (this._endPointer === this._internalArray.length) {\r\n                this._resize();\r\n            }\r\n            return this._internalArray[this._endPointer++] = element;\r\n        };\r\n        /**\r\n         * Removes elements from the end of the collection\r\n         */\r\n        Collection.prototype.pop = function () {\r\n            this._endPointer = this._endPointer - 1 < 0 ? 0 : this._endPointer - 1;\r\n            return this._internalArray[this._endPointer];\r\n        };\r\n        /**\r\n         * Returns the count of the collection\r\n         */\r\n        Collection.prototype.count = function () {\r\n            return this._endPointer;\r\n        };\r\n        /**\r\n         * Empties the collection\r\n         */\r\n        Collection.prototype.clear = function () {\r\n            this._endPointer = 0;\r\n        };\r\n        /**\r\n         * Returns the size of the internal backing array\r\n         */\r\n        Collection.prototype.internalSize = function () {\r\n            return this._internalArray.length;\r\n        };\r\n        /**\r\n         * Returns an element at a specific index\r\n         * @param index  Index of element to retrieve\r\n         */\r\n        Collection.prototype.elementAt = function (index) {\r\n            if (index >= this.count()) {\r\n                //Logger.getInstance().error(\'Invalid parameter: \' + index);\r\n                throw new Error(\'Invalid index \' + index);\r\n            }\r\n            return this._internalArray[index];\r\n        };\r\n        /**\r\n         * Inserts an element at a specific index\r\n         * @param index  Index to insert the element\r\n         * @param value  Element to insert\r\n         */\r\n        Collection.prototype.insert = function (index, value) {\r\n            if (index >= this.count()) {\r\n                this._resize();\r\n            }\r\n            return this._internalArray[index] = value;\r\n        };\r\n        /**\r\n         * Removes an element at a specific index\r\n         * @param index  Index of element to remove\r\n         */\r\n        Collection.prototype.remove = function (index) {\r\n            var count = this.count();\r\n            if (count === 0) {\r\n                //Logger.getInstance().error(\'Invalid parameter: \' + index);\r\n                throw new Error(\'Invalid parameter \' + index);\r\n            }\r\n            // O(n) Shift\r\n            var removed = this._internalArray[index];\r\n            for (var i = index; i < count; i++) {\r\n                this._internalArray[i] = this._internalArray[i + 1];\r\n            }\r\n            this._endPointer--;\r\n            return removed;\r\n        };\r\n        /**\r\n         * Removes an element by reference\r\n         * @param element  Element to retrieve\r\n         */\r\n        Collection.prototype.removeElement = function (element) {\r\n            var index = this._internalArray.indexOf(element);\r\n            this.remove(index);\r\n        };\r\n        /**\r\n         * Returns a array representing the collection\r\n         */\r\n        Collection.prototype.toArray = function () {\r\n            return this._internalArray.slice(0, this._endPointer);\r\n        };\r\n        /**\r\n         * Iterate over every element in the collection\r\n         * @param func  Callback to call for each element passing a reference to the element and its index, returned values are ignored\r\n         */\r\n        Collection.prototype.forEach = function (func) {\r\n            var i = 0, count = this.count();\r\n            for (i; i < count; i++) {\r\n                func.call(this, this._internalArray[i], i);\r\n            }\r\n        };\r\n        /**\r\n         * Mutate every element in the collection\r\n         * @param func  Callback to call for each element passing a reference to the element and its index, any values returned mutate\r\n         * the collection\r\n         */\r\n        Collection.prototype.map = function (func) {\r\n            var count = this.count();\r\n            for (var i = 0; i < count; i++) {\r\n                this._internalArray[i] = func.call(this, this._internalArray[i], i);\r\n            }\r\n        };\r\n        return Collection;\r\n    }());\r\n    /**\r\n     * Default collection size\r\n     */\r\n    Collection.DefaultSize = 200;\r\n    exports.Collection = Collection;\r\n});\r\ndefine("Camera", ["require", "exports", "Util/EasingFunctions", "Promises", "Algebra", "Util/Util"], function (require, exports, EasingFunctions_1, Promises_1, Algebra_3, Util_1) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Container to house convenience strategy methods\r\n     * @internal\r\n     */\r\n    var StrategyContainer = (function () {\r\n        function StrategyContainer(camera) {\r\n            this.camera = camera;\r\n        }\r\n        /**\r\n         * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.\r\n         * @param actor The actor to lock the camera to\r\n         */\r\n        StrategyContainer.prototype.lockToActor = function (actor) {\r\n            this.camera.addStrategy(new LockCameraToActorStrategy(actor));\r\n        };\r\n        /**\r\n         * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera\r\n         * @param actor The actor to lock the camera to\r\n         * @param axis The axis to follow the actor on\r\n         */\r\n        StrategyContainer.prototype.lockToActorAxis = function (actor, axis) {\r\n            this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));\r\n        };\r\n        /**\r\n         * Creates and adds the [[ElasticToActorStrategy]] on the current camera\r\n         * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n         * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillationg spring that will over\r\n         * correct and bounce around the target\r\n         *\r\n         * @param target Target actor to elastically follow\r\n         * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n         * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n         */\r\n        StrategyContainer.prototype.elasticToActor = function (actor, cameraElasticity, cameraFriction) {\r\n            this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));\r\n        };\r\n        /**\r\n         * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera\r\n         * @param target Target actor to follow when it is "radius" pixels away\r\n         * @param radius Number of pixels away before the camera will follow\r\n         */\r\n        StrategyContainer.prototype.radiusAroundActor = function (actor, radius) {\r\n            this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));\r\n        };\r\n        return StrategyContainer;\r\n    }());\r\n    exports.StrategyContainer = StrategyContainer;\r\n    /**\r\n     * Camera axis enum\r\n     */\r\n    var Axis;\r\n    (function (Axis) {\r\n        Axis[Axis["X"] = 0] = "X";\r\n        Axis[Axis["Y"] = 1] = "Y";\r\n    })(Axis = exports.Axis || (exports.Axis = {}));\r\n    /**\r\n     * Lock a camera to the exact x/y postition of an actor.\r\n     */\r\n    var LockCameraToActorStrategy = (function () {\r\n        function LockCameraToActorStrategy(target) {\r\n            this.target = target;\r\n            this.action = function (target, _cam, _eng, _delta) {\r\n                var center = target.getCenter();\r\n                return center;\r\n            };\r\n        }\r\n        return LockCameraToActorStrategy;\r\n    }());\r\n    exports.LockCameraToActorStrategy = LockCameraToActorStrategy;\r\n    /**\r\n     * Lock a camera to a specific axis around an actor.\r\n     */\r\n    var LockCameraToActorAxisStrategy = (function () {\r\n        function LockCameraToActorAxisStrategy(target, axis) {\r\n            var _this = this;\r\n            this.target = target;\r\n            this.axis = axis;\r\n            this.action = function (target, cam, _eng, _delta) {\r\n                var center = target.getCenter();\r\n                var currentFocus = cam.getFocus();\r\n                if (_this.axis === Axis.X) {\r\n                    return new Algebra_3.Vector(center.x, currentFocus.y);\r\n                }\r\n                else {\r\n                    return new Algebra_3.Vector(currentFocus.x, center.y);\r\n                }\r\n            };\r\n        }\r\n        return LockCameraToActorAxisStrategy;\r\n    }());\r\n    exports.LockCameraToActorAxisStrategy = LockCameraToActorAxisStrategy;\r\n    /**\r\n     * Using [Hook\'s law](https://en.wikipedia.org/wiki/Hooke\'s_law), elastically move the camera towards the target actor.\r\n     */\r\n    var ElasticToActorStrategy = (function () {\r\n        /**\r\n         * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n         * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillationg spring that will over\r\n         * correct and bounce around the target\r\n         *\r\n         * @param target Target actor to elastically follow\r\n         * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n         * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n         */\r\n        function ElasticToActorStrategy(target, cameraElasticity, cameraFriction) {\r\n            var _this = this;\r\n            this.target = target;\r\n            this.cameraElasticity = cameraElasticity;\r\n            this.cameraFriction = cameraFriction;\r\n            this.action = function (target, cam, _eng, _delta) {\r\n                var position = target.getCenter();\r\n                var focus = cam.getFocus();\r\n                var cameraVel = new Algebra_3.Vector(cam.dx, cam.dy);\r\n                // Calculate the strech vector, using the spring equation\r\n                // F = kX\r\n                // https://en.wikipedia.org/wiki/Hooke\'s_law\r\n                // Apply to the current camera velocity\r\n                var stretch = position.sub(focus).scale(_this.cameraElasticity); // stretch is X\r\n                cameraVel = cameraVel.add(stretch);\r\n                // Calculate the friction (-1 to apply a force in the opposition of motion)\r\n                // Apply to the current camera velocity\r\n                var friction = cameraVel.scale(-1).scale(_this.cameraFriction);\r\n                cameraVel = cameraVel.add(friction);\r\n                // Update position by velocity deltas\r\n                focus = focus.add(cameraVel);\r\n                return focus;\r\n            };\r\n        }\r\n        return ElasticToActorStrategy;\r\n    }());\r\n    exports.ElasticToActorStrategy = ElasticToActorStrategy;\r\n    var RadiusAroundActorStrategy = (function () {\r\n        /**\r\n         *\r\n         * @param target Target actor to follow when it is "radius" pixels away\r\n         * @param radius Number of pixels away before the camera will follow\r\n         */\r\n        function RadiusAroundActorStrategy(target, radius) {\r\n            var _this = this;\r\n            this.target = target;\r\n            this.radius = radius;\r\n            this.action = function (target, cam, _eng, _delta) {\r\n                var position = target.getCenter();\r\n                var focus = cam.getFocus();\r\n                var direction = position.sub(focus);\r\n                var distance = direction.magnitude();\r\n                if (distance >= _this.radius) {\r\n                    var offset = distance - _this.radius;\r\n                    return focus.add(direction.normalize().scale(offset));\r\n                }\r\n                return focus;\r\n            };\r\n        }\r\n        return RadiusAroundActorStrategy;\r\n    }());\r\n    exports.RadiusAroundActorStrategy = RadiusAroundActorStrategy;\r\n    /**\r\n     * Cameras\r\n     *\r\n     * [[BaseCamera]] is the base class for all Excalibur cameras. Cameras are used\r\n     * to move around your game and set focus. They are used to determine\r\n     * what is "off screen" and can be used to scale the game.\r\n     *\r\n     * [[include:Cameras.md]]\r\n     */\r\n    var BaseCamera = (function () {\r\n        function BaseCamera() {\r\n            this._cameraStrategies = [];\r\n            this.strategy = new StrategyContainer(this);\r\n            // camera physical quantities\r\n            this.z = 1;\r\n            this.dx = 0;\r\n            this.dy = 0;\r\n            this.dz = 0;\r\n            this.ax = 0;\r\n            this.ay = 0;\r\n            this.az = 0;\r\n            this.rotation = 0;\r\n            this.rx = 0;\r\n            this._x = 0;\r\n            this._y = 0;\r\n            this._cameraMoving = false;\r\n            this._currentLerpTime = 0;\r\n            this._lerpDuration = 1000; // 1 second   \r\n            this._lerpStart = null;\r\n            this._lerpEnd = null;\r\n            //camera effects\r\n            this._isShaking = false;\r\n            this._shakeMagnitudeX = 0;\r\n            this._shakeMagnitudeY = 0;\r\n            this._shakeDuration = 0;\r\n            this._elapsedShakeTime = 0;\r\n            this._xShake = 0;\r\n            this._yShake = 0;\r\n            this._isZooming = false;\r\n            this._maxZoomScale = 1;\r\n            this._zoomIncrement = 0.01;\r\n            this._easing = EasingFunctions_1.EasingFunctions.EaseInOutCubic;\r\n        }\r\n        Object.defineProperty(BaseCamera.prototype, "x", {\r\n            /**\r\n             * Get the camera\'s x position\r\n             */\r\n            get: function () {\r\n                return this._x;\r\n            },\r\n            /**\r\n             * Set the camera\'s x position (cannot be set when following an [[Actor]] or when moving)\r\n             */\r\n            set: function (value) {\r\n                if (!this._follow && !this._cameraMoving) {\r\n                    this._x = value;\r\n                }\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(BaseCamera.prototype, "y", {\r\n            /**\r\n             * Get the camera\'s y position\r\n             */\r\n            get: function () {\r\n                return this._y;\r\n            },\r\n            /**\r\n             * Set the camera\'s y position (cannot be set when following an [[Actor]] or when moving)\r\n             */\r\n            set: function (value) {\r\n                if (!this._follow && !this._cameraMoving) {\r\n                    this._y = value;\r\n                }\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(BaseCamera.prototype, "pos", {\r\n            /**\r\n             * Get the camera\'s position as a vector\r\n             */\r\n            get: function () {\r\n                return new Algebra_3.Vector(this.x, this.y);\r\n            },\r\n            /**\r\n             * Set the cameras position\r\n             */\r\n            set: function (value) {\r\n                this.x = value.x;\r\n                this.y = value.y;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(BaseCamera.prototype, "vel", {\r\n            /**\r\n             * Get the camera\'s velocity as a vector\r\n             */\r\n            get: function () {\r\n                return new Algebra_3.Vector(this.dx, this.dy);\r\n            },\r\n            /**\r\n             * Set the camera\'s velocity\r\n             */\r\n            set: function (value) {\r\n                this.dx = value.x;\r\n                this.dy = value.y;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Returns the focal point of the camera, a new point giving the x and y position of the camera\r\n         */\r\n        BaseCamera.prototype.getFocus = function () {\r\n            return new Algebra_3.Vector(this.x, this.y);\r\n        };\r\n        /**\r\n         * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.\r\n         *\r\n         * @param pos The target position to move to\r\n         * @param duration The duration in milliseconds the move should last\r\n         * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)\r\n         * @returns A [[Promise]] that resolves when movement is finished, including if it\'s interrupted.\r\n         *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.\r\n         */\r\n        BaseCamera.prototype.move = function (pos, duration, easingFn) {\r\n            if (easingFn === void 0) { easingFn = EasingFunctions_1.EasingFunctions.EaseInOutCubic; }\r\n            if (typeof easingFn !== \'function\') {\r\n                throw \'Please specify an EasingFunction\';\r\n            }\r\n            // cannot move when following an actor\r\n            if (this._follow) {\r\n                return new Promises_1.Promise().reject(pos);\r\n            }\r\n            // resolve existing promise, if any\r\n            if (this._lerpPromise && this._lerpPromise.state() === Promises_1.PromiseState.Pending) {\r\n                this._lerpPromise.resolve(pos);\r\n            }\r\n            this._lerpPromise = new Promises_1.Promise();\r\n            this._lerpStart = this.getFocus().clone();\r\n            this._lerpDuration = duration;\r\n            this._lerpEnd = pos;\r\n            this._currentLerpTime = 0;\r\n            this._cameraMoving = true;\r\n            this._easing = easingFn;\r\n            return this._lerpPromise;\r\n        };\r\n        /**\r\n         * Sets the camera to shake at the specified magnitudes for the specified duration\r\n         * @param magnitudeX  The x magnitude of the shake\r\n         * @param magnitudeY  The y magnitude of the shake\r\n         * @param duration    The duration of the shake in milliseconds\r\n         */\r\n        BaseCamera.prototype.shake = function (magnitudeX, magnitudeY, duration) {\r\n            this._isShaking = true;\r\n            this._shakeMagnitudeX = magnitudeX;\r\n            this._shakeMagnitudeY = magnitudeY;\r\n            this._shakeDuration = duration;\r\n        };\r\n        /**\r\n         * Zooms the camera in or out by the specified scale over the specified duration.\r\n         * If no duration is specified, it take effect immediately.\r\n         * @param scale    The scale of the zoom\r\n         * @param duration The duration of the zoom in milliseconds\r\n         */\r\n        BaseCamera.prototype.zoom = function (scale, duration) {\r\n            if (duration === void 0) { duration = 0; }\r\n            this._zoomPromise = new Promises_1.Promise();\r\n            if (duration) {\r\n                this._isZooming = true;\r\n                this._maxZoomScale = scale;\r\n                this._zoomIncrement = (scale - this.z) / duration;\r\n            }\r\n            else {\r\n                this._isZooming = false;\r\n                this.z = scale;\r\n                this._zoomPromise.resolve(true);\r\n            }\r\n            return this._zoomPromise;\r\n        };\r\n        /**\r\n         * Gets the current zoom scale\r\n         */\r\n        BaseCamera.prototype.getZoom = function () {\r\n            return this.z;\r\n        };\r\n        /**\r\n         * Adds a new camera strategy to this camera\r\n         * @param cameraStrategy Instance of an [[ICameraStrategy]]\r\n         */\r\n        BaseCamera.prototype.addStrategy = function (cameraStrategy) {\r\n            this._cameraStrategies.push(cameraStrategy);\r\n        };\r\n        /**\r\n         * Removes a camera strategy by reference\r\n         * @param cameraStrategy Instance of an [[ICameraStrategy]]\r\n         */\r\n        BaseCamera.prototype.removeStrategy = function (cameraStrategy) {\r\n            Util_1.removeItemFromArray(cameraStrategy, this._cameraStrategies);\r\n        };\r\n        /**\r\n         * Clears all camera strategies from the camera\r\n         */\r\n        BaseCamera.prototype.clearAllStrategies = function () {\r\n            this._cameraStrategies.length = 0;\r\n        };\r\n        BaseCamera.prototype.update = function (_engine, delta) {\r\n            // Update placements based on linear algebra\r\n            this._x += this.dx * delta / 1000;\r\n            this._y += this.dy * delta / 1000;\r\n            this.z += this.dz * delta / 1000;\r\n            this.dx += this.ax * delta / 1000;\r\n            this.dy += this.ay * delta / 1000;\r\n            this.dz += this.az * delta / 1000;\r\n            this.rotation += this.rx * delta / 1000;\r\n            if (this._isZooming) {\r\n                var newZoom = this.z + this._zoomIncrement * delta;\r\n                this.z = newZoom;\r\n                if (this._zoomIncrement > 0) {\r\n                    if (newZoom >= this._maxZoomScale) {\r\n                        this._isZooming = false;\r\n                        this.z = this._maxZoomScale;\r\n                        this._zoomPromise.resolve(true);\r\n                    }\r\n                }\r\n                else {\r\n                    if (newZoom <= this._maxZoomScale) {\r\n                        this._isZooming = false;\r\n                        this.z = this._maxZoomScale;\r\n                        this._zoomPromise.resolve(true);\r\n                    }\r\n                }\r\n            }\r\n            if (this._cameraMoving) {\r\n                if (this._currentLerpTime < this._lerpDuration) {\r\n                    if (this._lerpEnd.x < this._lerpStart.x) {\r\n                        this._x = this._lerpStart.x - (this._easing(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\r\n                    }\r\n                    else {\r\n                        this._x = this._easing(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\r\n                    }\r\n                    if (this._lerpEnd.y < this._lerpStart.y) {\r\n                        this._y = this._lerpStart.y - (this._easing(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\r\n                    }\r\n                    else {\r\n                        this._y = this._easing(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\r\n                    }\r\n                    this._currentLerpTime += delta;\r\n                }\r\n                else {\r\n                    this._x = this._lerpEnd.x;\r\n                    this._y = this._lerpEnd.y;\r\n                    this._lerpPromise.resolve(this._lerpEnd);\r\n                    this._lerpStart = null;\r\n                    this._lerpEnd = null;\r\n                    this._currentLerpTime = 0;\r\n                    this._cameraMoving = false;\r\n                }\r\n            }\r\n            if (this._isDoneShaking()) {\r\n                this._isShaking = false;\r\n                this._elapsedShakeTime = 0;\r\n                this._shakeMagnitudeX = 0;\r\n                this._shakeMagnitudeY = 0;\r\n                this._shakeDuration = 0;\r\n                this._xShake = 0;\r\n                this._yShake = 0;\r\n            }\r\n            else {\r\n                this._elapsedShakeTime += delta;\r\n                this._xShake = (Math.random() * this._shakeMagnitudeX | 0) + 1;\r\n                this._yShake = (Math.random() * this._shakeMagnitudeY | 0) + 1;\r\n            }\r\n            for (var _i = 0, _a = this._cameraStrategies; _i < _a.length; _i++) {\r\n                var s = _a[_i];\r\n                this.pos = s.action.call(s, s.target, this, _engine, delta);\r\n            }\r\n        };\r\n        /**\r\n         * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera\r\n         * @param ctx    Canvas context to apply transformations\r\n         * @param delta  The number of milliseconds since the last update\r\n         */\r\n        BaseCamera.prototype.draw = function (ctx) {\r\n            var focus = this.getFocus();\r\n            var canvasWidth = ctx.canvas.width;\r\n            var canvasHeight = ctx.canvas.height;\r\n            var pixelRatio = window.devicePixelRatio;\r\n            var zoom = this.getZoom();\r\n            var newCanvasWidth = (canvasWidth / zoom) / pixelRatio;\r\n            var newCanvasHeight = (canvasHeight / zoom) / pixelRatio;\r\n            ctx.scale(zoom, zoom);\r\n            ctx.translate(-focus.x + newCanvasWidth / 2 + this._xShake, -focus.y + newCanvasHeight / 2 + this._yShake);\r\n        };\r\n        BaseCamera.prototype.debugDraw = function (ctx) {\r\n            var focus = this.getFocus();\r\n            ctx.fillStyle = \'red\';\r\n            ctx.strokeStyle = \'white\';\r\n            ctx.lineWidth = 3;\r\n            ctx.beginPath();\r\n            ctx.arc(focus.x, focus.y, 15, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n            ctx.beginPath();\r\n            ctx.arc(focus.x, focus.y, 5, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n        };\r\n        BaseCamera.prototype._isDoneShaking = function () {\r\n            return !(this._isShaking) || (this._elapsedShakeTime >= this._shakeDuration);\r\n        };\r\n        return BaseCamera;\r\n    }());\r\n    exports.BaseCamera = BaseCamera;\r\n    /**\r\n     * An extension of [[BaseCamera]] that is locked vertically; it will only move side to side.\r\n     *\r\n     * Common usages: platformers.\r\n     * @deprecated OBSOLETE: Will be removed in v0.15, please use `BaseCamera.strategy.lockToActorAxis`\r\n     */\r\n    var SideCamera = (function (_super) {\r\n        __extends(SideCamera, _super);\r\n        function SideCamera() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        /**\r\n         * Sets the [[Actor]] to follow with the camera\r\n         * @param actor  The actor to follow\r\n         */\r\n        SideCamera.prototype.setActorToFollow = function (actor) {\r\n            this._follow = actor;\r\n        };\r\n        SideCamera.prototype.getFocus = function () {\r\n            if (this._follow) {\r\n                return new Algebra_3.Vector(this._follow.pos.x + this._follow.getWidth() / 2, _super.prototype.getFocus.call(this).y);\r\n            }\r\n            else {\r\n                return _super.prototype.getFocus.call(this);\r\n            }\r\n        };\r\n        return SideCamera;\r\n    }(BaseCamera));\r\n    exports.SideCamera = SideCamera;\r\n    /**\r\n     * An extension of [[BaseCamera]] that is locked to an [[Actor]] or\r\n     * [[LockedCamera.getFocus|focal point]]; the actor will appear in the\r\n     * center of the screen.\r\n     *\r\n     * Common usages: RPGs, adventure games, top-down games.\r\n     * @deprecated OBSOLETE: Will be removed in v0.15, please use `BaseCamera.strategy.lockToActor`\r\n     */\r\n    var LockedCamera = (function (_super) {\r\n        __extends(LockedCamera, _super);\r\n        function LockedCamera() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        /**\r\n         * Sets the [[Actor]] to follow with the camera\r\n         * @param actor  The actor to follow\r\n         */\r\n        LockedCamera.prototype.setActorToFollow = function (actor) {\r\n            this._follow = actor;\r\n        };\r\n        LockedCamera.prototype.getFocus = function () {\r\n            if (this._follow) {\r\n                return new Algebra_3.Vector(this._follow.pos.x + this._follow.getWidth() / 2, this._follow.pos.y + this._follow.getHeight() / 2);\r\n            }\r\n            else {\r\n                return _super.prototype.getFocus.call(this);\r\n            }\r\n        };\r\n        return LockedCamera;\r\n    }(BaseCamera));\r\n    exports.LockedCamera = LockedCamera;\r\n});\r\ndefine("DebugFlags", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Drawing/Color", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Provides standard colors (e.g. [[Color.Black]])\r\n     * but you can also create custom colors using RGB, HSL, or Hex. Also provides\r\n     * useful color operations like [[Color.lighten]], [[Color.darken]], and more.\r\n     *\r\n     * [[include:Colors.md]]\r\n     */\r\n    var Color = (function () {\r\n        /**\r\n         * Creates a new instance of Color from an r, g, b, a\r\n         *\r\n         * @param r  The red component of color (0-255)\r\n         * @param g  The green component of color (0-255)\r\n         * @param b  The blue component of color (0-255)\r\n         * @param a  The alpha component of color (0-1.0)\r\n         */\r\n        function Color(r, g, b, a) {\r\n            this.r = r;\r\n            this.g = g;\r\n            this.b = b;\r\n            this.a = (a != null ? a : 1);\r\n        }\r\n        /**\r\n         * Creates a new instance of Color from an r, g, b, a\r\n         *\r\n         * @param r  The red component of color (0-255)\r\n         * @param g  The green component of color (0-255)\r\n         * @param b  The blue component of color (0-255)\r\n         * @param a  The alpha component of color (0-1.0)\r\n         */\r\n        Color.fromRGB = function (r, g, b, a) {\r\n            return new Color(r, g, b, a);\r\n        };\r\n        /**\r\n         * Creates a new inscance of Color from a hex string\r\n         *\r\n         * @param hex  CSS color string of the form #ffffff, the alpha component is optional\r\n         */\r\n        Color.fromHex = function (hex) {\r\n            var hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;\r\n            var match = null;\r\n            if (match = hex.match(hexRegEx)) {\r\n                var r = parseInt(match[1], 16);\r\n                var g = parseInt(match[2], 16);\r\n                var b = parseInt(match[3], 16);\r\n                var a = 1;\r\n                if (match[4]) {\r\n                    a = parseInt(match[4], 16) / 255;\r\n                }\r\n                return new Color(r, g, b, a);\r\n            }\r\n            else {\r\n                throw new Error(\'Invalid hex string: \' + hex);\r\n            }\r\n        };\r\n        /**\r\n         * Creats a new instance of Color from hsla values\r\n         *\r\n         * @param h  Hue is represented [0-1]\r\n         * @param s  Saturation is represented [0-1]\r\n         * @param l  Luminance is represented [0-1]\r\n         * @param a  Alpha is represented [0-1]\r\n         */\r\n        Color.fromHSL = function (h, s, l, a) {\r\n            if (a === void 0) { a = 1.0; }\r\n            var temp = new HSLColor(h, s, l, a);\r\n            return temp.toRGBA();\r\n        };\r\n        /**\r\n         * Lightens the current color by a specified amount\r\n         *\r\n         * @param factor  The amount to lighten by [0-1]\r\n         */\r\n        Color.prototype.lighten = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n            temp.l += (temp.l * factor);\r\n            return temp.toRGBA();\r\n        };\r\n        /**\r\n         * Darkens the current color by a specified amount\r\n         *\r\n         * @param factor  The amount to darken by [0-1]\r\n         */\r\n        Color.prototype.darken = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n            temp.l -= (temp.l * factor);\r\n            return temp.toRGBA();\r\n        };\r\n        /**\r\n         * Saturates the current color by a specified amount\r\n         *\r\n         * @param factor  The amount to saturate by [0-1]\r\n         */\r\n        Color.prototype.saturate = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n            temp.s += (temp.s * factor);\r\n            return temp.toRGBA();\r\n        };\r\n        /**\r\n         * Desaturates the current color by a specified amount\r\n         *\r\n         * @param factor  The amount to desaturate by [0-1]\r\n         */\r\n        Color.prototype.desaturate = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n            temp.s -= (temp.s * factor);\r\n            return temp.toRGBA();\r\n        };\r\n        /**\r\n         * Multiplies a color by another, results in a darker color\r\n         *\r\n         * @param color  The other color\r\n         */\r\n        Color.prototype.mulitiply = function (color) {\r\n            var newR = ((color.r / 255 * this.r / 255) * 255);\r\n            var newG = ((color.g / 255 * this.g / 255) * 255);\r\n            var newB = ((color.b / 255 * this.b / 255) * 255);\r\n            var newA = (color.a * this.a);\r\n            return new Color(newR, newG, newB, newA);\r\n        };\r\n        /**\r\n         * Screens a color by another, results in a lighter color\r\n         *\r\n         * @param color  The other color\r\n         */\r\n        Color.prototype.screen = function (color) {\r\n            var color1 = color.invert();\r\n            var color2 = color.invert();\r\n            return color1.mulitiply(color2).invert();\r\n        };\r\n        /**\r\n         * Inverts the current color\r\n         */\r\n        Color.prototype.invert = function () {\r\n            return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);\r\n        };\r\n        /**\r\n         * Averages the current color with another\r\n         *\r\n         * @param color  The other color\r\n         */\r\n        Color.prototype.average = function (color) {\r\n            var newR = (color.r + this.r) / 2;\r\n            var newG = (color.g + this.g) / 2;\r\n            var newB = (color.b + this.b) / 2;\r\n            var newA = (color.a + this.a) / 2;\r\n            return new Color(newR, newG, newB, newA);\r\n        };\r\n        /**\r\n         * Returns a CSS string representation of a color.\r\n         *\r\n         * @param format Color representation, accepts: rgb, hsl, or hex\r\n         */\r\n        Color.prototype.toString = function (format) {\r\n            if (format === void 0) { format = \'rgb\'; }\r\n            switch (format) {\r\n                case \'rgb\':\r\n                    return this.toRGBA();\r\n                case \'hsl\':\r\n                    return this.toHSLA();\r\n                case \'hex\':\r\n                    return this.toHex();\r\n                default:\r\n                    throw new Error(\'Invalid Color format\');\r\n            }\r\n        };\r\n        /**\r\n         * Returns Hex Value of a color component\r\n         * @param c color component\r\n         * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\r\n         */\r\n        Color.prototype._componentToHex = function (c) {\r\n            var hex = c.toString(16);\r\n            return hex.length === 1 ? \'0\' + hex : hex;\r\n        };\r\n        /**\r\n         * Return Hex representation of a color.\r\n         */\r\n        Color.prototype.toHex = function () {\r\n            return \'#\' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);\r\n        };\r\n        /**\r\n         * Return RGBA representation of a color.\r\n         */\r\n        Color.prototype.toRGBA = function () {\r\n            var result = String(this.r.toFixed(0)) + \', \' + String(this.g.toFixed(0)) + \', \' + String(this.b.toFixed(0));\r\n            if (this.a !== undefined || this.a !== null) {\r\n                return \'rgba(\' + result + \', \' + String(this.a) + \')\';\r\n            }\r\n            return \'rgb(\' + result + \')\';\r\n        };\r\n        /**\r\n         * Return HSLA representation of a color.\r\n         */\r\n        Color.prototype.toHSLA = function () {\r\n            return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();\r\n        };\r\n        /**\r\n         * Returns a CSS string representation of a color.\r\n         */\r\n        Color.prototype.fillStyle = function () {\r\n            return this.toString();\r\n        };\r\n        /**\r\n         * Returns a clone of the current color.\r\n         */\r\n        Color.prototype.clone = function () {\r\n            return new Color(this.r, this.g, this.b, this.a);\r\n        };\r\n        return Color;\r\n    }());\r\n    /**\r\n     * Black (#000000)\r\n     */\r\n    Color.Black = Color.fromHex(\'#000000\');\r\n    /**\r\n     * White (#FFFFFF)\r\n     */\r\n    Color.White = Color.fromHex(\'#FFFFFF\');\r\n    /**\r\n     * Gray (#808080)\r\n     */\r\n    Color.Gray = Color.fromHex(\'#808080\');\r\n    /**\r\n     * Light gray (#D3D3D3)\r\n     */\r\n    Color.LightGray = Color.fromHex(\'#D3D3D3\');\r\n    /**\r\n     * Dark gray (#A9A9A9)\r\n     */\r\n    Color.DarkGray = Color.fromHex(\'#A9A9A9\');\r\n    /**\r\n     * Yellow (#FFFF00)\r\n     */\r\n    Color.Yellow = Color.fromHex(\'#FFFF00\');\r\n    /**\r\n     * Orange (#FFA500)\r\n     */\r\n    Color.Orange = Color.fromHex(\'#FFA500\');\r\n    /**\r\n     * Red (#FF0000)\r\n     */\r\n    Color.Red = Color.fromHex(\'#FF0000\');\r\n    /**\r\n     * Vermillion (#FF5B31)\r\n     */\r\n    Color.Vermillion = Color.fromHex(\'#FF5B31\');\r\n    /**\r\n     * Rose (#FF007F)\r\n     */\r\n    Color.Rose = Color.fromHex(\'#FF007F\');\r\n    /**\r\n     * Magenta (#FF00FF)\r\n     */\r\n    Color.Magenta = Color.fromHex(\'#FF00FF\');\r\n    /**\r\n     * Violet (#7F00FF)\r\n     */\r\n    Color.Violet = Color.fromHex(\'#7F00FF\');\r\n    /**\r\n     * Blue (#0000FF)\r\n     */\r\n    Color.Blue = Color.fromHex(\'#0000FF\');\r\n    /**\r\n     * Azure (#007FFF)\r\n     */\r\n    Color.Azure = Color.fromHex(\'#007FFF\');\r\n    /**\r\n     * Cyan (#00FFFF)\r\n     */\r\n    Color.Cyan = Color.fromHex(\'#00FFFF\');\r\n    /**\r\n     * Viridian (#59978F)\r\n     */\r\n    Color.Viridian = Color.fromHex(\'#59978F\');\r\n    /**\r\n     * Green (#00FF00)\r\n     */\r\n    Color.Green = Color.fromHex(\'#00FF00\');\r\n    /**\r\n     * Chartreuse (#7FFF00)\r\n     */\r\n    Color.Chartreuse = Color.fromHex(\'#7FFF00\');\r\n    /**\r\n     * Transparent (#FFFFFF00)\r\n     */\r\n    Color.Transparent = Color.fromHex(\'#FFFFFF00\');\r\n    exports.Color = Color;\r\n    /**\r\n     * Internal HSL Color representation\r\n     *\r\n     * http://en.wikipedia.org/wiki/HSL_and_HSV\r\n     * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n     */\r\n    var HSLColor = (function () {\r\n        function HSLColor(h, s, l, a) {\r\n            this.h = h;\r\n            this.s = s;\r\n            this.l = l;\r\n            this.a = a;\r\n        }\r\n        HSLColor.hue2rgb = function (p, q, t) {\r\n            if (t < 0) {\r\n                t += 1;\r\n            }\r\n            if (t > 1) {\r\n                t -= 1;\r\n            }\r\n            if (t < 1 / 6) {\r\n                return p + (q - p) * 6 * t;\r\n            }\r\n            if (t < 1 / 2) {\r\n                return q;\r\n            }\r\n            if (t < 2 / 3) {\r\n                return p + (q - p) * (2 / 3 - t) * 6;\r\n            }\r\n            return p;\r\n        };\r\n        HSLColor.fromRGBA = function (r, g, b, a) {\r\n            r /= 255;\r\n            g /= 255;\r\n            b /= 255;\r\n            var max = Math.max(r, g, b), min = Math.min(r, g, b);\r\n            var h, s, l = (max + min) / 2;\r\n            if (max === min) {\r\n                h = s = 0; // achromatic\r\n            }\r\n            else {\r\n                var d = max - min;\r\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n                switch (max) {\r\n                    case r:\r\n                        h = (g - b) / d + (g < b ? 6 : 0);\r\n                        break;\r\n                    case g:\r\n                        h = (b - r) / d + 2;\r\n                        break;\r\n                    case b:\r\n                        h = (r - g) / d + 4;\r\n                        break;\r\n                }\r\n                h /= 6;\r\n            }\r\n            return new HSLColor(h, s, l, a);\r\n        };\r\n        HSLColor.prototype.toRGBA = function () {\r\n            var r, g, b;\r\n            if (this.s === 0) {\r\n                r = g = b = this.l; // achromatic\r\n            }\r\n            else {\r\n                var q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;\r\n                var p = 2 * this.l - q;\r\n                r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);\r\n                g = HSLColor.hue2rgb(p, q, this.h);\r\n                b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);\r\n            }\r\n            return new Color(r * 255, g * 255, b * 255, this.a);\r\n        };\r\n        HSLColor.prototype.toString = function () {\r\n            var h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);\r\n            return "hsla(" + h + ", " + s + ", " + l + ", " + a + ")";\r\n        };\r\n        return HSLColor;\r\n    }());\r\n});\r\ndefine("Collision/CollisionContact", ["require", "exports", "Actor", "Algebra", "Physics", "Events", "Util/Util"], function (require, exports, Actor_1, Algebra_4, Physics_1, Events_1, Util) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Collision contacts are used internally by Excalibur to resolve collision between actors. This\r\n     * Pair prevents collisions from being evaluated more than one time\r\n     */\r\n    var CollisionContact = (function () {\r\n        function CollisionContact(bodyA, bodyB, mtv, point, normal) {\r\n            this.bodyA = bodyA;\r\n            this.bodyB = bodyB;\r\n            this.mtv = mtv;\r\n            this.point = point;\r\n            this.normal = normal;\r\n        }\r\n        CollisionContact.prototype.resolve = function (strategy) {\r\n            if (strategy === Physics_1.CollisionResolutionStrategy.RigidBody) {\r\n                this._resolveRigidBodyCollision();\r\n            }\r\n            else if (strategy === Physics_1.CollisionResolutionStrategy.Box) {\r\n                this._resolveBoxCollision();\r\n            }\r\n            else {\r\n                throw new Error(\'Unknown collision resolution strategy\');\r\n            }\r\n        };\r\n        CollisionContact.prototype._applyBoxImpulse = function (bodyA, bodyB, mtv) {\r\n            if (bodyA.collisionType === Actor_1.CollisionType.Active &&\r\n                bodyB.collisionType !== Actor_1.CollisionType.Passive) {\r\n                // Resolve overlaps\r\n                if (bodyA.collisionType === Actor_1.CollisionType.Active &&\r\n                    bodyB.collisionType === Actor_1.CollisionType.Active) {\r\n                    // split overlaps if both are Active\r\n                    mtv = mtv.scale(.5);\r\n                }\r\n                // Apply mtv\r\n                bodyA.pos.y += mtv.y;\r\n                bodyA.pos.x += mtv.x;\r\n                // non-zero intersection on the y axis\r\n                if (this.mtv.x !== 0) {\r\n                    var velX = 0;\r\n                    // both bodies are traveling in the same direction (negative or positive)\r\n                    if (bodyA.vel.x < 0 && bodyB.vel.x < 0) {\r\n                        velX = Math.min(bodyA.vel.x, bodyB.vel.x);\r\n                    }\r\n                    else if (bodyA.vel.x > 0 && bodyB.vel.x > 0) {\r\n                        velX = Math.max(bodyA.vel.x, bodyB.vel.x);\r\n                    }\r\n                    else if (bodyB.collisionType === Actor_1.CollisionType.Fixed) {\r\n                        // bodies are traveling in opposite directions\r\n                        if (bodyA.pos.sub(bodyB.pos).dot(bodyA.vel) > 0) {\r\n                            velX = bodyA.vel.x;\r\n                        }\r\n                        else {\r\n                            // bodyA is heading towards b\r\n                            velX = bodyB.vel.x;\r\n                        }\r\n                    }\r\n                    bodyA.vel.x = velX;\r\n                }\r\n                if (this.mtv.y !== 0) {\r\n                    var velY = 0;\r\n                    // both bodies are traveling in the same direction (negative or positive)\r\n                    if (bodyA.vel.y < 0 && bodyB.vel.y < 0) {\r\n                        velY = Math.min(bodyA.vel.y, bodyB.vel.y);\r\n                    }\r\n                    else if (bodyA.vel.y > 0 && bodyB.vel.y > 0) {\r\n                        velY = Math.max(bodyA.vel.y, bodyB.vel.y);\r\n                    }\r\n                    else if (bodyB.collisionType === Actor_1.CollisionType.Fixed) {\r\n                        // bodies are traveling in opposite directions\r\n                        if (bodyA.pos.sub(bodyB.pos).dot(bodyA.vel) > 0) {\r\n                            velY = bodyA.vel.y;\r\n                        }\r\n                        else {\r\n                            // bodyA is heading towards b\r\n                            velY = bodyB.vel.y;\r\n                        }\r\n                    }\r\n                    bodyA.vel.y = velY;\r\n                }\r\n                bodyA.emit(\'postcollision\', new Events_1.PostCollisionEvent(bodyA, bodyB, Util.getSideFromVector(mtv), mtv));\r\n            }\r\n        };\r\n        CollisionContact.prototype._resolveBoxCollision = function () {\r\n            var bodyA = this.bodyA.body.actor;\r\n            var bodyB = this.bodyB.body.actor;\r\n            var side = Util.getSideFromVector(this.mtv);\r\n            var mtv = this.mtv.negate();\r\n            // Publish collision events on both participants\r\n            bodyA.emit(\'precollision\', new Events_1.PreCollisionEvent(bodyA, bodyB, side, mtv));\r\n            bodyB.emit(\'precollision\', new Events_1.PreCollisionEvent(bodyB, bodyA, Util.getOppositeSide(side), mtv.negate()));\r\n            this._applyBoxImpulse(bodyA, bodyB, mtv);\r\n            this._applyBoxImpulse(bodyB, bodyA, mtv.negate());\r\n        };\r\n        CollisionContact.prototype._resolveRigidBodyCollision = function () {\r\n            // perform collison on bounding areas\r\n            var bodyA = this.bodyA.body;\r\n            var bodyB = this.bodyB.body;\r\n            var mtv = this.mtv; // normal pointing away from bodyA\r\n            var normal = this.normal; // normal pointing away from bodyA\r\n            if (bodyA.actor === bodyB.actor) {\r\n                return;\r\n            }\r\n            // Publish collision events on both participants\r\n            var side = Util.getSideFromVector(this.mtv);\r\n            bodyA.actor.emit(\'precollision\', new Events_1.PreCollisionEvent(this.bodyA.body.actor, this.bodyB.body.actor, side, this.mtv));\r\n            bodyB.actor.emit(\'precollision\', new Events_1.PreCollisionEvent(this.bodyB.body.actor, this.bodyA.body.actor, Util.getOppositeSide(side), this.mtv.negate()));\r\n            // If any of the participants are passive then short circuit\r\n            if (bodyA.actor.collisionType === Actor_1.CollisionType.Passive ||\r\n                bodyB.actor.collisionType === Actor_1.CollisionType.Passive) {\r\n                return;\r\n            }\r\n            var invMassA = bodyA.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyA.mass;\r\n            var invMassB = bodyB.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyB.mass;\r\n            var invMoiA = bodyA.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyA.moi;\r\n            var invMoiB = bodyB.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyB.moi;\r\n            // average restitution more relistic\r\n            var coefRestitution = Math.min(bodyA.restitution, bodyB.restitution);\r\n            var coefFriction = Math.min(bodyA.friction, bodyB.friction);\r\n            normal = normal.normalize();\r\n            var tangent = normal.normal().normalize();\r\n            var ra = this.point.sub(this.bodyA.getCenter()); // point relative to bodyA position\r\n            var rb = this.point.sub(this.bodyB.getCenter()); /// point relative to bodyB\r\n            // Relative velocity in linear terms\r\n            // Angular to linear velocity formula -> omega = v/r\r\n            var rv = bodyB.vel.add(rb.cross(-bodyB.rx)).sub(bodyA.vel.sub(ra.cross(bodyA.rx)));\r\n            var rvNormal = rv.dot(normal);\r\n            var rvTangent = rv.dot(tangent);\r\n            var raTangent = ra.dot(tangent);\r\n            var raNormal = ra.dot(normal);\r\n            var rbTangent = rb.dot(tangent);\r\n            var rbNormal = rb.dot(normal);\r\n            // If objects are moving away ignore\r\n            if (rvNormal > 0) {\r\n                return;\r\n            }\r\n            // Collision impulse formula from Chris Hecker\r\n            // https://en.wikipedia.org/wiki/Collision_response\r\n            var impulse = -((1 + coefRestitution) * rvNormal) /\r\n                ((invMassA + invMassB) + invMoiA * raTangent * raTangent + invMoiB * rbTangent * rbTangent);\r\n            if (bodyA.actor.collisionType === Actor_1.CollisionType.Fixed) {\r\n                bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));\r\n                if (Physics_1.Physics.allowRigidBodyRotation) {\r\n                    bodyB.rx -= impulse * invMoiB * -rb.cross(normal);\r\n                }\r\n                bodyB.addMtv(mtv);\r\n            }\r\n            else if (bodyB.actor.collisionType === Actor_1.CollisionType.Fixed) {\r\n                bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));\r\n                if (Physics_1.Physics.allowRigidBodyRotation) {\r\n                    bodyA.rx += impulse * invMoiA * -ra.cross(normal);\r\n                }\r\n                bodyA.addMtv(mtv.negate());\r\n            }\r\n            else {\r\n                bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));\r\n                bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));\r\n                if (Physics_1.Physics.allowRigidBodyRotation) {\r\n                    bodyB.rx -= impulse * invMoiB * -rb.cross(normal);\r\n                    bodyA.rx += impulse * invMoiA * -ra.cross(normal);\r\n                }\r\n                // Split the mtv in half for the two bodies, potentially we could do something smarter here\r\n                bodyB.addMtv(mtv.scale(.5));\r\n                bodyA.addMtv(mtv.scale(-.5));\r\n            }\r\n            // Friction portion of impulse\r\n            if (coefFriction && rvTangent) {\r\n                // Columb model of friction, formula for impulse due to friction from  \r\n                // https://en.wikipedia.org/wiki/Collision_response\r\n                // tangent force exerted by body on another in contact\r\n                var t = rv.sub(normal.scale(rv.dot(normal))).normalize();\r\n                // impulse in the direction of tangent force\r\n                var jt = rv.dot(t) / (invMassA + invMassB + raNormal * raNormal * invMoiA + rbNormal * rbNormal * invMoiB);\r\n                var frictionImpulse = new Algebra_4.Vector(0, 0);\r\n                if (Math.abs(jt) <= impulse * coefFriction) {\r\n                    frictionImpulse = t.scale(jt).negate();\r\n                }\r\n                else {\r\n                    frictionImpulse = t.scale(-impulse * coefFriction);\r\n                }\r\n                if (bodyA.actor.collisionType === Actor_1.CollisionType.Fixed) {\r\n                    // apply frictional impulse\r\n                    bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));\r\n                    if (Physics_1.Physics.allowRigidBodyRotation) {\r\n                        bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);\r\n                    }\r\n                }\r\n                else if (bodyB.actor.collisionType === Actor_1.CollisionType.Fixed) {\r\n                    // apply frictional impulse\r\n                    bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));\r\n                    if (Physics_1.Physics.allowRigidBodyRotation) {\r\n                        bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);\r\n                    }\r\n                }\r\n                else {\r\n                    // apply frictional impulse\r\n                    bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));\r\n                    bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));\r\n                    // apply frictional impulse\r\n                    if (Physics_1.Physics.allowRigidBodyRotation) {\r\n                        bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);\r\n                        bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);\r\n                    }\r\n                }\r\n            }\r\n            bodyA.actor.emit(\'postcollision\', new Events_1.PostCollisionEvent(this.bodyA.body.actor, this.bodyB.body.actor, side, this.mtv));\r\n            bodyB.actor.emit(\'postcollision\', new Events_1.PostCollisionEvent(this.bodyB.body.actor, this.bodyA.body.actor, Util.getOppositeSide(side), this.mtv.negate()));\r\n        };\r\n        return CollisionContact;\r\n    }());\r\n    exports.CollisionContact = CollisionContact;\r\n});\r\ndefine("Collision/ICollisionArea", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Collision/CircleArea", ["require", "exports", "Collision/BoundingBox", "Collision/PolygonArea", "Collision/EdgeArea", "Collision/CollisionJumpTable", "Algebra", "Physics", "Drawing/Color"], function (require, exports, BoundingBox_1, PolygonArea_1, EdgeArea_1, CollisionJumpTable_1, Algebra_5, Physics_2, Color_1) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * This is a circle collision area for the excalibur rigid body physics simulation\r\n     */\r\n    var CircleArea = (function () {\r\n        function CircleArea(options) {\r\n            /**\r\n             * This is the center position of the circle, relative to the body position\r\n             */\r\n            this.pos = Algebra_5.Vector.Zero.clone();\r\n            this.pos = options.pos || Algebra_5.Vector.Zero.clone();\r\n            this.radius = options.radius || 0;\r\n            this.body = options.body || null;\r\n        }\r\n        /**\r\n         * Get the center of the collision area in world coordinates\r\n         */\r\n        CircleArea.prototype.getCenter = function () {\r\n            if (this.body) {\r\n                return this.pos.add(this.body.pos);\r\n            }\r\n            return this.pos;\r\n        };\r\n        /**\r\n         * Tests if a point is contained in this collision area\r\n         */\r\n        CircleArea.prototype.contains = function (point) {\r\n            var distance = this.body.pos.distance(point);\r\n            if (distance <= this.radius) {\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        /**\r\n         * Casts a ray at the CircleArea and returns the nearest point of collision\r\n         * @param ray\r\n         */\r\n        CircleArea.prototype.rayCast = function (ray, max) {\r\n            if (max === void 0) { max = Infinity; }\r\n            //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\r\n            var c = this.getCenter();\r\n            var dir = ray.dir;\r\n            var orig = ray.pos;\r\n            var discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) -\r\n                Math.pow(orig.sub(c).distance(), 2) +\r\n                Math.pow(this.radius, 2));\r\n            if (discriminant < 0) {\r\n                // no intersection\r\n                return null;\r\n            }\r\n            else {\r\n                var toi = 0;\r\n                if (discriminant === 0) {\r\n                    toi = -dir.dot(orig.sub(c));\r\n                    if (toi > 0 && toi < max) {\r\n                        return ray.getPoint(toi);\r\n                    }\r\n                    return null;\r\n                }\r\n                else {\r\n                    var toi1 = -dir.dot(orig.sub(c)) + discriminant;\r\n                    var toi2 = -dir.dot(orig.sub(c)) - discriminant;\r\n                    var mintoi = Math.min(toi1, toi2);\r\n                    if (mintoi <= max) {\r\n                        return ray.getPoint(mintoi);\r\n                    }\r\n                    return null;\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * @inheritdoc\r\n         */\r\n        CircleArea.prototype.collide = function (area) {\r\n            if (area instanceof CircleArea) {\r\n                return CollisionJumpTable_1.CollisionJumpTable.CollideCircleCircle(this, area);\r\n            }\r\n            else if (area instanceof PolygonArea_1.PolygonArea) {\r\n                return CollisionJumpTable_1.CollisionJumpTable.CollideCirclePolygon(this, area);\r\n            }\r\n            else if (area instanceof EdgeArea_1.EdgeArea) {\r\n                return CollisionJumpTable_1.CollisionJumpTable.CollideCircleEdge(this, area);\r\n            }\r\n            else {\r\n                throw new Error("Circle could not collide with unknown ICollisionArea " + typeof area);\r\n            }\r\n        };\r\n        /**\r\n         * Find the point on the shape furthest in the direction specified\r\n         */\r\n        CircleArea.prototype.getFurthestPoint = function (direction) {\r\n            return this.getCenter().add(direction.normalize().scale(this.radius));\r\n        };\r\n        /**\r\n         * Get the axis aligned bounding box for the circle area\r\n         */\r\n        CircleArea.prototype.getBounds = function () {\r\n            return new BoundingBox_1.BoundingBox(this.pos.x + this.body.pos.x - this.radius, this.pos.y + this.body.pos.y - this.radius, this.pos.x + this.body.pos.x + this.radius, this.pos.y + this.body.pos.y + this.radius);\r\n        };\r\n        /**\r\n         * Get axis not implemented on circles, since there are infinite axis in a circle\r\n         */\r\n        CircleArea.prototype.getAxes = function () {\r\n            return null;\r\n        };\r\n        /**\r\n         * Returns the moment of inertia of a circle given it\'s mass\r\n         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n         */\r\n        CircleArea.prototype.getMomentOfInertia = function () {\r\n            var mass = this.body ? this.body.mass : Physics_2.Physics.defaultMass;\r\n            return (mass * this.radius * this.radius) / 2;\r\n        };\r\n        /**\r\n         * Tests the separating axis theorem for circles against polygons\r\n         */\r\n        CircleArea.prototype.testSeparatingAxisTheorem = function (polygon) {\r\n            var axes = polygon.getAxes();\r\n            var pc = polygon.getCenter();\r\n            // Special SAT with circles\r\n            var closestPointOnPoly = polygon.getFurthestPoint(this.pos.sub(pc));\r\n            axes.push(this.pos.sub(closestPointOnPoly).normalize());\r\n            var minOverlap = Number.MAX_VALUE;\r\n            var minAxis = null;\r\n            var minIndex = -1;\r\n            for (var i = 0; i < axes.length; i++) {\r\n                var proj1 = polygon.project(axes[i]);\r\n                var proj2 = this.project(axes[i]);\r\n                var overlap = proj1.getOverlap(proj2);\r\n                if (overlap <= 0) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    if (overlap < minOverlap) {\r\n                        minOverlap = overlap;\r\n                        minAxis = axes[i];\r\n                        minIndex = i;\r\n                    }\r\n                }\r\n            }\r\n            if (minIndex < 0) {\r\n                return null;\r\n            }\r\n            return minAxis.normalize().scale(minOverlap);\r\n        };\r\n        /* istanbul ignore next */\r\n        CircleArea.prototype.recalc = function () {\r\n            // circles don\'t cache\r\n        };\r\n        /**\r\n         * Project the circle along a specified axis\r\n         */\r\n        CircleArea.prototype.project = function (axis) {\r\n            var scalars = [];\r\n            var point = this.getCenter();\r\n            var dotProduct = point.dot(axis);\r\n            scalars.push(dotProduct);\r\n            scalars.push(dotProduct + this.radius);\r\n            scalars.push(dotProduct - this.radius);\r\n            return new Algebra_5.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n        };\r\n        /* istanbul ignore next */\r\n        CircleArea.prototype.debugDraw = function (ctx, color) {\r\n            if (color === void 0) { color = Color_1.Color.Green.clone(); }\r\n            var pos = this.body ? this.body.pos.add(this.pos) : this.pos;\r\n            var rotation = this.body ? this.body.rotation : 0;\r\n            ctx.beginPath();\r\n            ctx.strokeStyle = color.toString();\r\n            ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n            ctx.beginPath();\r\n            ctx.moveTo(pos.x, pos.y);\r\n            ctx.lineTo(Math.cos(rotation) * this.radius + pos.x, Math.sin(rotation) * this.radius + pos.y);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n        };\r\n        return CircleArea;\r\n    }());\r\n    exports.CircleArea = CircleArea;\r\n});\r\ndefine("Collision/CollisionJumpTable", ["require", "exports", "Collision/CollisionContact", "Collision/PolygonArea"], function (require, exports, CollisionContact_1, PolygonArea_2) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    exports.CollisionJumpTable = {\r\n        CollideCircleCircle: function (circleA, circleB) {\r\n            var radius = circleA.radius + circleB.radius;\r\n            var circleAPos = circleA.body.pos.add(circleA.pos);\r\n            var circleBPos = circleB.body.pos.add(circleB.pos);\r\n            if (circleAPos.distance(circleBPos) > radius) {\r\n                return null;\r\n            }\r\n            var axisOfCollision = circleBPos.sub(circleAPos).normalize();\r\n            var mvt = axisOfCollision.scale(radius - circleBPos.distance(circleAPos));\r\n            var pointOfCollision = circleA.getFurthestPoint(axisOfCollision);\r\n            return new CollisionContact_1.CollisionContact(circleA, circleB, mvt, pointOfCollision, axisOfCollision);\r\n        },\r\n        CollideCirclePolygon: function (circle, polygon) {\r\n            var minAxis = circle.testSeparatingAxisTheorem(polygon);\r\n            if (!minAxis) {\r\n                return null;\r\n            }\r\n            // make sure that the minAxis is pointing away from circle\r\n            var samedir = minAxis.dot(polygon.getCenter().sub(circle.getCenter()));\r\n            minAxis = samedir < 0 ? minAxis.negate() : minAxis;\r\n            var verts = [];\r\n            var point1 = polygon.getFurthestPoint(minAxis.negate());\r\n            var point2 = circle.getFurthestPoint(minAxis); //.add(cc);\r\n            if (circle.contains(point1)) {\r\n                verts.push(point1);\r\n            }\r\n            if (polygon.contains(point2)) {\r\n                verts.push(point2);\r\n            }\r\n            if (verts.length === 0) {\r\n                return null;\r\n            }\r\n            return new CollisionContact_1.CollisionContact(circle, polygon, minAxis, verts.length === 2 ? verts[0].average(verts[1]) : verts[0], minAxis.normalize());\r\n        },\r\n        CollideCircleEdge: function (circle, edge) {\r\n            // center of the circle\r\n            var cc = circle.getCenter();\r\n            // vector in the direction of the edge\r\n            var e = edge.end.sub(edge.begin);\r\n            // amount of overlap with the circle\'s center along the edge direction\r\n            var u = e.dot(edge.end.sub(cc));\r\n            var v = e.dot(cc.sub(edge.begin));\r\n            // Potential region A collision (circle is on the left side of the edge, before the beginning)\r\n            if (v <= 0) {\r\n                var da = edge.begin.sub(cc);\r\n                var dda = da.dot(da); // quick and dirty way of calc\'n distance in r^2 terms saves some sqrts\r\n                // save some sqrts\r\n                if (dda > circle.radius * circle.radius) {\r\n                    return null; // no collision\r\n                }\r\n                return new CollisionContact_1.CollisionContact(circle, edge, da.normalize().scale(circle.radius - Math.sqrt(dda)), edge.begin, da.normalize());\r\n            }\r\n            // Potential region B collision (circle is on the right side of the edge, after the end)\r\n            if (u <= 0) {\r\n                var db = edge.end.sub(cc);\r\n                var ddb = db.dot(db);\r\n                if (ddb > circle.radius * circle.radius) {\r\n                    return null;\r\n                }\r\n                return new CollisionContact_1.CollisionContact(circle, edge, db.normalize().scale(circle.radius - Math.sqrt(ddb)), edge.end, db.normalize());\r\n            }\r\n            // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)\r\n            var den = e.dot(e);\r\n            var pointOnEdge = (edge.begin.scale(u).add(edge.end.scale(v))).scale(1 / den);\r\n            var d = cc.sub(pointOnEdge);\r\n            var dd = d.dot(d);\r\n            if (dd > circle.radius * circle.radius) {\r\n                return null; // no collision\r\n            }\r\n            var n = e.perpendicular();\r\n            // flip correct direction\r\n            if (n.dot(cc.sub(edge.begin)) < 0) {\r\n                n.x = -n.x;\r\n                n.y = -n.y;\r\n            }\r\n            n = n.normalize();\r\n            var mvt = n.scale(Math.abs(circle.radius - Math.sqrt(dd)));\r\n            return new CollisionContact_1.CollisionContact(circle, edge, mvt.negate(), pointOnEdge, n.negate());\r\n        },\r\n        CollideEdgeEdge: function () {\r\n            // Edge-edge collision doesn\'t make sense\r\n            return null;\r\n        },\r\n        CollidePolygonEdge: function (polygon, edge) {\r\n            // 3 cases:\r\n            // (1) Polygon lands on the full face\r\n            // (2) Polygon lands on the right point\r\n            // (3) Polygon lands on the left point\r\n            var e = edge.end.sub(edge.begin);\r\n            var edgeNormal = e.normal();\r\n            if (polygon.contains(edge.begin)) {\r\n                var _a = polygon.getClosestFace(edge.begin), mtv = _a.distance, face = _a.face;\r\n                if (mtv) {\r\n                    return new CollisionContact_1.CollisionContact(polygon, edge, mtv.negate(), edge.begin.add(mtv.negate()), face.normal().negate());\r\n                }\r\n            }\r\n            if (polygon.contains(edge.end)) {\r\n                var _b = polygon.getClosestFace(edge.end), mtv = _b.distance, face = _b.face;\r\n                if (mtv) {\r\n                    return new CollisionContact_1.CollisionContact(polygon, edge, mtv.negate(), edge.end.add(mtv.negate()), face.normal().negate());\r\n                }\r\n            }\r\n            var pc = polygon.getCenter();\r\n            var ec = edge.getCenter();\r\n            var dir = ec.sub(pc).normalize();\r\n            // build a temporary polygon from the edge to use SAT\r\n            var linePoly = new PolygonArea_2.PolygonArea({\r\n                points: [\r\n                    edge.begin,\r\n                    edge.end,\r\n                    edge.end.add(dir.scale(30)),\r\n                    edge.begin.add(dir.scale(30))\r\n                ]\r\n            });\r\n            var minAxis = polygon.testSeparatingAxisTheorem(linePoly);\r\n            // no minAxis, no overlap, no collision\r\n            if (!minAxis) {\r\n                return null;\r\n            }\r\n            // flip the normal and axis to always have positive collisions\r\n            edgeNormal = edgeNormal.dot(dir) < 0 ? edgeNormal.negate() : edgeNormal;\r\n            minAxis = minAxis.dot(dir) < 0 ? minAxis.negate() : minAxis;\r\n            return new CollisionContact_1.CollisionContact(polygon, edge, minAxis, polygon.getFurthestPoint(edgeNormal), edgeNormal);\r\n        },\r\n        CollidePolygonPolygon: function (polyA, polyB) {\r\n            // do a SAT test to find a min axis if it exists\r\n            var minAxis = polyA.testSeparatingAxisTheorem(polyB);\r\n            // no overlap, no collision return null\r\n            if (!minAxis) {\r\n                return null;\r\n            }\r\n            // make sure that minAxis is pointing from A -> B\r\n            var sameDir = minAxis.dot(polyB.getCenter().sub(polyA.getCenter()));\r\n            minAxis = sameDir < 0 ? minAxis.negate() : minAxis;\r\n            // find rough point of collision\r\n            // todo this could be better\r\n            var verts = [];\r\n            var pointA = polyA.getFurthestPoint(minAxis);\r\n            var pointB = polyB.getFurthestPoint(minAxis.negate());\r\n            if (polyB.contains(pointA)) {\r\n                verts.push(pointA);\r\n            }\r\n            if (polyA.contains(pointB)) {\r\n                verts.push(pointB);\r\n            }\r\n            // no candidates, pick something\r\n            if (verts.length === 0) {\r\n                verts.push(pointB);\r\n            }\r\n            var contact = verts.length === 2 ? verts[0].add(verts[1]).scale(.5) : verts[0];\r\n            return new CollisionContact_1.CollisionContact(polyA, polyB, minAxis, contact, minAxis.normalize());\r\n        }\r\n    };\r\n});\r\ndefine("Collision/PolygonArea", ["require", "exports", "Drawing/Color", "Physics", "Collision/BoundingBox", "Collision/EdgeArea", "Collision/CollisionJumpTable", "Collision/CircleArea", "Algebra"], function (require, exports, Color_2, Physics_3, BoundingBox_2, EdgeArea_2, CollisionJumpTable_2, CircleArea_1, Algebra_6) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Polygon collision area for detecting collisions for actors, or independently\r\n     */\r\n    var PolygonArea = (function () {\r\n        function PolygonArea(options) {\r\n            this._transformedPoints = [];\r\n            this._axes = [];\r\n            this._sides = [];\r\n            this.pos = options.pos || Algebra_6.Vector.Zero.clone();\r\n            var winding = !!options.clockwiseWinding;\r\n            this.points = (winding ? options.points.reverse() : options.points) || [];\r\n            this.body = options.body || null;\r\n            // calculate initial transformation\r\n            this._calculateTransformation();\r\n        }\r\n        /**\r\n         * Get the center of the collision area in world coordinates\r\n         */\r\n        PolygonArea.prototype.getCenter = function () {\r\n            if (this.body) {\r\n                return this.body.pos.add(this.pos);\r\n            }\r\n            return this.pos;\r\n        };\r\n        /**\r\n         * Calculates the underlying transformation from the body relative space to world space\r\n         */\r\n        PolygonArea.prototype._calculateTransformation = function () {\r\n            var pos = this.body ? this.body.pos.add(this.pos) : this.pos;\r\n            var angle = this.body ? this.body.rotation : 0;\r\n            var len = this.points.length;\r\n            this._transformedPoints.length = 0; // clear out old transform\r\n            for (var i = 0; i < len; i++) {\r\n                this._transformedPoints[i] = this.points[i].rotate(angle).add(pos);\r\n            }\r\n        };\r\n        /**\r\n         * Gets the points that make up the polygon in world space, from actor relative space (if specified)\r\n         */\r\n        PolygonArea.prototype.getTransformedPoints = function () {\r\n            if (!this._transformedPoints.length) {\r\n                this._calculateTransformation();\r\n            }\r\n            ;\r\n            return this._transformedPoints;\r\n        };\r\n        /**\r\n         * Gets the sides of the polygon in world space\r\n         */\r\n        PolygonArea.prototype.getSides = function () {\r\n            if (this._sides.length) {\r\n                return this._sides;\r\n            }\r\n            var lines = [];\r\n            var points = this.getTransformedPoints();\r\n            var len = points.length;\r\n            for (var i = 0; i < len; i++) {\r\n                lines.push(new Algebra_6.Line(points[i], points[(i - 1 + len) % len]));\r\n            }\r\n            this._sides = lines;\r\n            return this._sides;\r\n        };\r\n        PolygonArea.prototype.recalc = function () {\r\n            this._sides.length = 0;\r\n            this._axes.length = 0;\r\n            this._transformedPoints.length = 0;\r\n            this.getTransformedPoints();\r\n            this.getAxes();\r\n            this.getSides();\r\n        };\r\n        /**\r\n         * Tests if a point is contained in this collision area in world space\r\n         */\r\n        PolygonArea.prototype.contains = function (point) {\r\n            // Always cast to the right, as long as we cast in a consitent fixed direction we\r\n            // will be fine\r\n            var testRay = new Algebra_6.Ray(point, new Algebra_6.Vector(1, 0));\r\n            var intersectCount = this.getSides().reduce(function (accum, side) {\r\n                if (testRay.intersect(side) >= 0) {\r\n                    return accum + 1;\r\n                }\r\n                return accum;\r\n            }, 0);\r\n            if (intersectCount % 2 === 0) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        /**\r\n         * Returns a collision contact if the 2 collision areas collide, otherwise collide will\r\n         * return null.\r\n         * @param area\r\n         */\r\n        PolygonArea.prototype.collide = function (area) {\r\n            if (area instanceof CircleArea_1.CircleArea) {\r\n                return CollisionJumpTable_2.CollisionJumpTable.CollideCirclePolygon(area, this);\r\n            }\r\n            else if (area instanceof PolygonArea) {\r\n                return CollisionJumpTable_2.CollisionJumpTable.CollidePolygonPolygon(this, area);\r\n            }\r\n            else if (area instanceof EdgeArea_2.EdgeArea) {\r\n                return CollisionJumpTable_2.CollisionJumpTable.CollidePolygonEdge(this, area);\r\n            }\r\n            else {\r\n                throw new Error("Polygon could not collide with unknown ICollisionArea " + typeof area);\r\n            }\r\n        };\r\n        /**\r\n         * Find the point on the shape furthest in the direction specified\r\n         */\r\n        PolygonArea.prototype.getFurthestPoint = function (direction) {\r\n            var pts = this.getTransformedPoints();\r\n            var furthestPoint = null;\r\n            var maxDistance = -Number.MAX_VALUE;\r\n            for (var i = 0; i < pts.length; i++) {\r\n                var distance = direction.dot(pts[i]);\r\n                if (distance > maxDistance) {\r\n                    maxDistance = distance;\r\n                    furthestPoint = pts[i];\r\n                }\r\n            }\r\n            return furthestPoint;\r\n        };\r\n        /**\r\n         * Finds the closes face to the point using perpendicular distance\r\n         * @param point point to test against polygon\r\n         */\r\n        PolygonArea.prototype.getClosestFace = function (point) {\r\n            var sides = this.getSides();\r\n            var min = Number.POSITIVE_INFINITY;\r\n            var faceIndex = -1;\r\n            var distance = -1;\r\n            for (var i = 0; i < sides.length; i++) {\r\n                var dist = sides[i].distanceToPoint(point);\r\n                if (dist < min) {\r\n                    min = dist;\r\n                    faceIndex = i;\r\n                    distance = dist;\r\n                }\r\n            }\r\n            if (faceIndex !== -1) {\r\n                return {\r\n                    distance: sides[faceIndex].normal().scale(distance),\r\n                    face: sides[faceIndex]\r\n                };\r\n            }\r\n            return null;\r\n        };\r\n        /**\r\n         * Get the axis aligned bounding box for the polygon area\r\n         */\r\n        PolygonArea.prototype.getBounds = function () {\r\n            // todo there is a faster way to do this\r\n            var points = this.getTransformedPoints();\r\n            var minX = points.reduce(function (prev, curr) {\r\n                return Math.min(prev, curr.x);\r\n            }, 999999999);\r\n            var maxX = points.reduce(function (prev, curr) {\r\n                return Math.max(prev, curr.x);\r\n            }, -99999999);\r\n            var minY = points.reduce(function (prev, curr) {\r\n                return Math.min(prev, curr.y);\r\n            }, 9999999999);\r\n            var maxY = points.reduce(function (prev, curr) {\r\n                return Math.max(prev, curr.y);\r\n            }, -9999999999);\r\n            return new BoundingBox_2.BoundingBox(minX, minY, maxX, maxY);\r\n        };\r\n        /**\r\n         * Get the moment of inertia for an arbitrary polygon\r\n         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n         */\r\n        PolygonArea.prototype.getMomentOfInertia = function () {\r\n            var mass = this.body ? this.body.mass : Physics_3.Physics.defaultMass;\r\n            var numerator = 0;\r\n            var denominator = 0;\r\n            for (var i = 0; i < this.points.length; i++) {\r\n                var iplusone = (i + 1) % this.points.length;\r\n                var crossTerm = this.points[iplusone].cross(this.points[i]);\r\n                numerator += crossTerm * (this.points[i].dot(this.points[i]) +\r\n                    this.points[i].dot(this.points[iplusone]) +\r\n                    this.points[iplusone].dot(this.points[iplusone]));\r\n                denominator += crossTerm;\r\n            }\r\n            return (mass / 6) * (numerator / denominator);\r\n        };\r\n        /**\r\n         * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.\r\n         */\r\n        PolygonArea.prototype.rayCast = function (ray, max) {\r\n            if (max === void 0) { max = Infinity; }\r\n            // find the minimum contact time greater than 0\r\n            // contact times less than 0 are behind the ray and we don\'t want those\r\n            var sides = this.getSides();\r\n            var len = sides.length;\r\n            var minContactTime = Number.MAX_VALUE;\r\n            var contactIndex = -1;\r\n            for (var i = 0; i < len; i++) {\r\n                var contactTime = ray.intersect(sides[i]);\r\n                if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {\r\n                    minContactTime = contactTime;\r\n                    contactIndex = i;\r\n                }\r\n            }\r\n            // contact was found\r\n            if (contactIndex >= 0) {\r\n                return ray.getPoint(minContactTime);\r\n            }\r\n            // no contact found\r\n            return null;\r\n        };\r\n        /**\r\n         * Get the axis associated with the edge\r\n         */\r\n        PolygonArea.prototype.getAxes = function () {\r\n            if (this._axes.length) {\r\n                return this._axes;\r\n            }\r\n            var axes = [];\r\n            var points = this.getTransformedPoints();\r\n            var len = points.length;\r\n            for (var i = 0; i < len; i++) {\r\n                axes.push(points[i].sub(points[(i + 1) % len]).normal());\r\n            }\r\n            this._axes = axes;\r\n            return this._axes;\r\n        };\r\n        /**\r\n         * Perform Separating Axis test against another polygon, returns null if no overlap in polys\r\n         * Reference http://www.dyn4j.org/2010/01/sat/\r\n         */\r\n        PolygonArea.prototype.testSeparatingAxisTheorem = function (other) {\r\n            var poly1 = this;\r\n            var poly2 = other;\r\n            var axes = poly1.getAxes().concat(poly2.getAxes());\r\n            var minOverlap = Number.MAX_VALUE;\r\n            var minAxis = null;\r\n            var minIndex = -1;\r\n            for (var i = 0; i < axes.length; i++) {\r\n                var proj1 = poly1.project(axes[i]);\r\n                var proj2 = poly2.project(axes[i]);\r\n                var overlap = proj1.getOverlap(proj2);\r\n                if (overlap <= 0) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    if (overlap < minOverlap) {\r\n                        minOverlap = overlap;\r\n                        minAxis = axes[i];\r\n                        minIndex = i;\r\n                    }\r\n                }\r\n            }\r\n            // Sanity check\r\n            if (minIndex === -1) {\r\n                return null;\r\n            }\r\n            return minAxis.normalize().scale(minOverlap);\r\n        };\r\n        /**\r\n         * Project the edges of the polygon along a specified axis\r\n         */\r\n        PolygonArea.prototype.project = function (axis) {\r\n            var points = this.getTransformedPoints();\r\n            var len = points.length;\r\n            var min = Number.MAX_VALUE;\r\n            var max = -Number.MAX_VALUE;\r\n            for (var i = 0; i < len; i++) {\r\n                var scalar = points[i].dot(axis);\r\n                min = Math.min(min, scalar);\r\n                max = Math.max(max, scalar);\r\n            }\r\n            return new Algebra_6.Projection(min, max);\r\n        };\r\n        /* istanbul ignore next */\r\n        PolygonArea.prototype.debugDraw = function (ctx, color) {\r\n            if (color === void 0) { color = Color_2.Color.Red.clone(); }\r\n            ctx.beginPath();\r\n            ctx.strokeStyle = color.toString();\r\n            // Iterate through the supplied points and construct a \'polygon\'\r\n            var firstPoint = this.getTransformedPoints()[0];\r\n            ctx.moveTo(firstPoint.x, firstPoint.y);\r\n            this.getTransformedPoints().forEach(function (point) {\r\n                ctx.lineTo(point.x, point.y);\r\n            });\r\n            ctx.lineTo(firstPoint.x, firstPoint.y);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n        };\r\n        return PolygonArea;\r\n    }());\r\n    exports.PolygonArea = PolygonArea;\r\n});\r\ndefine("Collision/BoundingBox", ["require", "exports", "Collision/PolygonArea", "Algebra", "Drawing/Color"], function (require, exports, PolygonArea_3, Algebra_7, Color_3) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Axis Aligned collision primitive for Excalibur.\r\n     */\r\n    var BoundingBox = (function () {\r\n        /**\r\n         * @param left    x coordinate of the left edge\r\n         * @param top     y coordinate of the top edge\r\n         * @param right   x coordinate of the right edge\r\n         * @param bottom  y coordinate of the bottom edge\r\n         */\r\n        function BoundingBox(left, top, right, bottom) {\r\n            if (left === void 0) { left = 0; }\r\n            if (top === void 0) { top = 0; }\r\n            if (right === void 0) { right = 0; }\r\n            if (bottom === void 0) { bottom = 0; }\r\n            this.left = left;\r\n            this.top = top;\r\n            this.right = right;\r\n            this.bottom = bottom;\r\n        }\r\n        BoundingBox.fromPoints = function (points) {\r\n            var minX = Infinity;\r\n            var minY = Infinity;\r\n            var maxX = -Infinity;\r\n            var maxY = -Infinity;\r\n            for (var i = 0; i < points.length; i++) {\r\n                if (points[i].x < minX) {\r\n                    minX = points[i].x;\r\n                }\r\n                if (points[i].x > maxX) {\r\n                    maxX = points[i].x;\r\n                }\r\n                if (points[i].y < minY) {\r\n                    minY = points[i].y;\r\n                }\r\n                if (points[i].y > maxY) {\r\n                    maxY = points[i].y;\r\n                }\r\n            }\r\n            return new BoundingBox(minX, minY, maxX, maxY);\r\n        };\r\n        /**\r\n         * Returns the calculated width of the bounding box\r\n         */\r\n        BoundingBox.prototype.getWidth = function () {\r\n            return this.right - this.left;\r\n        };\r\n        /**\r\n         * Returns the calculated height of the bounding box\r\n         */\r\n        BoundingBox.prototype.getHeight = function () {\r\n            return this.bottom - this.top;\r\n        };\r\n        /**\r\n         * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default\r\n         */\r\n        BoundingBox.prototype.rotate = function (angle, point) {\r\n            if (point === void 0) { point = Algebra_7.Vector.Zero.clone(); }\r\n            var points = this.getPoints().map(function (p) { return p.rotate(angle, point); });\r\n            return BoundingBox.fromPoints(points);\r\n        };\r\n        /**\r\n         * Returns the perimeter of the bounding box\r\n         */\r\n        BoundingBox.prototype.getPerimeter = function () {\r\n            var wx = this.getWidth();\r\n            var wy = this.getHeight();\r\n            return 2 * (wx + wy);\r\n        };\r\n        BoundingBox.prototype.getPoints = function () {\r\n            var results = [];\r\n            results.push(new Algebra_7.Vector(this.left, this.top));\r\n            results.push(new Algebra_7.Vector(this.right, this.top));\r\n            results.push(new Algebra_7.Vector(this.right, this.bottom));\r\n            results.push(new Algebra_7.Vector(this.left, this.bottom));\r\n            return results;\r\n        };\r\n        /**\r\n         * Creates a Polygon collision area from the points of the bounding box\r\n         */\r\n        BoundingBox.prototype.toPolygon = function (actor) {\r\n            return new PolygonArea_3.PolygonArea({\r\n                body: actor ? actor.body : null,\r\n                points: this.getPoints(),\r\n                pos: Algebra_7.Vector.Zero.clone()\r\n            });\r\n        };\r\n        /**\r\n         * Determines whether a ray intersects with a bounding box\r\n         */\r\n        BoundingBox.prototype.rayCast = function (ray, farClipDistance) {\r\n            if (farClipDistance === void 0) { farClipDistance = Infinity; }\r\n            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/ \r\n            var tmin = -Infinity;\r\n            var tmax = +Infinity;\r\n            var xinv = ray.dir.x === 0 ? Number.MAX_VALUE : (1 / ray.dir.x);\r\n            var yinv = ray.dir.y === 0 ? Number.MAX_VALUE : (1 / ray.dir.y);\r\n            var tx1 = (this.left - ray.pos.x) * xinv;\r\n            var tx2 = (this.right - ray.pos.x) * xinv;\r\n            tmin = Math.min(tx1, tx2);\r\n            tmax = Math.max(tx1, tx2);\r\n            var ty1 = (this.top - ray.pos.y) * yinv;\r\n            var ty2 = (this.bottom - ray.pos.y) * yinv;\r\n            tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n            tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n            return tmax >= Math.max(0, tmin) && tmin < farClipDistance;\r\n        };\r\n        BoundingBox.prototype.rayCastTime = function (ray, farClipDistance) {\r\n            if (farClipDistance === void 0) { farClipDistance = Infinity; }\r\n            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/ \r\n            var tmin = -Infinity;\r\n            var tmax = +Infinity;\r\n            var xinv = ray.dir.x === 0 ? Number.MAX_VALUE : (1 / ray.dir.x);\r\n            var yinv = ray.dir.y === 0 ? Number.MAX_VALUE : (1 / ray.dir.y);\r\n            var tx1 = (this.left - ray.pos.x) * xinv;\r\n            var tx2 = (this.right - ray.pos.x) * xinv;\r\n            tmin = Math.min(tx1, tx2);\r\n            tmax = Math.max(tx1, tx2);\r\n            var ty1 = (this.top - ray.pos.y) * yinv;\r\n            var ty2 = (this.bottom - ray.pos.y) * yinv;\r\n            tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n            tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n            if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {\r\n                return tmin;\r\n            }\r\n            return -1;\r\n        };\r\n        BoundingBox.prototype.contains = function (val) {\r\n            if (val instanceof Algebra_7.Vector) {\r\n                return (this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x);\r\n            }\r\n            else if (val instanceof BoundingBox) {\r\n                if (this.left < val.left &&\r\n                    this.top < val.top &&\r\n                    val.bottom < this.bottom &&\r\n                    val.right < this.right) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            return false;\r\n        };\r\n        /**\r\n         * Combines this bounding box and another together returning a new bounding box\r\n         * @param other  The bounding box to combine\r\n         */\r\n        BoundingBox.prototype.combine = function (other) {\r\n            var compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));\r\n            return compositeBB;\r\n        };\r\n        /**\r\n         * Test wether this bounding box collides with another returning,\r\n         * the intersection vector that can be used to resolve the collision. If there\r\n         * is no collision null is returned.\r\n         * @param collidable  Other collidable to test\r\n         */\r\n        BoundingBox.prototype.collides = function (collidable) {\r\n            if (collidable instanceof BoundingBox) {\r\n                var other = collidable;\r\n                var totalBoundingBox = this.combine(other);\r\n                // If the total bounding box is less than the sum of the 2 bounds then there is collision\r\n                if (totalBoundingBox.getWidth() < other.getWidth() + this.getWidth() &&\r\n                    totalBoundingBox.getHeight() < other.getHeight() + this.getHeight()) {\r\n                    // collision\r\n                    var overlapX = 0;\r\n                    if (this.right >= other.left && this.right <= other.right) {\r\n                        overlapX = other.left - this.right;\r\n                    }\r\n                    else {\r\n                        overlapX = other.right - this.left;\r\n                    }\r\n                    var overlapY = 0;\r\n                    if (this.top <= other.bottom && this.top >= other.top) {\r\n                        overlapY = other.bottom - this.top;\r\n                    }\r\n                    else {\r\n                        overlapY = other.top - this.bottom;\r\n                    }\r\n                    if (Math.abs(overlapX) < Math.abs(overlapY)) {\r\n                        return new Algebra_7.Vector(overlapX, 0);\r\n                    }\r\n                    else {\r\n                        return new Algebra_7.Vector(0, overlapY);\r\n                    }\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        /* istanbul ignore next */\r\n        BoundingBox.prototype.debugDraw = function (ctx, color) {\r\n            if (color === void 0) { color = Color_3.Color.Yellow; }\r\n            ctx.strokeStyle = color.toString();\r\n            ctx.strokeRect(this.left, this.top, this.getWidth(), this.getHeight());\r\n        };\r\n        return BoundingBox;\r\n    }());\r\n    exports.BoundingBox = BoundingBox;\r\n});\r\ndefine("Collision/EdgeArea", ["require", "exports", "Collision/BoundingBox", "Collision/CollisionJumpTable", "Collision/CircleArea", "Collision/PolygonArea", "Algebra", "Physics", "Drawing/Color"], function (require, exports, BoundingBox_3, CollisionJumpTable_3, CircleArea_2, PolygonArea_4, Algebra_8, Physics_4, Color_4) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var EdgeArea = (function () {\r\n        function EdgeArea(options) {\r\n            this.begin = options.begin || Algebra_8.Vector.Zero.clone();\r\n            this.end = options.end || Algebra_8.Vector.Zero.clone();\r\n            this.body = options.body || null;\r\n            this.pos = this.getCenter();\r\n        }\r\n        /**\r\n         * Get the center of the collision area in world coordinates\r\n         */\r\n        EdgeArea.prototype.getCenter = function () {\r\n            var pos = this.begin.average(this.end).add(this._getBodyPos());\r\n            return pos;\r\n        };\r\n        EdgeArea.prototype._getBodyPos = function () {\r\n            var bodyPos = Algebra_8.Vector.Zero.clone();\r\n            if (this.body.pos) {\r\n                bodyPos = this.body.pos;\r\n            }\r\n            return bodyPos;\r\n        };\r\n        EdgeArea.prototype._getTransformedBegin = function () {\r\n            var angle = this.body ? this.body.rotation : 0;\r\n            return this.begin.rotate(angle).add(this._getBodyPos());\r\n        };\r\n        EdgeArea.prototype._getTransformedEnd = function () {\r\n            var angle = this.body ? this.body.rotation : 0;\r\n            return this.end.rotate(angle).add(this._getBodyPos());\r\n        };\r\n        /**\r\n         * Returns the slope of the line in the form of a vector\r\n         */\r\n        EdgeArea.prototype.getSlope = function () {\r\n            var begin = this._getTransformedBegin();\r\n            var end = this._getTransformedEnd();\r\n            var distance = begin.distance(end);\r\n            return end.sub(begin).scale(1 / distance);\r\n        };\r\n        /**\r\n         * Returns the length of the line segment in pixels\r\n         */\r\n        EdgeArea.prototype.getLength = function () {\r\n            var begin = this._getTransformedBegin();\r\n            var end = this._getTransformedEnd();\r\n            var distance = begin.distance(end);\r\n            return distance;\r\n        };\r\n        /**\r\n         * Tests if a point is contained in this collision area\r\n         */\r\n        EdgeArea.prototype.contains = function () {\r\n            return false;\r\n        };\r\n        /**\r\n         * @inheritdoc\r\n         */\r\n        EdgeArea.prototype.rayCast = function (ray, max) {\r\n            if (max === void 0) { max = Infinity; }\r\n            var numerator = this._getTransformedBegin().sub(ray.pos);\r\n            // Test is line and ray are parallel and non intersecting\r\n            if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {\r\n                return null;\r\n            }\r\n            // Lines are parallel\r\n            var divisor = (ray.dir.cross(this.getSlope()));\r\n            if (divisor === 0) {\r\n                return null;\r\n            }\r\n            var t = numerator.cross(this.getSlope()) / divisor;\r\n            if (t >= 0 && t <= max) {\r\n                var u = (numerator.cross(ray.dir) / divisor) / this.getLength();\r\n                if (u >= 0 && u <= 1) {\r\n                    return ray.getPoint(t);\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        /**\r\n         * @inheritdoc\r\n         */\r\n        EdgeArea.prototype.collide = function (area) {\r\n            if (area instanceof CircleArea_2.CircleArea) {\r\n                return CollisionJumpTable_3.CollisionJumpTable.CollideCircleEdge(area, this);\r\n            }\r\n            else if (area instanceof PolygonArea_4.PolygonArea) {\r\n                return CollisionJumpTable_3.CollisionJumpTable.CollidePolygonEdge(area, this);\r\n            }\r\n            else if (area instanceof EdgeArea) {\r\n                return CollisionJumpTable_3.CollisionJumpTable.CollideEdgeEdge();\r\n            }\r\n            else {\r\n                throw new Error("Edge could not collide with unknown ICollisionArea " + typeof area);\r\n            }\r\n        };\r\n        /**\r\n         * Find the point on the shape furthest in the direction specified\r\n         */\r\n        EdgeArea.prototype.getFurthestPoint = function (direction) {\r\n            var transformedBegin = this._getTransformedBegin();\r\n            var transformedEnd = this._getTransformedEnd();\r\n            if (direction.dot(transformedBegin) > 0) {\r\n                return transformedBegin;\r\n            }\r\n            else {\r\n                return transformedEnd;\r\n            }\r\n        };\r\n        /**\r\n         * Get the axis aligned bounding box for the circle area\r\n         */\r\n        EdgeArea.prototype.getBounds = function () {\r\n            var transformedBegin = this._getTransformedBegin();\r\n            var transformedEnd = this._getTransformedEnd();\r\n            return new BoundingBox_3.BoundingBox(Math.min(transformedBegin.x, transformedEnd.x), Math.min(transformedBegin.y, transformedEnd.y), Math.max(transformedBegin.x, transformedEnd.x), Math.max(transformedBegin.y, transformedEnd.y));\r\n        };\r\n        /**\r\n         * Get the axis associated with the edge\r\n         */\r\n        EdgeArea.prototype.getAxes = function () {\r\n            var e = this._getTransformedEnd().sub(this._getTransformedBegin());\r\n            var edgeNormal = e.normal();\r\n            var axes = [];\r\n            axes.push(edgeNormal);\r\n            axes.push(edgeNormal.negate());\r\n            axes.push(edgeNormal.normal());\r\n            axes.push(edgeNormal.normal().negate());\r\n            return axes;\r\n        };\r\n        /**\r\n         * Get the moment of inertia for an edge\r\n         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n         */\r\n        EdgeArea.prototype.getMomentOfInertia = function () {\r\n            var mass = this.body ? this.body.mass : Physics_4.Physics.defaultMass;\r\n            var length = this.end.sub(this.begin).distance() / 2;\r\n            return mass * length * length;\r\n        };\r\n        /**\r\n         * @inheritdoc\r\n         */\r\n        EdgeArea.prototype.recalc = function () {\r\n            // edges don\'t have any cached data\r\n        };\r\n        /**\r\n         * Project the edge along a specified axis\r\n         */\r\n        EdgeArea.prototype.project = function (axis) {\r\n            var scalars = [];\r\n            var points = [this._getTransformedBegin(), this._getTransformedEnd()];\r\n            var len = points.length;\r\n            for (var i = 0; i < len; i++) {\r\n                scalars.push(points[i].dot(axis));\r\n            }\r\n            return new Algebra_8.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n        };\r\n        /* istanbul ignore next */\r\n        EdgeArea.prototype.debugDraw = function (ctx, color) {\r\n            if (color === void 0) { color = Color_4.Color.Red.clone(); }\r\n            ctx.strokeStyle = color.toString();\r\n            ctx.beginPath();\r\n            ctx.moveTo(this.begin.x, this.begin.y);\r\n            ctx.lineTo(this.end.x, this.end.y);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n        };\r\n        return EdgeArea;\r\n    }());\r\n    exports.EdgeArea = EdgeArea;\r\n});\r\ndefine("Util/DrawUtil", ["require", "exports", "Drawing/Color"], function (require, exports, Color_5) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Draw a line on canvas context\r\n     *\r\n     * @param ctx The canvas context\r\n     * @param color The color of the line\r\n     * @param x1 The start x coordinate\r\n     * @param y1 The start y coordinate\r\n     * @param x2 The ending x coordinate\r\n     * @param y2 The ending y coordinate\r\n     * @param thickness The line thickness\r\n     * @param cap The [[LineCapStyle]] (butt, round, or square)\r\n     */\r\n    /* istanbul ignore next */\r\n    function line(ctx, color, x1, y1, x2, y2, thickness, cap) {\r\n        if (color === void 0) { color = Color_5.Color.Red.clone(); }\r\n        if (thickness === void 0) { thickness = 1; }\r\n        if (cap === void 0) { cap = \'butt\'; }\r\n        ctx.beginPath();\r\n        ctx.lineWidth = thickness;\r\n        ctx.lineCap = cap;\r\n        ctx.strokeStyle = color.toString();\r\n        ctx.moveTo(x1, y1);\r\n        ctx.lineTo(x2, y2);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n    exports.line = line;\r\n    /**\r\n     * Draw the vector as a point onto the canvas.\r\n     */\r\n    /* istanbul ignore next */\r\n    function point(ctx, color, point) {\r\n        if (color === void 0) { color = Color_5.Color.Red.clone(); }\r\n        ctx.beginPath();\r\n        ctx.strokeStyle = color.toString();\r\n        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n    exports.point = point;\r\n    /**\r\n     * Draw the vector as a line onto the canvas starting a origin point.\r\n     */\r\n    /* istanbul ignore next */\r\n    function vector(ctx, color, origin, vector, scale) {\r\n        if (scale === void 0) { scale = 1.0; }\r\n        var c = color ? color.toString() : \'blue\';\r\n        var v = vector.scale(scale);\r\n        ctx.beginPath();\r\n        ctx.strokeStyle = c;\r\n        ctx.moveTo(origin.x, origin.y);\r\n        ctx.lineTo(origin.x + v.x, origin.y + v.y);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n    exports.vector = vector;\r\n    /**\r\n     * Draw a round rectangle on a canvas context\r\n     *\r\n     * @param ctx The canvas context\r\n     * @param x The top-left x coordinate\r\n     * @param y The top-left y coordinate\r\n     * @param width The width of the rectangle\r\n     * @param height The height of the rectangle\r\n     * @param radius The border radius of the rectangle\r\n     * @param fill The [[Color]] to fill rectangle with\r\n     * @param stroke The [[Color]] to stroke rectangle with\r\n     */\r\n    function roundRect(ctx, x, y, width, height, radius, stroke, fill) {\r\n        if (radius === void 0) { radius = 5; }\r\n        if (stroke === void 0) { stroke = Color_5.Color.White; }\r\n        if (fill === void 0) { fill = null; }\r\n        var br;\r\n        if (typeof radius === \'number\') {\r\n            br = { tl: radius, tr: radius, br: radius, bl: radius };\r\n        }\r\n        else {\r\n            var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };\r\n            for (var prop in defaultRadius) {\r\n                if (defaultRadius.hasOwnProperty(prop)) {\r\n                    var side = prop;\r\n                    br[side] = radius[side] || defaultRadius[side];\r\n                }\r\n            }\r\n        }\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + br.tl, y);\r\n        ctx.lineTo(x + width - br.tr, y);\r\n        ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);\r\n        ctx.lineTo(x + width, y + height - br.br);\r\n        ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);\r\n        ctx.lineTo(x + br.bl, y + height);\r\n        ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);\r\n        ctx.lineTo(x, y + br.tl);\r\n        ctx.quadraticCurveTo(x, y, x + br.tl, y);\r\n        ctx.closePath();\r\n        if (fill) {\r\n            ctx.fillStyle = fill.toString();\r\n            ctx.fill();\r\n        }\r\n        if (stroke) {\r\n            ctx.strokeStyle = stroke.toString();\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    exports.roundRect = roundRect;\r\n    function circle(ctx, x, y, radius, stroke, fill) {\r\n        if (stroke === void 0) { stroke = Color_5.Color.White; }\r\n        if (fill === void 0) { fill = null; }\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, radius, 0, Math.PI * 2);\r\n        ctx.closePath();\r\n        if (fill) {\r\n            ctx.fillStyle = fill.toString();\r\n            ctx.fill();\r\n        }\r\n        if (stroke) {\r\n            ctx.strokeStyle = stroke.toString();\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    exports.circle = circle;\r\n});\r\ndefine("Util/Log", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Logging level that Excalibur will tag\r\n     */\r\n    var LogLevel;\r\n    (function (LogLevel) {\r\n        LogLevel[LogLevel["Debug"] = 0] = "Debug";\r\n        LogLevel[LogLevel["Info"] = 1] = "Info";\r\n        LogLevel[LogLevel["Warn"] = 2] = "Warn";\r\n        LogLevel[LogLevel["Error"] = 3] = "Error";\r\n        LogLevel[LogLevel["Fatal"] = 4] = "Fatal";\r\n    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\r\n    /**\r\n     * Static singleton that represents the logging facility for Excalibur.\r\n     * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].\r\n     * Derive from [[IAppender]] to create your own logging appenders.\r\n     *\r\n     * [[include:Logger.md]]\r\n     */\r\n    var Logger = (function () {\r\n        function Logger() {\r\n            this._appenders = [];\r\n            /**\r\n             * Gets or sets the default logging level. Excalibur will only log\r\n             * messages if equal to or above this level. Default: [[LogLevel.Info]]\r\n             */\r\n            this.defaultLevel = LogLevel.Info;\r\n            if (Logger._instance) {\r\n                throw new Error(\'Logger is a singleton\');\r\n            }\r\n            Logger._instance = this;\r\n            // Default console appender\r\n            Logger._instance.addAppender(new ConsoleAppender());\r\n            return Logger._instance;\r\n        }\r\n        /**\r\n         * Gets the current static instance of Logger\r\n         */\r\n        Logger.getInstance = function () {\r\n            if (Logger._instance == null) {\r\n                Logger._instance = new Logger();\r\n            }\r\n            return Logger._instance;\r\n        };\r\n        /**\r\n         * Adds a new [[IAppender]] to the list of appenders to write to\r\n         */\r\n        Logger.prototype.addAppender = function (appender) {\r\n            this._appenders.push(appender);\r\n        };\r\n        /**\r\n         * Clears all appenders from the logger\r\n         */\r\n        Logger.prototype.clearAppenders = function () {\r\n            this._appenders.length = 0;\r\n        };\r\n        /**\r\n         * Logs a message at a given LogLevel\r\n         * @param level  The LogLevel`to log the message at\r\n         * @param args   An array of arguments to write to an appender\r\n         */\r\n        Logger.prototype._log = function (level, args) {\r\n            if (level == null) {\r\n                level = this.defaultLevel;\r\n            }\r\n            var i = 0, len = this._appenders.length;\r\n            for (i; i < len; i++) {\r\n                if (level >= this.defaultLevel) {\r\n                    this._appenders[i].log(level, args);\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * Writes a log message at the [[LogLevel.Debug]] level\r\n         * @param args  Accepts any number of arguments\r\n         */\r\n        Logger.prototype.debug = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            this._log(LogLevel.Debug, args);\r\n        };\r\n        /**\r\n         * Writes a log message at the [[LogLevel.Info]] level\r\n         * @param args  Accepts any number of arguments\r\n         */\r\n        Logger.prototype.info = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            this._log(LogLevel.Info, args);\r\n        };\r\n        /**\r\n         * Writes a log message at the [[LogLevel.Warn]] level\r\n         * @param args  Accepts any number of arguments\r\n         */\r\n        Logger.prototype.warn = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            this._log(LogLevel.Warn, args);\r\n        };\r\n        /**\r\n         * Writes a log message at the [[LogLevel.Error]] level\r\n         * @param args  Accepts any number of arguments\r\n         */\r\n        Logger.prototype.error = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            this._log(LogLevel.Error, args);\r\n        };\r\n        /**\r\n         * Writes a log message at the [[LogLevel.Fatal]] level\r\n         * @param args  Accepts any number of arguments\r\n         */\r\n        Logger.prototype.fatal = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            this._log(LogLevel.Fatal, args);\r\n        };\r\n        return Logger;\r\n    }());\r\n    Logger._instance = null;\r\n    exports.Logger = Logger;\r\n    /**\r\n     * Console appender for browsers (i.e. `console.log`)\r\n     */\r\n    var ConsoleAppender = (function () {\r\n        function ConsoleAppender() {\r\n        }\r\n        /**\r\n         * Logs a message at the given [[LogLevel]]\r\n         * @param level  Level to log at\r\n         * @param args   Arguments to log\r\n         */\r\n        ConsoleAppender.prototype.log = function (level, args) {\r\n            // Check for console support\r\n            if (!console && !console.log && console.warn && console.error) {\r\n                // todo maybe do something better than nothing\r\n                return;\r\n            }\r\n            // Create a new console args array\r\n            var consoleArgs = [];\r\n            consoleArgs.unshift.apply(consoleArgs, args);\r\n            consoleArgs.unshift(\'[\' + LogLevel[level] + \'] : \');\r\n            if (level < LogLevel.Warn) {\r\n                // Call .log for Debug/Info\r\n                if (console.log.apply) {\r\n                    // this is required on some older browsers that don\'t support apply on console.log :(\r\n                    console.log.apply(console, consoleArgs);\r\n                }\r\n                else {\r\n                    console.log(consoleArgs.join(\' \'));\r\n                }\r\n            }\r\n            else if (level < LogLevel.Error) {\r\n                // Call .warn for Warn\r\n                if (console.warn.apply) {\r\n                    console.warn.apply(console, consoleArgs);\r\n                }\r\n                else {\r\n                    console.warn(consoleArgs.join(\' \'));\r\n                }\r\n            }\r\n            else {\r\n                // Call .error for Error/Fatal\r\n                if (console.error.apply) {\r\n                    console.error.apply(console, consoleArgs);\r\n                }\r\n                else {\r\n                    console.error(consoleArgs.join(\' \'));\r\n                }\r\n            }\r\n        };\r\n        return ConsoleAppender;\r\n    }());\r\n    exports.ConsoleAppender = ConsoleAppender;\r\n    /**\r\n     * On-screen (canvas) appender\r\n     */\r\n    var ScreenAppender = (function () {\r\n        /**\r\n         * @param width   Width of the screen appender in pixels\r\n         * @param height  Height of the screen appender in pixels\r\n         */\r\n        function ScreenAppender(width, height) {\r\n            // @todo Clean this up\r\n            this._messages = [];\r\n            this._canvas = document.createElement(\'canvas\');\r\n            this._canvas.width = width || window.innerWidth;\r\n            this._canvas.height = height || window.innerHeight;\r\n            this._canvas.style.position = \'absolute\';\r\n            this._ctx = this._canvas.getContext(\'2d\');\r\n            document.body.appendChild(this._canvas);\r\n        }\r\n        /**\r\n         * Logs a message at the given [[LogLevel]]\r\n         * @param level  Level to log at\r\n         * @param args   Arguments to log\r\n         */\r\n        ScreenAppender.prototype.log = function (level, args) {\r\n            var message = args.join(\',\');\r\n            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n            this._messages.unshift(\'[\' + LogLevel[level] + \'] : \' + message);\r\n            var pos = 10;\r\n            var opacity = 1.0;\r\n            for (var i = 0; i < this._messages.length; i++) {\r\n                this._ctx.fillStyle = \'rgba(255,255,255,\' + opacity.toFixed(2) + \')\';\r\n                this._ctx.fillText(this._messages[i], 200, pos);\r\n                pos += 10;\r\n                opacity = opacity > 0 ? opacity - .05 : 0;\r\n            }\r\n        };\r\n        return ScreenAppender;\r\n    }());\r\n    exports.ScreenAppender = ScreenAppender;\r\n});\r\ndefine("Util/Decorators", ["require", "exports", "Util/Log", "Util/Util"], function (require, exports, Log_1, Util) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement\r\n     * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js\r\n     */\r\n    function obsolete(options) {\r\n        options = Util.extend({}, { message: \'This method will be removed in future versions of Excalibur.\', alternateMethod: null }, options);\r\n        return function (target, property, descriptor) {\r\n            if (!(typeof descriptor.value === \'function\' ||\r\n                typeof descriptor.get === \'function\' ||\r\n                typeof descriptor.set === \'function\')) {\r\n                throw new SyntaxError(\'Only functions/getters/setters can be marked as obsolete\');\r\n            }\r\n            var methodSignature = "" + (target.name || \'\') + (target.name ? \'.\' : \'\') + property;\r\n            var message = methodSignature + " is marked obsolete: " + options.message +\r\n                (options.alternateMethod ? " Use " + options.alternateMethod + " instead" : \'\');\r\n            var method = Util.extend({}, descriptor);\r\n            if (descriptor.value) {\r\n                method.value = function () {\r\n                    Log_1.Logger.getInstance().warn(message);\r\n                    return descriptor.value.apply(this, arguments);\r\n                };\r\n                return method;\r\n            }\r\n            if (descriptor.get) {\r\n                method.get = function () {\r\n                    Log_1.Logger.getInstance().warn(message);\r\n                    return descriptor.get.apply(this, arguments);\r\n                };\r\n            }\r\n            if (descriptor.set) {\r\n                method.set = function () {\r\n                    Log_1.Logger.getInstance().warn(message);\r\n                    return descriptor.set.apply(this, arguments);\r\n                };\r\n            }\r\n            return method;\r\n        };\r\n    }\r\n    exports.obsolete = obsolete;\r\n});\r\ndefine("Collision/Body", ["require", "exports", "Physics", "Collision/EdgeArea", "Collision/CircleArea", "Collision/PolygonArea", "Collision/Pair", "Algebra", "Drawing/Color", "Util/DrawUtil", "Util/Decorators"], function (require, exports, Physics_5, EdgeArea_3, CircleArea_3, PolygonArea_5, Pair_1, Algebra_9, Color_6, DrawUtil, Decorators_1) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var Body = (function () {\r\n        /**\r\n         * Constructs a new physics body associated with an actor\r\n         */\r\n        function Body(actor) {\r\n            this.actor = actor;\r\n            /**\r\n             * [ICollisionArea|Collision area] of this physics body, defines the shape for rigid body collision\r\n             */\r\n            this.collisionArea = null;\r\n            /**\r\n             * The (x, y) position of the actor this will be in the middle of the actor if the\r\n             * [[Actor.anchor]] is set to (0.5, 0.5) which is default.\r\n             * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).\r\n             */\r\n            this.pos = new Algebra_9.Vector(0, 0);\r\n            /**\r\n             * The position of the actor last frame (x, y) in pixels\r\n             */\r\n            this.oldPos = new Algebra_9.Vector(0, 0);\r\n            /**\r\n             * The current velocity vector (vx, vy) of the actor in pixels/second\r\n             */\r\n            this.vel = new Algebra_9.Vector(0, 0);\r\n            /**\r\n             * The velocity of the actor last frame (vx, vy) in pixels/second\r\n             */\r\n            this.oldVel = new Algebra_9.Vector(0, 0);\r\n            /**\r\n             * The curret acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may\r\n             * be useful to simulate a gravitational effect.\r\n             */\r\n            this.acc = new Algebra_9.Vector(0, 0);\r\n            /**\r\n             * The current torque applied to the actor\r\n             */\r\n            this.torque = 0;\r\n            /**\r\n             * The current mass of the actor, mass can be thought of as the resistance to acceleration.\r\n             */\r\n            this.mass = 1.0;\r\n            /**\r\n             * The current moment of inertia, moi can be thought of as the resistance to rotation.\r\n             */\r\n            this.moi = 1000;\r\n            /**\r\n             * The current "motion" of the actor, used to calculated sleep in the physics simulation\r\n             */\r\n            this.motion = 10;\r\n            /**\r\n             * The coefficient of friction on this actor\r\n             */\r\n            this.friction = .99;\r\n            /**\r\n             * The coefficient of restitution of this actor, represents the amount of energy preserved after collision\r\n             */\r\n            this.restitution = .2;\r\n            /**\r\n             * The rotation of the actor in radians\r\n             */\r\n            this.rotation = 0; // radians\r\n            /**\r\n             * The rotational velocity of the actor in radians/second\r\n             */\r\n            this.rx = 0; //radians/sec\r\n            this._totalMtv = Algebra_9.Vector.Zero.clone();\r\n        }\r\n        /**\r\n         * Add minimum translation vectors accumulated during the current frame to resolve collisions.\r\n         */\r\n        Body.prototype.addMtv = function (mtv) {\r\n            this._totalMtv.addEqual(mtv);\r\n        };\r\n        /**\r\n         * Applies the accumulated translation vectors to the actors position\r\n         */\r\n        Body.prototype.applyMtv = function () {\r\n            this.pos.addEqual(this._totalMtv);\r\n            this._totalMtv.setTo(0, 0);\r\n        };\r\n        /**\r\n         * Returns the body\'s [[BoundingBox]] calculated for this instant in world space.\r\n         */\r\n        Body.prototype.getBounds = function () {\r\n            if (Physics_5.Physics.collisionResolutionStrategy === Physics_5.CollisionResolutionStrategy.Box) {\r\n                return this.actor.getBounds();\r\n            }\r\n            else {\r\n                return this.collisionArea.getBounds();\r\n            }\r\n        };\r\n        /**\r\n         * Returns the actor\'s [[BoundingBox]] relative to the actors position.\r\n         */\r\n        Body.prototype.getRelativeBounds = function () {\r\n            if (Physics_5.Physics.collisionResolutionStrategy === Physics_5.CollisionResolutionStrategy.Box) {\r\n                return this.actor.getRelativeBounds();\r\n            }\r\n            else {\r\n                return this.actor.getRelativeBounds();\r\n            }\r\n        };\r\n        /**\r\n         * Updates the collision area geometry and internal caches\r\n         */\r\n        Body.prototype.update = function () {\r\n            if (this.collisionArea) {\r\n                this.collisionArea.recalc();\r\n            }\r\n        };\r\n        /**\r\n         * Sets up a box collision area based on the current bounds of the associated actor of this physics body.\r\n         *\r\n         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n         */\r\n        Body.prototype.useBoxCollision = function (center) {\r\n            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }\r\n            this.collisionArea = new PolygonArea_5.PolygonArea({\r\n                body: this,\r\n                points: this.actor.getRelativeBounds().getPoints(),\r\n                pos: center // position relative to actor\r\n            });\r\n            // in case of a nan moi, coalesce to a safe default\r\n            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;\r\n        };\r\n        /**\r\n         * Sets up a polygon collision area based on a list of of points relative to the anchor of the associated actor of this physics body.\r\n         *\r\n         * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.\r\n         *\r\n         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n         */\r\n        Body.prototype.usePolygonCollision = function (points, center) {\r\n            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }\r\n            this.collisionArea = new PolygonArea_5.PolygonArea({\r\n                body: this,\r\n                points: points,\r\n                pos: center // position relative to actor\r\n            });\r\n            // in case of a nan moi, collesce to a safe default\r\n            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;\r\n        };\r\n        /**\r\n         * Sets up a [[CircleArea|circle collision area]] with a specified radius in pixels.\r\n         *\r\n         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n         */\r\n        Body.prototype.useCircleCollision = function (radius, center) {\r\n            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }\r\n            if (!radius) {\r\n                radius = this.actor.getWidth() / 2;\r\n            }\r\n            this.collisionArea = new CircleArea_3.CircleArea({\r\n                body: this,\r\n                radius: radius,\r\n                pos: center\r\n            });\r\n            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;\r\n        };\r\n        /**\r\n         * Sets up an [[EdgeArea|edge collision]] with a start point and an end point relative to the anchor of the associated actor\r\n         * of this physics body.\r\n         *\r\n         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n         */\r\n        Body.prototype.useEdgeCollision = function (begin, end) {\r\n            this.collisionArea = new EdgeArea_3.EdgeArea({\r\n                begin: begin,\r\n                end: end,\r\n                body: this\r\n            });\r\n            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;\r\n        };\r\n        /* istanbul ignore next */\r\n        Body.prototype.debugDraw = function (ctx) {\r\n            // Draw motion vectors\r\n            if (Physics_5.Physics.showMotionVectors) {\r\n                DrawUtil.vector(ctx, Color_6.Color.Yellow, this.pos, (this.acc.add(Physics_5.Physics.acc)));\r\n                DrawUtil.vector(ctx, Color_6.Color.Red, this.pos, (this.vel));\r\n                DrawUtil.point(ctx, Color_6.Color.Red, this.pos);\r\n            }\r\n            if (Physics_5.Physics.showBounds) {\r\n                this.getBounds().debugDraw(ctx, Color_6.Color.Yellow);\r\n            }\r\n            if (Physics_5.Physics.showArea) {\r\n                this.collisionArea.debugDraw(ctx, Color_6.Color.Green);\r\n            }\r\n        };\r\n        /**\r\n         * Returns a boolean indicating whether this body collided with\r\n         * or was in stationary contact with\r\n         * the body of the other [[Actor]]\r\n         */\r\n        Body.prototype.touching = function (other) {\r\n            var pair = new Pair_1.Pair(this, other.body);\r\n            pair.collide();\r\n            if (pair.collision) {\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        /**\r\n         * Returns a boolean indicating true if this body COLLIDED with\r\n         * the body of the other Actor in the last frame, and they are no longer touching\r\n         * in this frame\r\n         */\r\n        Body.prototype.wasTouching = function (other, game) {\r\n            var pair = new Pair_1.Pair(this, other.body);\r\n            var wasTouchingLastFrame = false;\r\n            if (game && game.stats.prevFrame && game.stats.prevFrame.physics.collidersHash[pair.id]) {\r\n                wasTouchingLastFrame = true;\r\n            }\r\n            var currentlyTouching = this.touching(other);\r\n            return wasTouchingLastFrame && !currentlyTouching;\r\n        };\r\n        return Body;\r\n    }());\r\n    __decorate([\r\n        Decorators_1.obsolete({ message: \'will be removed in v0.15, use the collisionend event instead\' })\r\n    ], Body.prototype, "wasTouching", null);\r\n    exports.Body = Body;\r\n});\r\ndefine("Collision/Pair", ["require", "exports", "Physics", "Drawing/Color", "Actor", "Util/DrawUtil"], function (require, exports, Physics_6, Color_7, Actor_2, DrawUtil) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Models a potential collision between 2 bodies\r\n     */\r\n    var Pair = (function () {\r\n        function Pair(bodyA, bodyB) {\r\n            this.bodyA = bodyA;\r\n            this.bodyB = bodyB;\r\n            this.id = null;\r\n            this.collision = null;\r\n            this.id = Pair.calculatePairHash(bodyA, bodyB);\r\n        }\r\n        Object.defineProperty(Pair.prototype, "canCollide", {\r\n            /**\r\n             * Returns whether or not it is possible for the pairs to collide\r\n             */\r\n            get: function () {\r\n                var actorA = this.bodyA.actor;\r\n                var actorB = this.bodyB.actor;\r\n                // if both are fixed short circuit\r\n                if (actorA.collisionType === Actor_2.CollisionType.Fixed && actorB.collisionType === Actor_2.CollisionType.Fixed) {\r\n                    return false;\r\n                }\r\n                // if the other is prevent collision or is dead short circuit\r\n                if (actorB.collisionType === Actor_2.CollisionType.PreventCollision || actorB.isKilled()) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Runs the collison intersection logic on the members of this pair\r\n         */\r\n        Pair.prototype.collide = function () {\r\n            this.collision = this.bodyA.collisionArea.collide(this.bodyB.collisionArea);\r\n        };\r\n        /**\r\n         * Resovles the collision body position and velocity if a collision occured\r\n         */\r\n        Pair.prototype.resolve = function (strategy) {\r\n            if (this.collision) {\r\n                this.collision.resolve(strategy);\r\n            }\r\n        };\r\n        /**\r\n         * Calculates the unique pair hash id for this collision pair\r\n         */\r\n        Pair.calculatePairHash = function (bodyA, bodyB) {\r\n            if (bodyA.actor.id < bodyB.actor.id) {\r\n                return "#" + bodyA.actor.id + "+" + bodyB.actor.id;\r\n            }\r\n            else {\r\n                return "#" + bodyB.actor.id + "+" + bodyA.actor.id;\r\n            }\r\n        };\r\n        /* istanbul ignore next */\r\n        Pair.prototype.debugDraw = function (ctx) {\r\n            if (this.collision) {\r\n                if (Physics_6.Physics.showContacts) {\r\n                    DrawUtil.point(ctx, Color_7.Color.Red, this.collision.point);\r\n                }\r\n                if (Physics_6.Physics.showCollisionNormals) {\r\n                    DrawUtil.vector(ctx, Color_7.Color.Cyan, this.collision.point, this.collision.normal, 30);\r\n                }\r\n            }\r\n        };\r\n        return Pair;\r\n    }());\r\n    exports.Pair = Pair;\r\n});\r\ndefine("Debug", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Debug statistics and flags for Excalibur. If polling these values, it would be\r\n     * best to do so on the `postupdate` event for [[Engine]], after all values have been\r\n     * updated during a frame.\r\n     */\r\n    var Debug = (function () {\r\n        function Debug() {\r\n            /**\r\n             * Performance statistics\r\n             */\r\n            this.stats = {\r\n                /**\r\n                 * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n                 * Best accessed on [[postframe]] event. See [[IFrameStats]]\r\n                 */\r\n                currFrame: new FrameStats(),\r\n                /**\r\n                 * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n                 * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[IFrameStats]]\r\n                 */\r\n                prevFrame: new FrameStats()\r\n            };\r\n        }\r\n        return Debug;\r\n    }());\r\n    exports.Debug = Debug;\r\n    /**\r\n     * Implementation of a frame\'s stats. Meant to have values copied via [[FrameStats.reset]], avoid\r\n     * creating instances of this every frame.\r\n     */\r\n    var FrameStats = (function () {\r\n        function FrameStats() {\r\n            this._id = 0;\r\n            this._delta = 0;\r\n            this._fps = 0;\r\n            this._actorStats = {\r\n                alive: 0,\r\n                killed: 0,\r\n                ui: 0,\r\n                get remaining() {\r\n                    return this.alive - this.killed;\r\n                },\r\n                get total() {\r\n                    return this.remaining + this.ui;\r\n                }\r\n            };\r\n            this._durationStats = {\r\n                update: 0,\r\n                draw: 0,\r\n                get total() {\r\n                    return this.update + this.draw;\r\n                }\r\n            };\r\n            this._physicsStats = new PhysicsStats();\r\n        }\r\n        /**\r\n         * Zero out values or clone other IFrameStat stats. Allows instance reuse.\r\n         *\r\n         * @param [otherStats] Optional stats to clone\r\n         */\r\n        FrameStats.prototype.reset = function (otherStats) {\r\n            if (otherStats) {\r\n                this.id = otherStats.id;\r\n                this.delta = otherStats.delta;\r\n                this.fps = otherStats.fps;\r\n                this.actors.alive = otherStats.actors.alive;\r\n                this.actors.killed = otherStats.actors.killed;\r\n                this.actors.ui = otherStats.actors.ui;\r\n                this.duration.update = otherStats.duration.update;\r\n                this.duration.draw = otherStats.duration.draw;\r\n                this._physicsStats.reset(otherStats.physics);\r\n            }\r\n            else {\r\n                this.id = this.delta = this.fps = 0;\r\n                this.actors.alive = this.actors.killed = this.actors.ui = 0;\r\n                this.duration.update = this.duration.draw = 0;\r\n                this._physicsStats.reset();\r\n            }\r\n        };\r\n        /**\r\n         * Provides a clone of this instance.\r\n         */\r\n        FrameStats.prototype.clone = function () {\r\n            var fs = new FrameStats();\r\n            fs.reset(this);\r\n            return fs;\r\n        };\r\n        Object.defineProperty(FrameStats.prototype, "id", {\r\n            /**\r\n             * Gets the frame\'s id\r\n             */\r\n            get: function () {\r\n                return this._id;\r\n            },\r\n            /**\r\n             * Sets the frame\'s id\r\n             */\r\n            set: function (value) {\r\n                this._id = value;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(FrameStats.prototype, "delta", {\r\n            /**\r\n             * Gets the frame\'s delta (time since last frame)\r\n             */\r\n            get: function () {\r\n                return this._delta;\r\n            },\r\n            /**\r\n             * Sets the frame\'s delta (time since last frame). Internal use only.\r\n             * @internal\r\n             */\r\n            set: function (value) {\r\n                this._delta = value;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(FrameStats.prototype, "fps", {\r\n            /**\r\n             * Gets the frame\'s frames-per-second (FPS)\r\n             */\r\n            get: function () {\r\n                return this._fps;\r\n            },\r\n            /**\r\n             * Sets the frame\'s frames-per-second (FPS). Internal use only.\r\n             * @internal\r\n             */\r\n            set: function (value) {\r\n                this._fps = value;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(FrameStats.prototype, "actors", {\r\n            /**\r\n             * Gets the frame\'s actor statistics\r\n             */\r\n            get: function () {\r\n                return this._actorStats;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(FrameStats.prototype, "duration", {\r\n            /**\r\n             * Gets the frame\'s duration statistics\r\n             */\r\n            get: function () {\r\n                return this._durationStats;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(FrameStats.prototype, "physics", {\r\n            /**\r\n             * Gets the frame\'s physics statistics\r\n             */\r\n            get: function () {\r\n                return this._physicsStats;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return FrameStats;\r\n    }());\r\n    exports.FrameStats = FrameStats;\r\n    var PhysicsStats = (function () {\r\n        function PhysicsStats() {\r\n            this._pairs = 0;\r\n            this._collisions = 0;\r\n            this._collidersHash = {};\r\n            this._fastBodies = 0;\r\n            this._fastBodyCollisions = 0;\r\n            this._broadphase = 0;\r\n            this._narrowphase = 0;\r\n        }\r\n        /**\r\n         * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.\r\n         *\r\n         * @param [otherStats] Optional stats to clone\r\n         */\r\n        PhysicsStats.prototype.reset = function (otherStats) {\r\n            if (otherStats) {\r\n                this.pairs = otherStats.pairs;\r\n                this.collisions = otherStats.collisions;\r\n                this.collidersHash = otherStats.collidersHash;\r\n                this.fastBodies = otherStats.fastBodies;\r\n                this.fastBodyCollisions = otherStats.fastBodyCollisions;\r\n                this.broadphase = otherStats.broadphase;\r\n                this.narrowphase = otherStats.narrowphase;\r\n            }\r\n            else {\r\n                this.pairs = this.collisions = this.fastBodies = 0;\r\n                this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;\r\n                this.collidersHash = {};\r\n            }\r\n        };\r\n        /**\r\n         * Provides a clone of this instance.\r\n         */\r\n        PhysicsStats.prototype.clone = function () {\r\n            var ps = new PhysicsStats();\r\n            ps.reset(this);\r\n            return ps;\r\n        };\r\n        Object.defineProperty(PhysicsStats.prototype, "pairs", {\r\n            get: function () {\r\n                return this._pairs;\r\n            },\r\n            set: function (value) {\r\n                this._pairs = value;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(PhysicsStats.prototype, "collisions", {\r\n            get: function () {\r\n                return this._collisions;\r\n            },\r\n            set: function (value) {\r\n                this._collisions = value;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(PhysicsStats.prototype, "collidersHash", {\r\n            get: function () {\r\n                return this._collidersHash;\r\n            },\r\n            set: function (colliders) {\r\n                this._collidersHash = colliders;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(PhysicsStats.prototype, "fastBodies", {\r\n            get: function () {\r\n                return this._fastBodies;\r\n            },\r\n            set: function (value) {\r\n                this._fastBodies = value;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(PhysicsStats.prototype, "fastBodyCollisions", {\r\n            get: function () {\r\n                return this._fastBodyCollisions;\r\n            },\r\n            set: function (value) {\r\n                this._fastBodyCollisions = value;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(PhysicsStats.prototype, "broadphase", {\r\n            get: function () {\r\n                return this._broadphase;\r\n            },\r\n            set: function (value) {\r\n                this._broadphase = value;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(PhysicsStats.prototype, "narrowphase", {\r\n            get: function () {\r\n                return this._narrowphase;\r\n            },\r\n            set: function (value) {\r\n                this._narrowphase = value;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return PhysicsStats;\r\n    }());\r\n    exports.PhysicsStats = PhysicsStats;\r\n});\r\ndefine("Interfaces/IEvented", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("EventDispatcher", ["require", "exports", "Events"], function (require, exports, Events_2) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Excalibur\'s internal event dispatcher implementation.\r\n     * Callbacks are fired immediately after an event is published.\r\n     * Typically you will use [[Class.eventDispatcher]] since most classes in\r\n     * Excalibur inherit from [[Class]]. You will rarely create an `EventDispatcher`\r\n     * yourself.\r\n     *\r\n     * [[include:Events.md]]\r\n     */\r\n    var EventDispatcher = (function () {\r\n        /**\r\n         * @param target  The object that will be the recipient of events from this event dispatcher\r\n         */\r\n        function EventDispatcher(target) {\r\n            this._handlers = {};\r\n            this._wiredEventDispatchers = [];\r\n            this._target = target;\r\n        }\r\n        /**\r\n         * Emits an event for target\r\n         * @param eventName  The name of the event to publish\r\n         * @param event      Optionally pass an event data object to the handler\r\n         */\r\n        EventDispatcher.prototype.emit = function (eventName, event) {\r\n            if (!eventName) {\r\n                // key not mapped\r\n                return;\r\n            }\r\n            eventName = eventName.toLowerCase();\r\n            var target = this._target;\r\n            if (!event) {\r\n                event = new Events_2.GameEvent();\r\n            }\r\n            event.target = target;\r\n            var i, len;\r\n            if (this._handlers[eventName]) {\r\n                i = 0;\r\n                len = this._handlers[eventName].length;\r\n                for (i; i < len; i++) {\r\n                    this._handlers[eventName][i].call(target, event);\r\n                }\r\n            }\r\n            i = 0;\r\n            len = this._wiredEventDispatchers.length;\r\n            for (i; i < len; i++) {\r\n                this._wiredEventDispatchers[i].emit(eventName, event);\r\n            }\r\n        };\r\n        /**\r\n         * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.\r\n         * @param eventName  The name of the event to subscribe to\r\n         * @param handler    The handler callback to fire on this event\r\n         */\r\n        EventDispatcher.prototype.on = function (eventName, handler) {\r\n            eventName = eventName.toLowerCase();\r\n            if (!this._handlers[eventName]) {\r\n                this._handlers[eventName] = [];\r\n            }\r\n            this._handlers[eventName].push(handler);\r\n            // meta event handlers\r\n            if (eventName !== \'unsubscribe\' && eventName !== \'subscribe\') {\r\n                this.emit(\'subscribe\', new Events_2.SubscribeEvent(eventName, handler));\r\n            }\r\n        };\r\n        /**\r\n         * Unsubscribe an event handler(s) from an event. If a specific handler\r\n         * is specified for an event, only that handler will be unsubscribed.\r\n         * Otherwise all handlers will be unsubscribed for that event.\r\n         *\r\n         * @param eventName  The name of the event to unsubscribe\r\n         * @param handler    Optionally the specific handler to unsubscribe\r\n         *\r\n         */\r\n        EventDispatcher.prototype.off = function (eventName, handler) {\r\n            eventName = eventName.toLowerCase();\r\n            var eventHandlers = this._handlers[eventName];\r\n            if (eventHandlers) {\r\n                // if no explicit handler is give with the event name clear all handlers\r\n                if (!handler) {\r\n                    this._handlers[eventName].length = 0;\r\n                }\r\n                else {\r\n                    var index = eventHandlers.indexOf(handler);\r\n                    this._handlers[eventName].splice(index, 1);\r\n                }\r\n            }\r\n            // meta event handlers\r\n            if (eventName !== \'unsubscribe\' && eventName !== \'subscribe\') {\r\n                this.emit(\'unsubscribe\', new Events_2.UnsubscribeEvent(eventName, handler));\r\n            }\r\n        };\r\n        /**\r\n         * Once listens to an event one time, then unsubscribes from that event\r\n         *\r\n         * @param eventName The name of the event to subscribe to once\r\n         * @param handler   The handler of the event that will be auto unsubscribed\r\n         */\r\n        EventDispatcher.prototype.once = function (eventName, handler) {\r\n            var _this = this;\r\n            var metaHandler = function (event) {\r\n                var ev = event || new Events_2.GameEvent();\r\n                ev.target = ev.target || _this._target;\r\n                _this.off(eventName, handler);\r\n                handler.call(ev.target, ev);\r\n            };\r\n            this.on(eventName, metaHandler);\r\n        };\r\n        /**\r\n         * Wires this event dispatcher to also recieve events from another\r\n         */\r\n        EventDispatcher.prototype.wire = function (eventDispatcher) {\r\n            eventDispatcher._wiredEventDispatchers.push(this);\r\n        };\r\n        /**\r\n         * Unwires this event dispatcher from another\r\n         */\r\n        EventDispatcher.prototype.unwire = function (eventDispatcher) {\r\n            var index = eventDispatcher._wiredEventDispatchers.indexOf(this);\r\n            if (index > -1) {\r\n                eventDispatcher._wiredEventDispatchers.splice(index, 1);\r\n            }\r\n        };\r\n        return EventDispatcher;\r\n    }());\r\n    exports.EventDispatcher = EventDispatcher;\r\n});\r\ndefine("Actions/ActionContext", ["require", "exports", "Actions/Action", "Promises", "Util/EasingFunctions"], function (require, exports, Actions, Promises_2, EasingFunctions_2) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * The fluent Action API allows you to perform "actions" on\r\n     * [[Actor|Actors]] such as following, moving, rotating, and\r\n     * more. You can implement your own actions by implementing\r\n     * the [[IAction]] interface.\r\n     *\r\n     * [[include:Actions.md]]\r\n     */\r\n    var ActionContext = (function () {\r\n        function ActionContext() {\r\n            this._actors = [];\r\n            this._queues = [];\r\n            if (arguments !== null) {\r\n                this._actors = Array.prototype.slice.call(arguments, 0);\r\n                this._queues = this._actors.map(function (a) {\r\n                    return a.actionQueue;\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * Clears all queued actions from the Actor\r\n         */\r\n        ActionContext.prototype.clearActions = function () {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].clearActions();\r\n            }\r\n        };\r\n        ActionContext.prototype.addActorToContext = function (actor) {\r\n            this._actors.push(actor);\r\n            // if we run into problems replace the line below with:\r\n            this._queues.push(actor.actionQueue);\r\n        };\r\n        ActionContext.prototype.removeActorFromContext = function (actor) {\r\n            var index = this._actors.indexOf(actor);\r\n            if (index > -1) {\r\n                this._actors.splice(index, 1);\r\n                this._queues.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * This method will move an actor to the specified `x` and `y` position over the\r\n         * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n         * method is part of the actor \'Action\' fluent API allowing action chaining.\r\n         * @param x         The x location to move the actor to\r\n         * @param y         The y location to move the actor to\r\n         * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n         * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position\r\n         */\r\n        ActionContext.prototype.easeTo = function (x, y, duration, easingFcn) {\r\n            if (easingFcn === void 0) { easingFcn = EasingFunctions_2.EasingFunctions.Linear; }\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.EaseTo(this._actors[i], x, y, duration, easingFcn));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will move an actor to the specified x and y position at the\r\n         * speed specified (in pixels per second) and return back the actor. This\r\n         * method is part of the actor \'Action\' fluent API allowing action chaining.\r\n         * @param x      The x location to move the actor to\r\n         * @param y      The y location to move the actor to\r\n         * @param speed  The speed in pixels per second to move\r\n         */\r\n        ActionContext.prototype.moveTo = function (x, y, speed) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.MoveTo(this._actors[i], x, y, speed));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will move an actor to the specified x and y position by a\r\n         * certain time (in milliseconds). This method is part of the actor\r\n         * \'Action\' fluent API allowing action chaining.\r\n         * @param x     The x location to move the actor to\r\n         * @param y     The y location to move the actor to\r\n         * @param time  The time it should take the actor to move to the new location in milliseconds\r\n         */\r\n        ActionContext.prototype.moveBy = function (x, y, time) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.MoveBy(this._actors[i], x, y, time));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will rotate an actor to the specified angle at the speed\r\n         * specified (in radians per second) and return back the actor. This\r\n         * method is part of the actor \'Action\' fluent API allowing action chaining.\r\n         * @param angleRadians  The angle to rotate to in radians\r\n         * @param speed         The angular velocity of the rotation specified in radians per second\r\n         * @param rotationType  The [[RotationType]] to use for this rotation\r\n         */\r\n        ActionContext.prototype.rotateTo = function (angleRadians, speed, rotationType) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.RotateTo(this._actors[i], angleRadians, speed, rotationType));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will rotate an actor to the specified angle by a certain\r\n         * time (in milliseconds) and return back the actor. This method is part\r\n         * of the actor \'Action\' fluent API allowing action chaining.\r\n         * @param angleRadians  The angle to rotate to in radians\r\n         * @param time          The time it should take the actor to complete the rotation in milliseconds\r\n         * @param rotationType  The [[RotationType]] to use for this rotation\r\n         */\r\n        ActionContext.prototype.rotateBy = function (angleRadians, time, rotationType) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.RotateBy(this._actors[i], angleRadians, time, rotationType));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will scale an actor to the specified size at the speed\r\n         * specified (in magnitude increase per second) and return back the\r\n         * actor. This method is part of the actor \'Action\' fluent API allowing\r\n         * action chaining.\r\n         * @param sizeX   The scaling factor to apply on X axis\r\n         * @param sizeY   The scaling factor to apply on Y axis\r\n         * @param speedX  The speed of scaling specified in magnitude increase per second on X axis\r\n         * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis\r\n         */\r\n        ActionContext.prototype.scaleTo = function (sizeX, sizeY, speedX, speedY) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.ScaleTo(this._actors[i], sizeX, sizeY, speedX, speedY));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will scale an actor to the specified size by a certain time\r\n         * (in milliseconds) and return back the actor. This method is part of the\r\n         * actor \'Action\' fluent API allowing action chaining.\r\n         * @param sizeX   The scaling factor to apply on X axis\r\n         * @param sizeY   The scaling factor to apply on Y axis\r\n         * @param time    The time it should take to complete the scaling in milliseconds\r\n         */\r\n        ActionContext.prototype.scaleBy = function (sizeX, sizeY, time) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.ScaleBy(this._actors[i], sizeX, sizeY, time));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will cause an actor to blink (become visible and not\r\n         * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n         * the actor should be visible per blink, and the amount of time not visible.\r\n         * This method is part of the actor \'Action\' fluent API allowing action chaining.\r\n         * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n         * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n         * @param numBlinks       The number of times to blink\r\n         */\r\n        ActionContext.prototype.blink = function (timeVisible, timeNotVisible, numBlinks) {\r\n            if (numBlinks === void 0) { numBlinks = 1; }\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.Blink(this._actors[i], timeVisible, timeNotVisible, numBlinks));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will cause an actor\'s opacity to change from its current value\r\n         * to the provided value by a specified time (in milliseconds). This method is\r\n         * part of the actor \'Action\' fluent API allowing action chaining.\r\n         * @param opacity  The ending opacity\r\n         * @param time     The time it should take to fade the actor (in milliseconds)\r\n         */\r\n        ActionContext.prototype.fade = function (opacity, time) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.Fade(this._actors[i], opacity, time));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will delay the next action from executing for a certain\r\n         * amount of time (in milliseconds). This method is part of the actor\r\n         * \'Action\' fluent API allowing action chaining.\r\n         * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n         */\r\n        ActionContext.prototype.delay = function (time) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.Delay(this._actors[i], time));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will add an action to the queue that will remove the actor from the\r\n         * scene once it has completed its previous actions. Any actions on the\r\n         * action queue after this action will not be executed.\r\n         */\r\n        ActionContext.prototype.die = function () {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.Die(this._actors[i]));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method allows you to call an arbitrary method as the next action in the\r\n         * action queue. This is useful if you want to execute code in after a specific\r\n         * action, i.e An actor arrives at a destination after traversing a path\r\n         */\r\n        ActionContext.prototype.callMethod = function (method) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.CallMethod(this._actors[i], method));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will cause the actor to repeat all of the previously\r\n         * called actions a certain number of times. If the number of repeats\r\n         * is not specified it will repeat forever. This method is part of\r\n         * the actor \'Action\' fluent API allowing action chaining\r\n         * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n         * will repeat forever\r\n         */\r\n        ActionContext.prototype.repeat = function (times) {\r\n            if (!times) {\r\n                this.repeatForever();\r\n                return this;\r\n            }\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.Repeat(this._actors[i], times, this._actors[i].actionQueue.getActions()));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will cause the actor to repeat all of the previously\r\n         * called actions forever. This method is part of the actor \'Action\'\r\n         * fluent API allowing action chaining.\r\n         */\r\n        ActionContext.prototype.repeatForever = function () {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                this._queues[i].add(new Actions.RepeatForever(this._actors[i], this._actors[i].actionQueue.getActions()));\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will cause the actor to follow another at a specified distance\r\n         * @param actor           The actor to follow\r\n         * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n         */\r\n        ActionContext.prototype.follow = function (actor, followDistance) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                if (followDistance === undefined) {\r\n                    this._queues[i].add(new Actions.Follow(this._actors[i], actor));\r\n                }\r\n                else {\r\n                    this._queues[i].add(new Actions.Follow(this._actors[i], actor, followDistance));\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * This method will cause the actor to move towards another until they\r\n         * collide "meet" at a specified speed.\r\n         * @param actor  The actor to meet\r\n         * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n         */\r\n        ActionContext.prototype.meet = function (actor, speed) {\r\n            var i = 0, len = this._queues.length;\r\n            for (i; i < len; i++) {\r\n                if (speed === undefined) {\r\n                    this._queues[i].add(new Actions.Meet(this._actors[i], actor));\r\n                }\r\n                else {\r\n                    this._queues[i].add(new Actions.Meet(this._actors[i], actor, speed));\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Returns a promise that resolves when the current action queue up to now\r\n         * is finished.\r\n         */\r\n        ActionContext.prototype.asPromise = function () {\r\n            var _this = this;\r\n            var promises = this._queues.map(function (q, i) {\r\n                var temp = new Promises_2.Promise();\r\n                q.add(new Actions.CallMethod(_this._actors[i], function () {\r\n                    temp.resolve();\r\n                }));\r\n                return temp;\r\n            });\r\n            return Promises_2.Promise.join.apply(this, promises);\r\n        };\r\n        return ActionContext;\r\n    }());\r\n    exports.ActionContext = ActionContext;\r\n});\r\ndefine("Actions/IActionable", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Group", ["require", "exports", "Algebra", "Actions/ActionContext", "Actor", "Util/Log", "Class"], function (require, exports, Algebra_10, ActionContext_1, Actor_3, Log_2, Class_1) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Groups are used for logically grouping Actors so they can be acted upon\r\n     * in bulk.\r\n     *\r\n     * [[include:Groups.md]]\r\n     */\r\n    var Group = (function (_super) {\r\n        __extends(Group, _super);\r\n        function Group(name, scene) {\r\n            var _this = _super.call(this) || this;\r\n            _this.name = name;\r\n            _this.scene = scene;\r\n            _this._logger = Log_2.Logger.getInstance();\r\n            _this._members = [];\r\n            _this.actions = new ActionContext_1.ActionContext();\r\n            if (scene == null) {\r\n                _this._logger.error(\'Invalid constructor arguments passed to Group: \', name, \', scene must not be null!\');\r\n            }\r\n            else {\r\n                var existingGroup = scene.groups[name];\r\n                if (existingGroup) {\r\n                    _this._logger.warn(\'Group with name\', name, \'already exists. This new group will replace it.\');\r\n                }\r\n                scene.groups[name] = _this;\r\n            }\r\n            return _this;\r\n        }\r\n        Group.prototype.add = function (actorOrActors) {\r\n            if (actorOrActors instanceof Actor_3.Actor) {\r\n                actorOrActors = [].concat(actorOrActors);\r\n            }\r\n            var i = 0, len = actorOrActors.length, groupIdx;\r\n            for (i; i < len; i++) {\r\n                groupIdx = this.getMembers().indexOf(actorOrActors[i]);\r\n                if (groupIdx === -1) {\r\n                    this._members.push(actorOrActors[i]);\r\n                    this.scene.add(actorOrActors[i]);\r\n                    this.actions.addActorToContext(actorOrActors[i]);\r\n                    this.eventDispatcher.wire(actorOrActors[i].eventDispatcher);\r\n                }\r\n            }\r\n        };\r\n        Group.prototype.remove = function (actor) {\r\n            var index = this._members.indexOf(actor);\r\n            if (index > -1) {\r\n                this._members.splice(index, 1);\r\n                this.actions.removeActorFromContext(actor);\r\n                this.eventDispatcher.unwire(actor.eventDispatcher);\r\n            }\r\n        };\r\n        Group.prototype.move = function (args) {\r\n            var i = 0, members = this.getMembers(), len = members.length;\r\n            if (arguments.length === 1 && args instanceof Algebra_10.Vector) {\r\n                for (i; i < len; i++) {\r\n                    members[i].pos.x += args.x;\r\n                    members[i].pos.y += args.y;\r\n                }\r\n            }\r\n            else if (typeof arguments[0] === \'number\' && typeof arguments[1] === \'number\') {\r\n                var x = arguments[0];\r\n                var y = arguments[1];\r\n                for (i; i < len; i++) {\r\n                    members[i].pos.x += x;\r\n                    members[i].pos.y += y;\r\n                }\r\n            }\r\n            else {\r\n                this._logger.error(\'Invalid arguments passed to group move\', this.name, \'args:\', arguments);\r\n            }\r\n        };\r\n        Group.prototype.rotate = function (angle) {\r\n            if (typeof angle !== \'number\') {\r\n                this._logger.error(\'Invalid arguments passed to group rotate\', this.name, \'args:\', arguments);\r\n                return;\r\n            }\r\n            for (var _i = 0, _a = this.getMembers(); _i < _a.length; _i++) {\r\n                var member = _a[_i];\r\n                member.rotation += angle;\r\n            }\r\n        };\r\n        Group.prototype.on = function (eventName, handler) {\r\n            this.eventDispatcher.on(eventName, handler);\r\n        };\r\n        Group.prototype.off = function (eventName, handler) {\r\n            this.eventDispatcher.off(eventName, handler);\r\n        };\r\n        Group.prototype.emit = function (topic, event) {\r\n            this.eventDispatcher.emit(topic, event);\r\n        };\r\n        Group.prototype.contains = function (actor) {\r\n            return this.getMembers().indexOf(actor) > -1;\r\n        };\r\n        Group.prototype.getMembers = function () {\r\n            return this._members;\r\n        };\r\n        Group.prototype.getRandomMember = function () {\r\n            return this._members[Math.floor(Math.random() * this._members.length)];\r\n        };\r\n        Group.prototype.getBounds = function () {\r\n            return this.getMembers().map(function (a) { return a.getBounds(); }).reduce(function (prev, curr) {\r\n                return prev.combine(curr);\r\n            });\r\n        };\r\n        return Group;\r\n    }(Class_1.Class));\r\n    exports.Group = Group;\r\n});\r\n/**\r\n * These effects can be applied to any bitmap image but are mainly used\r\n * for [[Sprite]] effects or [[Animation]] effects.\r\n *\r\n * [[include:SpriteEffects.md]]\r\n */\r\ndefine("Drawing/SpriteEffects", ["require", "exports", "Drawing/Color"], function (require, exports, Color_8) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Applies the "Grayscale" effect to a sprite, removing color information.\r\n     */\r\n    var Grayscale = (function () {\r\n        function Grayscale() {\r\n        }\r\n        Grayscale.prototype.updatePixel = function (x, y, imageData) {\r\n            var firstPixel = (x + y * imageData.width) * 4;\r\n            var pixel = imageData.data;\r\n            var avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;\r\n            pixel[firstPixel + 0] = avg;\r\n            pixel[firstPixel + 1] = avg;\r\n            pixel[firstPixel + 2] = avg;\r\n        };\r\n        return Grayscale;\r\n    }());\r\n    exports.Grayscale = Grayscale;\r\n    /**\r\n     * Applies the "Invert" effect to a sprite, inverting the pixel colors.\r\n     */\r\n    var Invert = (function () {\r\n        function Invert() {\r\n        }\r\n        Invert.prototype.updatePixel = function (x, y, imageData) {\r\n            var firstPixel = (x + y * imageData.width) * 4;\r\n            var pixel = imageData.data;\r\n            pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];\r\n            pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];\r\n            pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];\r\n        };\r\n        return Invert;\r\n    }());\r\n    exports.Invert = Invert;\r\n    /**\r\n     * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.\r\n     */\r\n    var Opacity = (function () {\r\n        /**\r\n         * @param opacity  The new opacity of the sprite from 0-1.0\r\n         */\r\n        function Opacity(opacity) {\r\n            this.opacity = opacity;\r\n        }\r\n        Opacity.prototype.updatePixel = function (x, y, imageData) {\r\n            var firstPixel = (x + y * imageData.width) * 4;\r\n            var pixel = imageData.data;\r\n            if (pixel[firstPixel + 3] !== 0) {\r\n                pixel[firstPixel + 3] = Math.round(this.opacity * pixel[firstPixel + 3]);\r\n            }\r\n        };\r\n        return Opacity;\r\n    }());\r\n    exports.Opacity = Opacity;\r\n    /**\r\n     * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an\r\n     * average of the original color and the provided color\r\n     */\r\n    var Colorize = (function () {\r\n        /**\r\n         * @param color  The color to apply to the sprite\r\n         */\r\n        function Colorize(color) {\r\n            this.color = color;\r\n        }\r\n        Colorize.prototype.updatePixel = function (x, y, imageData) {\r\n            var firstPixel = (x + y * imageData.width) * 4;\r\n            var pixel = imageData.data;\r\n            if (pixel[firstPixel + 3] !== 0) {\r\n                pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;\r\n                pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;\r\n                pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;\r\n            }\r\n        };\r\n        return Colorize;\r\n    }());\r\n    exports.Colorize = Colorize;\r\n    /**\r\n     * Applies the "Lighten" effect to a sprite, changes the lightness of the color according to HSL\r\n     */\r\n    var Lighten = (function () {\r\n        /**\r\n         * @param factor  The factor of the effect between 0-1\r\n         */\r\n        function Lighten(factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.factor = factor;\r\n        }\r\n        Lighten.prototype.updatePixel = function (x, y, imageData) {\r\n            var firstPixel = (x + y * imageData.width) * 4;\r\n            var pixel = imageData.data;\r\n            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).lighten(this.factor);\r\n            pixel[firstPixel + 0] = color.r;\r\n            pixel[firstPixel + 1] = color.g;\r\n            pixel[firstPixel + 2] = color.b;\r\n            pixel[firstPixel + 3] = color.a;\r\n        };\r\n        return Lighten;\r\n    }());\r\n    exports.Lighten = Lighten;\r\n    /**\r\n     * Applies the "Darken" effect to a sprite, changes the darkness of the color according to HSL\r\n     */\r\n    var Darken = (function () {\r\n        /**\r\n         * @param factor  The factor of the effect between 0-1\r\n         */\r\n        function Darken(factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.factor = factor;\r\n        }\r\n        Darken.prototype.updatePixel = function (x, y, imageData) {\r\n            var firstPixel = (x + y * imageData.width) * 4;\r\n            var pixel = imageData.data;\r\n            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).darken(this.factor);\r\n            pixel[firstPixel + 0] = color.r;\r\n            pixel[firstPixel + 1] = color.g;\r\n            pixel[firstPixel + 2] = color.b;\r\n            pixel[firstPixel + 3] = color.a;\r\n        };\r\n        return Darken;\r\n    }());\r\n    exports.Darken = Darken;\r\n    /**\r\n     * Applies the "Saturate" effect to a sprite, saturates the color according to HSL\r\n     */\r\n    var Saturate = (function () {\r\n        /**\r\n         * @param factor  The factor of the effect between 0-1\r\n         */\r\n        function Saturate(factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.factor = factor;\r\n        }\r\n        Saturate.prototype.updatePixel = function (x, y, imageData) {\r\n            var firstPixel = (x + y * imageData.width) * 4;\r\n            var pixel = imageData.data;\r\n            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).saturate(this.factor);\r\n            pixel[firstPixel + 0] = color.r;\r\n            pixel[firstPixel + 1] = color.g;\r\n            pixel[firstPixel + 2] = color.b;\r\n            pixel[firstPixel + 3] = color.a;\r\n        };\r\n        return Saturate;\r\n    }());\r\n    exports.Saturate = Saturate;\r\n    /**\r\n     * Applies the "Desaturate" effect to a sprite, desaturates the color according to HSL\r\n     */\r\n    var Desaturate = (function () {\r\n        /**\r\n         * @param factor  The factor of the effect between 0-1\r\n         */\r\n        function Desaturate(factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.factor = factor;\r\n        }\r\n        Desaturate.prototype.updatePixel = function (x, y, imageData) {\r\n            var firstPixel = (x + y * imageData.width) * 4;\r\n            var pixel = imageData.data;\r\n            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).desaturate(this.factor);\r\n            pixel[firstPixel + 0] = color.r;\r\n            pixel[firstPixel + 1] = color.g;\r\n            pixel[firstPixel + 2] = color.b;\r\n            pixel[firstPixel + 3] = color.a;\r\n        };\r\n        return Desaturate;\r\n    }());\r\n    exports.Desaturate = Desaturate;\r\n    /**\r\n     * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match\r\n     * a given color\r\n     */\r\n    var Fill = (function () {\r\n        /**\r\n         * @param color  The color to apply to the sprite\r\n         */\r\n        function Fill(color) {\r\n            this.color = color;\r\n        }\r\n        Fill.prototype.updatePixel = function (x, y, imageData) {\r\n            var firstPixel = (x + y * imageData.width) * 4;\r\n            var pixel = imageData.data;\r\n            if (pixel[firstPixel + 3] !== 0) {\r\n                pixel[firstPixel + 0] = this.color.r;\r\n                pixel[firstPixel + 1] = this.color.g;\r\n                pixel[firstPixel + 2] = this.color.b;\r\n            }\r\n        };\r\n        return Fill;\r\n    }());\r\n    exports.Fill = Fill;\r\n});\r\ndefine("Interfaces/IDrawable", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Interfaces/ILoadable", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Resources/Resource", ["require", "exports", "Class", "Promises", "Util/Log"], function (require, exports, Class_2, Promises_3, Log_3) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * The [[Resource]] type allows games built in Excalibur to load generic resources.\r\n     * For any type of remote resource it is recommended to use [[Resource]] for preloading.\r\n     *\r\n     * [[include:Resources.md]]\r\n     */\r\n    var Resource = (function (_super) {\r\n        __extends(Resource, _super);\r\n        /**\r\n         * @param path          Path to the remote resource\r\n         * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";\r\n         * @param bustCache     Whether or not to cache-bust requests\r\n         */\r\n        function Resource(path, responseType, bustCache) {\r\n            if (bustCache === void 0) { bustCache = true; }\r\n            var _this = _super.call(this) || this;\r\n            _this.path = path;\r\n            _this.responseType = responseType;\r\n            _this.bustCache = bustCache;\r\n            _this.data = null;\r\n            _this.logger = Log_3.Logger.getInstance();\r\n            _this.onprogress = function () { return; };\r\n            _this.oncomplete = function () { return; };\r\n            _this.onerror = function () { return; };\r\n            return _this;\r\n        }\r\n        /**\r\n         * Returns true if the Resource is completely loaded and is ready\r\n         * to be drawn.\r\n         */\r\n        Resource.prototype.isLoaded = function () {\r\n            return this.data !== null;\r\n        };\r\n        Resource.prototype.wireEngine = function (engine) {\r\n            this._engine = engine;\r\n        };\r\n        Resource.prototype._cacheBust = function (uri) {\r\n            var query = /\\?\\w*=\\w*/;\r\n            if (query.test(uri)) {\r\n                uri += (\'&__=\' + Date.now());\r\n            }\r\n            else {\r\n                uri += (\'?__=\' + Date.now());\r\n            }\r\n            return uri;\r\n        };\r\n        Resource.prototype._start = function () {\r\n            this.logger.debug(\'Started loading resource \' + this.path);\r\n        };\r\n        /**\r\n         * Begin loading the resource and returns a promise to be resolved on completion\r\n         */\r\n        Resource.prototype.load = function () {\r\n            var _this = this;\r\n            var complete = new Promises_3.Promise();\r\n            // Exit early if we already have data\r\n            if (this.data !== null) {\r\n                this.logger.debug(\'Already have data for resource\', this.path);\r\n                complete.resolve(this.data);\r\n                this.oncomplete();\r\n                return complete;\r\n            }\r\n            var request = new XMLHttpRequest();\r\n            request.open(\'GET\', this.bustCache ? this._cacheBust(this.path) : this.path, true);\r\n            request.responseType = this.responseType;\r\n            request.onloadstart = function () { _this._start(); };\r\n            request.onprogress = this.onprogress;\r\n            request.onerror = this.onerror;\r\n            request.onload = function () {\r\n                // XHR on file:// success status is 0, such as with PhantomJS\r\n                if (request.status !== 0 && request.status !== 200) {\r\n                    _this.logger.error(\'Failed to load resource \', _this.path, \' server responded with error code\', request.status);\r\n                    _this.onerror(request.response);\r\n                    complete.resolve(request.response);\r\n                    return;\r\n                }\r\n                _this.data = _this.processData(request.response);\r\n                _this.oncomplete();\r\n                _this.logger.debug(\'Completed loading resource\', _this.path);\r\n                complete.resolve(_this.data);\r\n            };\r\n            request.send();\r\n            return complete;\r\n        };\r\n        /**\r\n         * Returns the loaded data once the resource is loaded\r\n         */\r\n        Resource.prototype.getData = function () {\r\n            return this.data;\r\n        };\r\n        /**\r\n         * Sets the data for this resource directly\r\n         */\r\n        Resource.prototype.setData = function (data) {\r\n            this.data = this.processData(data);\r\n        };\r\n        /**\r\n         * This method is meant to be overriden to handle any additional\r\n         * processing. Such as decoding downloaded audio bits.\r\n         */\r\n        Resource.prototype.processData = function (data) {\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType\r\n            // Blob requires an object url\r\n            if (this.responseType === \'blob\') {\r\n                return URL.createObjectURL(data);\r\n            }\r\n            return data;\r\n        };\r\n        return Resource;\r\n    }(Class_2.Class));\r\n    exports.Resource = Resource;\r\n});\r\ndefine("Resources/Texture", ["require", "exports", "Resources/Resource", "Promises", "Drawing/Sprite"], function (require, exports, Resource_1, Promises_4, Sprite_1) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * The [[Texture]] object allows games built in Excalibur to load image resources.\r\n     * [[Texture]] is an [[ILoadable]] which means it can be passed to a [[Loader]]\r\n     * to pre-load before starting a level or game.\r\n     *\r\n     * [[include:Textures.md]]\r\n     */\r\n    var Texture = (function (_super) {\r\n        __extends(Texture, _super);\r\n        /**\r\n         * @param path       Path to the image resource\r\n         * @param bustCache  Optionally load texture with cache busting\r\n         */\r\n        function Texture(path, bustCache) {\r\n            if (bustCache === void 0) { bustCache = true; }\r\n            var _this = _super.call(this, path, \'blob\', bustCache) || this;\r\n            _this.path = path;\r\n            _this.bustCache = bustCache;\r\n            /**\r\n             * A [[Promise]] that resolves when the Texture is loaded.\r\n             */\r\n            _this.loaded = new Promises_4.Promise();\r\n            _this._isLoaded = false;\r\n            _this._sprite = null;\r\n            _this._sprite = new Sprite_1.Sprite(_this, 0, 0, 0, 0);\r\n            return _this;\r\n        }\r\n        /**\r\n         * Returns true if the Texture is completely loaded and is ready\r\n         * to be drawn.\r\n         */\r\n        Texture.prototype.isLoaded = function () {\r\n            return this._isLoaded;\r\n        };\r\n        /**\r\n         * Begins loading the texture and returns a promise to be resolved on completion\r\n         */\r\n        Texture.prototype.load = function () {\r\n            var _this = this;\r\n            var complete = new Promises_4.Promise();\r\n            var loaded = _super.prototype.load.call(this);\r\n            loaded.then(function () {\r\n                _this.image = new Image();\r\n                _this.image.addEventListener(\'load\', function () {\r\n                    _this._isLoaded = true;\r\n                    _this.width = _this._sprite.swidth = _this._sprite.naturalWidth = _this._sprite.width = _this.image.naturalWidth;\r\n                    _this.height = _this._sprite.sheight = _this._sprite.naturalHeight = _this._sprite.height = _this.image.naturalHeight;\r\n                    _this.loaded.resolve(_this.image);\r\n                    complete.resolve(_this.image);\r\n                });\r\n                _this.image.src = _super.prototype.getData.call(_this);\r\n            }, function () {\r\n                complete.reject(\'Error loading texture.\');\r\n            });\r\n            return complete;\r\n        };\r\n        Texture.prototype.asSprite = function () {\r\n            return this._sprite;\r\n        };\r\n        return Texture;\r\n    }(Resource_1.Resource));\r\n    exports.Texture = Texture;\r\n});\r\ndefine("Drawing/Sprite", ["require", "exports", "Drawing/SpriteEffects", "Drawing/Color", "Algebra", "Util/Log", "Util/Util"], function (require, exports, Effects, Color_9, Algebra_11, Log_4, Util_2) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * A [[Sprite]] is one of the main drawing primitives. It is responsible for drawing\r\n     * images or parts of images from a [[Texture]] resource to the screen.\r\n     *\r\n     * [[include:Sprites.md]]\r\n     */\r\n    var Sprite = (function () {\r\n        /**\r\n         * @param image   The backing image texture to build the Sprite\r\n         * @param sx      The x position of the sprite\r\n         * @param sy      The y position of the sprite\r\n         * @param swidth  The width of the sprite in pixels\r\n         * @param sheight The height of the sprite in pixels\r\n         */\r\n        function Sprite(image, sx, sy, swidth, sheight) {\r\n            var _this = this;\r\n            this.sx = sx;\r\n            this.sy = sy;\r\n            this.swidth = swidth;\r\n            this.sheight = sheight;\r\n            this.rotation = 0.0;\r\n            this.anchor = new Algebra_11.Vector(0.0, 0.0);\r\n            this.scale = new Algebra_11.Vector(1, 1);\r\n            this.logger = Log_4.Logger.getInstance();\r\n            /**\r\n             * Draws the sprite flipped vertically\r\n             */\r\n            this.flipVertical = false;\r\n            /**\r\n             * Draws the sprite flipped horizontally\r\n             */\r\n            this.flipHorizontal = false;\r\n            this.width = 0;\r\n            this.height = 0;\r\n            this.effects = [];\r\n            this.naturalWidth = 0;\r\n            this.naturalHeight = 0;\r\n            this._spriteCanvas = null;\r\n            this._spriteCtx = null;\r\n            this._pixelData = null;\r\n            this._pixelsLoaded = false;\r\n            this._dirtyEffect = false;\r\n            if (sx < 0 || sy < 0 || swidth < 0 || sheight < 0) {\r\n                this.logger.error(\'Sprite cannot have any negative dimensions x:\', sx, \'y:\', sy, \'width:\', swidth, \'height:\', sheight);\r\n            }\r\n            this._texture = image;\r\n            this._spriteCanvas = document.createElement(\'canvas\');\r\n            this._spriteCanvas.width = swidth;\r\n            this._spriteCanvas.height = sheight;\r\n            this._spriteCtx = this._spriteCanvas.getContext(\'2d\');\r\n            this._texture.loaded.then(function () {\r\n                _this._spriteCanvas.width = _this._spriteCanvas.width || _this._texture.image.naturalWidth;\r\n                _this._spriteCanvas.height = _this._spriteCanvas.height || _this._texture.image.naturalHeight;\r\n                _this._loadPixels();\r\n                _this._dirtyEffect = true;\r\n            }).error(function (e) {\r\n                _this.logger.error(\'Error loading texture \', _this._texture.path, e);\r\n            });\r\n            this.width = swidth;\r\n            this.height = sheight;\r\n            this.naturalWidth = swidth;\r\n            this.naturalHeight = sheight;\r\n        }\r\n        Sprite.prototype._loadPixels = function () {\r\n            if (this._texture.isLoaded() && !this._pixelsLoaded) {\r\n                var naturalWidth = this._texture.image.naturalWidth || 0;\r\n                var naturalHeight = this._texture.image.naturalHeight || 0;\r\n                if (this.swidth > naturalWidth) {\r\n                    this.logger.warn(\'The sprite width\', this.swidth, \'exceeds the width\', naturalWidth, \'of the backing texture\', this._texture.path);\r\n                }\r\n                if (this.sheight > naturalHeight) {\r\n                    this.logger.warn(\'The sprite height\', this.sheight, \'exceeds the height\', naturalHeight, \'of the backing texture\', this._texture.path);\r\n                }\r\n                this._spriteCtx.drawImage(this._texture.image, Util_2.clamp(this.sx, 0, naturalWidth), Util_2.clamp(this.sy, 0, naturalHeight), Util_2.clamp(this.swidth, 0, naturalWidth), Util_2.clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);\r\n                this._pixelsLoaded = true;\r\n            }\r\n        };\r\n        /**\r\n         * Applies the [[Opacity]] effect to a sprite, setting the alpha of all pixels to a given value\r\n         */\r\n        Sprite.prototype.opacity = function (value) {\r\n            this.addEffect(new Effects.Opacity(value));\r\n        };\r\n        /**\r\n         * Applies the [[Grayscale]] effect to a sprite, removing color information.\r\n         */\r\n        Sprite.prototype.grayscale = function () {\r\n            this.addEffect(new Effects.Grayscale());\r\n        };\r\n        /**\r\n         * Applies the [[Invert]] effect to a sprite, inverting the pixel colors.\r\n         */\r\n        Sprite.prototype.invert = function () {\r\n            this.addEffect(new Effects.Invert());\r\n        };\r\n        /**\r\n         * Applies the [[Fill]] effect to a sprite, changing the color channels of all non-transparent pixels to match a given color\r\n         */\r\n        Sprite.prototype.fill = function (color) {\r\n            this.addEffect(new Effects.Fill(color));\r\n        };\r\n        /**\r\n         * Applies the [[Colorize]] effect to a sprite, changing the color channels of all pixels to be the average of the original color\r\n         * and the provided color.\r\n         */\r\n        Sprite.prototype.colorize = function (color) {\r\n            this.addEffect(new Effects.Colorize(color));\r\n        };\r\n        /**\r\n         * Applies the [[Lighten]] effect to a sprite, changes the lightness of the color according to HSL\r\n         */\r\n        Sprite.prototype.lighten = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.addEffect(new Effects.Lighten(factor));\r\n        };\r\n        /**\r\n         * Applies the [[Darken]] effect to a sprite, changes the darkness of the color according to HSL\r\n         */\r\n        Sprite.prototype.darken = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.addEffect(new Effects.Darken(factor));\r\n        };\r\n        /**\r\n         * Applies the [[Saturate]] effect to a sprite, saturates the color according to HSL\r\n         */\r\n        Sprite.prototype.saturate = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.addEffect(new Effects.Saturate(factor));\r\n        };\r\n        /**\r\n         * Applies the [[Desaturate]] effect to a sprite, desaturates the color according to HSL\r\n         */\r\n        Sprite.prototype.desaturate = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.addEffect(new Effects.Desaturate(factor));\r\n        };\r\n        /**\r\n         * Adds a new [[ISpriteEffect]] to this drawing.\r\n         * @param effect  Effect to add to the this drawing\r\n         */\r\n        Sprite.prototype.addEffect = function (effect) {\r\n            this.effects.push(effect);\r\n            // We must check if the texture and the backing sprite pixels are loaded as well before \r\n            // an effect can be applied\r\n            if (!this._texture.isLoaded() || !this._pixelsLoaded) {\r\n                this._dirtyEffect = true;\r\n            }\r\n            else {\r\n                this._applyEffects();\r\n            }\r\n        };\r\n        Sprite.prototype.removeEffect = function (param) {\r\n            var indexToRemove = -1;\r\n            if (typeof param === \'number\') {\r\n                indexToRemove = param;\r\n            }\r\n            else {\r\n                indexToRemove = this.effects.indexOf(param);\r\n            }\r\n            // bounds check\r\n            if (indexToRemove < 0 || indexToRemove >= this.effects.length) {\r\n                return;\r\n            }\r\n            this.effects.splice(indexToRemove, 1);\r\n            // We must check if the texture and the backing sprite pixels are loaded as well before \r\n            // an effect can be applied\r\n            if (!this._texture.isLoaded() || !this._pixelsLoaded) {\r\n                this._dirtyEffect = true;\r\n            }\r\n            else {\r\n                this._applyEffects();\r\n            }\r\n        };\r\n        Sprite.prototype._applyEffects = function () {\r\n            var naturalWidth = this._texture.image.naturalWidth || 0;\r\n            var naturalHeight = this._texture.image.naturalHeight || 0;\r\n            this._spriteCtx.clearRect(0, 0, this.swidth, this.sheight);\r\n            this._spriteCtx.drawImage(this._texture.image, Util_2.clamp(this.sx, 0, naturalWidth), Util_2.clamp(this.sy, 0, naturalHeight), Util_2.clamp(this.swidth, 0, naturalWidth), Util_2.clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);\r\n            this._pixelData = this._spriteCtx.getImageData(0, 0, this.swidth, this.sheight);\r\n            var i = 0, x = 0, y = 0, len = this.effects.length;\r\n            for (i; i < len; i++) {\r\n                y = 0;\r\n                for (y; y < this.sheight; y++) {\r\n                    x = 0;\r\n                    for (x; x < this.swidth; x++) {\r\n                        this.effects[i].updatePixel(x, y, this._pixelData);\r\n                    }\r\n                }\r\n            }\r\n            this._spriteCtx.clearRect(0, 0, this.swidth, this.sheight);\r\n            this._spriteCtx.putImageData(this._pixelData, 0, 0);\r\n            this._dirtyEffect = false;\r\n        };\r\n        /**\r\n         * Clears all effects from the drawing and return it to its original state.\r\n         */\r\n        Sprite.prototype.clearEffects = function () {\r\n            this.effects.length = 0;\r\n            this._applyEffects();\r\n        };\r\n        /**\r\n         * Resets the internal state of the drawing (if any)\r\n         */\r\n        Sprite.prototype.reset = function () {\r\n            // do nothing\r\n        };\r\n        Sprite.prototype.debugDraw = function (ctx, x, y) {\r\n            ctx.save();\r\n            ctx.translate(x, y);\r\n            ctx.rotate(this.rotation);\r\n            var scaledSWidth = this.width * this.scale.x;\r\n            var scaledSHeight = this.height * this.scale.y;\r\n            var xpoint = (scaledSWidth) * this.anchor.x;\r\n            var ypoint = (scaledSHeight) * this.anchor.y;\r\n            ctx.strokeStyle = Color_9.Color.Black.toString();\r\n            ctx.strokeRect(-xpoint, -ypoint, scaledSWidth, scaledSHeight);\r\n            ctx.restore();\r\n        };\r\n        /**\r\n         * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.\r\n         * @param ctx  The 2D rendering context\r\n         * @param x    The x coordinate of where to draw\r\n         * @param y    The y coordinate of where to draw\r\n         */\r\n        Sprite.prototype.draw = function (ctx, x, y) {\r\n            if (this._dirtyEffect) {\r\n                this._applyEffects();\r\n            }\r\n            // calculating current dimensions\r\n            this.width = this.naturalWidth * this.scale.x;\r\n            this.height = this.naturalHeight * this.scale.y;\r\n            ctx.save();\r\n            var xpoint = this.width * this.anchor.x;\r\n            var ypoint = this.height * this.anchor.y;\r\n            ctx.translate(x, y);\r\n            ctx.rotate(this.rotation);\r\n            var scaledSWidth = this.swidth * this.scale.x;\r\n            var scaledSHeight = this.sheight * this.scale.y;\r\n            // todo cache flipped sprites\r\n            if (this.flipHorizontal) {\r\n                ctx.translate(scaledSWidth, 0);\r\n                ctx.scale(-1, 1);\r\n            }\r\n            if (this.flipVertical) {\r\n                ctx.translate(0, scaledSHeight);\r\n                ctx.scale(1, -1);\r\n            }\r\n            ctx.drawImage(this._spriteCanvas, 0, 0, this.swidth, this.sheight, -xpoint, -ypoint, scaledSWidth, scaledSHeight);\r\n            ctx.restore();\r\n        };\r\n        /**\r\n         * Produces a copy of the current sprite\r\n         */\r\n        Sprite.prototype.clone = function () {\r\n            var result = new Sprite(this._texture, this.sx, this.sy, this.swidth, this.sheight);\r\n            result.scale = this.scale.clone();\r\n            result.rotation = this.rotation;\r\n            result.flipHorizontal = this.flipHorizontal;\r\n            result.flipVertical = this.flipVertical;\r\n            var i = 0, len = this.effects.length;\r\n            for (i; i < len; i++) {\r\n                result.addEffect(this.effects[i]);\r\n            }\r\n            return result;\r\n        };\r\n        return Sprite;\r\n    }());\r\n    exports.Sprite = Sprite;\r\n});\r\ndefine("Drawing/Animation", ["require", "exports", "Drawing/SpriteEffects", "Algebra", "Util/Util"], function (require, exports, Effects, Algebra_12, Util) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Animations allow you to display a series of images one after another,\r\n     * creating the illusion of change. Generally these images will come from a [[SpriteSheet]] source.\r\n     *\r\n     * [[include:Animations.md]]\r\n     */\r\n    var Animation = (function () {\r\n        /**\r\n         * Typically you will use a [[SpriteSheet]] to generate an [[Animation]].\r\n         *\r\n         * @param engine  Reference to the current game engine\r\n         * @param images  An array of sprites to create the frames for the animation\r\n         * @param speed   The number in milliseconds to display each frame in the animation\r\n         * @param loop    Indicates whether the animation should loop after it is completed\r\n         */\r\n        function Animation(engine, images, speed, loop) {\r\n            /**\r\n             * Current frame index being shown\r\n             */\r\n            this.currentFrame = 0;\r\n            this._oldTime = Date.now();\r\n            this.anchor = new Algebra_12.Vector(0.0, 0.0);\r\n            this.rotation = 0.0;\r\n            this.scale = new Algebra_12.Vector(1, 1);\r\n            /**\r\n             * Indicates whether the animation should loop after it is completed\r\n             */\r\n            this.loop = true;\r\n            /**\r\n             * Indicates the frame index the animation should freeze on for a non-looping\r\n             * animation. By default it is the last frame.\r\n             */\r\n            this.freezeFrame = -1;\r\n            /**\r\n             * Flip each frame vertically. Sets [[Sprite.flipVertical]].\r\n             */\r\n            this.flipVertical = false;\r\n            /**\r\n             * Flip each frame horizontally. Sets [[Sprite.flipHorizontal]].\r\n             */\r\n            this.flipHorizontal = false;\r\n            this.width = 0;\r\n            this.height = 0;\r\n            this.naturalWidth = 0;\r\n            this.naturalHeight = 0;\r\n            this.sprites = images;\r\n            this.speed = speed;\r\n            this._engine = engine;\r\n            if (loop != null) {\r\n                this.loop = loop;\r\n            }\r\n            if (images && images[0]) {\r\n                this.height = images[0] ? images[0].height : 0;\r\n                this.width = images[0] ? images[0].width : 0;\r\n                this.naturalWidth = images[0] ? images[0].naturalWidth : 0;\r\n                this.naturalHeight = images[0] ? images[0].naturalHeight : 0;\r\n                this.freezeFrame = images.length - 1;\r\n            }\r\n        }\r\n        /**\r\n         * Applies the opacity effect to a sprite, setting the alpha of all pixels to a given value\r\n         */\r\n        Animation.prototype.opacity = function (value) {\r\n            this.addEffect(new Effects.Opacity(value));\r\n        };\r\n        /**\r\n         * Applies the grayscale effect to a sprite, removing color information.\r\n         */\r\n        Animation.prototype.grayscale = function () {\r\n            this.addEffect(new Effects.Grayscale());\r\n        };\r\n        /**\r\n         * Applies the invert effect to a sprite, inverting the pixel colors.\r\n         */\r\n        Animation.prototype.invert = function () {\r\n            this.addEffect(new Effects.Invert());\r\n        };\r\n        /**\r\n         * Applies the fill effect to a sprite, changing the color channels of all non-transparent pixels to match a given color\r\n         */\r\n        Animation.prototype.fill = function (color) {\r\n            this.addEffect(new Effects.Fill(color));\r\n        };\r\n        /**\r\n         * Applies the colorize effect to a sprite, changing the color channels of all pixels to be the average of the original color and the\r\n         * provided color.\r\n         */\r\n        Animation.prototype.colorize = function (color) {\r\n            this.addEffect(new Effects.Colorize(color));\r\n        };\r\n        /**\r\n         * Applies the lighten effect to a sprite, changes the lightness of the color according to hsl\r\n         */\r\n        Animation.prototype.lighten = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.addEffect(new Effects.Lighten(factor));\r\n        };\r\n        /**\r\n         * Applies the darken effect to a sprite, changes the darkness of the color according to hsl\r\n         */\r\n        Animation.prototype.darken = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.addEffect(new Effects.Darken(factor));\r\n        };\r\n        /**\r\n         * Applies the saturate effect to a sprite, saturates the color according to hsl\r\n         */\r\n        Animation.prototype.saturate = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.addEffect(new Effects.Saturate(factor));\r\n        };\r\n        /**\r\n         * Applies the desaturate effect to a sprite, desaturates the color according to hsl\r\n         */\r\n        Animation.prototype.desaturate = function (factor) {\r\n            if (factor === void 0) { factor = 0.1; }\r\n            this.addEffect(new Effects.Desaturate(factor));\r\n        };\r\n        /**\r\n         * Add a [[ISpriteEffect]] manually\r\n         */\r\n        Animation.prototype.addEffect = function (effect) {\r\n            for (var i in this.sprites) {\r\n                this.sprites[i].addEffect(effect);\r\n            }\r\n        };\r\n        Animation.prototype.removeEffect = function (param) {\r\n            for (var i in this.sprites) {\r\n                this.sprites[i].removeEffect(param);\r\n            }\r\n        };\r\n        /**\r\n         * Clear all sprite effects\r\n         */\r\n        Animation.prototype.clearEffects = function () {\r\n            for (var i in this.sprites) {\r\n                this.sprites[i].clearEffects();\r\n            }\r\n        };\r\n        Animation.prototype._setAnchor = function (point) {\r\n            //if (!this.anchor.equals(point)) {\r\n            for (var i in this.sprites) {\r\n                this.sprites[i].anchor.setTo(point.x, point.y);\r\n            }\r\n            //}\r\n        };\r\n        Animation.prototype._setRotation = function (radians) {\r\n            //if (this.rotation !== radians) {\r\n            for (var i in this.sprites) {\r\n                this.sprites[i].rotation = radians;\r\n            }\r\n            //}\r\n        };\r\n        Animation.prototype._setScale = function (scale) {\r\n            //if (!this.scale.equals(scale)) {\r\n            for (var i in this.sprites) {\r\n                this.sprites[i].scale = scale;\r\n            }\r\n            //}\r\n        };\r\n        /**\r\n         * Resets the animation to first frame.\r\n         */\r\n        Animation.prototype.reset = function () {\r\n            this.currentFrame = 0;\r\n        };\r\n        /**\r\n         * Indicates whether the animation is complete, animations that loop are never complete.\r\n         */\r\n        Animation.prototype.isDone = function () {\r\n            return (!this.loop && this.currentFrame >= this.sprites.length);\r\n        };\r\n        /**\r\n         * Not meant to be called by game developers. Ticks the animation forward internally and\r\n         * calculates whether to change to the frame.\r\n         * @internal\r\n         */\r\n        Animation.prototype.tick = function () {\r\n            var time = Date.now();\r\n            if ((time - this._oldTime) > this.speed) {\r\n                this.currentFrame = (this.loop ? (this.currentFrame + 1) % this.sprites.length : this.currentFrame + 1);\r\n                this._oldTime = time;\r\n            }\r\n        };\r\n        Animation.prototype._updateValues = function () {\r\n            this._setAnchor(this.anchor);\r\n            this._setRotation(this.rotation);\r\n            this._setScale(this.scale);\r\n        };\r\n        /**\r\n         * Skips ahead a specified number of frames in the animation\r\n         * @param frames  Frames to skip ahead\r\n         */\r\n        Animation.prototype.skip = function (frames) {\r\n            this.currentFrame = (this.currentFrame + frames) % this.sprites.length;\r\n        };\r\n        Animation.prototype.draw = function (ctx, x, y) {\r\n            this.tick();\r\n            this._updateValues();\r\n            var currSprite;\r\n            if (this.currentFrame < this.sprites.length) {\r\n                currSprite = this.sprites[this.currentFrame];\r\n                if (this.flipVertical) {\r\n                    currSprite.flipVertical = this.flipVertical;\r\n                }\r\n                if (this.flipHorizontal) {\r\n                    currSprite.flipHorizontal = this.flipHorizontal;\r\n                }\r\n                currSprite.draw(ctx, x, y);\r\n            }\r\n            if (this.freezeFrame !== -1 && this.currentFrame >= this.sprites.length) {\r\n                currSprite = this.sprites[Util.clamp(this.freezeFrame, 0, this.sprites.length - 1)];\r\n                currSprite.draw(ctx, x, y);\r\n            }\r\n            // add the calculated width\r\n            if (currSprite) {\r\n                this.width = currSprite.width;\r\n                this.height = currSprite.height;\r\n            }\r\n        };\r\n        /**\r\n         * Plays an animation at an arbitrary location in the game.\r\n         * @param x  The x position in the game to play\r\n         * @param y  The y position in the game to play\r\n         */\r\n        Animation.prototype.play = function (x, y) {\r\n            this.reset();\r\n            this._engine.playAnimation(this, x, y);\r\n        };\r\n        return Animation;\r\n    }());\r\n    exports.Animation = Animation;\r\n});\r\ndefine("Drawing/SpriteSheet", ["require", "exports", "Drawing/Sprite", "Drawing/Animation", "Drawing/Color", "Drawing/SpriteEffects", "Util/Log", "Label"], function (require, exports, Sprite_2, Animation_1, Color_10, Effects, Log_5, Label_1) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Sprite sheets are a useful mechanism for slicing up image resources into\r\n     * separate sprites or for generating in game animations. [[Sprite|Sprites]] are organized\r\n     * in row major order in the [[SpriteSheet]].\r\n     *\r\n     * [[include:SpriteSheets.md]]\r\n     */\r\n    var SpriteSheet = (function () {\r\n        /**\r\n         * @param image     The backing image texture to build the SpriteSheet\r\n         * @param columns   The number of columns in the image texture\r\n         * @param rows      The number of rows in the image texture\r\n         * @param spWidth   The width of each individual sprite in pixels\r\n         * @param spHeight  The height of each individual sprite in pixels\r\n         */\r\n        function SpriteSheet(image, columns, rows, spWidth, spHeight) {\r\n            this.image = image;\r\n            this.columns = columns;\r\n            this.rows = rows;\r\n            this.sprites = [];\r\n            this._internalImage = image.image;\r\n            this.sprites = new Array(columns * rows);\r\n            // TODO: Inspect actual image dimensions with preloading\r\n            /*if(spWidth * columns > this.internalImage.naturalWidth){\r\n               throw new Error("SpriteSheet specified is wider than image width");\r\n            }\r\n      \r\n            if(spHeight * rows > this.internalImage.naturalHeight){\r\n               throw new Error("SpriteSheet specified is higher than image height");\r\n            }*/\r\n            var i = 0;\r\n            var j = 0;\r\n            for (i = 0; i < rows; i++) {\r\n                for (j = 0; j < columns; j++) {\r\n                    this.sprites[j + i * columns] = new Sprite_2.Sprite(this.image, j * spWidth, i * spHeight, spWidth, spHeight);\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Create an animation from the this SpriteSheet by listing out the\r\n         * sprite indices. Sprites are organized in row major order in the SpriteSheet.\r\n         * @param engine   Reference to the current game [[Engine]]\r\n         * @param indices  An array of sprite indices to use in the animation\r\n         * @param speed    The number in milliseconds to display each frame in the animation\r\n         */\r\n        SpriteSheet.prototype.getAnimationByIndices = function (engine, indices, speed) {\r\n            var _this = this;\r\n            var images = indices.map(function (index) {\r\n                return _this.sprites[index];\r\n            });\r\n            images = images.map(function (i) {\r\n                return i.clone();\r\n            });\r\n            return new Animation_1.Animation(engine, images, speed);\r\n        };\r\n        /**\r\n         * Create an animation from the this SpriteSheet by specifing the range of\r\n         * images with the beginning and ending index\r\n         * @param engine      Reference to the current game Engine\r\n         * @param beginIndex  The index to start taking frames\r\n         * @param endIndex    The index to stop taking frames\r\n         * @param speed       The number in milliseconds to display each frame in the animation\r\n         */\r\n        SpriteSheet.prototype.getAnimationBetween = function (engine, beginIndex, endIndex, speed) {\r\n            var images = this.sprites.slice(beginIndex, endIndex);\r\n            images = images.map(function (i) {\r\n                return i.clone();\r\n            });\r\n            return new Animation_1.Animation(engine, images, speed);\r\n        };\r\n        /**\r\n         * Treat the entire SpriteSheet as one animation, organizing the frames in\r\n         * row major order.\r\n         * @param engine  Reference to the current game [[Engine]]\r\n         * @param speed   The number in milliseconds to display each frame the animation\r\n         */\r\n        SpriteSheet.prototype.getAnimationForAll = function (engine, speed) {\r\n            var sprites = this.sprites.map(function (i) {\r\n                return i.clone();\r\n            });\r\n            return new Animation_1.Animation(engine, sprites, speed);\r\n        };\r\n        /**\r\n         * Retreive a specific sprite from the SpriteSheet by its index. Sprites are organized\r\n         * in row major order in the SpriteSheet.\r\n         * @param index  The index of the sprite\r\n         */\r\n        SpriteSheet.prototype.getSprite = function (index) {\r\n            if (index >= 0 && index < this.sprites.length) {\r\n                return this.sprites[index];\r\n            }\r\n            else {\r\n                throw new Error(\'Invalid index: \' + index);\r\n            }\r\n        };\r\n        return SpriteSheet;\r\n    }());\r\n    exports.SpriteSheet = SpriteSheet;\r\n    /**\r\n     * Sprite fonts are a used in conjunction with a [[Label]] to specify\r\n     * a particular bitmap as a font. Note that some font features are not\r\n     * supported by Sprite fonts.\r\n     *\r\n     * [[include:SpriteFonts.md]]\r\n     */\r\n    var SpriteFont = (function (_super) {\r\n        __extends(SpriteFont, _super);\r\n        /**\r\n         * @param image           The backing image texture to build the SpriteFont\r\n         * @param alphabet        A string representing all the characters in the image, in row major order.\r\n         * @param caseInsensitive  Indicate whether this font takes case into account\r\n         * @param columns         The number of columns of characters in the image\r\n         * @param rows            The number of rows of characters in the image\r\n         * @param spWidth         The width of each character in pixels\r\n         * @param spHeight        The height of each character in pixels\r\n         */\r\n        function SpriteFont(image, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {\r\n            var _this = _super.call(this, image, columns, rows, spWidth, spHeight) || this;\r\n            _this.image = image;\r\n            _this.alphabet = alphabet;\r\n            _this.caseInsensitive = caseInsensitive;\r\n            _this.spWidth = spWidth;\r\n            _this.spHeight = spHeight;\r\n            _this._currentColor = Color_10.Color.Black.clone();\r\n            _this._currentOpacity = 1.0;\r\n            _this._sprites = {};\r\n            // text shadow\r\n            _this._textShadowOn = false;\r\n            _this._textShadowDirty = true;\r\n            _this._textShadowColor = Color_10.Color.Black.clone();\r\n            _this._textShadowSprites = {};\r\n            _this._shadowOffsetX = 5;\r\n            _this._shadowOffsetY = 5;\r\n            _this._sprites = _this.getTextSprites();\r\n            return _this;\r\n        }\r\n        /**\r\n         * Returns a dictionary that maps each character in the alphabet to the appropriate [[Sprite]].\r\n         */\r\n        SpriteFont.prototype.getTextSprites = function () {\r\n            var lookup = {};\r\n            for (var i = 0; i < this.alphabet.length; i++) {\r\n                var char = this.alphabet[i];\r\n                if (this.caseInsensitive) {\r\n                    char = char.toLowerCase();\r\n                }\r\n                lookup[char] = this.sprites[i].clone();\r\n            }\r\n            return lookup;\r\n        };\r\n        /**\r\n         * Sets the text shadow for sprite fonts\r\n         * @param offsetX      The x offset in pixels to place the shadow\r\n         * @param offsetY      The y offset in pixels to place the shadow\r\n         * @param shadowColor  The color of the text shadow\r\n         */\r\n        SpriteFont.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {\r\n            this._textShadowOn = true;\r\n            this._shadowOffsetX = offsetX;\r\n            this._shadowOffsetY = offsetY;\r\n            this._textShadowColor = shadowColor.clone();\r\n            this._textShadowDirty = true;\r\n            for (var character in this._sprites) {\r\n                this._textShadowSprites[character] = this._sprites[character].clone();\r\n            }\r\n        };\r\n        /**\r\n         * Toggles text shadows on or off\r\n         */\r\n        SpriteFont.prototype.useTextShadow = function (on) {\r\n            this._textShadowOn = on;\r\n            if (on) {\r\n                this.setTextShadow(5, 5, this._textShadowColor);\r\n            }\r\n        };\r\n        /**\r\n         * Draws the current sprite font\r\n         */\r\n        SpriteFont.prototype.draw = function (ctx, text, x, y, options) {\r\n            options = this._parseOptions(options);\r\n            if (this._currentColor.toString() !== options.color.toString() || this._currentOpacity !== options.opacity) {\r\n                this._currentOpacity = options.opacity;\r\n                this._currentColor = options.color;\r\n                for (var char in this._sprites) {\r\n                    this._sprites[char].clearEffects();\r\n                    this._sprites[char].fill(options.color);\r\n                    this._sprites[char].opacity(options.opacity);\r\n                }\r\n            }\r\n            if (this._textShadowOn && this._textShadowDirty && this._textShadowColor) {\r\n                for (var characterShadow in this._textShadowSprites) {\r\n                    this._textShadowSprites[characterShadow].clearEffects();\r\n                    this._textShadowSprites[characterShadow].addEffect(new Effects.Fill(this._textShadowColor.clone()));\r\n                }\r\n                this._textShadowDirty = false;\r\n            }\r\n            // find the current length of text in pixels\r\n            var sprite = this.sprites[0];\r\n            // find the current height fo the text in pixels\r\n            var height = sprite.sheight;\r\n            // calculate appropriate scale for font size\r\n            var scale = options.fontSize / height;\r\n            var length = (text.length * sprite.swidth * scale) + (text.length * options.letterSpacing);\r\n            var currX = x;\r\n            if (options.textAlign === Label_1.TextAlign.Left || options.textAlign === Label_1.TextAlign.Start) {\r\n                currX = x;\r\n            }\r\n            else if (options.textAlign === Label_1.TextAlign.Right || options.textAlign === Label_1.TextAlign.End) {\r\n                currX = x - length;\r\n            }\r\n            else if (options.textAlign === Label_1.TextAlign.Center) {\r\n                currX = x - length / 2;\r\n            }\r\n            var currY = y - height * scale;\r\n            if (options.baseAlign === Label_1.BaseAlign.Top || options.baseAlign === Label_1.BaseAlign.Hanging) {\r\n                currY = y;\r\n            }\r\n            else if (options.baseAlign === Label_1.BaseAlign.Ideographic ||\r\n                options.baseAlign === Label_1.BaseAlign.Bottom ||\r\n                options.baseAlign === Label_1.BaseAlign.Alphabetic) {\r\n                currY = y - height * scale;\r\n            }\r\n            else if (options.baseAlign === Label_1.BaseAlign.Middle) {\r\n                currY = y - (height * scale) / 2;\r\n            }\r\n            for (var i = 0; i < text.length; i++) {\r\n                var character = text[i];\r\n                if (this.caseInsensitive) {\r\n                    character = character.toLowerCase();\r\n                }\r\n                try {\r\n                    // if text shadow\r\n                    if (this._textShadowOn) {\r\n                        this._textShadowSprites[character].scale.x = scale;\r\n                        this._textShadowSprites[character].scale.y = scale;\r\n                        this._textShadowSprites[character].draw(ctx, currX + this._shadowOffsetX, currY + this._shadowOffsetY);\r\n                    }\r\n                    var charSprite = this._sprites[character];\r\n                    charSprite.scale.x = scale;\r\n                    charSprite.scale.y = scale;\r\n                    charSprite.draw(ctx, currX, currY);\r\n                    currX += (charSprite.width + options.letterSpacing);\r\n                }\r\n                catch (e) {\r\n                    Log_5.Logger.getInstance().error("SpriteFont Error drawing char " + character);\r\n                }\r\n            }\r\n        };\r\n        SpriteFont.prototype._parseOptions = function (options) {\r\n            return {\r\n                fontSize: options.fontSize || 10,\r\n                letterSpacing: options.letterSpacing || 0,\r\n                color: options.color || Color_10.Color.Black.clone(),\r\n                textAlign: typeof options.textAlign === undefined ? Label_1.TextAlign.Left : options.textAlign,\r\n                baseAlign: typeof options.baseAlign === undefined ? Label_1.BaseAlign.Bottom : options.baseAlign,\r\n                maxWidth: options.maxWidth || -1,\r\n                opacity: options.opacity || 0\r\n            };\r\n        };\r\n        return SpriteFont;\r\n    }(SpriteSheet));\r\n    exports.SpriteFont = SpriteFont;\r\n});\r\ndefine("Label", ["require", "exports", "Drawing/Color", "Actor"], function (require, exports, Color_11, Actor_4) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Enum representing the different font size units\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\r\n     */\r\n    var FontUnit;\r\n    (function (FontUnit) {\r\n        /**\r\n         * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values\r\n         */\r\n        FontUnit[FontUnit["Em"] = 0] = "Em";\r\n        /**\r\n         * Rem is similar to the Em, it is a scalable unit. 1 rem is eqaul to the font size of the root element\r\n         */\r\n        FontUnit[FontUnit["Rem"] = 1] = "Rem";\r\n        /**\r\n         * Pixel is a unit of length in screen pixels\r\n         */\r\n        FontUnit[FontUnit["Px"] = 2] = "Px";\r\n        /**\r\n         * Point is a physical unit length (1/72 of an inch)\r\n         */\r\n        FontUnit[FontUnit["Pt"] = 3] = "Pt";\r\n        /**\r\n         * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff\r\n         */\r\n        FontUnit[FontUnit["Percent"] = 4] = "Percent";\r\n    })(FontUnit = exports.FontUnit || (exports.FontUnit = {}));\r\n    /**\r\n     * Enum representing the different horizontal text alignments\r\n     */\r\n    var TextAlign;\r\n    (function (TextAlign) {\r\n        /**\r\n         * The text is left-aligned.\r\n         */\r\n        TextAlign[TextAlign["Left"] = 0] = "Left";\r\n        /**\r\n         * The text is right-aligned.\r\n         */\r\n        TextAlign[TextAlign["Right"] = 1] = "Right";\r\n        /**\r\n         * The text is centered.\r\n         */\r\n        TextAlign[TextAlign["Center"] = 2] = "Center";\r\n        /**\r\n         * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,\r\n         * right-aligned for right-to-left locales).\r\n         */\r\n        TextAlign[TextAlign["Start"] = 3] = "Start";\r\n        /**\r\n         * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,\r\n         * left-aligned for right-to-left locales).\r\n         */\r\n        TextAlign[TextAlign["End"] = 4] = "End";\r\n    })(TextAlign = exports.TextAlign || (exports.TextAlign = {}));\r\n    /**\r\n     * Enum representing the different baseline text alignments\r\n     */\r\n    var BaseAlign;\r\n    (function (BaseAlign) {\r\n        /**\r\n         * The text baseline is the top of the em square.\r\n         */\r\n        BaseAlign[BaseAlign["Top"] = 0] = "Top";\r\n        /**\r\n         * The text baseline is the hanging baseline.  Currently unsupported; this will act like\r\n         * alphabetic.\r\n         */\r\n        BaseAlign[BaseAlign["Hanging"] = 1] = "Hanging";\r\n        /**\r\n         * The text baseline is the middle of the em square.\r\n         */\r\n        BaseAlign[BaseAlign["Middle"] = 2] = "Middle";\r\n        /**\r\n         * The text baseline is the normal alphabetic baseline.\r\n         */\r\n        BaseAlign[BaseAlign["Alphabetic"] = 3] = "Alphabetic";\r\n        /**\r\n         * The text baseline is the ideographic baseline; this is the bottom of\r\n         * the body of the characters, if the main body of characters protrudes\r\n         * beneath the alphabetic baseline.  Currently unsupported; this will\r\n         * act like alphabetic.\r\n         */\r\n        BaseAlign[BaseAlign["Ideographic"] = 4] = "Ideographic";\r\n        /**\r\n         * The text baseline is the bottom of the bounding box.  This differs\r\n         * from the ideographic baseline in that the ideographic baseline\r\n         * doesn\'t consider descenders.\r\n         */\r\n        BaseAlign[BaseAlign["Bottom"] = 5] = "Bottom";\r\n    })(BaseAlign = exports.BaseAlign || (exports.BaseAlign = {}));\r\n    /**\r\n     * Enum representing the different possible font styles\r\n     */\r\n    var FontStyle;\r\n    (function (FontStyle) {\r\n        FontStyle[FontStyle["Normal"] = 0] = "Normal";\r\n        FontStyle[FontStyle["Italic"] = 1] = "Italic";\r\n        FontStyle[FontStyle["Oblique"] = 2] = "Oblique";\r\n    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));\r\n    /**\r\n     * Labels are the way to draw small amounts of text to the screen. They are\r\n     * actors and inherit all of the benefits and capabilities.\r\n     *\r\n     * [[include:Labels.md]]\r\n     */\r\n    var Label = (function (_super) {\r\n        __extends(Label, _super);\r\n        /**\r\n         * @param text        The text of the label\r\n         * @param x           The x position of the label\r\n         * @param y           The y position of the label\r\n         * @param fontFamily  Use any valid CSS font string for the label\'s font. Web fonts are supported. Default is `10px sans-serif`.\r\n         * @param spriteFont  Use an Excalibur sprite font for the label\'s font, if a SpriteFont is provided it will take precedence\r\n         * over a css font.\r\n         */\r\n        function Label(text, x, y, fontFamily, spriteFont) {\r\n            var _this = _super.call(this, x, y) || this;\r\n            /**\r\n             * Sets or gets the bold property of the label\'s text, by default it\'s false\r\n             */\r\n            _this.bold = false;\r\n            /**\r\n             * The font size in the selected units, default is 10 (default units is pixel)\r\n             */\r\n            _this.fontSize = 10;\r\n            /**\r\n             * The font style for this label, the default is [[FontStyle.Normal]]\r\n             */\r\n            _this.fontStyle = FontStyle.Normal;\r\n            /**\r\n             * The css units for a font size such as px, pt, em (SpriteFont only support px), by default is \'px\';\r\n             */\r\n            _this.fontUnit = FontUnit.Px;\r\n            /**\r\n             * Gets or sets the horizontal text alignment property for the label.\r\n             */\r\n            _this.textAlign = TextAlign.Left;\r\n            /**\r\n             * Gets or sets the baseline alignment property for the label.\r\n             */\r\n            _this.baseAlign = BaseAlign.Bottom;\r\n            /**\r\n             * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.\r\n             */\r\n            _this.letterSpacing = 0; //px\r\n            /**\r\n             * Whether or not the [[SpriteFont]] will be case-sensitive when matching characters.\r\n             */\r\n            _this.caseInsensitive = true;\r\n            _this._textShadowOn = false;\r\n            _this._shadowOffsetX = 0;\r\n            _this._shadowOffsetY = 0;\r\n            _this._shadowColor = Color_11.Color.Black.clone();\r\n            _this.text = text || \'\';\r\n            _this.color = Color_11.Color.Black.clone();\r\n            _this.spriteFont = spriteFont;\r\n            _this.collisionType = Actor_4.CollisionType.PreventCollision;\r\n            _this.fontFamily = fontFamily || \'sans-serif\'; // coalesce to default canvas font\r\n            if (spriteFont) {\r\n                //this._textSprites = spriteFont.getTextSprites();\r\n            }\r\n            return _this;\r\n        }\r\n        /**\r\n         * Returns the width of the text in the label (in pixels);\r\n         * @param ctx  Rendering context to measure the string with\r\n         */\r\n        Label.prototype.getTextWidth = function (ctx) {\r\n            var oldFont = ctx.font;\r\n            ctx.font = this._fontString;\r\n            var width = ctx.measureText(this.text).width;\r\n            ctx.font = oldFont;\r\n            return width;\r\n        };\r\n        // TypeScript doesn\'t support string enums :(\r\n        Label.prototype._lookupFontUnit = function (fontUnit) {\r\n            switch (fontUnit) {\r\n                case FontUnit.Em:\r\n                    return \'em\';\r\n                case FontUnit.Rem:\r\n                    return \'rem\';\r\n                case FontUnit.Pt:\r\n                    return \'pt\';\r\n                case FontUnit.Px:\r\n                    return \'px\';\r\n                case FontUnit.Percent:\r\n                    return \'%\';\r\n                default:\r\n                    return \'px\';\r\n            }\r\n        };\r\n        Label.prototype._lookupTextAlign = function (textAlign) {\r\n            switch (textAlign) {\r\n                case TextAlign.Left:\r\n                    return \'left\';\r\n                case TextAlign.Right:\r\n                    return \'right\';\r\n                case TextAlign.Center:\r\n                    return \'center\';\r\n                case TextAlign.End:\r\n                    return \'end\';\r\n                case TextAlign.Start:\r\n                    return \'start\';\r\n                default:\r\n                    return \'start\';\r\n            }\r\n        };\r\n        Label.prototype._lookupBaseAlign = function (baseAlign) {\r\n            switch (baseAlign) {\r\n                case BaseAlign.Alphabetic:\r\n                    return \'alphabetic\';\r\n                case BaseAlign.Bottom:\r\n                    return \'bottom\';\r\n                case BaseAlign.Hanging:\r\n                    return \'hangin\';\r\n                case BaseAlign.Ideographic:\r\n                    return \'ideographic\';\r\n                case BaseAlign.Middle:\r\n                    return \'middle\';\r\n                case BaseAlign.Top:\r\n                    return \'top\';\r\n                default:\r\n                    return \'alphabetic\';\r\n            }\r\n        };\r\n        Label.prototype._lookupFontStyle = function (fontStyle) {\r\n            var boldstring = this.bold ? \' bold\' : \'\';\r\n            switch (fontStyle) {\r\n                case FontStyle.Italic:\r\n                    return \'italic\' + boldstring;\r\n                case FontStyle.Normal:\r\n                    return \'normal\' + boldstring;\r\n                case FontStyle.Oblique:\r\n                    return \'oblique\' + boldstring;\r\n                default:\r\n                    return \'normal\' + boldstring;\r\n            }\r\n        };\r\n        /**\r\n         * Sets the text shadow for sprite fonts\r\n         * @param offsetX      The x offset in pixels to place the shadow\r\n         * @param offsetY      The y offset in pixels to place the shadow\r\n         * @param shadowColor  The color of the text shadow\r\n         */\r\n        Label.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {\r\n            this.spriteFont.setTextShadow(offsetX, offsetY, shadowColor);\r\n        };\r\n        /**\r\n         * Toggles text shadows on or off, only applies when using sprite fonts\r\n         */\r\n        Label.prototype.useTextShadow = function (on) {\r\n            this.spriteFont.useTextShadow(on);\r\n        };\r\n        /**\r\n         * Clears the current text shadow\r\n         */\r\n        Label.prototype.clearTextShadow = function () {\r\n            this._textShadowOn = false;\r\n            this._shadowOffsetX = 0;\r\n            this._shadowOffsetY = 0;\r\n            this._shadowColor = Color_11.Color.Black.clone();\r\n        };\r\n        Label.prototype.update = function (engine, delta) {\r\n            _super.prototype.update.call(this, engine, delta);\r\n            /*\r\n           if (this.spriteFont && (this._color !== this.color || this.previousOpacity !== this.opacity)) {\r\n              for (var character in this._textSprites) {\r\n                 this._textSprites[character].clearEffects();\r\n                 this._textSprites[character].fill(this.color.clone());\r\n                 this._textSprites[character].opacity(this.opacity);\r\n                 \r\n              }\r\n              this._color = this.color;\r\n              this.previousOpacity = this.opacity;\r\n           }\r\n      \r\n           if (this.spriteFont && this._textShadowOn && this._shadowColorDirty && this._shadowColor) {\r\n              for (var characterShadow in this._shadowSprites) {\r\n                 this._shadowSprites[characterShadow].clearEffects();\r\n                 this._shadowSprites[characterShadow].addEffect(new Effects.Fill(this._shadowColor.clone()));\r\n              }\r\n              this._shadowColorDirty = false;\r\n           }*/\r\n        };\r\n        Label.prototype.draw = function (ctx, delta) {\r\n            ctx.save();\r\n            ctx.translate(this.pos.x, this.pos.y);\r\n            ctx.scale(this.scale.x, this.scale.y);\r\n            ctx.rotate(this.rotation);\r\n            if (this._textShadowOn) {\r\n                ctx.save();\r\n                ctx.translate(this._shadowOffsetX, this._shadowOffsetY);\r\n                this._fontDraw(ctx);\r\n                ctx.restore();\r\n            }\r\n            this._fontDraw(ctx);\r\n            _super.prototype.draw.call(this, ctx, delta);\r\n            ctx.restore();\r\n        };\r\n        Label.prototype._fontDraw = function (ctx) {\r\n            if (this.spriteFont) {\r\n                this.spriteFont.draw(ctx, this.text, 0, 0, {\r\n                    color: this.color.clone(),\r\n                    baseAlign: this.baseAlign,\r\n                    textAlign: this.textAlign,\r\n                    fontSize: this.fontSize,\r\n                    letterSpacing: this.letterSpacing,\r\n                    opacity: this.opacity\r\n                });\r\n            }\r\n            else {\r\n                var oldAlign = ctx.textAlign;\r\n                var oldTextBaseline = ctx.textBaseline;\r\n                ctx.textAlign = this._lookupTextAlign(this.textAlign);\r\n                ctx.textBaseline = this._lookupBaseAlign(this.baseAlign);\r\n                if (this.color) {\r\n                    this.color.a = this.opacity;\r\n                }\r\n                ctx.fillStyle = this.color.toString();\r\n                ctx.font = this._fontString;\r\n                if (this.maxWidth) {\r\n                    ctx.fillText(this.text, 0, 0, this.maxWidth);\r\n                }\r\n                else {\r\n                    ctx.fillText(this.text, 0, 0);\r\n                }\r\n                ctx.textAlign = oldAlign;\r\n                ctx.textBaseline = oldTextBaseline;\r\n            }\r\n        };\r\n        Object.defineProperty(Label.prototype, "_fontString", {\r\n            get: function () {\r\n                return this._lookupFontStyle(this.fontStyle) + " " + this.fontSize + this._lookupFontUnit(this.fontUnit) + " " + this.fontFamily;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Label.prototype.debugDraw = function (ctx) {\r\n            _super.prototype.debugDraw.call(this, ctx);\r\n        };\r\n        return Label;\r\n    }(Actor_4.Actor));\r\n    exports.Label = Label;\r\n});\r\ndefine("Interfaces/IAudio", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Interfaces/IAudioImplementation", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Resources/Sound", ["require", "exports", "Util/Log", "Util/Util", "Promises"], function (require, exports, Log_6, Util, Promises_5) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    // set up audio context reference\r\n    // when we introduce multi-tracking, we may need to move this to a factory method\r\n    if (window.AudioContext) {\r\n        var audioContext = new window.AudioContext();\r\n    }\r\n    /**\r\n     * An audio implementation for HTML5 audio.\r\n     */\r\n    var AudioTag = (function () {\r\n        function AudioTag() {\r\n            this.responseType = \'blob\';\r\n        }\r\n        /**\r\n         * Transforms raw Blob data into a object URL for use in audio tag\r\n         */\r\n        AudioTag.prototype.processData = function (data) {\r\n            var url = URL.createObjectURL(data);\r\n            return Promises_5.Promise.resolve(url);\r\n        };\r\n        /**\r\n         * Creates a new instance of an audio tag referencing the provided audio URL\r\n         */\r\n        AudioTag.prototype.createInstance = function (url) {\r\n            return new AudioTagInstance(url);\r\n        };\r\n        return AudioTag;\r\n    }());\r\n    exports.AudioTag = AudioTag;\r\n    /**\r\n     * An audio implementation for Web Audio API.\r\n     */\r\n    var WebAudio = (function () {\r\n        function WebAudio() {\r\n            this._logger = Log_6.Logger.getInstance();\r\n            this.responseType = \'arraybuffer\';\r\n        }\r\n        /**\r\n         * Processes raw arraybuffer data and decodes into WebAudio buffer (async).\r\n         */\r\n        WebAudio.prototype.processData = function (data) {\r\n            var _this = this;\r\n            var complete = new Promises_5.Promise();\r\n            audioContext.decodeAudioData(data, function (buffer) {\r\n                complete.resolve(buffer);\r\n            }, function () {\r\n                _this._logger.error(\'Unable to decode \' +\r\n                    \' this browser may not fully support this format, or the file may be corrupt, \' +\r\n                    \'if this is an mp3 try removing id3 tags and album art from the file.\');\r\n                complete.resolve(undefined);\r\n            });\r\n            return complete;\r\n        };\r\n        /**\r\n         * Creates a new WebAudio AudioBufferSourceNode to play a sound instance\r\n         */\r\n        WebAudio.prototype.createInstance = function (buffer) {\r\n            return new WebAudioInstance(buffer);\r\n        };\r\n        /**\r\n         * Play an empty sound to unlock Safari WebAudio context. Call this function\r\n         * right after a user interaction event. Typically used by [[PauseAfterLoader]]\r\n         * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/\r\n         */\r\n        WebAudio.unlock = function () {\r\n            if (WebAudio._unlocked || !audioContext) {\r\n                return;\r\n            }\r\n            // create empty buffer and play it\r\n            var buffer = audioContext.createBuffer(1, 1, 22050);\r\n            var source = audioContext.createBufferSource();\r\n            var ended = false;\r\n            source.buffer = buffer;\r\n            source.connect(audioContext.destination);\r\n            source.onended = function () { return ended = true; };\r\n            if (source.noteOn) {\r\n                // deprecated\r\n                source.noteOn(0);\r\n            }\r\n            else {\r\n                source.start(0);\r\n            }\r\n            // by checking the play state after some time, we know if we\'re really unlocked\r\n            setTimeout(function () {\r\n                if (source.playbackState) {\r\n                    var legacySource = source;\r\n                    if (legacySource.playbackState === legacySource.PLAYING_STATE ||\r\n                        legacySource.playbackState === legacySource.FINISHED_STATE) {\r\n                        WebAudio._unlocked = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (audioContext.currentTime > 0 || ended) {\r\n                        WebAudio._unlocked = true;\r\n                    }\r\n                }\r\n            }, 0);\r\n        };\r\n        WebAudio.isUnlocked = function () {\r\n            return this._unlocked;\r\n        };\r\n        return WebAudio;\r\n    }());\r\n    WebAudio._unlocked = false;\r\n    exports.WebAudio = WebAudio;\r\n    /**\r\n     * Factory method that gets the audio implementation to use\r\n     */\r\n    function getAudioImplementation() {\r\n        if (window.AudioContext) {\r\n            return new WebAudio();\r\n        }\r\n        else {\r\n            return new AudioTag();\r\n        }\r\n    }\r\n    exports.getAudioImplementation = getAudioImplementation;\r\n    ;\r\n    /**\r\n     * The [[Sound]] object allows games built in Excalibur to load audio\r\n     * components, from soundtracks to sound effects. [[Sound]] is an [[ILoadable]]\r\n     * which means it can be passed to a [[Loader]] to pre-load before a game or level.\r\n     *\r\n     * [[include:Sounds.md]]\r\n     */\r\n    var Sound = (function () {\r\n        /**\r\n         * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.\r\n         */\r\n        function Sound() {\r\n            var paths = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                paths[_i] = arguments[_i];\r\n            }\r\n            this._logger = Log_6.Logger.getInstance();\r\n            this._data = null;\r\n            this._tracks = [];\r\n            this._isLoaded = false;\r\n            this._isPaused = false;\r\n            this._loop = false;\r\n            this._volume = 1.0;\r\n            this.onprogress = function () { return; };\r\n            this.oncomplete = function () { return; };\r\n            this.onerror = function () { return; };\r\n            this._wasPlayingOnHidden = false;\r\n            /* Chrome : MP3, WAV, Ogg\r\n               * Firefox : WAV, Ogg,\r\n               * IE : MP3, WAV coming soon\r\n               * Safari MP3, WAV, Ogg\r\n               */\r\n            this.path = \'\';\r\n            for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {\r\n                var path = paths_1[_a];\r\n                if (Sound.canPlayFile(path)) {\r\n                    this.path = path;\r\n                    break;\r\n                }\r\n            }\r\n            if (!this.path) {\r\n                this._logger.warn(\'This browser does not support any of the audio files specified:\', paths.join(\', \'));\r\n                this._logger.warn(\'Attempting to use\', paths[0]);\r\n                this.path = paths[0]; // select the first specified\r\n            }\r\n            this.sound = getAudioImplementation();\r\n        }\r\n        /**\r\n         * Whether or not the browser can play this file as HTML5 Audio\r\n         */\r\n        Sound.canPlayFile = function (file) {\r\n            try {\r\n                var a = new Audio();\r\n                var filetype = /.*\\.([A-Za-z0-9]+)$/;\r\n                var type = file.match(filetype)[1];\r\n                if (a.canPlayType(\'audio/\' + type)) {\r\n                    return true;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n            catch (e) {\r\n                Log_6.Logger.getInstance().warn(\'Cannot determine audio support, assuming no support for the Audio Tag\', e);\r\n                return false;\r\n            }\r\n        };\r\n        Sound.prototype.wireEngine = function (engine) {\r\n            var _this = this;\r\n            if (engine) {\r\n                this._engine = engine;\r\n                this._engine.on(\'hidden\', function () {\r\n                    if (engine.pauseAudioWhenHidden && _this.isPlaying()) {\r\n                        _this._wasPlayingOnHidden = true;\r\n                        _this.pause();\r\n                    }\r\n                });\r\n                this._engine.on(\'visible\', function () {\r\n                    if (engine.pauseAudioWhenHidden && _this._wasPlayingOnHidden) {\r\n                        _this.play();\r\n                        _this._wasPlayingOnHidden = false;\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        /**\r\n         * Returns how many instances of the sound are currently playing\r\n         */\r\n        Sound.prototype.instanceCount = function () {\r\n            return this._tracks.length;\r\n        };\r\n        /**\r\n         * Sets the volume of the sound clip\r\n         * @param volume  A volume value between 0-1.0\r\n         */\r\n        Sound.prototype.setVolume = function (volume) {\r\n            this._volume = volume;\r\n            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {\r\n                var track = _a[_i];\r\n                track.setVolume(volume);\r\n            }\r\n            this._logger.debug(\'Set volume for all instances of sound\', this.path, \'to\', volume);\r\n        };\r\n        /**\r\n         * Indicates whether the clip should loop when complete\r\n         * @param loop  Set the looping flag\r\n         */\r\n        Sound.prototype.setLoop = function (loop) {\r\n            this._loop = loop;\r\n            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {\r\n                var track = _a[_i];\r\n                track.setLoop(loop);\r\n            }\r\n            this._logger.debug(\'Set loop for all instances of sound\', this.path, \'to\', loop);\r\n        };\r\n        /**\r\n         * Whether or not the sound is playing right now\r\n         */\r\n        Sound.prototype.isPlaying = function () {\r\n            return this._tracks.some(function (t) { return t.isPlaying(); });\r\n        };\r\n        /**\r\n         * Play the sound, returns a promise that resolves when the sound is done playing\r\n         * An optional volume argument can be passed in to play the sound. Max volume is 1.0\r\n         */\r\n        Sound.prototype.play = function (volume) {\r\n            var _this = this;\r\n            if (this._isLoaded) {\r\n                var resumed = [];\r\n                // ensure we resume *current* tracks (if paused)\r\n                for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {\r\n                    var track = _a[_i];\r\n                    resumed.push(track.play());\r\n                }\r\n                // when paused, don\'t start playing new track\r\n                if (this._isPaused) {\r\n                    this._isPaused = false;\r\n                    this._logger.debug(\'Resuming paused instances for sound\', this.path, this._tracks);\r\n                    // resolve when resumed tracks are done\r\n                    return Promises_5.Promise.join(resumed);\r\n                }\r\n                // push a new track\r\n                var newTrack = this.sound.createInstance(this._data);\r\n                newTrack.setLoop(this._loop);\r\n                if (volume) {\r\n                    newTrack.setVolume(Util.clamp(volume, 0.0, 1.0));\r\n                }\r\n                else {\r\n                    newTrack.setVolume(this._volume);\r\n                }\r\n                this._tracks.push(newTrack);\r\n                this._logger.debug(\'Playing new instance for sound\', this.path);\r\n                return newTrack.play().then(function () {\r\n                    // when done, remove track\r\n                    _this._tracks.splice(_this._tracks.indexOf(newTrack), 1);\r\n                    return true;\r\n                });\r\n            }\r\n            else {\r\n                return Promises_5.Promise.resolve(true);\r\n            }\r\n        };\r\n        /**\r\n         * Stop the sound, and do not rewind\r\n         */\r\n        Sound.prototype.pause = function () {\r\n            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {\r\n                var track = _a[_i];\r\n                track.pause();\r\n            }\r\n            this._isPaused = true;\r\n            this._logger.debug(\'Paused all instances of sound\', this.path);\r\n        };\r\n        /**\r\n         * Stop the sound and rewind\r\n         */\r\n        Sound.prototype.stop = function () {\r\n            this._isPaused = false;\r\n            var tracks = this._tracks.concat([]);\r\n            for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {\r\n                var track = tracks_1[_i];\r\n                track.stop();\r\n            }\r\n            this._logger.debug(\'Stopped all instances of sound\', this.path);\r\n        };\r\n        /**\r\n         * Returns true if the sound is loaded\r\n         */\r\n        Sound.prototype.isLoaded = function () {\r\n            return this._isLoaded;\r\n        };\r\n        /**\r\n         * Begins loading the sound and returns a promise to be resolved on completion\r\n         */\r\n        Sound.prototype.load = function () {\r\n            var _this = this;\r\n            var complete = new Promises_5.Promise();\r\n            if (!!this.getData()) {\r\n                this._logger.debug(\'Already have data for audio resource\', this.path);\r\n                complete.resolve(this.sound);\r\n                this.oncomplete();\r\n                return complete;\r\n            }\r\n            this._logger.debug(\'Started loading sound\', this.path);\r\n            try {\r\n                this._fetchResource(function (request) {\r\n                    if (request.status !== 200) {\r\n                        _this._logger.error(\'Failed to load audio resource \', _this.path, \' server responded with error code\', request.status);\r\n                        _this.onerror(request.response);\r\n                        complete.resolve(null);\r\n                        return;\r\n                    }\r\n                    // load sound\r\n                    _this.setData(request.response).then(function () {\r\n                        _this.oncomplete();\r\n                        _this._logger.debug(\'Completed loading sound\', _this.path);\r\n                        complete.resolve(_this.sound);\r\n                    }, function (e) { return complete.resolve(e); });\r\n                });\r\n            }\r\n            catch (e) {\r\n                this._logger.error(\'Error loading sound! If this is a cross origin error, \\\r\n            you must host your sound with your html and javascript.\');\r\n                this.onerror(e);\r\n                complete.resolve(e);\r\n            }\r\n            return complete;\r\n        };\r\n        /* istanbul ignore next */\r\n        Sound.prototype._fetchResource = function (onload) {\r\n            var request = new XMLHttpRequest();\r\n            request.open(\'GET\', this.path, true);\r\n            request.responseType = this.sound.responseType;\r\n            request.onprogress = this.onprogress;\r\n            request.onerror = this.onerror;\r\n            request.onload = function () { return onload(request); };\r\n            request.send();\r\n        };\r\n        /**\r\n         * Gets the raw sound data (e.g. blob URL or AudioBuffer)\r\n         */\r\n        Sound.prototype.getData = function () {\r\n            return this._data;\r\n        };\r\n        /**\r\n         * Sets raw sound data and returns a Promise that is resolved when sound data is processed\r\n         *\r\n         * @param data The XHR data for the sound implementation to process (Blob or ArrayBuffer)\r\n         */\r\n        Sound.prototype.setData = function (data) {\r\n            var _this = this;\r\n            return this.sound.processData(data).then(function (data) {\r\n                _this._isLoaded = true;\r\n                _this._data = _this.processData(data);\r\n                return data;\r\n            });\r\n        };\r\n        /**\r\n         * Set the raw sound data (e.g. blob URL or AudioBuffer)\r\n         */\r\n        Sound.prototype.processData = function (data) {\r\n            return data;\r\n        };\r\n        return Sound;\r\n    }());\r\n    exports.Sound = Sound;\r\n    /**\r\n     * Internal class representing a HTML5 audio instance\r\n     */\r\n    /* istanbul ignore next */\r\n    var AudioTagInstance = (function () {\r\n        function AudioTagInstance(src) {\r\n            this._isPlaying = false;\r\n            this._isPaused = false;\r\n            this._loop = false;\r\n            this._volume = 1.0;\r\n            this._audioElement = new Audio(src);\r\n        }\r\n        AudioTagInstance.prototype.isPlaying = function () {\r\n            return this._isPlaying;\r\n        };\r\n        Object.defineProperty(AudioTagInstance.prototype, "loop", {\r\n            get: function () {\r\n                return this._loop;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        AudioTagInstance.prototype.setLoop = function (value) {\r\n            this._loop = value;\r\n            this._audioElement.loop = value;\r\n            this._wireUpOnEnded();\r\n        };\r\n        AudioTagInstance.prototype.setVolume = function (value) {\r\n            this._volume = value;\r\n            this._audioElement.volume = Util.clamp(value, 0, 1.0);\r\n        };\r\n        AudioTagInstance.prototype.play = function () {\r\n            if (this._isPaused) {\r\n                this._resume();\r\n            }\r\n            else if (!this._isPlaying) {\r\n                this._start();\r\n            }\r\n            return this._playingPromise;\r\n        };\r\n        AudioTagInstance.prototype._start = function () {\r\n            this._audioElement.load();\r\n            this._audioElement.loop = this._loop;\r\n            this._audioElement.play();\r\n            this._isPlaying = true;\r\n            this._isPaused = false;\r\n            this._playingPromise = new Promises_5.Promise();\r\n            this._wireUpOnEnded();\r\n        };\r\n        AudioTagInstance.prototype._resume = function () {\r\n            if (!this._isPaused) {\r\n                return;\r\n            }\r\n            this._audioElement.play();\r\n            this._isPaused = false;\r\n            this._isPlaying = true;\r\n            this._wireUpOnEnded();\r\n        };\r\n        AudioTagInstance.prototype.pause = function () {\r\n            if (!this._isPlaying) {\r\n                return;\r\n            }\r\n            this._audioElement.pause();\r\n            this._isPaused = true;\r\n            this._isPlaying = false;\r\n        };\r\n        AudioTagInstance.prototype.stop = function () {\r\n            if (!this._isPlaying) {\r\n                return;\r\n            }\r\n            this._audioElement.pause();\r\n            this._audioElement.currentTime = 0;\r\n            this._handleOnEnded();\r\n        };\r\n        AudioTagInstance.prototype._wireUpOnEnded = function () {\r\n            var _this = this;\r\n            if (!this._loop) {\r\n                this._audioElement.onended = function () { return _this._handleOnEnded(); };\r\n            }\r\n        };\r\n        AudioTagInstance.prototype._handleOnEnded = function () {\r\n            this._isPlaying = false;\r\n            this._isPaused = false;\r\n            this._playingPromise.resolve(true);\r\n        };\r\n        return AudioTagInstance;\r\n    }());\r\n    /**\r\n     * Internal class representing a Web Audio AudioBufferSourceNode instance\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\r\n     */\r\n    /* istanbul ignore next */\r\n    var WebAudioInstance = (function () {\r\n        function WebAudioInstance(_buffer) {\r\n            this._buffer = _buffer;\r\n            this._volumeNode = audioContext.createGain();\r\n            this._isPlaying = false;\r\n            this._isPaused = false;\r\n            this._loop = false;\r\n            this._volume = 1.0;\r\n            /**\r\n             * Current playback offset (in seconds)\r\n             */\r\n            this._currentOffset = 0;\r\n        }\r\n        WebAudioInstance.prototype.isPlaying = function () {\r\n            return this._isPlaying;\r\n        };\r\n        WebAudioInstance.prototype.setVolume = function (value) {\r\n            this._volume = value;\r\n            this._volumeNode.gain.value = Util.clamp(value, 0, 1.0);\r\n        };\r\n        WebAudioInstance.prototype.setLoop = function (value) {\r\n            this._loop = value;\r\n            if (this._bufferSource) {\r\n                this._bufferSource.loop = value;\r\n                this._wireUpOnEnded();\r\n            }\r\n        };\r\n        WebAudioInstance.prototype.play = function () {\r\n            if (this._isPaused) {\r\n                this._resume();\r\n            }\r\n            else if (!this._isPlaying) {\r\n                this._start();\r\n            }\r\n            return this._playingPromise;\r\n        };\r\n        WebAudioInstance.prototype._start = function () {\r\n            this._volumeNode.connect(audioContext.destination);\r\n            this._createBufferSource();\r\n            this._bufferSource.start(0, 0);\r\n            this._startTime = new Date().getTime();\r\n            this._currentOffset = 0;\r\n            this._isPlaying = true;\r\n            this._isPaused = false;\r\n            this._playingPromise = new Promises_5.Promise();\r\n            this._wireUpOnEnded();\r\n        };\r\n        WebAudioInstance.prototype._resume = function () {\r\n            if (!this._isPaused) {\r\n                return;\r\n            }\r\n            // a buffer source can only be started once\r\n            // so we need to dispose of the previous instance before\r\n            // "resuming" the next one\r\n            this._bufferSource.onended = null; // dispose of any previous event handler\r\n            this._createBufferSource();\r\n            var duration = (1 / this._bufferSource.playbackRate.value) * this._buffer.duration;\r\n            this._bufferSource.start(0, this._currentOffset % duration);\r\n            this._isPaused = false;\r\n            this._isPlaying = true;\r\n            this._wireUpOnEnded();\r\n        };\r\n        WebAudioInstance.prototype._createBufferSource = function () {\r\n            this._bufferSource = audioContext.createBufferSource();\r\n            this._bufferSource.buffer = this._buffer;\r\n            this._bufferSource.loop = this._loop;\r\n            this._bufferSource.playbackRate.value = 1.0;\r\n            this._bufferSource.connect(this._volumeNode);\r\n        };\r\n        WebAudioInstance.prototype.pause = function () {\r\n            if (!this._isPlaying) {\r\n                return;\r\n            }\r\n            this._bufferSource.stop(0);\r\n            // Playback rate will be a scale factor of how fast/slow the audio is being played\r\n            // default is 1.0\r\n            // we need to invert it to get the time scale\r\n            var pbRate = 1 / (this._bufferSource.playbackRate.value || 1.0);\r\n            this._currentOffset = ((new Date().getTime() - this._startTime) * pbRate) / 1000; // in seconds\r\n            this._isPaused = true;\r\n            this._isPlaying = false;\r\n        };\r\n        WebAudioInstance.prototype.stop = function () {\r\n            if (!this._isPlaying) {\r\n                return;\r\n            }\r\n            this._bufferSource.stop(0);\r\n            // handler will not be wired up if we were looping\r\n            if (!this._bufferSource.onended) {\r\n                this._handleOnEnded();\r\n            }\r\n            this._currentOffset = 0;\r\n            this._isPlaying = false;\r\n            this._isPaused = false;\r\n        };\r\n        WebAudioInstance.prototype._wireUpOnEnded = function () {\r\n            var _this = this;\r\n            if (!this._loop) {\r\n                this._bufferSource.onended = function () { return _this._handleOnEnded(); };\r\n            }\r\n        };\r\n        WebAudioInstance.prototype._handleOnEnded = function () {\r\n            // pausing calls stop(0) which triggers onended event\r\n            // so we don\'t "resolve" yet (when we resume we\'ll try again)\r\n            if (!this._isPaused) {\r\n                this._isPlaying = false;\r\n                this._playingPromise.resolve(true);\r\n            }\r\n        };\r\n        return WebAudioInstance;\r\n    }());\r\n});\r\ndefine("Interfaces/ILoader", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Loader", ["require", "exports", "Drawing/Color", "Resources/Sound", "Util/Log", "Promises", "Class", "Util/DrawUtil"], function (require, exports, Color_12, Sound_1, Log_7, Promises_6, Class_3, DrawUtil) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Pre-loading assets\r\n     *\r\n     * The loader provides a mechanism to preload multiple resources at\r\n     * one time. The loader must be passed to the engine in order to\r\n     * trigger the loading progress bar.\r\n     *\r\n     * The [[Loader]] itself implements [[ILoadable]] so you can load loaders.\r\n     *\r\n     * ## Example: Pre-loading resources for a game\r\n     *\r\n     * ```js\r\n     * // create a loader\r\n     * var loader = new ex.Loader();\r\n     *\r\n     * // create a resource dictionary (best practice is to keep a separate file)\r\n     * var resources = {\r\n     *   TextureGround: new ex.Texture("/images/textures/ground.png"),\r\n     *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")\r\n     * };\r\n     *\r\n     * // loop through dictionary and add to loader\r\n     * for (var loadable in resources) {\r\n     *   if (resources.hasOwnProperty(loadable)) {\r\n     *     loader.addResource(resources[loadable]);\r\n     *   }\r\n     * }\r\n     *\r\n     * // start game\r\n     * game.start(loader).then(function () {\r\n     *   console.log("Game started!");\r\n     * });\r\n     * ```\r\n     */\r\n    var Loader = (function (_super) {\r\n        __extends(Loader, _super);\r\n        /**\r\n         * @param loadables  Optionally provide the list of resources you want to load at constructor time\r\n         */\r\n        function Loader(loadables) {\r\n            var _this = _super.call(this) || this;\r\n            _this._resourceList = [];\r\n            _this._index = 0;\r\n            _this._resourceCount = 0;\r\n            _this._numLoaded = 0;\r\n            _this._progressCounts = {};\r\n            _this._totalCounts = {};\r\n            // logo drawing stuff\r\n            /* tslint:disable:max-line-length */\r\n            // base64 string encoding of the excalibur logo (logo-white.png)\r\n            _this.logo = \'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=\';\r\n            /* tslint:enable:max-line-length */\r\n            _this.logoWidth = 468;\r\n            _this.logoHeight = 118;\r\n            _this.backgroundColor = \'#176BAA\';\r\n            _this.getData = function () { return; };\r\n            _this.setData = function () { return; };\r\n            _this.processData = function () { return; };\r\n            _this.onprogress = function (e) {\r\n                Log_7.Logger.getInstance().debug(\'[ex.Loader] Loading \' + (100 * e.loaded / e.total).toFixed(0));\r\n                return;\r\n            };\r\n            _this.oncomplete = function () { return; };\r\n            _this.onerror = function () { return; };\r\n            if (loadables) {\r\n                _this.addResources(loadables);\r\n            }\r\n            return _this;\r\n        }\r\n        Object.defineProperty(Loader.prototype, "_image", {\r\n            get: function () {\r\n                if (!this._imageElement) {\r\n                    this._imageElement = new Image();\r\n                    this._imageElement.src = this.logo;\r\n                }\r\n                return this._imageElement;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        ;\r\n        Loader.prototype.wireEngine = function (engine) {\r\n            this._engine = engine;\r\n        };\r\n        /**\r\n         * Add a resource to the loader to load\r\n         * @param loadable  Resource to add\r\n         */\r\n        Loader.prototype.addResource = function (loadable) {\r\n            var key = this._index++;\r\n            this._resourceList.push(loadable);\r\n            this._progressCounts[key] = 0;\r\n            this._totalCounts[key] = 1;\r\n            this._resourceCount++;\r\n        };\r\n        /**\r\n         * Add a list of resources to the loader to load\r\n         * @param loadables  The list of resources to load\r\n         */\r\n        Loader.prototype.addResources = function (loadables) {\r\n            var i = 0, len = loadables.length;\r\n            for (i; i < len; i++) {\r\n                this.addResource(loadables[i]);\r\n            }\r\n        };\r\n        /**\r\n         * Returns true if the loader has completely loaded all resources\r\n         */\r\n        Loader.prototype.isLoaded = function () {\r\n            return this._numLoaded === this._resourceCount;\r\n        };\r\n        /**\r\n         * Begin loading all of the supplied resources, returning a promise\r\n         * that resolves when loading of all is complete\r\n         */\r\n        Loader.prototype.load = function () {\r\n            var _this = this;\r\n            var complete = new Promises_6.Promise();\r\n            var me = this;\r\n            if (this._resourceList.length === 0) {\r\n                me.oncomplete.call(me);\r\n                return complete.resolve();\r\n            }\r\n            var progressArray = new Array(this._resourceList.length);\r\n            var progressChunks = this._resourceList.length;\r\n            this._resourceList.forEach(function (r, i) {\r\n                if (_this._engine) {\r\n                    r.wireEngine(_this._engine);\r\n                }\r\n                r.onprogress = function (e) {\r\n                    var total = e.total;\r\n                    var loaded = e.loaded;\r\n                    progressArray[i] = { loaded: ((loaded / total) * (100 / progressChunks)), total: 100 };\r\n                    var progressResult = progressArray.reduce(function (accum, next) {\r\n                        return { loaded: (accum.loaded + next.loaded), total: 100 };\r\n                    }, { loaded: 0, total: 100 });\r\n                    me.onprogress.call(me, progressResult);\r\n                };\r\n                r.oncomplete = r.onerror = function () {\r\n                    me._numLoaded++;\r\n                    if (me._numLoaded === me._resourceCount) {\r\n                        me.oncomplete.call(me);\r\n                        complete.resolve();\r\n                    }\r\n                };\r\n            });\r\n            function loadNext(list, index) {\r\n                if (!list[index]) {\r\n                    return;\r\n                }\r\n                list[index].load().then(function () {\r\n                    loadNext(list, index + 1);\r\n                });\r\n            }\r\n            loadNext(this._resourceList, 0);\r\n            return complete;\r\n        };\r\n        /**\r\n         * Loader draw function. Draws the default Excalibur loading screen.\r\n         * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties\r\n         * to customize the drawing, or just override entire method.\r\n         */\r\n        Loader.prototype.draw = function (ctx) {\r\n            var canvasHeight = this._engine.canvasHeight / window.devicePixelRatio;\r\n            var canvasWidth = this._engine.canvasWidth / window.devicePixelRatio;\r\n            ctx.fillStyle = this.backgroundColor;\r\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n            var y = canvasHeight / 2;\r\n            var width = Math.min(this.logoWidth, canvasWidth * 0.75);\r\n            var x = (canvasWidth / 2) - (width / 2);\r\n            var imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor\r\n            var oldAntialias = this._engine.getAntialiasing();\r\n            this._engine.setAntialiasing(true);\r\n            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, x, y - imageHeight - 20, width, imageHeight);\r\n            // loading box\r\n            ctx.lineWidth = 2;\r\n            DrawUtil.roundRect(ctx, x, y, width, 20, 10);\r\n            var progress = width * (this._numLoaded / this._resourceCount);\r\n            var margin = 5;\r\n            var progressWidth = progress - margin * 2;\r\n            var height = 20 - margin * 2;\r\n            DrawUtil.roundRect(ctx, x + margin, y + margin, progressWidth > 0 ? progressWidth : 0, height, 5, null, Color_12.Color.White);\r\n            this._engine.setAntialiasing(oldAntialias);\r\n        };\r\n        /**\r\n         * Perform any calculations or logic in the `update` method. The default `Loader` does not\r\n         * do anything in this method so it is safe to override.\r\n         */\r\n        Loader.prototype.update = function (_engine, _delta) {\r\n            // overridable update\r\n        };\r\n        return Loader;\r\n    }(Class_3.Class));\r\n    exports.Loader = Loader;\r\n    /**\r\n     * A [[Loader]] that pauses after loading to allow user\r\n     * to proceed to play the game. Typically you will\r\n     * want to use this loader for iOS to allow sounds\r\n     * to play after loading (Apple Safari requires user\r\n     * interaction to allow sounds, even for games)\r\n     *\r\n     * **Note:** Because Loader is not part of a Scene, you must\r\n     * call `update` and `draw` manually on "child" objects.\r\n     *\r\n     * ## Implementing a Trigger\r\n     *\r\n     * The `PauseAfterLoader` requires an element to act as the trigger button\r\n     * to start the game.\r\n     *\r\n     * For example, let\'s create an `<a>` tag to be our trigger and call it `tap-to-play`.\r\n     *\r\n     * ```html\r\n     * <div id="wrapper">\r\n     *    <canvas id="game"></canvas>\r\n     *    <a id="tap-to-play" href=\'javascript:void(0);\'>Tap to Play</a>\r\n     * </div>\r\n     * ```\r\n     *\r\n     * We\'ve put it inside a wrapper to position it properly over the game canvas.\r\n     *\r\n     * Now let\'s add some CSS to style it (insert into `<head>`):\r\n     *\r\n     * ```html\r\n     * <style>\r\n     *     #wrapper {\r\n     *         position: relative;\r\n     *         width: 500px;\r\n     *         height: 500px;\r\n     *     }\r\n     *     #tap-to-play {\r\n     *         display: none;\r\n     *         font-size: 24px;\r\n     *         font-family: sans-serif;\r\n     *         text-align: center;\r\n     *         border: 3px solid white;\r\n     *         position: absolute;\r\n     *         color: white;\r\n     *         width: 200px;\r\n     *         height: 50px;\r\n     *         line-height: 50px;\r\n     *         text-decoration: none;\r\n     *         left: 147px;\r\n     *         top: 80%;\r\n     *     }\r\n     * </style>\r\n     * ```\r\n     *\r\n     * Now we can create a `PauseAfterLoader` with a reference to our trigger button:\r\n     *\r\n     * ```ts\r\n     * var loader = new ex.PauseAfterLoader(\'tap-to-play\', [...]);\r\n     * ```\r\n     *\r\n     * ## Use PauseAfterLoader for iOS\r\n     *\r\n     * The primary use case for pausing before starting the game is to\r\n     * pass Apple\'s requirement of user interaction. The Web Audio context\r\n     * in Safari is disabled by default until user interaction.\r\n     *\r\n     * Therefore, you can use this snippet to only use PauseAfterLoader when\r\n     * iOS is detected (see [this thread](http://stackoverflow.com/questions/9038625/detect-if-device-is-ios)\r\n     * for more techniques).\r\n     *\r\n     * ```ts\r\n     * var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(<any>window).MSStream;\r\n     * var loader: ex.Loader = iOS ? new ex.PauseAfterLoader(\'tap-to-play\') : new ex.Loader();\r\n     *\r\n     * loader.addResource(...);\r\n     * ```\r\n     */\r\n    var PauseAfterLoader = (function (_super) {\r\n        __extends(PauseAfterLoader, _super);\r\n        function PauseAfterLoader(triggerElementId, loadables) {\r\n            var _this = _super.call(this, loadables) || this;\r\n            _this._handleOnTrigger = function () {\r\n                if (_this._waitPromise.state() !== Promises_6.PromiseState.Pending) {\r\n                    return false;\r\n                }\r\n                // unlock Safari WebAudio context\r\n                Sound_1.WebAudio.unlock();\r\n                // continue to play game\r\n                _this._waitPromise.resolve(_this._loadedValue);\r\n                // hide DOM element\r\n                _this._playTrigger.style.display = \'none\';\r\n                return false;\r\n            };\r\n            _this._playTrigger = document.getElementById(triggerElementId);\r\n            _this._playTrigger.addEventListener(\'click\', _this._handleOnTrigger);\r\n            return _this;\r\n        }\r\n        PauseAfterLoader.prototype.load = function () {\r\n            var _this = this;\r\n            this._waitPromise = new Promises_6.Promise();\r\n            // wait until user indicates to proceed before finishing load\r\n            _super.prototype.load.call(this).then(function (value) {\r\n                _this._loaded = true;\r\n                _this._loadedValue = value;\r\n                // show element\r\n                _this._playTrigger.style.display = \'block\';\r\n            }, function (value) {\r\n                _this._waitPromise.reject(value);\r\n            });\r\n            return this._waitPromise;\r\n        };\r\n        return PauseAfterLoader;\r\n    }(Loader));\r\n    exports.PauseAfterLoader = PauseAfterLoader;\r\n});\r\ndefine("Interfaces/IActorTrait", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Traits/CapturePointer", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Propogates pointer events to the actor\r\n     */\r\n    var CapturePointer = (function () {\r\n        function CapturePointer() {\r\n        }\r\n        CapturePointer.prototype.update = function (actor, engine) {\r\n            if (!actor.enableCapturePointer) {\r\n                return;\r\n            }\r\n            if (actor.isKilled()) {\r\n                return;\r\n            }\r\n            engine.input.pointers.propogate(actor);\r\n        };\r\n        return CapturePointer;\r\n    }());\r\n    exports.CapturePointer = CapturePointer;\r\n});\r\ndefine("Traits/EulerMovement", ["require", "exports", "Physics", "Actor"], function (require, exports, Physics_7, Actor_5) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var EulerMovement = (function () {\r\n        function EulerMovement() {\r\n        }\r\n        EulerMovement.prototype.update = function (actor, _engine, delta) {\r\n            // Update placements based on linear algebra\r\n            var seconds = delta / 1000;\r\n            var totalAcc = actor.acc.clone();\r\n            // Only active vanilla actors are affected by global acceleration\r\n            if (actor.collisionType === Actor_5.CollisionType.Active) {\r\n                totalAcc.addEqual(Physics_7.Physics.acc);\r\n            }\r\n            actor.oldVel = actor.vel;\r\n            actor.vel.addEqual(totalAcc.scale(seconds));\r\n            actor.pos.addEqual(actor.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));\r\n            actor.rx += actor.torque * (1.0 / actor.moi) * seconds;\r\n            actor.rotation += actor.rx * seconds;\r\n            actor.scale.x += actor.sx * delta / 1000;\r\n            actor.scale.y += actor.sy * delta / 1000;\r\n        };\r\n        return EulerMovement;\r\n    }());\r\n    exports.EulerMovement = EulerMovement;\r\n});\r\ndefine("Util/CullingBox", ["require", "exports", "Algebra", "Drawing/Color"], function (require, exports, Algebra_13, Color_13) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var CullingBox = (function () {\r\n        function CullingBox() {\r\n            this._topLeft = new Algebra_13.Vector(0, 0);\r\n            this._topRight = new Algebra_13.Vector(0, 0);\r\n            this._bottomLeft = new Algebra_13.Vector(0, 0);\r\n            this._bottomRight = new Algebra_13.Vector(0, 0);\r\n        }\r\n        CullingBox.prototype.isSpriteOffScreen = function (actor, engine) {\r\n            var drawingWidth = actor.currentDrawing.width;\r\n            var drawingHeight = actor.currentDrawing.height;\r\n            var rotation = actor.rotation;\r\n            var anchor = actor.getCenter();\r\n            var worldPos = actor.getWorldPos();\r\n            this._topLeft.x = worldPos.x - (drawingWidth / 2);\r\n            this._topLeft.y = worldPos.y - (drawingHeight / 2);\r\n            this._topLeft = this._topLeft.rotate(rotation, anchor);\r\n            this._topRight.x = worldPos.x + (drawingWidth / 2);\r\n            this._topRight.y = worldPos.y - (drawingHeight / 2);\r\n            this._topRight = this._topRight.rotate(rotation, anchor);\r\n            this._bottomLeft.x = worldPos.x - (drawingWidth / 2);\r\n            this._bottomLeft.y = worldPos.y + (drawingHeight / 2);\r\n            this._bottomLeft = this._bottomLeft.rotate(rotation, anchor);\r\n            this._bottomRight.x = worldPos.x + (drawingWidth / 2);\r\n            this._bottomRight.y = worldPos.y + (drawingHeight / 2);\r\n            this._bottomRight = this._bottomRight.rotate(rotation, anchor);\r\n            ///\r\n            var topLeftScreen = engine.worldToScreenCoordinates(this._topLeft);\r\n            var topRightScreen = engine.worldToScreenCoordinates(this._topRight);\r\n            var bottomLeftScreen = engine.worldToScreenCoordinates(this._bottomLeft);\r\n            var bottomRightScreen = engine.worldToScreenCoordinates(this._bottomRight);\r\n            this._xCoords = [];\r\n            this._yCoords = [];\r\n            this._xCoords.push(topLeftScreen.x, topRightScreen.x, bottomLeftScreen.x, bottomRightScreen.x);\r\n            this._yCoords.push(topLeftScreen.y, topRightScreen.y, bottomLeftScreen.y, bottomRightScreen.y);\r\n            this._xMin = Math.min.apply(null, this._xCoords);\r\n            this._yMin = Math.min.apply(null, this._yCoords);\r\n            this._xMax = Math.max.apply(null, this._xCoords);\r\n            this._yMax = Math.max.apply(null, this._yCoords);\r\n            var minWorld = engine.screenToWorldCoordinates(new Algebra_13.Vector(this._xMin, this._yMin));\r\n            var maxWorld = engine.screenToWorldCoordinates(new Algebra_13.Vector(this._xMax, this._yMax));\r\n            this._xMinWorld = minWorld.x;\r\n            this._yMinWorld = minWorld.y;\r\n            this._xMaxWorld = maxWorld.x;\r\n            this._yMaxWorld = maxWorld.y;\r\n            var boundingPoints = [\r\n                new Algebra_13.Vector(this._xMin, this._yMin),\r\n                new Algebra_13.Vector(this._xMax, this._yMin),\r\n                new Algebra_13.Vector(this._xMin, this._yMax),\r\n                new Algebra_13.Vector(this._xMax, this._yMax)\r\n            ]; // bottomright\r\n            // sprite can be wider than canvas screen (and still visible within canvas)\r\n            // top or bottom of sprite must be within canvas\r\n            if (boundingPoints[0].x < 0 && boundingPoints[1].x > engine.canvas.clientWidth &&\r\n                (boundingPoints[0].y > 0 || boundingPoints[2].y < engine.canvas.clientHeight)) {\r\n                return false;\r\n            }\r\n            // sprite can be taller than canvas screen (and still visible within canvas)\r\n            // left or right of sprite must be within canvas\r\n            if (boundingPoints[0].y < 0 && boundingPoints[2].y > engine.canvas.clientHeight &&\r\n                (boundingPoints[1].x > 0 || boundingPoints[0].x < engine.canvas.clientWidth)) {\r\n                return false;\r\n            }\r\n            // otherwise if any corner is visible, we\'re not offscreen\r\n            for (var i = 0; i < boundingPoints.length; i++) {\r\n                if (boundingPoints[i].x > 0 &&\r\n                    boundingPoints[i].y > 0 &&\r\n                    boundingPoints[i].x < engine.canvas.clientWidth &&\r\n                    boundingPoints[i].y < engine.canvas.clientHeight) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        CullingBox.prototype.debugDraw = function (ctx) {\r\n            // bounding rectangle\r\n            ctx.beginPath();\r\n            ctx.strokeStyle = Color_13.Color.White.toString();\r\n            ctx.rect(this._xMinWorld, this._yMinWorld, this._xMaxWorld - this._xMinWorld, this._yMaxWorld - this._yMinWorld);\r\n            ctx.stroke();\r\n            ctx.fillStyle = Color_13.Color.Red.toString();\r\n            ctx.beginPath();\r\n            ctx.arc(this._topLeft.x, this._topLeft.y, 5, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            ctx.fillStyle = Color_13.Color.Green.toString();\r\n            ctx.beginPath();\r\n            ctx.arc(this._topRight.x, this._topRight.y, 5, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            ctx.fillStyle = Color_13.Color.Blue.toString();\r\n            ctx.beginPath();\r\n            ctx.arc(this._bottomLeft.x, this._bottomLeft.y, 5, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            ctx.fillStyle = Color_13.Color.Magenta.toString();\r\n            ctx.beginPath();\r\n            ctx.arc(this._bottomRight.x, this._bottomRight.y, 5, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        };\r\n        return CullingBox;\r\n    }());\r\n    exports.CullingBox = CullingBox;\r\n});\r\ndefine("Traits/OffscreenCulling", ["require", "exports", "Util/CullingBox", "Algebra", "Events"], function (require, exports, CullingBox_1, Algebra_14, Events_3) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var OffscreenCulling = (function () {\r\n        function OffscreenCulling() {\r\n            this.cullingBox = new CullingBox_1.CullingBox();\r\n        }\r\n        OffscreenCulling.prototype.update = function (actor, engine) {\r\n            var eventDispatcher = actor.eventDispatcher;\r\n            var anchor = actor.anchor;\r\n            var globalScale = actor.getGlobalScale();\r\n            var width = globalScale.x * actor.getWidth() / actor.scale.x;\r\n            var height = globalScale.y * actor.getHeight() / actor.scale.y;\r\n            var worldPos = actor.getWorldPos();\r\n            var actorScreenCoords = engine.worldToScreenCoordinates(new Algebra_14.Vector(worldPos.x - anchor.x * width, worldPos.y - anchor.y * height));\r\n            var zoom = 1.0;\r\n            if (actor.scene && actor.scene.camera) {\r\n                zoom = Math.abs(actor.scene.camera.getZoom());\r\n            }\r\n            var isSpriteOffScreen = true;\r\n            if (actor.currentDrawing != null) {\r\n                isSpriteOffScreen = this.cullingBox.isSpriteOffScreen(actor, engine);\r\n            }\r\n            if (!actor.isOffScreen) {\r\n                if ((actorScreenCoords.x + width * zoom < 0 ||\r\n                    actorScreenCoords.y + height * zoom < 0 ||\r\n                    actorScreenCoords.x > engine.canvasWidth ||\r\n                    actorScreenCoords.y > engine.canvasHeight) &&\r\n                    isSpriteOffScreen) {\r\n                    eventDispatcher.emit(\'exitviewport\', new Events_3.ExitViewPortEvent(actor));\r\n                    actor.isOffScreen = true;\r\n                }\r\n            }\r\n            else {\r\n                if ((actorScreenCoords.x + width * zoom > 0 &&\r\n                    actorScreenCoords.y + height * zoom > 0 &&\r\n                    actorScreenCoords.x < engine.canvasWidth &&\r\n                    actorScreenCoords.y < engine.canvasHeight) ||\r\n                    !isSpriteOffScreen) {\r\n                    eventDispatcher.emit(\'enterviewport\', new Events_3.EnterViewPortEvent(actor));\r\n                    actor.isOffScreen = false;\r\n                }\r\n            }\r\n        };\r\n        return OffscreenCulling;\r\n    }());\r\n    exports.OffscreenCulling = OffscreenCulling;\r\n});\r\ndefine("Traits/TileMapCollisionDetection", ["require", "exports", "Actor", "Collision/Side", "Events"], function (require, exports, Actor_6, Side_2, Events_4) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var TileMapCollisionDetection = (function () {\r\n        function TileMapCollisionDetection() {\r\n        }\r\n        TileMapCollisionDetection.prototype.update = function (actor, engine) {\r\n            var eventDispatcher = actor.eventDispatcher;\r\n            if (actor.collisionType !== Actor_6.CollisionType.PreventCollision && engine.currentScene && engine.currentScene.tileMaps) {\r\n                for (var j = 0; j < engine.currentScene.tileMaps.length; j++) {\r\n                    var map = engine.currentScene.tileMaps[j];\r\n                    var intersectMap;\r\n                    var side = Side_2.Side.None;\r\n                    var max = 2;\r\n                    while (intersectMap = map.collides(actor)) {\r\n                        if (max-- < 0) {\r\n                            break;\r\n                        }\r\n                        side = actor.getSideFromIntersect(intersectMap);\r\n                        eventDispatcher.emit(\'precollision\', new Events_4.PreCollisionEvent(actor, null, side, intersectMap));\r\n                        if (actor.collisionType === Actor_6.CollisionType.Active) {\r\n                            actor.pos.y += intersectMap.y;\r\n                            actor.pos.x += intersectMap.x;\r\n                            eventDispatcher.emit(\'postcollision\', new Events_4.PostCollisionEvent(actor, null, side, intersectMap));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        return TileMapCollisionDetection;\r\n    }());\r\n    exports.TileMapCollisionDetection = TileMapCollisionDetection;\r\n});\r\ndefine("Traits/Index", ["require", "exports", "Traits/CapturePointer", "Traits/EulerMovement", "Traits/OffscreenCulling", "Traits/TileMapCollisionDetection"], function (require, exports, CapturePointer_1, EulerMovement_1, OffscreenCulling_1, TileMapCollisionDetection_1) {\r\n    "use strict";\r\n    function __export(m) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    __export(CapturePointer_1);\r\n    __export(EulerMovement_1);\r\n    __export(OffscreenCulling_1);\r\n    __export(TileMapCollisionDetection_1);\r\n});\r\ndefine("Particles", ["require", "exports", "Actor", "Drawing/Color", "Algebra", "Util/Util", "Util/DrawUtil", "Traits/Index"], function (require, exports, Actor_7, Color_14, Algebra_15, Util, DrawUtil, Traits) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * An enum that represents the types of emitter nozzles\r\n     */\r\n    var EmitterType;\r\n    (function (EmitterType) {\r\n        /**\r\n         * Constant for the circular emitter type\r\n         */\r\n        EmitterType[EmitterType["Circle"] = 0] = "Circle";\r\n        /**\r\n         * Constant for the rectangular emitter type\r\n         */\r\n        EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";\r\n    })(EmitterType = exports.EmitterType || (exports.EmitterType = {}));\r\n    /**\r\n     * Particle is used in a [[ParticleEmitter]]\r\n     */\r\n    var Particle = (function () {\r\n        function Particle(emitter, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {\r\n            this.position = new Algebra_15.Vector(0, 0);\r\n            this.velocity = new Algebra_15.Vector(0, 0);\r\n            this.acceleration = new Algebra_15.Vector(0, 0);\r\n            this.particleRotationalVelocity = 0;\r\n            this.currentRotation = 0;\r\n            this.focus = null;\r\n            this.focusAccel = 0;\r\n            this.opacity = 1;\r\n            this.beginColor = Color_14.Color.White.clone();\r\n            this.endColor = Color_14.Color.White.clone();\r\n            // Life is counted in ms\r\n            this.life = 300;\r\n            this.fadeFlag = false;\r\n            // Color transitions\r\n            this._rRate = 1;\r\n            this._gRate = 1;\r\n            this._bRate = 1;\r\n            this._aRate = 0;\r\n            this._currentColor = Color_14.Color.White.clone();\r\n            this.emitter = null;\r\n            this.particleSize = 5;\r\n            this.particleSprite = null;\r\n            this.sizeRate = 0;\r\n            this.elapsedMultiplier = 0;\r\n            this.emitter = emitter;\r\n            this.life = life || this.life;\r\n            this.opacity = opacity || this.opacity;\r\n            this.endColor = endColor || this.endColor.clone();\r\n            this.beginColor = beginColor || this.beginColor.clone();\r\n            this._currentColor = this.beginColor.clone();\r\n            this.position = position || this.position;\r\n            this.velocity = velocity || this.velocity;\r\n            this.acceleration = acceleration || this.acceleration;\r\n            this._rRate = (this.endColor.r - this.beginColor.r) / this.life;\r\n            this._gRate = (this.endColor.g - this.beginColor.g) / this.life;\r\n            this._bRate = (this.endColor.b - this.beginColor.b) / this.life;\r\n            this._aRate = this.opacity / this.life;\r\n            this.startSize = startSize || 0;\r\n            this.endSize = endSize || 0;\r\n            if ((this.endSize > 0) && (this.startSize > 0)) {\r\n                this.sizeRate = (this.endSize - this.startSize) / this.life;\r\n                this.particleSize = this.startSize;\r\n            }\r\n        }\r\n        Particle.prototype.kill = function () {\r\n            this.emitter.removeParticle(this);\r\n        };\r\n        Particle.prototype.update = function (delta) {\r\n            this.life = this.life - delta;\r\n            this.elapsedMultiplier = this.elapsedMultiplier + delta;\r\n            if (this.life < 0) {\r\n                this.kill();\r\n            }\r\n            if (this.fadeFlag) {\r\n                this.opacity = Util.clamp(this._aRate * this.life, 0.0001, 1);\r\n            }\r\n            if ((this.startSize > 0) && (this.endSize > 0)) {\r\n                this.particleSize = Util.clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));\r\n            }\r\n            this._currentColor.r = Util.clamp(this._currentColor.r + this._rRate * delta, 0, 255);\r\n            this._currentColor.g = Util.clamp(this._currentColor.g + this._gRate * delta, 0, 255);\r\n            this._currentColor.b = Util.clamp(this._currentColor.b + this._bRate * delta, 0, 255);\r\n            this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);\r\n            if (this.focus) {\r\n                var accel = this.focus.sub(this.position).normalize().scale(this.focusAccel).scale(delta / 1000);\r\n                this.velocity = this.velocity.add(accel);\r\n            }\r\n            else {\r\n                this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));\r\n            }\r\n            this.position = this.position.add(this.velocity.scale(delta / 1000));\r\n            if (this.particleRotationalVelocity) {\r\n                this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1000) % (2 * Math.PI);\r\n            }\r\n        };\r\n        Particle.prototype.draw = function (ctx) {\r\n            if (this.particleSprite) {\r\n                this.particleSprite.rotation = this.currentRotation;\r\n                this.particleSprite.scale.setTo(this.particleSize, this.particleSize);\r\n                this.particleSprite.draw(ctx, this.position.x, this.position.y);\r\n                return;\r\n            }\r\n            this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);\r\n            ctx.fillStyle = this._currentColor.toString();\r\n            ctx.beginPath();\r\n            ctx.arc(this.position.x, this.position.y, this.particleSize, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n        };\r\n        return Particle;\r\n    }());\r\n    exports.Particle = Particle;\r\n    /**\r\n     * Using a particle emitter is a great way to create interesting effects\r\n     * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`\r\n     * extend [[Actor]] allowing you to use all of the features that come with.\r\n     *\r\n     * [[include:Particles.md]]\r\n     */\r\n    var ParticleEmitter = (function (_super) {\r\n        __extends(ParticleEmitter, _super);\r\n        /**\r\n         * @param x       The x position of the emitter\r\n         * @param y       The y position of the emitter\r\n         * @param width   The width of the emitter\r\n         * @param height  The height of the emitter\r\n         */\r\n        function ParticleEmitter(x, y, width, height) {\r\n            var _this = _super.call(this, x, y, width, height, Color_14.Color.White) || this;\r\n            _this._particlesToEmit = 0;\r\n            _this.numParticles = 0;\r\n            /**\r\n             * Gets or sets the isEmitting flag\r\n             */\r\n            _this.isEmitting = true;\r\n            /**\r\n             * Gets or sets the backing particle collection\r\n             */\r\n            _this.particles = null;\r\n            /**\r\n             * Gets or sets the backing deadParticle collection\r\n             */\r\n            _this.deadParticles = null;\r\n            /**\r\n             * Gets or sets the minimum particle velocity\r\n             */\r\n            _this.minVel = 0;\r\n            /**\r\n             * Gets or sets the maximum particle velocity\r\n             */\r\n            _this.maxVel = 0;\r\n            /**\r\n             * Gets or sets the acceleration vector for all particles\r\n             */\r\n            _this.acceleration = new Algebra_15.Vector(0, 0);\r\n            /**\r\n             * Gets or sets the minimum angle in radians\r\n             */\r\n            _this.minAngle = 0;\r\n            /**\r\n             * Gets or sets the maximum angle in radians\r\n             */\r\n            _this.maxAngle = 0;\r\n            /**\r\n             * Gets or sets the emission rate for particles (particles/sec)\r\n             */\r\n            _this.emitRate = 1; //particles/sec\r\n            /**\r\n             * Gets or sets the life of each particle in milliseconds\r\n             */\r\n            _this.particleLife = 2000;\r\n            /**\r\n             * Gets or sets the opacity of each particle from 0 to 1.0\r\n             */\r\n            _this.opacity = 1;\r\n            /**\r\n             * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.\r\n             */\r\n            _this.fadeFlag = false;\r\n            /**\r\n             * Gets or sets the optional focus where all particles should accelerate towards\r\n             */\r\n            _this.focus = null;\r\n            /**\r\n             * Gets or sets the acceleration for focusing particles if a focus has been specified\r\n             */\r\n            _this.focusAccel = 1;\r\n            /*\r\n             * Gets or sets the optional starting size for the particles\r\n             */\r\n            _this.startSize = null;\r\n            /*\r\n             * Gets or sets the optional ending size for the particles\r\n             */\r\n            _this.endSize = null;\r\n            /**\r\n             * Gets or sets the minimum size of all particles\r\n             */\r\n            _this.minSize = 5;\r\n            /**\r\n             * Gets or sets the maximum size of all particles\r\n             */\r\n            _this.maxSize = 5;\r\n            /**\r\n             * Gets or sets the beginning color of all particles\r\n             */\r\n            _this.beginColor = Color_14.Color.White;\r\n            /**\r\n             * Gets or sets the ending color of all particles\r\n             */\r\n            _this.endColor = Color_14.Color.White;\r\n            /**\r\n             * Gets or sets the sprite that a particle should use\r\n             * @warning Performance intensive\r\n             */\r\n            _this.particleSprite = null;\r\n            /**\r\n             * Gets or sets the emitter type for the particle emitter\r\n             */\r\n            _this.emitterType = EmitterType.Rectangle;\r\n            /**\r\n             * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]\r\n             */\r\n            _this.radius = 0;\r\n            /**\r\n             * Gets or sets the particle rotational speed velocity\r\n             */\r\n            _this.particleRotationalVelocity = 0;\r\n            /**\r\n             * Indicates whether particles should start with a random rotation\r\n             */\r\n            _this.randomRotation = false;\r\n            _this.collisionType = Actor_7.CollisionType.PreventCollision;\r\n            _this.particles = new Util.Collection();\r\n            _this.deadParticles = new Util.Collection();\r\n            // Remove offscreen culling from particle emitters\r\n            for (var i = 0; i < _this.traits.length; i++) {\r\n                if (_this.traits[i] instanceof Traits.OffscreenCulling) {\r\n                    _this.traits.splice(i, 1);\r\n                }\r\n            }\r\n            return _this;\r\n        }\r\n        ParticleEmitter.prototype.removeParticle = function (particle) {\r\n            this.deadParticles.push(particle);\r\n        };\r\n        /**\r\n         * Causes the emitter to emit particles\r\n         * @param particleCount  Number of particles to emit right now\r\n         */\r\n        ParticleEmitter.prototype.emitParticles = function (particleCount) {\r\n            for (var i = 0; i < particleCount; i++) {\r\n                this.particles.push(this._createParticle());\r\n            }\r\n        };\r\n        ParticleEmitter.prototype.clearParticles = function () {\r\n            this.particles.clear();\r\n        };\r\n        // Creates a new particle given the constraints of the emitter\r\n        ParticleEmitter.prototype._createParticle = function () {\r\n            // todo implement emitter constraints;\r\n            var ranX = 0;\r\n            var ranY = 0;\r\n            var angle = Util.randomInRange(this.minAngle, this.maxAngle);\r\n            var vel = Util.randomInRange(this.minVel, this.maxVel);\r\n            var size = this.startSize || Util.randomInRange(this.minSize, this.maxSize);\r\n            var dx = vel * Math.cos(angle);\r\n            var dy = vel * Math.sin(angle);\r\n            if (this.emitterType === EmitterType.Rectangle) {\r\n                ranX = Util.randomInRange(this.pos.x, this.pos.x + this.getWidth());\r\n                ranY = Util.randomInRange(this.pos.y, this.pos.y + this.getHeight());\r\n            }\r\n            else if (this.emitterType === EmitterType.Circle) {\r\n                var radius = Util.randomInRange(0, this.radius);\r\n                ranX = radius * Math.cos(angle) + this.pos.x;\r\n                ranY = radius * Math.sin(angle) + this.pos.y;\r\n            }\r\n            var p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Algebra_15.Vector(ranX, ranY), new Algebra_15.Vector(dx, dy), this.acceleration, this.startSize, this.endSize);\r\n            p.fadeFlag = this.fadeFlag;\r\n            p.particleSize = size;\r\n            if (this.particleSprite) {\r\n                p.particleSprite = this.particleSprite;\r\n            }\r\n            p.particleRotationalVelocity = this.particleRotationalVelocity;\r\n            if (this.randomRotation) {\r\n                p.currentRotation = Util.randomInRange(0, Math.PI * 2);\r\n            }\r\n            if (this.focus) {\r\n                p.focus = this.focus.add(new Algebra_15.Vector(this.pos.x, this.pos.y));\r\n                p.focusAccel = this.focusAccel;\r\n            }\r\n            return p;\r\n        };\r\n        ParticleEmitter.prototype.update = function (engine, delta) {\r\n            var _this = this;\r\n            _super.prototype.update.call(this, engine, delta);\r\n            if (this.isEmitting) {\r\n                this._particlesToEmit += this.emitRate * (delta / 1000);\r\n                //var numParticles = Math.ceil(this.emitRate * delta / 1000);\r\n                if (this._particlesToEmit > 1.0) {\r\n                    this.emitParticles(Math.floor(this._particlesToEmit));\r\n                    this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);\r\n                }\r\n            }\r\n            this.particles.forEach(function (p) { return p.update(delta); });\r\n            this.deadParticles.forEach(function (p) { return _this.particles.removeElement(p); });\r\n            this.deadParticles.clear();\r\n        };\r\n        ParticleEmitter.prototype.draw = function (ctx) {\r\n            // todo is there a more efficient to draw \r\n            // possibly use a webgl offscreen canvas and shaders to do particles?\r\n            this.particles.forEach(function (p) { return p.draw(ctx); });\r\n        };\r\n        ParticleEmitter.prototype.debugDraw = function (ctx) {\r\n            _super.prototype.debugDraw.call(this, ctx);\r\n            ctx.fillStyle = Color_14.Color.Black.toString();\r\n            ctx.fillText(\'Particles: \' + this.particles.count(), this.pos.x, this.pos.y + 20);\r\n            if (this.focus) {\r\n                ctx.fillRect(this.focus.x + this.pos.x, this.focus.y + this.pos.y, 3, 3);\r\n                DrawUtil.line(ctx, Color_14.Color.Yellow, this.focus.x + this.pos.x, this.focus.y + this.pos.y, _super.prototype.getCenter.call(this).x, _super.prototype.getCenter.call(this).y);\r\n                ctx.fillText(\'Focus\', this.focus.x + this.pos.x, this.focus.y + this.pos.y);\r\n            }\r\n        };\r\n        return ParticleEmitter;\r\n    }(Actor_7.Actor));\r\n    exports.ParticleEmitter = ParticleEmitter;\r\n});\r\ndefine("TileMap", ["require", "exports", "Collision/BoundingBox", "Drawing/Color", "Class", "Algebra", "Util/Log", "Events"], function (require, exports, BoundingBox_4, Color_15, Class_4, Algebra_16, Log_8, Events) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * The [[TileMap]] class provides a lightweight way to do large complex scenes with collision\r\n     * without the overhead of actors.\r\n     *\r\n     * [[include:TileMaps.md]]\r\n     */\r\n    var TileMap = (function (_super) {\r\n        __extends(TileMap, _super);\r\n        /**\r\n         * @param x             The x coordinate to anchor the TileMap\'s upper left corner (should not be changed once set)\r\n         * @param y             The y coordinate to anchor the TileMap\'s upper left corner (should not be changed once set)\r\n         * @param cellWidth     The individual width of each cell (in pixels) (should not be changed once set)\r\n         * @param cellHeight    The individual height of each cell (in pixels) (should not be changed once set)\r\n         * @param rows          The number of rows in the TileMap (should not be changed once set)\r\n         * @param cols          The number of cols in the TileMap (should not be changed once set)\r\n         */\r\n        function TileMap(x, y, cellWidth, cellHeight, rows, cols) {\r\n            var _this = _super.call(this) || this;\r\n            _this.x = x;\r\n            _this.y = y;\r\n            _this.cellWidth = cellWidth;\r\n            _this.cellHeight = cellHeight;\r\n            _this.rows = rows;\r\n            _this.cols = cols;\r\n            _this._collidingX = -1;\r\n            _this._collidingY = -1;\r\n            _this._onScreenXStart = 0;\r\n            _this._onScreenXEnd = 9999;\r\n            _this._onScreenYStart = 0;\r\n            _this._onScreenYEnd = 9999;\r\n            _this._spriteSheets = {};\r\n            _this.logger = Log_8.Logger.getInstance();\r\n            _this.data = [];\r\n            _this.data = new Array(rows * cols);\r\n            for (var i = 0; i < cols; i++) {\r\n                for (var j = 0; j < rows; j++) {\r\n                    (function () {\r\n                        var cd = new Cell(i * cellWidth + x, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);\r\n                        _this.data[i + j * cols] = cd;\r\n                    })();\r\n                }\r\n            }\r\n            return _this;\r\n        }\r\n        TileMap.prototype.on = function (eventName, handler) {\r\n            _super.prototype.on.call(this, eventName, handler);\r\n        };\r\n        TileMap.prototype.registerSpriteSheet = function (key, spriteSheet) {\r\n            this._spriteSheets[key] = spriteSheet;\r\n        };\r\n        /**\r\n         * Returns the intersection vector that can be used to resolve collisions with actors. If there\r\n         * is no collision null is returned.\r\n         */\r\n        TileMap.prototype.collides = function (actor) {\r\n            var width = actor.pos.x + actor.getWidth();\r\n            var height = actor.pos.y + actor.getHeight();\r\n            var actorBounds = actor.getBounds();\r\n            var overlaps = [];\r\n            // trace points for overlap\r\n            for (var x = actorBounds.left; x <= width; x += Math.min(actor.getWidth() / 2, this.cellWidth / 2)) {\r\n                for (var y = actorBounds.top; y <= height; y += Math.min(actor.getHeight() / 2, this.cellHeight / 2)) {\r\n                    var cell = this.getCellByPoint(x, y);\r\n                    if (cell && cell.solid) {\r\n                        var overlap = actorBounds.collides(cell.getBounds());\r\n                        var dir = actor.getCenter().sub(cell.getCenter());\r\n                        if (overlap && overlap.dot(dir) > 0) {\r\n                            overlaps.push(overlap);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (overlaps.length === 0) {\r\n                return null;\r\n            }\r\n            // Return the smallest change other than zero\r\n            var result = overlaps.reduce(function (accum, next) {\r\n                var x = accum.x;\r\n                var y = accum.y;\r\n                if (Math.abs(accum.x) < Math.abs(next.x)) {\r\n                    x = next.x;\r\n                }\r\n                if (Math.abs(accum.y) < Math.abs(next.y)) {\r\n                    y = next.y;\r\n                }\r\n                return new Algebra_16.Vector(x, y);\r\n            });\r\n            return result;\r\n        };\r\n        /**\r\n         * Returns the [[Cell]] by index (row major order)\r\n         */\r\n        TileMap.prototype.getCellByIndex = function (index) {\r\n            return this.data[index];\r\n        };\r\n        /**\r\n         * Returns the [[Cell]] by its x and y coordinates\r\n         */\r\n        TileMap.prototype.getCell = function (x, y) {\r\n            if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {\r\n                return null;\r\n            }\r\n            return this.data[x + y * this.cols];\r\n        };\r\n        /**\r\n         * Returns the [[Cell]] by testing a point in global coordinates,\r\n         * returns `null` if no cell was found.\r\n         */\r\n        TileMap.prototype.getCellByPoint = function (x, y) {\r\n            x = Math.floor((x - this.x) / this.cellWidth);\r\n            y = Math.floor((y - this.y) / this.cellHeight);\r\n            var cell = this.getCell(x, y);\r\n            if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {\r\n                return cell;\r\n            }\r\n            return null;\r\n        };\r\n        TileMap.prototype.update = function (engine, delta) {\r\n            this.emit(\'preupdate\', new Events.PreUpdateEvent(engine, delta, this));\r\n            var worldCoordsUpperLeft = engine.screenToWorldCoordinates(new Algebra_16.Vector(0, 0));\r\n            var worldCoordsLowerRight = engine.screenToWorldCoordinates(new Algebra_16.Vector(engine.canvas.clientWidth, engine.canvas.clientHeight));\r\n            this._onScreenXStart = Math.max(Math.floor(worldCoordsUpperLeft.x / this.cellWidth) - 2, 0);\r\n            this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);\r\n            this._onScreenXEnd = Math.max(Math.floor(worldCoordsLowerRight.x / this.cellWidth) + 2, 0);\r\n            this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);\r\n            this.emit(\'postupdate\', new Events.PostUpdateEvent(engine, delta, this));\r\n        };\r\n        /**\r\n         * Draws the tile map to the screen. Called by the [[Scene]].\r\n         * @param ctx    The current rendering context\r\n         * @param delta  The number of milliseconds since the last draw\r\n         */\r\n        TileMap.prototype.draw = function (ctx, delta) {\r\n            this.emit(\'predraw\', new Events.PreDrawEvent(ctx, delta, this));\r\n            ctx.save();\r\n            ctx.translate(this.x, this.y);\r\n            var x = this._onScreenXStart, xEnd = Math.min(this._onScreenXEnd, this.cols);\r\n            var y = this._onScreenYStart, yEnd = Math.min(this._onScreenYEnd, this.rows);\r\n            var cs, csi, cslen;\r\n            for (x; x < xEnd; x++) {\r\n                for (y; y < yEnd; y++) {\r\n                    // get non-negative tile sprites\r\n                    cs = this.getCell(x, y).sprites.filter(function (s) {\r\n                        return s.spriteId > -1;\r\n                    });\r\n                    for (csi = 0, cslen = cs.length; csi < cslen; csi++) {\r\n                        var ss = this._spriteSheets[cs[csi].spriteSheetKey];\r\n                        // draw sprite, warning if sprite doesn\'t exist\r\n                        if (ss) {\r\n                            var sprite = ss.getSprite(cs[csi].spriteId);\r\n                            if (sprite) {\r\n                                sprite.draw(ctx, x * this.cellWidth, y * this.cellHeight);\r\n                            }\r\n                            else {\r\n                                this.logger.warn(\'Sprite does not exist for id\', cs[csi].spriteId, \'in sprite sheet\', cs[csi].spriteSheetKey, sprite, ss);\r\n                            }\r\n                        }\r\n                        else {\r\n                            this.logger.warn(\'Sprite sheet\', cs[csi].spriteSheetKey, \'does not exist\', ss);\r\n                        }\r\n                    }\r\n                }\r\n                y = this._onScreenYStart;\r\n            }\r\n            ctx.restore();\r\n            this.emit(\'postdraw\', new Events.PostDrawEvent(ctx, delta, this));\r\n        };\r\n        /**\r\n         * Draws all the tile map\'s debug info. Called by the [[Scene]].\r\n         * @param ctx  The current rendering context\r\n         */\r\n        TileMap.prototype.debugDraw = function (ctx) {\r\n            var width = this.cols * this.cellWidth;\r\n            var height = this.rows * this.cellHeight;\r\n            ctx.save();\r\n            ctx.strokeStyle = Color_15.Color.Red.toString();\r\n            for (var x = 0; x < this.cols + 1; x++) {\r\n                ctx.beginPath();\r\n                ctx.moveTo(this.x + x * this.cellWidth, this.y);\r\n                ctx.lineTo(this.x + x * this.cellWidth, this.y + height);\r\n                ctx.stroke();\r\n            }\r\n            for (var y = 0; y < this.rows + 1; y++) {\r\n                ctx.beginPath();\r\n                ctx.moveTo(this.x, this.y + y * this.cellHeight);\r\n                ctx.lineTo(this.x + width, this.y + y * this.cellHeight);\r\n                ctx.stroke();\r\n            }\r\n            var solid = Color_15.Color.Red.clone();\r\n            solid.a = .3;\r\n            this.data.filter(function (cell) {\r\n                return cell.solid;\r\n            }).forEach(function (cell) {\r\n                ctx.fillStyle = solid.toString();\r\n                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);\r\n            });\r\n            if (this._collidingY > -1 && this._collidingX > -1) {\r\n                ctx.fillStyle = Color_15.Color.Cyan.toString();\r\n                ctx.fillRect(this.x + this._collidingX * this.cellWidth, this.y + this._collidingY * this.cellHeight, this.cellWidth, this.cellHeight);\r\n            }\r\n            ctx.restore();\r\n        };\r\n        return TileMap;\r\n    }(Class_4.Class));\r\n    exports.TileMap = TileMap;\r\n    /**\r\n     * Tile sprites are used to render a specific sprite from a [[TileMap]]\'s spritesheet(s)\r\n     */\r\n    var TileSprite = (function () {\r\n        /**\r\n         * @param spriteSheetKey  The key of the spritesheet to use\r\n         * @param spriteId        The index of the sprite in the [[SpriteSheet]]\r\n         */\r\n        function TileSprite(spriteSheetKey, spriteId) {\r\n            this.spriteSheetKey = spriteSheetKey;\r\n            this.spriteId = spriteId;\r\n        }\r\n        return TileSprite;\r\n    }());\r\n    exports.TileSprite = TileSprite;\r\n    /**\r\n     * TileMap Cell\r\n     *\r\n     * A light-weight object that occupies a space in a collision map. Generally\r\n     * created by a [[TileMap]].\r\n     *\r\n     * Cells can draw multiple sprites. Note that the order of drawing is the order\r\n     * of the sprites in the array so the last one will be drawn on top. You can\r\n     * use transparency to create layers this way.\r\n     */\r\n    var Cell = (function () {\r\n        /**\r\n         * @param x       Gets or sets x coordinate of the cell in world coordinates\r\n         * @param y       Gets or sets y coordinate of the cell in world coordinates\r\n         * @param width   Gets or sets the width of the cell\r\n         * @param height  Gets or sets the height of the cell\r\n         * @param index   The index of the cell in row major order\r\n         * @param solid   Gets or sets whether this cell is solid\r\n         * @param sprites The list of tile sprites to use to draw in this cell (in order)\r\n         */\r\n        function Cell(x, y, width, height, index, solid, sprites) {\r\n            if (solid === void 0) { solid = false; }\r\n            if (sprites === void 0) { sprites = []; }\r\n            this.x = x;\r\n            this.y = y;\r\n            this.width = width;\r\n            this.height = height;\r\n            this.index = index;\r\n            this.solid = solid;\r\n            this.sprites = sprites;\r\n            this._bounds = new BoundingBox_4.BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);\r\n        }\r\n        /**\r\n         * Returns the bounding box for this cell\r\n         */\r\n        Cell.prototype.getBounds = function () {\r\n            return this._bounds;\r\n        };\r\n        /**\r\n         * Gets the center coordinate of this cell\r\n         */\r\n        Cell.prototype.getCenter = function () {\r\n            return new Algebra_16.Vector(this.x + this.width / 2, this.y + this.height / 2);\r\n        };\r\n        /**\r\n         * Add another [[TileSprite]] to this cell\r\n         */\r\n        Cell.prototype.pushSprite = function (tileSprite) {\r\n            this.sprites.push(tileSprite);\r\n        };\r\n        /**\r\n         * Remove an instance of [[TileSprite]] from this cell\r\n         */\r\n        Cell.prototype.removeSprite = function (tileSprite) {\r\n            var index = -1;\r\n            if ((index = this.sprites.indexOf(tileSprite)) > -1) {\r\n                this.sprites.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * Clear all sprites from this cell\r\n         */\r\n        Cell.prototype.clearSprites = function () {\r\n            this.sprites.length = 0;\r\n        };\r\n        return Cell;\r\n    }());\r\n    exports.Cell = Cell;\r\n});\r\ndefine("Timer", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * The Excalibur timer hooks into the internal timer and fires callbacks,\r\n     * after a certain interval, optionally repeating.\r\n     */\r\n    var Timer = (function () {\r\n        /**\r\n         * @param fcn        The callback to be fired after the interval is complete.\r\n         * @param interval   Interval length\r\n         * @param repeats    Indicates whether this call back should be fired only once, or repeat after every interval as completed.\r\n         */\r\n        function Timer(fcn, interval, repeats) {\r\n            this.id = 0;\r\n            this.interval = 10;\r\n            this.fcn = function () { return; };\r\n            this.repeats = false;\r\n            this._elapsedTime = 0;\r\n            this._totalTimeAlive = 0;\r\n            this._paused = false;\r\n            this.complete = false;\r\n            this.scene = null;\r\n            this.id = Timer.id++;\r\n            this.interval = interval || this.interval;\r\n            this.fcn = fcn || this.fcn;\r\n            this.repeats = repeats || this.repeats;\r\n        }\r\n        /**\r\n         * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.\r\n         * @param delta  Number of elapsed milliseconds since the last update.\r\n         */\r\n        Timer.prototype.update = function (delta) {\r\n            if (!this._paused) {\r\n                this._totalTimeAlive += delta;\r\n                this._elapsedTime += delta;\r\n                if (!this.complete && this._elapsedTime >= this.interval) {\r\n                    this.fcn.call(this);\r\n                    if (this.repeats) {\r\n                        this._elapsedTime = 0;\r\n                    }\r\n                    else {\r\n                        this.complete = true;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.\r\n         * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback\r\n         */\r\n        Timer.prototype.reset = function (newInterval) {\r\n            if (!!newInterval && newInterval >= 0) {\r\n                this.interval = newInterval;\r\n            }\r\n            this.complete = false;\r\n            this._elapsedTime = 0;\r\n        };\r\n        Timer.prototype.getTimeRunning = function () {\r\n            return this._totalTimeAlive;\r\n        };\r\n        /**\r\n         * Pauses the timer so that no more time will be incremented towards the next call\r\n         */\r\n        Timer.prototype.pause = function () {\r\n            this._paused = true;\r\n        };\r\n        /**\r\n         * Unpauses the timer. Time will now increment towards the next call\r\n         */\r\n        Timer.prototype.unpause = function () {\r\n            this._paused = false;\r\n        };\r\n        /**\r\n         * Cancels the timer, preventing any further executions.\r\n         */\r\n        Timer.prototype.cancel = function () {\r\n            if (this.scene) {\r\n                this.scene.cancelTimer(this);\r\n            }\r\n        };\r\n        return Timer;\r\n    }());\r\n    Timer.id = 0;\r\n    exports.Timer = Timer;\r\n});\r\ndefine("Trigger", ["require", "exports", "Drawing/Color", "Actions/Action", "EventDispatcher", "Actor", "Algebra", "Events", "Util/Util"], function (require, exports, Color_16, Action_1, EventDispatcher_1, Actor_8, Algebra_17, Events_5, Util) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var triggerDefaults = {\r\n        pos: Algebra_17.Vector.Zero.clone(),\r\n        width: 10,\r\n        height: 10,\r\n        visible: false,\r\n        action: function () { return; },\r\n        filter: function () { return true; },\r\n        repeat: -1\r\n    };\r\n    /**\r\n     * Triggers are a method of firing arbitrary code on collision. These are useful\r\n     * as \'buttons\', \'switches\', or to trigger effects in a game. By default triggers\r\n     * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.\r\n     *\r\n     * [[include:Triggers.md]]\r\n     */\r\n    var Trigger = (function (_super) {\r\n        __extends(Trigger, _super);\r\n        /**\r\n         *\r\n         * @param opts Trigger options\r\n         */\r\n        function Trigger(opts) {\r\n            var _this = _super.call(this, opts.pos.x, opts.pos.y, opts.width, opts.height) || this;\r\n            /**\r\n             * Action to fire when triggered by collision\r\n             */\r\n            _this.action = function () { return; };\r\n            /**\r\n             * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when\r\n             * filter return true for the collided actor.\r\n             */\r\n            _this.filter = function () { return true; };\r\n            /**\r\n             * Number of times to repeat before killing the trigger,\r\n             */\r\n            _this.repeat = -1;\r\n            opts = Util.extend({}, triggerDefaults, opts);\r\n            _this.filter = opts.filter || _this.filter;\r\n            _this.repeat = opts.repeat || _this.repeat;\r\n            _this.action = opts.action || _this.action;\r\n            if (opts.target) {\r\n                _this.target = opts.target;\r\n            }\r\n            _this.visible = opts.visible;\r\n            _this.collisionType = Actor_8.CollisionType.Passive;\r\n            _this.eventDispatcher = new EventDispatcher_1.EventDispatcher(_this);\r\n            _this.actionQueue = new Action_1.ActionQueue(_this);\r\n            _this.on(\'collisionstart\', function (evt) {\r\n                if (_this.filter(evt.other)) {\r\n                    _this.emit(\'enter\', new Events_5.EnterTriggerEvent(_this, evt.other));\r\n                    _this._dispatchAction();\r\n                    // remove trigger if its done, -1 repeat forever\r\n                    if (_this.repeat === 0) {\r\n                        _this.kill();\r\n                    }\r\n                }\r\n            });\r\n            _this.on(\'collisionend\', function (evt) {\r\n                if (_this.filter(evt.other)) {\r\n                    _this.emit(\'exit\', new Events_5.ExitTriggerEvent(_this, evt.other));\r\n                }\r\n            });\r\n            return _this;\r\n        }\r\n        Object.defineProperty(Trigger.prototype, "target", {\r\n            get: function () {\r\n                return this._target;\r\n            },\r\n            set: function (target) {\r\n                this._target = target;\r\n                this.filter = function (actor) { return actor === target; };\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Trigger.prototype._initialize = function (engine) {\r\n            _super.prototype._initialize.call(this, engine);\r\n            this._engine = engine;\r\n        };\r\n        Trigger.prototype._dispatchAction = function () {\r\n            this.action.call(this);\r\n            this.repeat--;\r\n        };\r\n        /* istanbul ignore next */\r\n        Trigger.prototype.debugDraw = function (ctx) {\r\n            _super.prototype.debugDraw.call(this, ctx);\r\n            // Meant to draw debug information about actors\r\n            ctx.save();\r\n            ctx.translate(this.pos.x, this.pos.y);\r\n            var bb = this.getBounds();\r\n            var wp = this.getWorldPos();\r\n            bb.left = bb.left - wp.x;\r\n            bb.right = bb.right - wp.x;\r\n            bb.top = bb.top - wp.y;\r\n            bb.bottom = bb.bottom - wp.y;\r\n            // Currently collision primitives cannot rotate \r\n            // ctx.rotate(this.rotation);\r\n            ctx.fillStyle = Color_16.Color.Violet.toString();\r\n            ctx.strokeStyle = Color_16.Color.Violet.toString();\r\n            ctx.fillText(\'Trigger\', 10, 10);\r\n            bb.debugDraw(ctx);\r\n            ctx.restore();\r\n        };\r\n        return Trigger;\r\n    }(Actor_8.Actor));\r\n    exports.Trigger = Trigger;\r\n});\r\ndefine("Actions/Index", ["require", "exports", "Actions/ActionContext", "Actions/RotationType", "Actions/Action"], function (require, exports, ActionContext_2, RotationType_1, actions) {\r\n    "use strict";\r\n    function __export(m) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    __export(ActionContext_2);\r\n    __export(RotationType_1);\r\n    exports.Actions = actions;\r\n    // legacy Internal.Actions namespace support\r\n    exports.Internal = { Actions: actions };\r\n});\r\ndefine("Collision/DynamicTree", ["require", "exports", "Physics", "Collision/BoundingBox", "Util/Log"], function (require, exports, Physics_8, BoundingBox_5, Log_9) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Dynamic Tree Node used for tracking bounds within the tree\r\n     */\r\n    var TreeNode = (function () {\r\n        function TreeNode(parent) {\r\n            this.parent = parent;\r\n            this.parent = parent || null;\r\n            this.body = null;\r\n            this.bounds = new BoundingBox_5.BoundingBox();\r\n            this.left = null;\r\n            this.right = null;\r\n            this.height = 0;\r\n        }\r\n        TreeNode.prototype.isLeaf = function () {\r\n            return (!this.left && !this.right);\r\n        };\r\n        return TreeNode;\r\n    }());\r\n    exports.TreeNode = TreeNode;\r\n    /**\r\n     * The DynamicTrees provides a spatial partiioning data structure for quickly querying for overlapping bounding boxes for\r\n     * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.\r\n     *\r\n     * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.\r\n     * Every non-leaf node is a bounding box that contains child bounding boxes.\r\n     */\r\n    var DynamicTree = (function () {\r\n        function DynamicTree(worldBounds) {\r\n            if (worldBounds === void 0) { worldBounds = new BoundingBox_5.BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE); }\r\n            this.worldBounds = worldBounds;\r\n            this.root = null;\r\n            this.nodes = {};\r\n        }\r\n        /**\r\n         * Inserts a node into the dynamic tree\r\n         */\r\n        DynamicTree.prototype._insert = function (leaf) {\r\n            // If there are no nodes in the tree, make this the root leaf\r\n            if (this.root === null) {\r\n                this.root = leaf;\r\n                this.root.parent = null;\r\n                return;\r\n            }\r\n            // Search the tree for a node that is not a leaf and find the best place to insert\r\n            var leafAABB = leaf.bounds;\r\n            var currentRoot = this.root;\r\n            while (!currentRoot.isLeaf()) {\r\n                var left = currentRoot.left;\r\n                var right = currentRoot.right;\r\n                var area = currentRoot.bounds.getPerimeter();\r\n                var combinedAABB = currentRoot.bounds.combine(leafAABB);\r\n                var combinedArea = combinedAABB.getPerimeter();\r\n                // Calculate cost heuristic for creating a new parent and leaf\r\n                var cost = 2 * combinedArea;\r\n                // Minimum cost of pushing the leaf down the tree\r\n                var inheritanceCost = 2 * (combinedArea - area);\r\n                // Cost of descending\r\n                var leftCost = 0;\r\n                var leftCombined = leafAABB.combine(left.bounds);\r\n                var newArea;\r\n                var oldArea;\r\n                if (left.isLeaf()) {\r\n                    leftCost = leftCombined.getPerimeter() + inheritanceCost;\r\n                }\r\n                else {\r\n                    oldArea = left.bounds.getPerimeter();\r\n                    newArea = leftCombined.getPerimeter();\r\n                    leftCost = (newArea - oldArea) + inheritanceCost;\r\n                }\r\n                var rightCost = 0;\r\n                var rightCombined = leafAABB.combine(right.bounds);\r\n                if (right.isLeaf()) {\r\n                    rightCost = rightCombined.getPerimeter() + inheritanceCost;\r\n                }\r\n                else {\r\n                    oldArea = right.bounds.getPerimeter();\r\n                    newArea = rightCombined.getPerimeter();\r\n                    rightCost = (newArea - oldArea) + inheritanceCost;\r\n                }\r\n                // cost is acceptable\r\n                if (cost < leftCost && cost < rightCost) {\r\n                    break;\r\n                }\r\n                // Descend to the depths\r\n                if (leftCost < rightCost) {\r\n                    currentRoot = left;\r\n                }\r\n                else {\r\n                    currentRoot = right;\r\n                }\r\n            }\r\n            // Create the new parent node and insert into the tree\r\n            var oldParent = currentRoot.parent;\r\n            var newParent = new TreeNode(oldParent);\r\n            newParent.bounds = leafAABB.combine(currentRoot.bounds);\r\n            newParent.height = currentRoot.height + 1;\r\n            if (oldParent !== null) {\r\n                // The sibling node was not the root\r\n                if (oldParent.left === currentRoot) {\r\n                    oldParent.left = newParent;\r\n                }\r\n                else {\r\n                    oldParent.right = newParent;\r\n                }\r\n                newParent.left = currentRoot;\r\n                newParent.right = leaf;\r\n                currentRoot.parent = newParent;\r\n                leaf.parent = newParent;\r\n            }\r\n            else {\r\n                // The sibling node was the root\r\n                newParent.left = currentRoot;\r\n                newParent.right = leaf;\r\n                currentRoot.parent = newParent;\r\n                leaf.parent = newParent;\r\n                this.root = newParent;\r\n            }\r\n            // Walk up the tree fixing heights and AABBs\r\n            var currentNode = leaf.parent;\r\n            while (currentNode) {\r\n                currentNode = this._balance(currentNode);\r\n                if (!currentNode.left) {\r\n                    throw new Error(\'Parent of current leaf cannot have a null left child\' + currentNode);\r\n                }\r\n                if (!currentNode.right) {\r\n                    throw new Error(\'Parent of current leaf cannot have a null right child\' + currentNode);\r\n                }\r\n                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n                currentNode = currentNode.parent;\r\n            }\r\n        };\r\n        /**\r\n         * Removes a node from the dynamic tree\r\n         */\r\n        DynamicTree.prototype._remove = function (leaf) {\r\n            if (leaf === this.root) {\r\n                this.root = null;\r\n                return;\r\n            }\r\n            var parent = leaf.parent;\r\n            var grandParent = parent.parent;\r\n            var sibling;\r\n            if (parent.left === leaf) {\r\n                sibling = parent.right;\r\n            }\r\n            else {\r\n                sibling = parent.left;\r\n            }\r\n            if (grandParent) {\r\n                if (grandParent.left === parent) {\r\n                    grandParent.left = sibling;\r\n                }\r\n                else {\r\n                    grandParent.right = sibling;\r\n                }\r\n                sibling.parent = grandParent;\r\n                var currentNode = grandParent;\r\n                while (currentNode) {\r\n                    currentNode = this._balance(currentNode);\r\n                    currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n                    currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n                    currentNode = currentNode.parent;\r\n                }\r\n            }\r\n            else {\r\n                this.root = sibling;\r\n                sibling.parent = null;\r\n            }\r\n        };\r\n        /**\r\n         * Tracks a body in the dynamic tree\r\n         */\r\n        DynamicTree.prototype.trackBody = function (body) {\r\n            var node = new TreeNode();\r\n            node.body = body;\r\n            node.bounds = body.getBounds();\r\n            node.bounds.left -= 2;\r\n            node.bounds.top -= 2;\r\n            node.bounds.right += 2;\r\n            node.bounds.bottom += 2;\r\n            this.nodes[body.actor.id] = node;\r\n            this._insert(node);\r\n        };\r\n        /**\r\n         * Updates the dynamic tree given the current bounds of each body being tracked\r\n         */\r\n        DynamicTree.prototype.updateBody = function (body) {\r\n            var node = this.nodes[body.actor.id];\r\n            if (!node) {\r\n                return false;\r\n            }\r\n            var b = body.getBounds();\r\n            // if the body is outside the world no longer update it\r\n            if (!this.worldBounds.contains(b)) {\r\n                Log_9.Logger.getInstance().warn(\'Actor with id \' + body.actor.id +\r\n                    \' is outside the world bounds and will no longer be tracked for physics\');\r\n                this.untrackBody(body);\r\n                return false;\r\n            }\r\n            if (node.bounds.contains(b)) {\r\n                return false;\r\n            }\r\n            this._remove(node);\r\n            b.left -= Physics_8.Physics.boundsPadding;\r\n            b.top -= Physics_8.Physics.boundsPadding;\r\n            b.right += Physics_8.Physics.boundsPadding;\r\n            b.bottom += Physics_8.Physics.boundsPadding;\r\n            var multdx = body.vel.x * Physics_8.Physics.dynamicTreeVelocityMultiplyer;\r\n            var multdy = body.vel.y * Physics_8.Physics.dynamicTreeVelocityMultiplyer;\r\n            if (multdx < 0) {\r\n                b.left += multdx;\r\n            }\r\n            else {\r\n                b.right += multdx;\r\n            }\r\n            if (multdy < 0) {\r\n                b.top += multdy;\r\n            }\r\n            else {\r\n                b.bottom += multdy;\r\n            }\r\n            node.bounds = b;\r\n            this._insert(node);\r\n            return true;\r\n        };\r\n        /**\r\n         * Untracks a body from the dynamic tree\r\n         */\r\n        DynamicTree.prototype.untrackBody = function (body) {\r\n            var node = this.nodes[body.actor.id];\r\n            if (!node) {\r\n                return;\r\n            }\r\n            this._remove(node);\r\n            this.nodes[body.actor.id] = null;\r\n            delete this.nodes[body.actor.id];\r\n        };\r\n        /**\r\n         * Balances the tree about a node\r\n         */\r\n        DynamicTree.prototype._balance = function (node) {\r\n            if (node === null) {\r\n                throw new Error(\'Cannot balance at null node\');\r\n            }\r\n            if (node.isLeaf() || node.height < 2) {\r\n                return node;\r\n            }\r\n            var left = node.left;\r\n            var right = node.right;\r\n            var a = node;\r\n            var b = left;\r\n            var c = right;\r\n            var d = left.left;\r\n            var e = left.right;\r\n            var f = right.left;\r\n            var g = right.right;\r\n            var balance = c.height - b.height;\r\n            // Rotate c node up\r\n            if (balance > 1) {\r\n                // Swap the right node with it\'s parent\r\n                c.left = a;\r\n                c.parent = a.parent;\r\n                a.parent = c;\r\n                // The original node\'s old parent should point to the right node\r\n                // this is mega confusing\r\n                if (c.parent) {\r\n                    if (c.parent.left === a) {\r\n                        c.parent.left = c;\r\n                    }\r\n                    else {\r\n                        c.parent.right = c;\r\n                    }\r\n                }\r\n                else {\r\n                    this.root = c;\r\n                }\r\n                // Rotate\r\n                if (f.height > g.height) {\r\n                    c.right = f;\r\n                    a.right = g;\r\n                    g.parent = a;\r\n                    a.bounds = b.bounds.combine(g.bounds);\r\n                    c.bounds = a.bounds.combine(f.bounds);\r\n                    a.height = 1 + Math.max(b.height, g.height);\r\n                    c.height = 1 + Math.max(a.height, f.height);\r\n                }\r\n                else {\r\n                    c.right = g;\r\n                    a.right = f;\r\n                    f.parent = a;\r\n                    a.bounds = b.bounds.combine(f.bounds);\r\n                    c.bounds = a.bounds.combine(g.bounds);\r\n                    a.height = 1 + Math.max(b.height, f.height);\r\n                    c.height = 1 + Math.max(a.height, g.height);\r\n                }\r\n                return c;\r\n            }\r\n            // Rotate left node up\r\n            if (balance < -1) {\r\n                // swap\r\n                b.left = a;\r\n                b.parent = a.parent;\r\n                a.parent = b;\r\n                // node\'s old parent should point to b\r\n                if (b.parent) {\r\n                    if (b.parent.left === a) {\r\n                        b.parent.left = b;\r\n                    }\r\n                    else {\r\n                        if (b.parent.right !== a) {\r\n                            throw \'Error rotating Dynamic Tree\';\r\n                        }\r\n                        b.parent.right = b;\r\n                    }\r\n                }\r\n                else {\r\n                    this.root = b;\r\n                }\r\n                // rotate\r\n                if (d.height > e.height) {\r\n                    b.right = d;\r\n                    a.left = e;\r\n                    e.parent = a;\r\n                    a.bounds = c.bounds.combine(e.bounds);\r\n                    b.bounds = a.bounds.combine(d.bounds);\r\n                    a.height = 1 + Math.max(c.height, e.height);\r\n                    b.height = 1 + Math.max(a.height, d.height);\r\n                }\r\n                else {\r\n                    b.right = e;\r\n                    a.left = d;\r\n                    d.parent = a;\r\n                    a.bounds = c.bounds.combine(d.bounds);\r\n                    b.bounds = a.bounds.combine(e.bounds);\r\n                    a.height = 1 + Math.max(c.height, d.height);\r\n                    b.height = 1 + Math.max(a.height, e.height);\r\n                }\r\n                return b;\r\n            }\r\n            return node;\r\n        };\r\n        /**\r\n         * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows\r\n         */\r\n        DynamicTree.prototype.getHeight = function () {\r\n            if (this.root === null) {\r\n                return 0;\r\n            }\r\n            return this.root.height;\r\n        };\r\n        /**\r\n         * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.\r\n         *\r\n         * In the query callback, it will be passed a potential collider. Returning true from this callback indicates\r\n         * that you are complete with your query and you do not want to continue. Returning false will continue searching\r\n         * the tree until all possible colliders have been returned.\r\n         */\r\n        DynamicTree.prototype.query = function (body, callback) {\r\n            var bounds = body.getBounds();\r\n            var helper = function (currentNode) {\r\n                if (currentNode && currentNode.bounds.collides(bounds)) {\r\n                    if (currentNode.isLeaf() && currentNode.body !== body) {\r\n                        if (callback.call(body, currentNode.body)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        return helper(currentNode.left) || helper(currentNode.right);\r\n                    }\r\n                }\r\n                return false;\r\n            };\r\n            helper(this.root);\r\n        };\r\n        /**\r\n         * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely\r\n         * long ray to test the tree specified by `max`.\r\n         *\r\n         * In the query callback, it will be passed a potential body that intersects with the racast. Returning true from this\r\n         * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching\r\n         * the tree until all possible bodies that would intersect with the ray have been returned.\r\n         */\r\n        DynamicTree.prototype.rayCastQuery = function (ray, max, callback) {\r\n            if (max === void 0) { max = Infinity; }\r\n            var helper = function (currentNode) {\r\n                if (currentNode && currentNode.bounds.rayCast(ray, max)) {\r\n                    if (currentNode.isLeaf()) {\r\n                        if (callback.call(ray, currentNode.body)) {\r\n                            // ray hit a leaf! return the body\r\n                            return true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // ray hit but not at a leaf, recurse deeper\r\n                        return helper(currentNode.left) || helper(currentNode.right);\r\n                    }\r\n                }\r\n                return false; // ray missed         \r\n            };\r\n            helper(this.root);\r\n        };\r\n        DynamicTree.prototype.getNodes = function () {\r\n            var helper = function (currentNode) {\r\n                if (currentNode) {\r\n                    return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));\r\n                }\r\n                else {\r\n                    return [];\r\n                }\r\n            };\r\n            return helper(this.root);\r\n        };\r\n        DynamicTree.prototype.debugDraw = function (ctx) {\r\n            // draw all the nodes in the Dynamic Tree\r\n            var helper = function (currentNode) {\r\n                if (currentNode) {\r\n                    if (currentNode.isLeaf()) {\r\n                        ctx.lineWidth = 1;\r\n                        ctx.strokeStyle = \'green\';\r\n                    }\r\n                    else {\r\n                        ctx.lineWidth = 1;\r\n                        ctx.strokeStyle = \'white\';\r\n                    }\r\n                    currentNode.bounds.debugDraw(ctx);\r\n                    if (currentNode.left) {\r\n                        helper(currentNode.left);\r\n                    }\r\n                    if (currentNode.right) {\r\n                        helper(currentNode.right);\r\n                    }\r\n                }\r\n            };\r\n            helper(this.root);\r\n        };\r\n        return DynamicTree;\r\n    }());\r\n    exports.DynamicTree = DynamicTree;\r\n});\r\ndefine("Collision/ICollisionResolver", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Collision/DynamicTreeCollisionBroadphase", ["require", "exports", "Physics", "Collision/DynamicTree", "Collision/Pair", "Algebra", "Actor", "Util/Log", "Events"], function (require, exports, Physics_9, DynamicTree_1, Pair_2, Algebra_18, Actor_9, Log_10, Events_6) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var DynamicTreeCollisionBroadphase = (function () {\r\n        function DynamicTreeCollisionBroadphase() {\r\n            this._dynamicCollisionTree = new DynamicTree_1.DynamicTree();\r\n            this._collisionHash = {};\r\n            this._collisionPairCache = [];\r\n            this._lastFramePairs = [];\r\n            this._lastFramePairsHash = {};\r\n        }\r\n        /**\r\n         * Tracks a physics body for collisions\r\n         */\r\n        DynamicTreeCollisionBroadphase.prototype.track = function (target) {\r\n            if (!target) {\r\n                Log_10.Logger.getInstance().warn(\'Cannot track null physics body\');\r\n                return;\r\n            }\r\n            this._dynamicCollisionTree.trackBody(target);\r\n        };\r\n        /**\r\n         * Untracks a physics body\r\n         */\r\n        DynamicTreeCollisionBroadphase.prototype.untrack = function (target) {\r\n            if (!target) {\r\n                Log_10.Logger.getInstance().warn(\'Cannot untrack a null physics body\');\r\n                return;\r\n            }\r\n            this._dynamicCollisionTree.untrackBody(target);\r\n        };\r\n        DynamicTreeCollisionBroadphase.prototype._canCollide = function (actorA, actorB) {\r\n            // if the collision pair has been calculated already short circuit\r\n            var hash = Pair_2.Pair.calculatePairHash(actorA.body, actorB.body);\r\n            if (this._collisionHash[hash]) {\r\n                return false; // pair exists easy exit return false\r\n            }\r\n            // if both are fixed short circuit\r\n            if (actorA.collisionType === Actor_9.CollisionType.Fixed && actorB.collisionType === Actor_9.CollisionType.Fixed) {\r\n                return false;\r\n            }\r\n            // if the other is prevent collision or is dead short circuit\r\n            if (actorB.collisionType === Actor_9.CollisionType.PreventCollision || actorB.isKilled()) {\r\n                return false;\r\n            }\r\n            // they can collide\r\n            return true;\r\n        };\r\n        /**\r\n         * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy\r\n         */\r\n        DynamicTreeCollisionBroadphase.prototype.broadphase = function (targets, delta, stats) {\r\n            var _this = this;\r\n            var seconds = delta / 1000;\r\n            // TODO optimization use only the actors that are moving to start \r\n            // Retrieve the list of potential colliders, exclude killed, prevented, and self\r\n            var potentialColliders = targets.filter(function (other) {\r\n                return !other.isKilled() && other.collisionType !== Actor_9.CollisionType.PreventCollision;\r\n            });\r\n            // clear old list of collision pairs\r\n            this._collisionPairCache = [];\r\n            this._collisionHash = {};\r\n            // check for normal collision pairs\r\n            var actor;\r\n            for (var j = 0, l = potentialColliders.length; j < l; j++) {\r\n                actor = potentialColliders[j];\r\n                // Query the collision tree for potential colliders\r\n                this._dynamicCollisionTree.query(actor.body, function (other) {\r\n                    if (_this._canCollide(actor, other.actor)) {\r\n                        var pair = new Pair_2.Pair(actor.body, other);\r\n                        _this._collisionHash[pair.id] = true;\r\n                        _this._collisionPairCache.push(pair);\r\n                    }\r\n                    // Always return false, to query whole tree. Returning true in the query method stops searching\r\n                    return false;\r\n                });\r\n            }\r\n            if (stats) {\r\n                stats.physics.pairs = this._collisionPairCache.length;\r\n            }\r\n            // Check dynamic tree for fast moving objects\r\n            // Fast moving objects are those moving at least there smallest bound per frame\r\n            if (Physics_9.Physics.checkForFastBodies) {\r\n                for (var _i = 0, potentialColliders_1 = potentialColliders; _i < potentialColliders_1.length; _i++) {\r\n                    var actor = potentialColliders_1[_i];\r\n                    // Skip non-active objects. Does not make sense on other collison types\r\n                    if (actor.collisionType !== Actor_9.CollisionType.Active) {\r\n                        continue;\r\n                    }\r\n                    ;\r\n                    // Maximum travel distance next frame\r\n                    var updateDistance = (actor.vel.magnitude() * seconds) +\r\n                        (actor.acc.magnitude() * .5 * seconds * seconds); // acc term\r\n                    // Find the minimum dimension\r\n                    var minDimension = Math.min(actor.body.getBounds().getHeight(), actor.body.getBounds().getWidth());\r\n                    if (Physics_9.Physics.disableMinimumSpeedForFastBody || updateDistance > (minDimension / 2)) {\r\n                        if (stats) {\r\n                            stats.physics.fastBodies++;\r\n                        }\r\n                        // start with the oldPos because the integration for actors has already happened\r\n                        // objects resting on a surface may be slightly penatrating in the current position\r\n                        var updateVec = actor.pos.sub(actor.oldPos);\r\n                        var centerPoint = actor.body.collisionArea.getCenter();\r\n                        var furthestPoint = actor.body.collisionArea.getFurthestPoint(actor.vel);\r\n                        var origin = furthestPoint.sub(updateVec);\r\n                        var ray = new Algebra_18.Ray(origin, actor.vel);\r\n                        // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface \r\n                        ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics_9.Physics.surfaceEpsilon));\r\n                        var minBody;\r\n                        var minTranslate = new Algebra_18.Vector(Infinity, Infinity);\r\n                        this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics_9.Physics.surfaceEpsilon * 2, function (other) {\r\n                            if (actor.body !== other && other.collisionArea) {\r\n                                var hitPoint = other.collisionArea.rayCast(ray, updateDistance + Physics_9.Physics.surfaceEpsilon * 10);\r\n                                if (hitPoint) {\r\n                                    var translate = hitPoint.sub(origin);\r\n                                    if (translate.magnitude() < minTranslate.magnitude()) {\r\n                                        minTranslate = translate;\r\n                                        minBody = other;\r\n                                    }\r\n                                }\r\n                            }\r\n                            return false;\r\n                        });\r\n                        if (minBody && Algebra_18.Vector.isValid(minTranslate)) {\r\n                            var pair = new Pair_2.Pair(actor.body, minBody);\r\n                            if (!this._collisionHash[pair.id]) {\r\n                                this._collisionHash[pair.id] = true;\r\n                                this._collisionPairCache.push(pair);\r\n                            }\r\n                            // move the fast moving object to the other body\r\n                            // need to push into the surface by ex.Physics.surfaceEpsilon\r\n                            var shift = centerPoint.sub(furthestPoint);\r\n                            actor.pos = origin.add(shift).add(minTranslate).add(ray.dir.scale(2 * Physics_9.Physics.surfaceEpsilon));\r\n                            actor.body.collisionArea.recalc();\r\n                            if (stats) {\r\n                                stats.physics.fastBodyCollisions++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // return cache\r\n            return this._collisionPairCache;\r\n        };\r\n        /**\r\n         * Applies narrow phase on collision pairs to find actual area intersections\r\n         * Adds actual colliding pairs to stats\' Frame data\r\n         */\r\n        DynamicTreeCollisionBroadphase.prototype.narrowphase = function (pairs, stats) {\r\n            for (var i = 0; i < pairs.length; i++) {\r\n                pairs[i].collide();\r\n                if (stats && pairs[i].collision) {\r\n                    stats.physics.collisions++;\r\n                    stats.physics.collidersHash[pairs[i].id] = pairs[i];\r\n                }\r\n            }\r\n            return pairs.filter(function (p) { return p.collision; });\r\n        };\r\n        /**\r\n         * Perform collision resolution given a strategy (rigid body or box) and move objects out of intersect.\r\n         */\r\n        DynamicTreeCollisionBroadphase.prototype.resolve = function (pairs, delta, strategy) {\r\n            for (var _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++) {\r\n                var pair = pairs_1[_i];\r\n                pair.resolve(strategy);\r\n                if (pair.collision) {\r\n                    pair.bodyA.applyMtv();\r\n                    pair.bodyB.applyMtv();\r\n                    // todo still don\'t like this, this is a small integration step to resolve narrowphase collisions\r\n                    pair.bodyA.actor.integrate(delta * Physics_9.Physics.collisionShift);\r\n                    pair.bodyB.actor.integrate(delta * Physics_9.Physics.collisionShift);\r\n                }\r\n            }\r\n            return pairs.filter(function (p) { return p.canCollide; });\r\n        };\r\n        DynamicTreeCollisionBroadphase.prototype.runCollisionStartEnd = function (pairs) {\r\n            var currentFrameHash = {};\r\n            for (var _i = 0, pairs_2 = pairs; _i < pairs_2.length; _i++) {\r\n                var p = pairs_2[_i];\r\n                // load currentFrameHash\r\n                currentFrameHash[p.id] = p;\r\n                // find all new collisions\r\n                if (!this._lastFramePairsHash[p.id]) {\r\n                    var actor1 = p.bodyA.actor;\r\n                    var actor2 = p.bodyB.actor;\r\n                    actor1.emit(\'collisionstart\', new Events_6.CollisionStartEvent(actor1, actor2, p));\r\n                    actor2.emit(\'collisionstart\', new Events_6.CollisionStartEvent(actor2, actor1, p));\r\n                }\r\n            }\r\n            // find all old collisions\r\n            for (var _a = 0, _b = this._lastFramePairs; _a < _b.length; _a++) {\r\n                var p = _b[_a];\r\n                if (!currentFrameHash[p.id]) {\r\n                    var actor1 = p.bodyA.actor;\r\n                    var actor2 = p.bodyB.actor;\r\n                    actor1.emit(\'collisionend\', new Events_6.CollisionEndEvent(actor1, actor2));\r\n                    actor2.emit(\'collisionend\', new Events_6.CollisionEndEvent(actor2, actor1));\r\n                }\r\n            }\r\n            // reset the last frame cache\r\n            this._lastFramePairs = pairs;\r\n            this._lastFramePairsHash = currentFrameHash;\r\n        };\r\n        /**\r\n         * Update the dynamic tree positions\r\n         */\r\n        DynamicTreeCollisionBroadphase.prototype.update = function (targets) {\r\n            var updated = 0, i = 0, len = targets.length;\r\n            for (i; i < len; i++) {\r\n                if (this._dynamicCollisionTree.updateBody(targets[i].body)) {\r\n                    updated++;\r\n                }\r\n            }\r\n            return updated;\r\n        };\r\n        /* istanbul ignore next */\r\n        DynamicTreeCollisionBroadphase.prototype.debugDraw = function (ctx) {\r\n            if (Physics_9.Physics.broadphaseDebug) {\r\n                this._dynamicCollisionTree.debugDraw(ctx);\r\n            }\r\n            if (Physics_9.Physics.showContacts || Physics_9.Physics.showCollisionNormals) {\r\n                for (var _i = 0, _a = this._collisionPairCache; _i < _a.length; _i++) {\r\n                    var pair = _a[_i];\r\n                    pair.debugDraw(ctx);\r\n                }\r\n            }\r\n        };\r\n        return DynamicTreeCollisionBroadphase;\r\n    }());\r\n    exports.DynamicTreeCollisionBroadphase = DynamicTreeCollisionBroadphase;\r\n});\r\ndefine("Collision/IPhysics", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("Collision/NaiveCollisionBroadphase", ["require", "exports", "Physics", "Collision/CollisionContact", "Collision/Pair", "Actor", "Events"], function (require, exports, Physics_10, CollisionContact_2, Pair_3, Actor_10, Events_7) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var NaiveCollisionBroadphase = (function () {\r\n        function NaiveCollisionBroadphase() {\r\n            this._lastFramePairs = [];\r\n            this._lastFramePairsHash = {};\r\n        }\r\n        NaiveCollisionBroadphase.prototype.track = function () {\r\n            // pass\r\n        };\r\n        NaiveCollisionBroadphase.prototype.untrack = function () {\r\n            // pass\r\n        };\r\n        /**\r\n         * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy\r\n         */\r\n        NaiveCollisionBroadphase.prototype.broadphase = function (targets) {\r\n            // Retrieve the list of potential colliders, exclude killed, prevented, and self\r\n            var potentialColliders = targets.filter(function (other) {\r\n                return !other.isKilled() && other.collisionType !== Actor_10.CollisionType.PreventCollision;\r\n            });\r\n            var actor1;\r\n            var actor2;\r\n            var collisionPairs = [];\r\n            for (var j = 0, l = potentialColliders.length; j < l; j++) {\r\n                actor1 = potentialColliders[j];\r\n                for (var i = j + 1; i < l; i++) {\r\n                    actor2 = potentialColliders[i];\r\n                    var minimumTranslationVector;\r\n                    if (minimumTranslationVector = actor1.collides(actor2)) {\r\n                        var pair = new Pair_3.Pair(actor1.body, actor2.body);\r\n                        pair.collision = new CollisionContact_2.CollisionContact(actor1.collisionArea, actor2.collisionArea, minimumTranslationVector, actor1.pos, minimumTranslationVector);\r\n                        if (!collisionPairs.some(function (cp) {\r\n                            return cp.id === pair.id;\r\n                        })) {\r\n                            collisionPairs.push(pair);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return collisionPairs;\r\n        };\r\n        /**\r\n         * Identify actual collisions from those pairs, and calculate collision impulse\r\n         */\r\n        NaiveCollisionBroadphase.prototype.narrowphase = function (pairs) {\r\n            return pairs;\r\n        };\r\n        NaiveCollisionBroadphase.prototype.runCollisionStartEnd = function (pairs) {\r\n            var currentFrameHash = {};\r\n            for (var _i = 0, pairs_3 = pairs; _i < pairs_3.length; _i++) {\r\n                var p = pairs_3[_i];\r\n                // load currentFrameHash\r\n                currentFrameHash[p.id] = p;\r\n                // find all new collisions\r\n                if (!this._lastFramePairsHash[p.id]) {\r\n                    var actor1 = p.bodyA.actor;\r\n                    var actor2 = p.bodyB.actor;\r\n                    actor1.emit(\'collisionstart\', new Events_7.CollisionStartEvent(actor1, actor2, p));\r\n                    actor2.emit(\'collisionstart\', new Events_7.CollisionStartEvent(actor2, actor1, p));\r\n                }\r\n            }\r\n            // find all old collisions\r\n            for (var _a = 0, _b = this._lastFramePairs; _a < _b.length; _a++) {\r\n                var p = _b[_a];\r\n                if (!currentFrameHash[p.id]) {\r\n                    var actor1 = p.bodyA.actor;\r\n                    var actor2 = p.bodyB.actor;\r\n                    actor1.emit(\'collisionend\', new Events_7.CollisionEndEvent(actor1, actor2));\r\n                    actor2.emit(\'collisionend\', new Events_7.CollisionEndEvent(actor2, actor1));\r\n                }\r\n            }\r\n            // reset the last frame cache\r\n            this._lastFramePairs = pairs;\r\n            this._lastFramePairsHash = currentFrameHash;\r\n        };\r\n        /**\r\n         * Resolve the position and velocity of the physics bodies\r\n         */\r\n        NaiveCollisionBroadphase.prototype.resolve = function (pairs) {\r\n            for (var _i = 0, pairs_4 = pairs; _i < pairs_4.length; _i++) {\r\n                var pair = pairs_4[_i];\r\n                pair.resolve(Physics_10.Physics.collisionResolutionStrategy);\r\n            }\r\n            return pairs.filter(function (p) { return p.canCollide; });\r\n        };\r\n        NaiveCollisionBroadphase.prototype.update = function () {\r\n            return 0;\r\n        };\r\n        NaiveCollisionBroadphase.prototype.debugDraw = function () {\r\n            return;\r\n        };\r\n        return NaiveCollisionBroadphase;\r\n    }());\r\n    exports.NaiveCollisionBroadphase = NaiveCollisionBroadphase;\r\n});\r\ndefine("Collision/Index", ["require", "exports", "Collision/Body", "Collision/BoundingBox", "Collision/CircleArea", "Collision/CollisionContact", "Collision/CollisionJumpTable", "Collision/DynamicTree", "Collision/DynamicTreeCollisionBroadphase", "Collision/EdgeArea", "Collision/NaiveCollisionBroadphase", "Collision/Pair", "Collision/PolygonArea", "Collision/Side"], function (require, exports, Body_1, BoundingBox_6, CircleArea_4, CollisionContact_3, CollisionJumpTable_4, DynamicTree_2, DynamicTreeCollisionBroadphase_1, EdgeArea_4, NaiveCollisionBroadphase_1, Pair_4, PolygonArea_6, Side_3) {\r\n    "use strict";\r\n    function __export(m) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    __export(Body_1);\r\n    __export(BoundingBox_6);\r\n    __export(CircleArea_4);\r\n    __export(CollisionContact_3);\r\n    __export(CollisionJumpTable_4);\r\n    __export(DynamicTree_2);\r\n    __export(DynamicTreeCollisionBroadphase_1);\r\n    __export(EdgeArea_4);\r\n    __export(NaiveCollisionBroadphase_1);\r\n    __export(Pair_4);\r\n    __export(PolygonArea_6);\r\n    __export(Side_3);\r\n});\r\ndefine("Drawing/Polygon", ["require", "exports", "Algebra"], function (require, exports, Algebra_19) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Creates a closed polygon drawing given a list of [[Vector]]s.\r\n     *\r\n     * @warning Use sparingly as Polygons are performance intensive\r\n     */\r\n    var Polygon = (function () {\r\n        /**\r\n         * @param points  The vectors to use to build the polygon in order\r\n         */\r\n        function Polygon(points) {\r\n            /**\r\n             * The width of the lines of the polygon\r\n             */\r\n            this.lineWidth = 5;\r\n            /**\r\n             * Indicates whether the polygon is filled or not.\r\n             */\r\n            this.filled = false;\r\n            this._points = [];\r\n            this.anchor = new Algebra_19.Vector(0, 0);\r\n            this.rotation = 0;\r\n            this.scale = new Algebra_19.Vector(1, 1);\r\n            this._points = points;\r\n            var minX = this._points.reduce(function (prev, curr) {\r\n                return Math.min(prev, curr.x);\r\n            }, 0);\r\n            var maxX = this._points.reduce(function (prev, curr) {\r\n                return Math.max(prev, curr.x);\r\n            }, 0);\r\n            this.width = maxX - minX;\r\n            var minY = this._points.reduce(function (prev, curr) {\r\n                return Math.min(prev, curr.y);\r\n            }, 0);\r\n            var maxY = this._points.reduce(function (prev, curr) {\r\n                return Math.max(prev, curr.y);\r\n            }, 0);\r\n            this.height = maxY - minY;\r\n            this.naturalHeight = this.height;\r\n            this.naturalWidth = this.width;\r\n        }\r\n        /**\r\n         * @notimplemented Effects are not supported on `Polygon`\r\n         */\r\n        Polygon.prototype.addEffect = function () {\r\n            // not supported on polygons\r\n        };\r\n        /**\r\n         * @notimplemented Effects are not supported on `Polygon`\r\n         */\r\n        Polygon.prototype.removeEffect = function () {\r\n            // not supported on polygons\r\n        };\r\n        /**\r\n         * @notimplemented Effects are not supported on `Polygon`\r\n         */\r\n        Polygon.prototype.clearEffects = function () {\r\n            // not supported on polygons\r\n        };\r\n        Polygon.prototype.reset = function () {\r\n            //pass\r\n        };\r\n        Polygon.prototype.draw = function (ctx, x, y) {\r\n            ctx.save();\r\n            ctx.translate(x + this.anchor.x, y + this.anchor.y);\r\n            ctx.scale(this.scale.x, this.scale.y);\r\n            ctx.rotate(this.rotation);\r\n            ctx.beginPath();\r\n            ctx.lineWidth = this.lineWidth;\r\n            // Iterate through the supplied points and construct a \'polygon\'\r\n            var firstPoint = this._points[0];\r\n            ctx.moveTo(firstPoint.x, firstPoint.y);\r\n            var i = 0, len = this._points.length;\r\n            for (i; i < len; i++) {\r\n                ctx.lineTo(this._points[i].x, this._points[i].y);\r\n            }\r\n            ctx.lineTo(firstPoint.x, firstPoint.y);\r\n            ctx.closePath();\r\n            if (this.filled) {\r\n                ctx.fillStyle = this.fillColor.toString();\r\n                ctx.fill();\r\n            }\r\n            ctx.strokeStyle = this.lineColor.toString();\r\n            if (this.flipHorizontal) {\r\n                ctx.translate(this.width, 0);\r\n                ctx.scale(-1, 1);\r\n            }\r\n            if (this.flipVertical) {\r\n                ctx.translate(0, this.height);\r\n                ctx.scale(1, -1);\r\n            }\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        };\r\n        return Polygon;\r\n    }());\r\n    exports.Polygon = Polygon;\r\n});\r\ndefine("Drawing/Index", ["require", "exports", "Drawing/Animation", "Drawing/Color", "Drawing/Polygon", "Drawing/Sprite", "Drawing/SpriteSheet", "Drawing/SpriteEffects"], function (require, exports, Animation_2, Color_17, Polygon_1, Sprite_3, SpriteSheet_1, effects) {\r\n    "use strict";\r\n    function __export(m) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    __export(Animation_2);\r\n    __export(Color_17);\r\n    __export(Polygon_1);\r\n    __export(Sprite_3);\r\n    __export(SpriteSheet_1);\r\n    exports.Effects = effects;\r\n});\r\ndefine("Interfaces/Index", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\n/**\r\n * Pseudo-Random Utility\r\n *\r\n * A pseudo-random utility to add seeded random support for help in\r\n * generating things like terrain or reproducible randomness. Uses the\r\n * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.\r\n *\r\n * [[include:Random.md]]\r\n */\r\ndefine("Math/Random", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * 32-bit mask\r\n     */\r\n    var BITMASK32 = 0xFFFFFFFF;\r\n    /**\r\n     * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence\r\n     * of numbers each time it is called.\r\n     * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.\r\n     * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html\r\n     *\r\n     * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs\r\n     */\r\n    var Random = (function () {\r\n        /**\r\n         * If no seed is specified, the Date.now() is used\r\n         */\r\n        function Random(seed) {\r\n            this.seed = seed;\r\n            // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1\r\n            this._lowerMask = 0x7FFFFFFF; // 31 bits same as _r\r\n            this._upperMask = 0x80000000; // 34 high bits\r\n            // Word size, 64 bits\r\n            this._w = 32;\r\n            // Degree of recurrance\r\n            this._n = 624;\r\n            // Middle word, an offset used in the recurrance defining the series x, 1<=m<n\r\n            this._m = 397;\r\n            // coefficients of teh rational normal form twist matrix\r\n            this._a = 0x9908B0DF;\r\n            // tempering bit shifts and masks\r\n            this._u = 11;\r\n            this._s = 7;\r\n            this._b = 0x9d2c5680;\r\n            this._t = 15;\r\n            this._c = 0xefc60000;\r\n            this._l = 18;\r\n            this._f = 1812433253;\r\n            this._mt = new Array(this._n);\r\n            // need to mask to support higher bit machines\r\n            this._mt[0] = (seed || Date.now()) >>> 0;\r\n            for (var i = 1; i < this._n; i++) {\r\n                var s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));\r\n                // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits         \r\n                this._mt[i] = (((this._f * ((s & 0xFFFF0000) >>> 16)) << 16) + (this._f * (s & 0xFFFF)) + i) >>> 0;\r\n            }\r\n            this._index = this._n;\r\n        }\r\n        /**\r\n         * Apply the twist\r\n         */\r\n        Random.prototype._twist = function () {\r\n            var mag01 = [0x0, this._a];\r\n            var y = 0;\r\n            for (var i = 0; i < this._n - this._m; i++) {\r\n                y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n                this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;\r\n            }\r\n            for (; i < this._n - 1; i++) {\r\n                y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n                this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;\r\n            }\r\n            y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);\r\n            this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;\r\n            this._index = 0;\r\n        };\r\n        /**\r\n         * Return next 32 bit integer number in sequence\r\n         */\r\n        Random.prototype.nextInt = function () {\r\n            if (this._index >= this._n) {\r\n                this._twist();\r\n            }\r\n            var y = this._mt[this._index++];\r\n            y ^= y >>> this._u;\r\n            y ^= ((y << this._s) & this._b);\r\n            y ^= ((y << this._t) & this._c);\r\n            y ^= (y >>> this._l);\r\n            return y >>> 0;\r\n        };\r\n        /**\r\n         * Return a random floating point number between [0, 1)\r\n         */\r\n        Random.prototype.next = function () {\r\n            return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32\r\n        };\r\n        /**\r\n         * Return a random floating point in range [min, max) min is included, max is not included\r\n         */\r\n        Random.prototype.floating = function (min, max) {\r\n            return (max - min) * this.next() + min;\r\n        };\r\n        /**\r\n         * Return a random integer in range [min, max] min is included, max is included.\r\n         * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a\r\n         */\r\n        Random.prototype.integer = function (min, max) {\r\n            return Math.floor((max - min + 1) * this.next() + min);\r\n        };\r\n        /**\r\n         * Returns true or false randomly with 50/50 odds by default.\r\n         * By default the likelihood of returning a true is .5 (50%).\r\n         * @param likelihood takes values between [0, 1]\r\n         */\r\n        Random.prototype.bool = function (likelihood) {\r\n            if (likelihood === void 0) { likelihood = .5; }\r\n            return this.next() <= likelihood;\r\n        };\r\n        /**\r\n         * Returns one element from an array at random\r\n         */\r\n        Random.prototype.pickOne = function (array) {\r\n            return array[this.integer(0, array.length - 1)];\r\n        };\r\n        /**\r\n         * Returns a new array random picking elements from the original\r\n         * @param array Original array to pick from\r\n         * @param numPicks can be any positive number\r\n         * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates\r\n         * just that it is possible)\r\n         */\r\n        Random.prototype.pickSet = function (array, numPicks, allowDuplicates) {\r\n            if (allowDuplicates === void 0) { allowDuplicates = false; }\r\n            if (allowDuplicates) {\r\n                return this._pickSetWithDuplicates(array, numPicks);\r\n            }\r\n            else {\r\n                return this._pickSetWithoutDuplicates(array, numPicks);\r\n            }\r\n        };\r\n        /**\r\n         * Returns a new array randomly picking elements in the original (not reused)\r\n         * @param numPicks must be less than or equal to the number of elements in the array.\r\n         */\r\n        Random.prototype._pickSetWithoutDuplicates = function (array, numPicks) {\r\n            if (numPicks > array.length || numPicks < 0) {\r\n                throw new Error(\'Invalid number of elements to pick, must pick a value 0 < n <= length\');\r\n            }\r\n            if (numPicks === array.length) {\r\n                return array;\r\n            }\r\n            var result = new Array(numPicks);\r\n            var currentPick = 0;\r\n            var tempArray = array.slice(0);\r\n            while (currentPick < numPicks) {\r\n                var index = this.integer(0, tempArray.length - 1);\r\n                result[currentPick++] = tempArray[index];\r\n                tempArray.splice(index, 1);\r\n            }\r\n            return result;\r\n        };\r\n        /**\r\n         * Returns a new array random picking elements from the original allowing duplicates\r\n         * @param numPicks can be any positive number\r\n         */\r\n        Random.prototype._pickSetWithDuplicates = function (array, numPicks) {\r\n            // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)\r\n            if (numPicks < 0) {\r\n                throw new Error(\'Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT\');\r\n            }\r\n            var result = new Array(numPicks);\r\n            for (var i = 0; i < numPicks; i++) {\r\n                result.push(this.pickOne(array));\r\n            }\r\n            return result;\r\n        };\r\n        /**\r\n         * Returns a new array that has its elements shuffled. Using the Fisher/Yates method\r\n         * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\r\n         */\r\n        Random.prototype.shuffle = function (array) {\r\n            var tempArray = array.slice(0);\r\n            var swap = null;\r\n            for (var i = 0; i < tempArray.length - 2; i++) {\r\n                var randomIndex = this.integer(i, tempArray.length - 1);\r\n                swap = tempArray[i];\r\n                tempArray[i] = tempArray[randomIndex];\r\n                tempArray[randomIndex] = swap;\r\n            }\r\n            return tempArray;\r\n        };\r\n        /**\r\n         * Generate a list of random integer numbers\r\n         * @param length the length of the final array\r\n         * @param min the minimum integer number to generate inclusive\r\n         * @param max the maximum integer number to generate inclusive\r\n         */\r\n        Random.prototype.range = function (length, min, max) {\r\n            var result = new Array(length);\r\n            for (var i = 0; i < length; i++) {\r\n                result[i] = this.integer(min, max);\r\n            }\r\n            return result;\r\n        };\r\n        /**\r\n         * Returns the result of a d4 dice roll\r\n         */\r\n        Random.prototype.d4 = function () {\r\n            return this.integer(1, 4);\r\n        };\r\n        /**\r\n         * Returns the result of a d6 dice roll\r\n         */\r\n        Random.prototype.d6 = function () {\r\n            return this.integer(1, 6);\r\n        };\r\n        /**\r\n         * Returns the result of a d8 dice roll\r\n         */\r\n        Random.prototype.d8 = function () {\r\n            return this.integer(1, 8);\r\n        };\r\n        /**\r\n         * Returns the result of a d10 dice roll\r\n         */\r\n        Random.prototype.d10 = function () {\r\n            return this.integer(1, 10);\r\n        };\r\n        /**\r\n         * Returns the result of a d12 dice roll\r\n         */\r\n        Random.prototype.d12 = function () {\r\n            return this.integer(1, 12);\r\n        };\r\n        /**\r\n         * Returns the result of a d20 dice roll\r\n         */\r\n        Random.prototype.d20 = function () {\r\n            return this.integer(1, 20);\r\n        };\r\n        return Random;\r\n    }());\r\n    exports.Random = Random;\r\n});\r\ndefine("Math/PerlinNoise", ["require", "exports", "Math/Random", "Drawing/Color", "Util/Util"], function (require, exports, Random_1, Color_18, Util) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    function _lerp(time, a, b) {\r\n        return a + time * (b - a);\r\n    }\r\n    function _fade(t) {\r\n        return t * t * t * (t * (t * 6 - 15) + 10);\r\n    }\r\n    /**\r\n     * Generates perlin noise based on the 2002 Siggraph paper http://mrl.nyu.edu/~perlin/noise/\r\n     * Also https://flafla2.github.io/2014/08/09/perlinnoise.html\r\n     */\r\n    var PerlinGenerator = (function () {\r\n        function PerlinGenerator(options) {\r\n            this._perm = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,\r\n                140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26,\r\n                197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136,\r\n                171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,\r\n                211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80,\r\n                73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\r\n                173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206,\r\n                59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70,\r\n                221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178,\r\n                185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81,\r\n                51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115,\r\n                121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195,\r\n                78, 66, 215, 61, 156, 180];\r\n            this._p = new Uint8Array(512);\r\n            this._defaultPerlinOptions = {\r\n                octaves: 1,\r\n                frequency: 1,\r\n                amplitude: 1,\r\n                persistance: .5\r\n            };\r\n            options = Util.extend({}, this._defaultPerlinOptions, options);\r\n            this.persistance = options.persistance;\r\n            this.amplitude = options.amplitude;\r\n            this.frequency = options.frequency;\r\n            this.octaves = options.octaves;\r\n            if (options.seed) {\r\n                this._random = new Random_1.Random(options.seed);\r\n            }\r\n            else {\r\n                this._random = new Random_1.Random();\r\n            }\r\n            this._perm = this._random.shuffle(this._perm);\r\n            for (var i = 0; i < 512; i++) {\r\n                this._p[i] = this._perm[i % 256] & 0xFF;\r\n            }\r\n        }\r\n        PerlinGenerator.prototype.noise = function () {\r\n            var amp = this.amplitude;\r\n            var freq = this.frequency;\r\n            var total = 0;\r\n            var maxValue = 0;\r\n            for (var i = 0; i < this.octaves; i++) {\r\n                switch (arguments.length) {\r\n                    case 1:\r\n                        total += this._noise1d(arguments[0] * freq) * amp;\r\n                        break;\r\n                    case 2:\r\n                        total += this._noise2d(arguments[0] * freq, arguments[1] * freq) * amp;\r\n                        break;\r\n                    case 3:\r\n                        total += this._noise3d(arguments[0] * freq, arguments[1] * freq, arguments[2] * freq) * amp;\r\n                        break;\r\n                    /* istanbul ignore next */\r\n                    default: throw new Error(\'Invalid arguments for perlin noise\');\r\n                }\r\n                maxValue += amp;\r\n                amp *= this.persistance;\r\n                freq *= 2;\r\n            }\r\n            return total / maxValue;\r\n        };\r\n        /**\r\n         * Generates a list starting at 0 and ending at 1 of contious perlin noise, by default the step is 1/length;\r\n         *\r\n         */\r\n        PerlinGenerator.prototype.sequence = function (length, step) {\r\n            if (!step) {\r\n                step = 1 / length;\r\n            }\r\n            var array = new Array(length);\r\n            for (var i = 0; i < length; i++) {\r\n                array[i] = this.noise(i * step);\r\n            }\r\n            return array;\r\n        };\r\n        /**\r\n         * Generates a 2D grid of perlin noise given a step value packed into a 1D array i = (x + y*width),\r\n         * by default the step will 1/(min(dimension))\r\n         */\r\n        PerlinGenerator.prototype.grid = function (width, height, step) {\r\n            if (!step) {\r\n                step = 1 / (Math.min(width, height));\r\n            }\r\n            var array = new Array(width * height);\r\n            for (var y = 0; y < height; y++) {\r\n                for (var x = 0; x < width; x++) {\r\n                    array[x + y * width] = this.noise(x * step, y * step);\r\n                }\r\n            }\r\n            return array;\r\n        };\r\n        PerlinGenerator.prototype._gradient3d = function (hash, x, y, z) {\r\n            var h = hash & 0xF;\r\n            var u = h < 8 ? x : y;\r\n            var v = h < 4 ? y : ((h === 12 || h === 14) ? x : z);\r\n            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);\r\n        };\r\n        PerlinGenerator.prototype._gradient2d = function (hash, x, y) {\r\n            var value = (hash & 1) === 0 ? x : y;\r\n            return (hash & 2) === 0 ? -value : value;\r\n        };\r\n        PerlinGenerator.prototype._gradient1d = function (hash, x) {\r\n            return (hash & 1) === 0 ? -x : x;\r\n        };\r\n        PerlinGenerator.prototype._noise1d = function (x) {\r\n            var intX = Math.floor(x) & 0xFF; // force 0-255 integers to lookup in permutation\r\n            x -= Math.floor(x);\r\n            var fadeX = _fade(x);\r\n            return (_lerp(fadeX, this._gradient1d(this._p[intX], x), this._gradient1d(this._p[intX + 1], x - 1)) + 1) / 2;\r\n        };\r\n        PerlinGenerator.prototype._noise2d = function (x, y) {\r\n            var intX = Math.floor(x) & 0xFF;\r\n            var intY = Math.floor(y) & 0xFF;\r\n            x -= Math.floor(x);\r\n            y -= Math.floor(y);\r\n            var fadeX = _fade(x);\r\n            var fadeY = _fade(y);\r\n            var a = this._p[intX] + intY;\r\n            var b = this._p[intX + 1] + intY;\r\n            return (_lerp(fadeY, _lerp(fadeX, this._gradient2d(this._p[a], x, y), this._gradient2d(this._p[b], x - 1, y)), _lerp(fadeX, this._gradient2d(this._p[a + 1], x, y - 1), this._gradient2d(this._p[b + 1], x - 1, y - 1))) + 1) / 2;\r\n        };\r\n        PerlinGenerator.prototype._noise3d = function (x, y, z) {\r\n            var intX = Math.floor(x) & 0xFF;\r\n            var intY = Math.floor(y) & 0xFF;\r\n            var intZ = Math.floor(z) & 0xFF;\r\n            x -= Math.floor(x);\r\n            y -= Math.floor(y);\r\n            z -= Math.floor(z);\r\n            var fadeX = _fade(x);\r\n            var fadeY = _fade(y);\r\n            var fadeZ = _fade(z);\r\n            var a = this._p[intX] + intY;\r\n            var b = this._p[intX + 1] + intY;\r\n            var aa = this._p[a] + intZ;\r\n            var ba = this._p[b] + intZ;\r\n            var ab = this._p[a + 1] + intZ;\r\n            var bb = this._p[b + 1] + intZ;\r\n            return (_lerp(fadeZ, _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa], x, y, z), this._gradient3d(this._p[ba], x - 1, y, z)), _lerp(fadeX, this._gradient3d(this._p[ab], x, y - 1, z), this._gradient3d(this._p[bb], x - 1, y - 1, z))), _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa + 1], x, y, z - 1), this._gradient3d(this._p[ba + 1], x - 1, y, z - 1)), _lerp(fadeX, this._gradient3d(this._p[ab + 1], x, y - 1, z - 1), this._gradient3d(this._p[bb + 1], x - 1, y - 1, z - 1)))) + 1) / 2;\r\n        };\r\n        return PerlinGenerator;\r\n    }());\r\n    exports.PerlinGenerator = PerlinGenerator;\r\n    /**\r\n     * A helper to draw 2D perlin maps given a perlin generator and a function\r\n     */\r\n    var PerlinDrawer2D = (function () {\r\n        /**\r\n         * @param generator - An existing perlin generator\r\n         * @param colorFcn - A color function that takes a value between [0, 255] derived from the perlin generator, and returns a color\r\n         */\r\n        function PerlinDrawer2D(generator, colorFcn) {\r\n            this.generator = generator;\r\n            this.colorFcn = colorFcn;\r\n            if (!colorFcn) {\r\n                this.colorFcn = function (val) { return val < 125 ? Color_18.Color.Black : Color_18.Color.White; };\r\n            }\r\n        }\r\n        /**\r\n         * Returns an image of 2D perlin noise\r\n         */\r\n        PerlinDrawer2D.prototype.image = function (width, height) {\r\n            var image = document.createElement(\'img\');\r\n            var canvas = document.createElement(\'canvas\');\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            var ctx = canvas.getContext(\'2d\');\r\n            this.draw(ctx, 0, 0, width, height);\r\n            image.src = canvas.toDataURL();\r\n            return image;\r\n        };\r\n        /**\r\n         * This draws a 2D perlin grid on a canvas context, not recommended to be called every frame due to performance\r\n         */\r\n        PerlinDrawer2D.prototype.draw = function (ctx, x, y, width, height) {\r\n            var grid = this.generator.grid(width, height);\r\n            var imageData = ctx.getImageData(x, y, width, height);\r\n            for (var j = 0; j < height; j++) {\r\n                for (var i = 0; i < width; i++) {\r\n                    var val = grid[i + width * j];\r\n                    var c = Math.floor(val * 255) & 0xff;\r\n                    var pixel = (i + j * imageData.width) * 4;\r\n                    var color = this.colorFcn(c);\r\n                    imageData.data[pixel] = color.r;\r\n                    imageData.data[pixel + 1] = color.g;\r\n                    imageData.data[pixel + 2] = color.b;\r\n                    imageData.data[pixel + 3] = Math.floor(color.a * 255);\r\n                }\r\n            }\r\n            ctx.putImageData(imageData, x, y);\r\n        };\r\n        return PerlinDrawer2D;\r\n    }());\r\n    exports.PerlinDrawer2D = PerlinDrawer2D;\r\n});\r\ndefine("Math/Index", ["require", "exports", "Math/PerlinNoise", "Math/Random"], function (require, exports, PerlinNoise_1, Random_2) {\r\n    "use strict";\r\n    function __export(m) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    __export(PerlinNoise_1);\r\n    __export(Random_2);\r\n});\r\ndefine("PostProcessing/IPostProcessor", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\ndefine("PostProcessing/ColorBlindCorrector", ["require", "exports", "Util/Log"], function (require, exports, Log_11) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var ColorBlindness;\r\n    (function (ColorBlindness) {\r\n        ColorBlindness[ColorBlindness["Protanope"] = 0] = "Protanope";\r\n        ColorBlindness[ColorBlindness["Deuteranope"] = 1] = "Deuteranope";\r\n        ColorBlindness[ColorBlindness["Tritanope"] = 2] = "Tritanope";\r\n    })(ColorBlindness = exports.ColorBlindness || (exports.ColorBlindness = {}));\r\n    /**\r\n     * This post processor can correct colors and simulate color blindness.\r\n     * It is possible to use this on every game, but the game\'s performance\r\n     * will suffer measurably. It\'s better to use it as a helpful tool while developing your game.\r\n     * Remember, the best practice is to design with color blindness in mind.\r\n     *\r\n     * [[include:ColorBlind.md]]\r\n     */\r\n    var ColorBlindCorrector = (function () {\r\n        function ColorBlindCorrector(engine, simulate, colorMode) {\r\n            if (simulate === void 0) { simulate = false; }\r\n            if (colorMode === void 0) { colorMode = ColorBlindness.Protanope; }\r\n            this.engine = engine;\r\n            this.simulate = simulate;\r\n            this.colorMode = colorMode;\r\n            this._vertexShader = \'attribute vec2 a_position;\' +\r\n                \'attribute vec2 a_texCoord;\' +\r\n                \'uniform vec2 u_resolution;\' +\r\n                \'varying vec2 v_texCoord;\' +\r\n                \'void main() {\' +\r\n                // convert the rectangle from pixels to 0.0 to 1.0\r\n                \'vec2 zeroToOne = a_position / u_resolution;\' +\r\n                // convert from 0->1 to 0->2\r\n                \'vec2 zeroToTwo = zeroToOne * 2.0;\' +\r\n                // convert from 0->2 to -1->+1 (clipspace)\r\n                \'vec2 clipSpace = zeroToTwo - 1.0;\' +\r\n                \'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\' +\r\n                // pass the texCoord to the fragment shader\r\n                // The GPU will interpolate this value between points.\r\n                \'v_texCoord = a_texCoord;\' +\r\n                \'}\';\r\n            this._fragmentShader = \'precision mediump float;\' +\r\n                // our texture\r\n                \'uniform sampler2D u_image;\' +\r\n                // the texCoords passed in from the vertex shader.\r\n                \'varying vec2 v_texCoord;\' +\r\n                // Color blind conversions\r\n                /*\'mat3 m[9] =\' +\r\n                \'{\' +\r\n                   \'mat3(1.0, 0.0, 0.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0  ),\' + // normal\r\n                   \'mat3(0.567, 0.433, 0.0,  0.558, 0.442, 0.0,  0.0, 0.242, 0.758),\' + // protanopia\r\n                   \'mat3(0.817, 0.183, 0.0,  0.333, 0.667, 0.0,  0.0, 0.125,0.875),\' + // protanomaly\r\n                   \'mat3(0.625, 0.375, 0.0,  0.7, 0.3, 0.0,  0.0, 0.3,0.7  ),\' + // deuteranopia\r\n                   \'mat3(0.8, 0.2, 0.0,  0.258, 0.742, 0.0,  0.0, 0.142,0.858),\' + // deuteranomaly\r\n                   \'mat3(0.95, 0.05, 0.0,  0.0, 0.433, 0.567,  0.0, 0.475,0.525),\' + // tritanopia\r\n                   \'mat3(0.967, 0.033, 0.0,  0.0, 0.733, 0.267,  0.0, 0.183,0.817),\' + // tritanomaly\r\n                   \'mat3(0.299, 0.587, 0.114,  0.299, 0.587, 0.114,  0.299, 0.587,0.114),\' + // achromatopsia\r\n                   \'mat3(0.618, 0.320, 0.062,  0.163, 0.775, 0.062,  0.163, 0.320,0.516)\' +  // achromatomaly\r\n                \'};\' +*/\r\n                \'void main() {\' +\r\n                \'vec4 o =  texture2D(u_image, v_texCoord);\' +\r\n                // RGB to LMS matrix conversion\r\n                \'float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);\' +\r\n                \'float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);\' +\r\n                \'float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);\' +\r\n                // Simulate color blindness\r\n                \'//MODE CODE//\' +\r\n                /* Deuteranope for testing\r\n                \'float l = 1.0 * L + 0.0 * M + 0.0 * S;\' +\r\n                      \'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;\' +\r\n                      \'float s = 0.0 * L + 0.0 * M + 1.0 * S;\' +*/\r\n                // LMS to RGB matrix conversion\r\n                \'vec4 error;\' +\r\n                \'error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);\' +\r\n                \'error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);\' +\r\n                \'error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);\' +\r\n                \'error.a = 1.0;\' +\r\n                \'vec4 diff = o - error;\' +\r\n                \'vec4 correction;\' +\r\n                \'correction.r = 0.0;\' +\r\n                \'correction.g =  (diff.r * 0.7) + (diff.g * 1.0);\' +\r\n                \'correction.b =  (diff.r * 0.7) + (diff.b * 1.0);\' +\r\n                \'correction = o + correction;\' +\r\n                \'correction.a = o.a;\' +\r\n                \'//SIMULATE//\' +\r\n                \'}\';\r\n            this._internalCanvas = document.createElement(\'canvas\');\r\n            this._internalCanvas.width = engine.drawWidth;\r\n            this._internalCanvas.height = engine.drawHeight;\r\n            this._gl = this._internalCanvas.getContext(\'webgl\', { preserveDrawingBuffer: true });\r\n            this._program = this._gl.createProgram();\r\n            var fragmentShader = this._getShader(\'Fragment\', this._getFragmentShaderByMode(colorMode));\r\n            var vertextShader = this._getShader(\'Vertex\', this._vertexShader);\r\n            this._gl.attachShader(this._program, vertextShader);\r\n            this._gl.attachShader(this._program, fragmentShader);\r\n            this._gl.linkProgram(this._program);\r\n            if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {\r\n                Log_11.Logger.getInstance().error(\'Unable to link shader program!\');\r\n            }\r\n            this._gl.useProgram(this._program);\r\n        }\r\n        ColorBlindCorrector.prototype._getFragmentShaderByMode = function (colorMode) {\r\n            var code = \'\';\r\n            if (colorMode === ColorBlindness.Protanope) {\r\n                code =\r\n                    \'float l = 0.0 * L + 2.02344 * M + -2.52581 * S;\' +\r\n                        \'float m = 0.0 * L + 1.0 * M + 0.0 * S;\' +\r\n                        \'float s = 0.0 * L + 0.0 * M + 1.0 * S;\';\r\n            }\r\n            else if (colorMode === ColorBlindness.Deuteranope) {\r\n                code =\r\n                    \'float l = 1.0 * L + 0.0 * M + 0.0 * S;\' +\r\n                        \'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;\' +\r\n                        \'float s = 0.0 * L + 0.0 * M + 1.0 * S;\';\r\n            }\r\n            else if (colorMode === ColorBlindness.Tritanope) {\r\n                code =\r\n                    \'float l = 1.0 * L + 0.0 * M + 0.0 * S;\' +\r\n                        \'float m = 0.0 * L + 1.0 * M + 0.0 * S;\' +\r\n                        \'float s = -0.395913 * L + 0.801109 * M + 0.0 * S;\';\r\n            }\r\n            if (this.simulate) {\r\n                this._fragmentShader = this._fragmentShader.replace(\'//SIMULATE//\', \'gl_FragColor = error.rgba;\');\r\n            }\r\n            else {\r\n                this._fragmentShader = this._fragmentShader.replace(\'//SIMULATE//\', \'gl_FragColor = correction.rgba;\');\r\n            }\r\n            return this._fragmentShader.replace(\'//MODE CODE//\', code);\r\n        };\r\n        ColorBlindCorrector.prototype._setRectangle = function (x, y, width, height) {\r\n            var x1 = x;\r\n            var x2 = x + width;\r\n            var y1 = y;\r\n            var y2 = y + height;\r\n            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([\r\n                x1, y1,\r\n                x2, y1,\r\n                x1, y2,\r\n                x1, y2,\r\n                x2, y1,\r\n                x2, y2\r\n            ]), this._gl.STATIC_DRAW);\r\n        };\r\n        ColorBlindCorrector.prototype._getShader = function (type, program) {\r\n            var shader;\r\n            if (type === \'Fragment\') {\r\n                shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);\r\n            }\r\n            else if (type === \'Vertex\') {\r\n                shader = this._gl.createShader(this._gl.VERTEX_SHADER);\r\n            }\r\n            else {\r\n                Log_11.Logger.getInstance().error(\'Error unknown shader type\', type);\r\n            }\r\n            this._gl.shaderSource(shader, program);\r\n            this._gl.compileShader(shader);\r\n            if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {\r\n                Log_11.Logger.getInstance().error(\'Unable to compile shader!\', this._gl.getShaderInfoLog(shader));\r\n                return null;\r\n            }\r\n            return shader;\r\n        };\r\n        ColorBlindCorrector.prototype.process = function (image, out) {\r\n            // look up where the vertex data needs to go.\r\n            var positionLocation = this._gl.getAttribLocation(this._program, \'a_position\');\r\n            var texCoordLocation = this._gl.getAttribLocation(this._program, \'a_texCoord\');\r\n            var texCoordBuffer = this._gl.createBuffer();\r\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, texCoordBuffer);\r\n            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([\r\n                0.0, 0.0,\r\n                1.0, 0.0,\r\n                0.0, 1.0,\r\n                0.0, 1.0,\r\n                1.0, 0.0,\r\n                1.0, 1.0\r\n            ]), this._gl.STATIC_DRAW);\r\n            this._gl.enableVertexAttribArray(texCoordLocation);\r\n            this._gl.vertexAttribPointer(texCoordLocation, 2, this._gl.FLOAT, false, 0, 0);\r\n            // Create a texture.\r\n            var texture = this._gl.createTexture();\r\n            this._gl.bindTexture(this._gl.TEXTURE_2D, texture);\r\n            // Set the parameters so we can render any size image.\r\n            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\r\n            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\r\n            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);\r\n            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);\r\n            // Flip the texture when unpacking into the gl context, gl reads textures in the opposite order as everything else :/\r\n            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);\r\n            // Upload the image into the texture.\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);\r\n            // lookup uniforms\r\n            var resolutionLocation = this._gl.getUniformLocation(this._program, \'u_resolution\');\r\n            // set the resolution\r\n            this._gl.uniform2f(resolutionLocation, this._internalCanvas.width, this._internalCanvas.height);\r\n            // Create a buffer for the position of the rectangle corners.\r\n            var positionBuffer = this._gl.createBuffer();\r\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, positionBuffer);\r\n            this._gl.enableVertexAttribArray(positionLocation);\r\n            this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);\r\n            // Set a rectangle the same size as the image.\r\n            this._setRectangle(0, 0, image.width, image.height);\r\n            // Draw the rectangle.\r\n            this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);\r\n            // Grab tranformed image from internal canvas\r\n            var pixelData = new Uint8Array(image.width * image.height * 4);\r\n            this._gl.readPixels(0, 0, image.width, image.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixelData);\r\n            image.data.set(pixelData);\r\n            out.putImageData(image, 0, 0);\r\n        };\r\n        return ColorBlindCorrector;\r\n    }());\r\n    exports.ColorBlindCorrector = ColorBlindCorrector;\r\n});\r\ndefine("PostProcessing/Index", ["require", "exports", "PostProcessing/ColorBlindCorrector"], function (require, exports, ColorBlindCorrector_1) {\r\n    "use strict";\r\n    function __export(m) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    __export(ColorBlindCorrector_1);\r\n});\r\ndefine("Resources/Index", ["require", "exports", "Resources/Resource", "Resources/Sound", "Resources/Texture"], function (require, exports, Resource_2, Sound_2, Texture_1) {\r\n    "use strict";\r\n    function __export(m) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    __export(Resource_2);\r\n    __export(Sound_2);\r\n    __export(Texture_1);\r\n});\r\ndefine("Input/Gamepad", ["require", "exports", "Class", "Events"], function (require, exports, Class_5, Events_8) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)\r\n     * to provide controller support for your games.\r\n     *\r\n     * [[include:Gamepads.md]]\r\n     */\r\n    var Gamepads = (function (_super) {\r\n        __extends(Gamepads, _super);\r\n        function Gamepads(engine) {\r\n            var _this = _super.call(this) || this;\r\n            /**\r\n             * Whether or not to poll for Gamepad input (default: `false`)\r\n             */\r\n            _this.enabled = false;\r\n            /**\r\n             * Whether or not Gamepad API is supported\r\n             */\r\n            _this.supported = !!navigator.getGamepads;\r\n            _this._gamePadTimeStamps = [0, 0, 0, 0];\r\n            _this._oldPads = [];\r\n            _this._pads = [];\r\n            _this._initSuccess = false;\r\n            _this._navigator = navigator;\r\n            _this._minimumConfiguration = null;\r\n            _this._engine = engine;\r\n            return _this;\r\n        }\r\n        Gamepads.prototype.init = function () {\r\n            if (!this.supported) {\r\n                return;\r\n            }\r\n            if (this._initSuccess) {\r\n                return;\r\n            }\r\n            // In Chrome, this will return 4 undefined items until a button is pressed\r\n            // In FF, this will not return any items until a button is pressed\r\n            this._oldPads = this._clonePads(this._navigator.getGamepads());\r\n            if (this._oldPads.length && this._oldPads[0]) {\r\n                this._initSuccess = true;\r\n            }\r\n        };\r\n        /**\r\n         * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means\r\n         * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive\r\n         * all other controllers with more axis or buttons are valid as well. If no minimum\r\n         * configuration is set all pads are valid.\r\n         */\r\n        Gamepads.prototype.setMinimumGamepadConfiguration = function (config) {\r\n            this._enableAndUpdate(); // if config is used, implicitly enable\r\n            this._minimumConfiguration = config;\r\n        };\r\n        /**\r\n         * When implicitly enabled, set the enabled flag and run an update so information is updated\r\n         */\r\n        Gamepads.prototype._enableAndUpdate = function () {\r\n            if (!this.enabled) {\r\n                this.enabled = true;\r\n                this.update();\r\n            }\r\n        };\r\n        /**\r\n         * Checks a navigator gamepad against the minimum configuration if present.\r\n         */\r\n        Gamepads.prototype._isGamepadValid = function (pad) {\r\n            if (!this._minimumConfiguration) {\r\n                return true;\r\n            }\r\n            ;\r\n            if (!pad) {\r\n                return false;\r\n            }\r\n            ;\r\n            var axesLength = pad.axes.filter(function (value) {\r\n                return (typeof value !== undefined);\r\n            }).length;\r\n            var buttonLength = pad.buttons.filter(function (value) {\r\n                return (typeof value !== undefined);\r\n            }).length;\r\n            return axesLength >= this._minimumConfiguration.axis &&\r\n                buttonLength >= this._minimumConfiguration.buttons &&\r\n                pad.connected;\r\n        };\r\n        Gamepads.prototype.on = function (eventName, handler) {\r\n            this._enableAndUpdate(); // implicitly enable\r\n            _super.prototype.on.call(this, eventName, handler);\r\n        };\r\n        Gamepads.prototype.off = function (eventName, handler) {\r\n            this._enableAndUpdate(); // implicitly enable\r\n            _super.prototype.off.call(this, eventName, handler);\r\n        };\r\n        /**\r\n         * Updates Gamepad state and publishes Gamepad events\r\n         */\r\n        Gamepads.prototype.update = function () {\r\n            if (!this.enabled || !this.supported) {\r\n                return;\r\n            }\r\n            this.init();\r\n            var gamepads = this._navigator.getGamepads();\r\n            for (var i = 0; i < gamepads.length; i++) {\r\n                if (!gamepads[i]) {\r\n                    var gamepad = this.at(i);\r\n                    // If was connected, but now isn\'t emit the disconnect event\r\n                    if (gamepad.connected) {\r\n                        this.eventDispatcher.emit(\'disconnect\', new Events_8.GamepadDisconnectEvent(i, gamepad));\r\n                    }\r\n                    // Reset connection status\r\n                    gamepad.connected = false;\r\n                    continue;\r\n                }\r\n                else {\r\n                    if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {\r\n                        this.eventDispatcher.emit(\'connect\', new Events_8.GamepadConnectEvent(i, this.at(i)));\r\n                    }\r\n                    // Set connection status\r\n                    this.at(i).connected = true;\r\n                }\r\n                ;\r\n                // Only supported in Chrome\r\n                if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {\r\n                    continue;\r\n                }\r\n                this._gamePadTimeStamps[i] = gamepads[i].timestamp;\r\n                // Add reference to navigator gamepad\r\n                this.at(i).navigatorGamepad = gamepads[i];\r\n                // Buttons\r\n                var b, bi, a, ai, value;\r\n                for (b in Buttons) {\r\n                    bi = Buttons[b];\r\n                    if (typeof bi === \'number\') {\r\n                        if (gamepads[i].buttons[bi]) {\r\n                            value = gamepads[i].buttons[bi].value;\r\n                            if (value !== this._oldPads[i].getButton(bi)) {\r\n                                if (gamepads[i].buttons[bi].pressed) {\r\n                                    this.at(i).updateButton(bi, value);\r\n                                    this.at(i).eventDispatcher.emit(\'button\', new Events_8.GamepadButtonEvent(bi, value, this.at(i)));\r\n                                }\r\n                                else {\r\n                                    this.at(i).updateButton(bi, 0);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // Axes\r\n                for (a in Axes) {\r\n                    ai = Axes[a];\r\n                    if (typeof ai === \'number\') {\r\n                        value = gamepads[i].axes[ai];\r\n                        if (value !== this._oldPads[i].getAxes(ai)) {\r\n                            this.at(i).updateAxes(ai, value);\r\n                            this.at(i).eventDispatcher.emit(\'axis\', new Events_8.GamepadAxisEvent(ai, value, this.at(i)));\r\n                        }\r\n                    }\r\n                }\r\n                this._oldPads[i] = this._clonePad(gamepads[i]);\r\n            }\r\n        };\r\n        /**\r\n         * Safely retrieves a Gamepad at a specific index and creates one if it doesn\'t yet exist\r\n         */\r\n        Gamepads.prototype.at = function (index) {\r\n            this._enableAndUpdate(); // implicitly enable gamepads when at() is called         \r\n            if (index >= this._pads.length) {\r\n                // Ensure there is a pad to retrieve\r\n                for (var i = this._pads.length - 1, max = index; i < max; i++) {\r\n                    this._pads.push(new Gamepad());\r\n                    this._oldPads.push(new Gamepad());\r\n                }\r\n            }\r\n            return this._pads[index];\r\n        };\r\n        /**\r\n         * Returns a list of all valid gamepads that meet the minimum configuration requirement.\r\n         */\r\n        Gamepads.prototype.getValidGamepads = function () {\r\n            this._enableAndUpdate();\r\n            var result = [];\r\n            for (var i = 0; i < this._pads.length; i++) {\r\n                if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {\r\n                    result.push(this.at(i));\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        /**\r\n         * Gets the number of connected gamepads\r\n         */\r\n        Gamepads.prototype.count = function () {\r\n            return this._pads.filter(function (p) { return p.connected; }).length;\r\n        };\r\n        Gamepads.prototype._clonePads = function (pads) {\r\n            var arr = [];\r\n            for (var i = 0, len = pads.length; i < len; i++) {\r\n                arr.push(this._clonePad(pads[i]));\r\n            }\r\n            return arr;\r\n        };\r\n        /**\r\n         * Fastest way to clone a known object is to do it yourself\r\n         */\r\n        Gamepads.prototype._clonePad = function (pad) {\r\n            var i, len;\r\n            var clonedPad = new Gamepad();\r\n            if (!pad) {\r\n                return clonedPad;\r\n            }\r\n            for (i = 0, len = pad.buttons.length; i < len; i++) {\r\n                if (pad.buttons[i]) {\r\n                    clonedPad.updateButton(i, pad.buttons[i].value);\r\n                }\r\n            }\r\n            for (i = 0, len = pad.axes.length; i < len; i++) {\r\n                clonedPad.updateAxes(i, pad.axes[i]);\r\n            }\r\n            return clonedPad;\r\n        };\r\n        return Gamepads;\r\n    }(Class_5.Class));\r\n    /**\r\n     * The minimum value an axis has to move before considering it a change\r\n     */\r\n    Gamepads.MinAxisMoveThreshold = 0.05;\r\n    exports.Gamepads = Gamepads;\r\n    /**\r\n     * Gamepad holds state information for a connected controller. See [[Gamepads]]\r\n     * for more information on handling controller input.\r\n     */\r\n    var Gamepad = (function (_super) {\r\n        __extends(Gamepad, _super);\r\n        function Gamepad() {\r\n            var _this = _super.call(this) || this;\r\n            _this.connected = false;\r\n            _this._buttons = new Array(16);\r\n            _this._axes = new Array(4);\r\n            var i;\r\n            for (i = 0; i < _this._buttons.length; i++) {\r\n                _this._buttons[i] = 0;\r\n            }\r\n            for (i = 0; i < _this._axes.length; i++) {\r\n                _this._axes[i] = 0;\r\n            }\r\n            return _this;\r\n        }\r\n        /**\r\n         * Whether or not the given button is pressed\r\n         * @param button     The button to query\r\n         * @param threshold  The threshold over which the button is considered to be pressed\r\n         */\r\n        Gamepad.prototype.isButtonPressed = function (button, threshold) {\r\n            if (threshold === void 0) { threshold = 1; }\r\n            return this._buttons[button] >= threshold;\r\n        };\r\n        /**\r\n         * Gets the given button value between 0 and 1\r\n         */\r\n        Gamepad.prototype.getButton = function (button) {\r\n            return this._buttons[button];\r\n        };\r\n        /**\r\n         * Gets the given axis value between -1 and 1. Values below\r\n         * [[MinAxisMoveThreshold]] are considered 0.\r\n         */\r\n        Gamepad.prototype.getAxes = function (axes) {\r\n            var value = this._axes[axes];\r\n            if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return value;\r\n            }\r\n        };\r\n        Gamepad.prototype.updateButton = function (buttonIndex, value) {\r\n            this._buttons[buttonIndex] = value;\r\n        };\r\n        Gamepad.prototype.updateAxes = function (axesIndex, value) {\r\n            this._axes[axesIndex] = value;\r\n        };\r\n        return Gamepad;\r\n    }(Class_5.Class));\r\n    exports.Gamepad = Gamepad;\r\n    /**\r\n     * Gamepad Buttons enumeration\r\n     */\r\n    var Buttons;\r\n    (function (Buttons) {\r\n        /**\r\n         * Face 1 button (e.g. A)\r\n         */\r\n        Buttons[Buttons["Face1"] = 0] = "Face1";\r\n        /**\r\n         * Face 2 button (e.g. B)\r\n         */\r\n        Buttons[Buttons["Face2"] = 1] = "Face2";\r\n        /**\r\n         * Face 3 button (e.g. X)\r\n         */\r\n        Buttons[Buttons["Face3"] = 2] = "Face3";\r\n        /**\r\n         * Face 4 button (e.g. Y)\r\n         */\r\n        Buttons[Buttons["Face4"] = 3] = "Face4";\r\n        /**\r\n         * Left bumper button\r\n         */\r\n        Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";\r\n        /**\r\n         * Right bumper button\r\n         */\r\n        Buttons[Buttons["RightBumper"] = 5] = "RightBumper";\r\n        /**\r\n         * Left trigger button\r\n         */\r\n        Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";\r\n        /**\r\n         * Right trigger button\r\n         */\r\n        Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";\r\n        /**\r\n         * Select button\r\n         */\r\n        Buttons[Buttons["Select"] = 8] = "Select";\r\n        /**\r\n         * Start button\r\n         */\r\n        Buttons[Buttons["Start"] = 9] = "Start";\r\n        /**\r\n         * Left analog stick press (e.g. L3)\r\n         */\r\n        Buttons[Buttons["LeftStick"] = 10] = "LeftStick";\r\n        /**\r\n         * Right analog stick press (e.g. R3)\r\n         */\r\n        Buttons[Buttons["RightStick"] = 11] = "RightStick";\r\n        /**\r\n         * D-pad up\r\n         */\r\n        Buttons[Buttons["DpadUp"] = 12] = "DpadUp";\r\n        /**\r\n         * D-pad down\r\n         */\r\n        Buttons[Buttons["DpadDown"] = 13] = "DpadDown";\r\n        /**\r\n         * D-pad left\r\n         */\r\n        Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";\r\n        /**\r\n         * D-pad right\r\n         */\r\n        Buttons[Buttons["DpadRight"] = 15] = "DpadRight";\r\n    })(Buttons = exports.Buttons || (exports.Buttons = {}));\r\n    /**\r\n     * Gamepad Axes enumeration\r\n     */\r\n    var Axes;\r\n    (function (Axes) {\r\n        /**\r\n         * Left analogue stick X direction\r\n         */\r\n        Axes[Axes["LeftStickX"] = 0] = "LeftStickX";\r\n        /**\r\n         * Left analogue stick Y direction\r\n         */\r\n        Axes[Axes["LeftStickY"] = 1] = "LeftStickY";\r\n        /**\r\n         * Right analogue stick X direction\r\n         */\r\n        Axes[Axes["RightStickX"] = 2] = "RightStickX";\r\n        /**\r\n         * Right analogue stick Y direction\r\n         */\r\n        Axes[Axes["RightStickY"] = 3] = "RightStickY";\r\n    })(Axes = exports.Axes || (exports.Axes = {}));\r\n});\r\ndefine("Input/Pointer", ["require", "exports", "Engine", "Events", "UIActor", "Algebra", "Class", "Util/Util"], function (require, exports, Engine_1, Events_9, UIActor_1, Algebra_20, Class_6, Util) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * The type of pointer for a [[PointerEvent]].\r\n     */\r\n    var PointerType;\r\n    (function (PointerType) {\r\n        PointerType[PointerType["Touch"] = 0] = "Touch";\r\n        PointerType[PointerType["Mouse"] = 1] = "Mouse";\r\n        PointerType[PointerType["Pen"] = 2] = "Pen";\r\n        PointerType[PointerType["Unknown"] = 3] = "Unknown";\r\n    })(PointerType = exports.PointerType || (exports.PointerType = {}));\r\n    /**\r\n     * The mouse button being pressed.\r\n     */\r\n    var PointerButton;\r\n    (function (PointerButton) {\r\n        PointerButton[PointerButton["Left"] = 0] = "Left";\r\n        PointerButton[PointerButton["Middle"] = 1] = "Middle";\r\n        PointerButton[PointerButton["Right"] = 2] = "Right";\r\n        PointerButton[PointerButton["Unknown"] = 3] = "Unknown";\r\n    })(PointerButton = exports.PointerButton || (exports.PointerButton = {}));\r\n    var WheelDeltaMode;\r\n    (function (WheelDeltaMode) {\r\n        WheelDeltaMode[WheelDeltaMode["Pixel"] = 0] = "Pixel";\r\n        WheelDeltaMode[WheelDeltaMode["Line"] = 1] = "Line";\r\n        WheelDeltaMode[WheelDeltaMode["Page"] = 2] = "Page";\r\n    })(WheelDeltaMode = exports.WheelDeltaMode || (exports.WheelDeltaMode = {}));\r\n    /**\r\n     * Determines the scope of handling mouse/touch events. See [[Pointers]] for more information.\r\n     */\r\n    var PointerScope;\r\n    (function (PointerScope) {\r\n        /**\r\n         * Handle events on the `canvas` element only. Events originating outside the\r\n         * `canvas` will not be handled.\r\n         */\r\n        PointerScope[PointerScope["Canvas"] = 0] = "Canvas";\r\n        /**\r\n         * Handles events on the entire document. All events will be handled by Excalibur.\r\n         */\r\n        PointerScope[PointerScope["Document"] = 1] = "Document";\r\n    })(PointerScope = exports.PointerScope || (exports.PointerScope = {}));\r\n    /**\r\n     * A constant used to normalize wheel events across different browsers\r\n     *\r\n     * This normalization factor is pulled from https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser\r\n     */\r\n    var ScrollWheelNormalizationFactor = -1 / 40;\r\n    /**\r\n     * Pointer events\r\n     *\r\n     * Represents a mouse, touch, or stylus event. See [[Pointers]] for more information on\r\n     * handling pointer input.\r\n     *\r\n     * For mouse-based events, you can inspect [[PointerEvent.button]] to see what button was pressed.\r\n     */\r\n    var PointerEvent = (function (_super) {\r\n        __extends(PointerEvent, _super);\r\n        /**\r\n         * @param pageX        The `x` coordinate of the event (in document coordinates)\r\n         * @param pageY        The `y` coordinate of the event (in document coordinates)\r\n         * @param screenX      The `x` coordinate of the event (in screen coordinates)\r\n         * @param screenY      The `y` coordinate of the event (in screen coordinates)\r\n         * @param index        The index of the pointer (zero-based)\r\n         * @param pointerType  The type of pointer\r\n         * @param button       The button pressed (if [[PointerType.Mouse]])\r\n         * @param ev           The raw DOM event being handled\r\n         * @param pos          (Will be added to signature in 0.14.0 release) The position of the event (in world coordinates)\r\n         */\r\n        function PointerEvent(x, y, pageX, pageY, screenX, screenY, index, pointerType, button, ev) {\r\n            var _this = _super.call(this) || this;\r\n            _this.x = x;\r\n            _this.y = y;\r\n            _this.pageX = pageX;\r\n            _this.pageY = pageY;\r\n            _this.screenX = screenX;\r\n            _this.screenY = screenY;\r\n            _this.index = index;\r\n            _this.pointerType = pointerType;\r\n            _this.button = button;\r\n            _this.ev = ev;\r\n            return _this;\r\n        }\r\n        Object.defineProperty(PointerEvent.prototype, "pos", {\r\n            get: function () {\r\n                return new Algebra_20.Vector(this.x, this.y);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return PointerEvent;\r\n    }(Events_9.GameEvent));\r\n    exports.PointerEvent = PointerEvent;\r\n    ;\r\n    /**\r\n     * Wheel Events\r\n     *\r\n     * Represents a mouse wheel event. See [[Pointers]] for more information on\r\n     * handling point input.\r\n     */\r\n    var WheelEvent = (function (_super) {\r\n        __extends(WheelEvent, _super);\r\n        /**\r\n         * @param x            The `x` coordinate of the event (in world coordinates)\r\n         * @param y            The `y` coordinate of the event (in world coordinates)\r\n         * @param pageX        The `x` coordinate of the event (in document coordinates)\r\n         * @param pageY        The `y` coordinate of the event (in document coordinates)\r\n         * @param screenX      The `x` coordinate of the event (in screen coordinates)\r\n         * @param screenY      The `y` coordinate of the event (in screen coordinates)\r\n         * @param index        The index of the pointer (zero-based)\r\n         * @param deltaX       The type of pointer\r\n         * @param deltaY       The type of pointer\r\n         * @param deltaZ       The type of pointer\r\n         * @param deltaMode    The type of movement [[WheelDeltaMode]]\r\n         * @param ev           The raw DOM event being handled\r\n         */\r\n        function WheelEvent(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {\r\n            var _this = _super.call(this) || this;\r\n            _this.x = x;\r\n            _this.y = y;\r\n            _this.pageX = pageX;\r\n            _this.pageY = pageY;\r\n            _this.screenX = screenX;\r\n            _this.screenY = screenY;\r\n            _this.index = index;\r\n            _this.deltaX = deltaX;\r\n            _this.deltaY = deltaY;\r\n            _this.deltaZ = deltaZ;\r\n            _this.deltaMode = deltaMode;\r\n            _this.ev = ev;\r\n            return _this;\r\n        }\r\n        return WheelEvent;\r\n    }(Events_9.GameEvent));\r\n    exports.WheelEvent = WheelEvent;\r\n    ;\r\n    /**\r\n     * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to\r\n     * [W3C Pointer Events](http://www.w3.org/TR/pointerevents/).\r\n     *\r\n     * [[include:Pointers.md]]\r\n     */\r\n    var Pointers = (function (_super) {\r\n        __extends(Pointers, _super);\r\n        function Pointers(engine) {\r\n            var _this = _super.call(this) || this;\r\n            _this._pointerDown = [];\r\n            _this._pointerUp = [];\r\n            _this._pointerMove = [];\r\n            _this._pointerCancel = [];\r\n            _this._wheel = [];\r\n            _this._pointers = [];\r\n            _this._activePointers = [];\r\n            _this._engine = engine;\r\n            _this._pointers.push(new Pointer());\r\n            _this._activePointers = [-1];\r\n            _this.primary = _this._pointers[0];\r\n            return _this;\r\n        }\r\n        Pointers.prototype.on = function (eventName, handler) {\r\n            _super.prototype.on.call(this, eventName, handler);\r\n        };\r\n        /**\r\n         * Initializes pointer event listeners\r\n         */\r\n        Pointers.prototype.init = function (target) {\r\n            target = target || this._engine.canvas;\r\n            // Touch Events\r\n            target.addEventListener(\'touchstart\', this._handleTouchEvent(\'down\', this._pointerDown));\r\n            target.addEventListener(\'touchend\', this._handleTouchEvent(\'up\', this._pointerUp));\r\n            target.addEventListener(\'touchmove\', this._handleTouchEvent(\'move\', this._pointerMove));\r\n            target.addEventListener(\'touchcancel\', this._handleTouchEvent(\'cancel\', this._pointerCancel));\r\n            // W3C Pointer Events\r\n            // Current: IE11, IE10\r\n            if (window.PointerEvent) {\r\n                // IE11\r\n                this._engine.canvas.style.touchAction = \'none\';\r\n                target.addEventListener(\'pointerdown\', this._handlePointerEvent(\'down\', this._pointerDown));\r\n                target.addEventListener(\'pointerup\', this._handlePointerEvent(\'up\', this._pointerUp));\r\n                target.addEventListener(\'pointermove\', this._handlePointerEvent(\'move\', this._pointerMove));\r\n                target.addEventListener(\'pointercancel\', this._handlePointerEvent(\'cancel\', this._pointerMove));\r\n            }\r\n            else if (window.MSPointerEvent) {\r\n                // IE10\r\n                this._engine.canvas.style.msTouchAction = \'none\';\r\n                target.addEventListener(\'MSPointerDown\', this._handlePointerEvent(\'down\', this._pointerDown));\r\n                target.addEventListener(\'MSPointerUp\', this._handlePointerEvent(\'up\', this._pointerUp));\r\n                target.addEventListener(\'MSPointerMove\', this._handlePointerEvent(\'move\', this._pointerMove));\r\n                target.addEventListener(\'MSPointerCancel\', this._handlePointerEvent(\'cancel\', this._pointerMove));\r\n            }\r\n            else {\r\n                // Mouse Events\r\n                target.addEventListener(\'mousedown\', this._handleMouseEvent(\'down\', this._pointerDown));\r\n                target.addEventListener(\'mouseup\', this._handleMouseEvent(\'up\', this._pointerUp));\r\n                target.addEventListener(\'mousemove\', this._handleMouseEvent(\'move\', this._pointerMove));\r\n            }\r\n            // MDN MouseWheelEvent\r\n            if (\'onwheel\' in document.createElement(\'div\')) {\r\n                // Modern Browsers\r\n                target.addEventListener(\'wheel\', this._handleWheelEvent(\'wheel\', this._wheel));\r\n            }\r\n            else if (document.onmousewheel !== undefined) {\r\n                // Webkit and IE\r\n                target.addEventListener(\'mousewheel\', this._handleWheelEvent(\'wheel\', this._wheel));\r\n            }\r\n            else {\r\n                // Remaining browser and older Firefox\r\n                target.addEventListener(\'MozMousePixelScroll\', this._handleWheelEvent(\'wheel\', this._wheel));\r\n            }\r\n        };\r\n        Pointers.prototype.update = function () {\r\n            this._pointerUp.length = 0;\r\n            this._pointerDown.length = 0;\r\n            this._pointerMove.length = 0;\r\n            this._pointerCancel.length = 0;\r\n            this._wheel.length = 0;\r\n        };\r\n        /**\r\n         * Safely gets a Pointer at a specific index and initializes one if it doesn\'t yet exist\r\n         * @param index  The pointer index to retrieve\r\n         */\r\n        Pointers.prototype.at = function (index) {\r\n            if (index >= this._pointers.length) {\r\n                // Ensure there is a pointer to retrieve\r\n                for (var i = this._pointers.length - 1, max = index; i < max; i++) {\r\n                    this._pointers.push(new Pointer());\r\n                    this._activePointers.push(-1);\r\n                }\r\n            }\r\n            return this._pointers[index];\r\n        };\r\n        /**\r\n         * Get number of pointers being watched\r\n         */\r\n        Pointers.prototype.count = function () {\r\n            return this._pointers.length;\r\n        };\r\n        /**\r\n         * Propogates events to actor if necessary\r\n         */\r\n        Pointers.prototype.propogate = function (actor) {\r\n            var isUIActor = actor instanceof UIActor_1.UIActor;\r\n            var i = 0, len = this._pointerUp.length;\r\n            for (i; i < len; i++) {\r\n                if (actor.contains(this._pointerUp[i].x, this._pointerUp[i].y, !isUIActor)) {\r\n                    actor.eventDispatcher.emit(\'pointerup\', this._pointerUp[i]);\r\n                }\r\n            }\r\n            i = 0;\r\n            len = this._pointerDown.length;\r\n            for (i; i < len; i++) {\r\n                if (actor.contains(this._pointerDown[i].x, this._pointerDown[i].y, !isUIActor)) {\r\n                    actor.eventDispatcher.emit(\'pointerdown\', this._pointerDown[i]);\r\n                }\r\n            }\r\n            if (actor.capturePointer.captureMoveEvents) {\r\n                i = 0;\r\n                len = this._pointerMove.length;\r\n                for (i; i < len; i++) {\r\n                    if (actor.contains(this._pointerMove[i].x, this._pointerMove[i].y, !isUIActor)) {\r\n                        actor.eventDispatcher.emit(\'pointermove\', this._pointerMove[i]);\r\n                    }\r\n                }\r\n            }\r\n            i = 0;\r\n            len = this._pointerCancel.length;\r\n            for (i; i < len; i++) {\r\n                if (actor.contains(this._pointerCancel[i].x, this._pointerCancel[i].y, !isUIActor)) {\r\n                    actor.eventDispatcher.emit(\'pointercancel\', this._pointerCancel[i]);\r\n                }\r\n            }\r\n            i = 0;\r\n            len = this._wheel.length;\r\n            for (i; i < len; i++) {\r\n                if (actor.contains(this._wheel[i].x, this._wheel[i].y, !isUIActor)) {\r\n                    actor.eventDispatcher.emit(\'pointerwheel\', this._wheel[i]);\r\n                }\r\n            }\r\n        };\r\n        Pointers.prototype._handleMouseEvent = function (eventName, eventArr) {\r\n            var _this = this;\r\n            return function (e) {\r\n                e.preventDefault();\r\n                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;\r\n                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;\r\n                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));\r\n                var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, PointerType.Mouse, e.button, e);\r\n                eventArr.push(pe);\r\n                _this.at(0).eventDispatcher.emit(eventName, pe);\r\n            };\r\n        };\r\n        Pointers.prototype._handleTouchEvent = function (eventName, eventArr) {\r\n            var _this = this;\r\n            return function (e) {\r\n                e.preventDefault();\r\n                for (var i = 0, len = e.changedTouches.length; i < len; i++) {\r\n                    var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.changedTouches[i].identifier) : 0;\r\n                    if (index === -1) {\r\n                        continue;\r\n                    }\r\n                    var x = e.changedTouches[i].pageX - Util.getPosition(_this._engine.canvas).x;\r\n                    var y = e.changedTouches[i].pageY - Util.getPosition(_this._engine.canvas).y;\r\n                    var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));\r\n                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.changedTouches[i].pageX, e.changedTouches[i].pageY, x, y, index, PointerType.Touch, PointerButton.Unknown, e);\r\n                    eventArr.push(pe);\r\n                    _this.at(index).eventDispatcher.emit(eventName, pe);\r\n                    // only with multi-pointer\r\n                    if (_this._pointers.length > 1) {\r\n                        if (eventName === \'up\') {\r\n                            // remove pointer ID from pool when pointer is lifted\r\n                            _this._activePointers[index] = -1;\r\n                        }\r\n                        else if (eventName === \'down\') {\r\n                            // set pointer ID to given index\r\n                            _this._activePointers[index] = e.changedTouches[i].identifier;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        };\r\n        Pointers.prototype._handlePointerEvent = function (eventName, eventArr) {\r\n            var _this = this;\r\n            return function (e) {\r\n                e.preventDefault();\r\n                // get the index for this pointer ID if multi-pointer is asked for\r\n                var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.pointerId) : 0;\r\n                if (index === -1) {\r\n                    return;\r\n                }\r\n                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;\r\n                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;\r\n                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));\r\n                var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, index, _this._stringToPointerType(e.pointerType), e.button, e);\r\n                eventArr.push(pe);\r\n                _this.at(index).eventDispatcher.emit(eventName, pe);\r\n                // only with multi-pointer\r\n                if (_this._pointers.length > 1) {\r\n                    if (eventName === \'up\') {\r\n                        // remove pointer ID from pool when pointer is lifted\r\n                        _this._activePointers[index] = -1;\r\n                    }\r\n                    else if (eventName === \'down\') {\r\n                        // set pointer ID to given index\r\n                        _this._activePointers[index] = e.pointerId;\r\n                    }\r\n                }\r\n            };\r\n        };\r\n        Pointers.prototype._handleWheelEvent = function (eventName, eventArr) {\r\n            var _this = this;\r\n            return function (e) {\r\n                // Should we prevent page scroll because of this event\r\n                if (_this._engine.pageScrollPreventionMode === Engine_1.ScrollPreventionMode.All ||\r\n                    (_this._engine.pageScrollPreventionMode === Engine_1.ScrollPreventionMode.Canvas && e.target === _this._engine.canvas)) {\r\n                    e.preventDefault();\r\n                }\r\n                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;\r\n                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;\r\n                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));\r\n                // deltaX, deltaY, and deltaZ are the standard modern properties\r\n                // wheelDeltaX, wheelDeltaY, are legacy properties in webkit browsers and older IE\r\n                // e.detail is only used in opera\r\n                var deltaX = e.deltaX ||\r\n                    (e.wheelDeltaX * ScrollWheelNormalizationFactor) ||\r\n                    0;\r\n                var deltaY = e.deltaY ||\r\n                    (e.wheelDeltaY * ScrollWheelNormalizationFactor) ||\r\n                    (e.wheelDelta * ScrollWheelNormalizationFactor) ||\r\n                    e.detail ||\r\n                    0;\r\n                var deltaZ = e.deltaZ || 0;\r\n                var deltaMode = WheelDeltaMode.Pixel;\r\n                if (e.deltaMode) {\r\n                    if (e.deltaMode === 1) {\r\n                        deltaMode = WheelDeltaMode.Line;\r\n                    }\r\n                    else if (e.deltaMode === 2) {\r\n                        deltaMode = WheelDeltaMode.Page;\r\n                    }\r\n                }\r\n                var we = new WheelEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, deltaX, deltaY, deltaZ, deltaMode, e);\r\n                eventArr.push(we);\r\n                _this.at(0).eventDispatcher.emit(eventName, we);\r\n            };\r\n        };\r\n        /**\r\n         * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.\r\n         * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx\r\n         */\r\n        Pointers.prototype._getPointerIndex = function (pointerId) {\r\n            var idx;\r\n            if ((idx = this._activePointers.indexOf(pointerId)) > -1) {\r\n                return idx;\r\n            }\r\n            for (var i = 0; i < this._activePointers.length; i++) {\r\n                if (this._activePointers[i] === -1) {\r\n                    return i;\r\n                }\r\n            }\r\n            // ignore pointer because game isn\'t watching\r\n            return -1;\r\n        };\r\n        Pointers.prototype._stringToPointerType = function (s) {\r\n            switch (s) {\r\n                case \'touch\':\r\n                    return PointerType.Touch;\r\n                case \'mouse\':\r\n                    return PointerType.Mouse;\r\n                case \'pen\':\r\n                    return PointerType.Pen;\r\n                default:\r\n                    return PointerType.Unknown;\r\n            }\r\n        };\r\n        return Pointers;\r\n    }(Class_6.Class));\r\n    exports.Pointers = Pointers;\r\n    /**\r\n     * Captures and dispatches PointerEvents\r\n     */\r\n    var Pointer = (function (_super) {\r\n        __extends(Pointer, _super);\r\n        function Pointer() {\r\n            var _this = _super.call(this) || this;\r\n            /**\r\n             * The last position on the document this pointer was at. Can be `null` if pointer was never active.\r\n             */\r\n            _this.lastPagePos = null;\r\n            /**\r\n             * The last position on the screen this pointer was at. Can be `null` if pointer was never active.\r\n             */\r\n            _this.lastScreenPos = null;\r\n            /**\r\n             * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.\r\n             */\r\n            _this.lastWorldPos = null;\r\n            _this.on(\'move\', _this._onPointerMove);\r\n            return _this;\r\n        }\r\n        Pointer.prototype._onPointerMove = function (ev) {\r\n            this.lastWorldPos = new Algebra_20.Vector(ev.x, ev.y);\r\n            this.lastPagePos = new Algebra_20.Vector(ev.pageX, ev.pageY);\r\n            this.lastScreenPos = new Algebra_20.Vector(ev.screenX, ev.screenY);\r\n        };\r\n        return Pointer;\r\n    }(Class_6.Class));\r\n    exports.Pointer = Pointer;\r\n});\r\ndefine("Input/Keyboard", ["require", "exports", "Class", "Events"], function (require, exports, Class_7, Events_10) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Enum representing input key codes\r\n     */\r\n    var Keys;\r\n    (function (Keys) {\r\n        Keys[Keys["Num1"] = 97] = "Num1";\r\n        Keys[Keys["Num2"] = 98] = "Num2";\r\n        Keys[Keys["Num3"] = 99] = "Num3";\r\n        Keys[Keys["Num4"] = 100] = "Num4";\r\n        Keys[Keys["Num5"] = 101] = "Num5";\r\n        Keys[Keys["Num6"] = 102] = "Num6";\r\n        Keys[Keys["Num7"] = 103] = "Num7";\r\n        Keys[Keys["Num8"] = 104] = "Num8";\r\n        Keys[Keys["Num9"] = 105] = "Num9";\r\n        Keys[Keys["Num0"] = 96] = "Num0";\r\n        Keys[Keys["Numlock"] = 144] = "Numlock";\r\n        Keys[Keys["Semicolon"] = 186] = "Semicolon";\r\n        Keys[Keys["A"] = 65] = "A";\r\n        Keys[Keys["B"] = 66] = "B";\r\n        Keys[Keys["C"] = 67] = "C";\r\n        Keys[Keys["D"] = 68] = "D";\r\n        Keys[Keys["E"] = 69] = "E";\r\n        Keys[Keys["F"] = 70] = "F";\r\n        Keys[Keys["G"] = 71] = "G";\r\n        Keys[Keys["H"] = 72] = "H";\r\n        Keys[Keys["I"] = 73] = "I";\r\n        Keys[Keys["J"] = 74] = "J";\r\n        Keys[Keys["K"] = 75] = "K";\r\n        Keys[Keys["L"] = 76] = "L";\r\n        Keys[Keys["M"] = 77] = "M";\r\n        Keys[Keys["N"] = 78] = "N";\r\n        Keys[Keys["O"] = 79] = "O";\r\n        Keys[Keys["P"] = 80] = "P";\r\n        Keys[Keys["Q"] = 81] = "Q";\r\n        Keys[Keys["R"] = 82] = "R";\r\n        Keys[Keys["S"] = 83] = "S";\r\n        Keys[Keys["T"] = 84] = "T";\r\n        Keys[Keys["U"] = 85] = "U";\r\n        Keys[Keys["V"] = 86] = "V";\r\n        Keys[Keys["W"] = 87] = "W";\r\n        Keys[Keys["X"] = 88] = "X";\r\n        Keys[Keys["Y"] = 89] = "Y";\r\n        Keys[Keys["Z"] = 90] = "Z";\r\n        Keys[Keys["Shift"] = 16] = "Shift";\r\n        Keys[Keys["Alt"] = 18] = "Alt";\r\n        Keys[Keys["Up"] = 38] = "Up";\r\n        Keys[Keys["Down"] = 40] = "Down";\r\n        Keys[Keys["Left"] = 37] = "Left";\r\n        Keys[Keys["Right"] = 39] = "Right";\r\n        Keys[Keys["Space"] = 32] = "Space";\r\n        Keys[Keys["Esc"] = 27] = "Esc";\r\n    })(Keys = exports.Keys || (exports.Keys = {}));\r\n    ;\r\n    /**\r\n     * Event thrown on a game object for a key event\r\n     */\r\n    var KeyEvent = (function (_super) {\r\n        __extends(KeyEvent, _super);\r\n        /**\r\n         * @param key  The key responsible for throwing the event\r\n         */\r\n        function KeyEvent(key) {\r\n            var _this = _super.call(this) || this;\r\n            _this.key = key;\r\n            return _this;\r\n        }\r\n        return KeyEvent;\r\n    }(Events_10.GameEvent));\r\n    exports.KeyEvent = KeyEvent;\r\n    /**\r\n     * Provides keyboard support for Excalibur.\r\n     *\r\n     * [[include:Keyboard.md]]\r\n     */\r\n    var Keyboard = (function (_super) {\r\n        __extends(Keyboard, _super);\r\n        function Keyboard(engine) {\r\n            var _this = _super.call(this) || this;\r\n            _this._keys = [];\r\n            _this._keysUp = [];\r\n            _this._keysDown = [];\r\n            _this._engine = engine;\r\n            return _this;\r\n        }\r\n        Keyboard.prototype.on = function (eventName, handler) {\r\n            _super.prototype.on.call(this, eventName, handler);\r\n        };\r\n        /**\r\n         * Initialize Keyboard event listeners\r\n         */\r\n        Keyboard.prototype.init = function (global) {\r\n            var _this = this;\r\n            global = global || window;\r\n            global.addEventListener(\'blur\', function () {\r\n                _this._keys.length = 0; // empties array efficiently\r\n            });\r\n            // key up is on window because canvas cannot have focus\r\n            global.addEventListener(\'keyup\', function (ev) {\r\n                var code = _this._normalizeKeyCode(ev.keyCode);\r\n                var key = _this._keys.indexOf(code);\r\n                _this._keys.splice(key, 1);\r\n                _this._keysUp.push(code);\r\n                var keyEvent = new KeyEvent(code);\r\n                // alias the old api, we may want to deprecate this in the future\r\n                _this.eventDispatcher.emit(\'up\', keyEvent);\r\n                _this.eventDispatcher.emit(\'release\', keyEvent);\r\n            });\r\n            // key down is on window because canvas cannot have focus\r\n            global.addEventListener(\'keydown\', function (ev) {\r\n                var code = _this._normalizeKeyCode(ev.keyCode);\r\n                if (_this._keys.indexOf(code) === -1) {\r\n                    _this._keys.push(code);\r\n                    _this._keysDown.push(code);\r\n                    var keyEvent = new KeyEvent(code);\r\n                    _this.eventDispatcher.emit(\'down\', keyEvent);\r\n                    _this.eventDispatcher.emit(\'press\', keyEvent);\r\n                }\r\n            });\r\n        };\r\n        Keyboard.prototype.update = function () {\r\n            // Reset keysDown and keysUp after update is complete\r\n            this._keysDown.length = 0;\r\n            this._keysUp.length = 0;\r\n            // Emit synthetic "hold" event\r\n            for (var i = 0; i < this._keys.length; i++) {\r\n                this.eventDispatcher.emit(\'hold\', new KeyEvent(this._keys[i]));\r\n            }\r\n        };\r\n        /**\r\n         * Gets list of keys being pressed down\r\n         */\r\n        Keyboard.prototype.getKeys = function () {\r\n            return this._keys;\r\n        };\r\n        /**\r\n         * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.\r\n         * @param key Test whether a key was just pressed\r\n         */\r\n        Keyboard.prototype.wasPressed = function (key) {\r\n            return this._keysDown.indexOf(key) > -1;\r\n        };\r\n        /**\r\n         * Tests if a certain key is held down. This is persisted between frames.\r\n         * @param key  Test whether a key is held down\r\n         */\r\n        Keyboard.prototype.isHeld = function (key) {\r\n            return this._keys.indexOf(key) > -1;\r\n        };\r\n        /**\r\n         * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.\r\n         * @param key  Test whether a key was just released\r\n         */\r\n        Keyboard.prototype.wasReleased = function (key) {\r\n            return this._keysUp.indexOf(key) > -1;\r\n        };\r\n        /**\r\n         * Normalizes some browser event key codes to map to standard Excalibur key codes\r\n         * @param code Event keyCode\r\n         * @see http://unixpapa.com/js/key.html\r\n         */\r\n        Keyboard.prototype._normalizeKeyCode = function (code) {\r\n            switch (code) {\r\n                case 59:\r\n                    return Keys.Semicolon;\r\n                default:\r\n                    return code;\r\n            }\r\n        };\r\n        return Keyboard;\r\n    }(Class_7.Class));\r\n    exports.Keyboard = Keyboard;\r\n});\r\ndefine("Input/IEngineInput", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n});\r\n/**\r\n * Provides support for mice, keyboards, and controllers.\r\n *\r\n * [[include:Input.md]]\r\n */\r\ndefine("Input/Index", ["require", "exports", "Input/Gamepad", "Input/Pointer", "Input/Keyboard"], function (require, exports, Gamepad_1, Pointer_1, Keyboard_1) {\r\n    "use strict";\r\n    function __export(m) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * @typedoc\r\n     */\r\n    __export(Gamepad_1);\r\n    __export(Pointer_1);\r\n    __export(Keyboard_1);\r\n});\r\ndefine("Util/Index", ["require", "exports", "Util/Util", "Util/DrawUtil"], function (require, exports, Util_3, drawUtil) {\r\n    "use strict";\r\n    function __export(m) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    __export(Util_3);\r\n    exports.DrawUtil = drawUtil;\r\n});\r\ndefine("Util/Detector", ["require", "exports", "Util/Log"], function (require, exports, Log_12) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * This is the list of features that will be used to log the supported\r\n     * features to the console when Detector.logBrowserFeatures() is called.\r\n     */\r\n    var REPORTED_FEATURES = {\r\n        webgl: \'WebGL\',\r\n        webaudio: \'WebAudio\',\r\n        gamepadapi: \'Gamepad API\'\r\n    };\r\n    /**\r\n     * Excalibur internal feature detection helper class\r\n     */\r\n    var Detector = (function () {\r\n        function Detector() {\r\n            this._features = null;\r\n            this.failedTests = [];\r\n            // critical browser features required for ex to run\r\n            this._criticalTests = {\r\n                // Test canvas/2d context support\r\n                canvasSupport: function () {\r\n                    var elem = document.createElement(\'canvas\');\r\n                    return !!(elem.getContext && elem.getContext(\'2d\'));\r\n                },\r\n                // Test array buffer support ex uses for downloading binary data\r\n                arrayBufferSupport: function () {\r\n                    var xhr = new XMLHttpRequest();\r\n                    xhr.open(\'GET\', \'/\');\r\n                    try {\r\n                        xhr.responseType = \'arraybuffer\';\r\n                    }\r\n                    catch (e) {\r\n                        return false;\r\n                    }\r\n                    return xhr.responseType === \'arraybuffer\';\r\n                },\r\n                // Test data urls ex uses for sprites\r\n                dataUrlSupport: function () {\r\n                    var canvas = document.createElement(\'canvas\');\r\n                    return canvas.toDataURL(\'image/png\').indexOf(\'data:image/png\') === 0;\r\n                },\r\n                // Test object url support for loading\r\n                objectUrlSupport: function () {\r\n                    return (\'URL\' in window) && (\'revokeObjectURL\' in URL) && (\'createObjectURL\' in URL);\r\n                },\r\n                // RGBA support for colors\r\n                rgbaSupport: function () {\r\n                    var style = document.createElement(\'a\').style;\r\n                    style.cssText = \'background-color:rgba(150,255,150,.5)\';\r\n                    return (\'\' + style.backgroundColor).indexOf(\'rgba\') > -1;\r\n                }\r\n            };\r\n            // warnings excalibur performance will be degraded\r\n            this._warningTest = {\r\n                webAudioSupport: function () {\r\n                    return !!(window.AudioContext ||\r\n                        window.webkitAudioContext ||\r\n                        window.mozAudioContext ||\r\n                        window.msAudioContext ||\r\n                        window.oAudioContext);\r\n                },\r\n                webglSupport: function () {\r\n                    var elem = document.createElement(\'canvas\');\r\n                    return !!(elem.getContext && elem.getContext(\'webgl\'));\r\n                }\r\n            };\r\n            this._features = this._loadBrowserFeatures();\r\n        }\r\n        /**\r\n         * Returns a map of currently supported browser features. This method\r\n         * treats the features as a singleton and will only calculate feature\r\n         * support if it has not previously been done.\r\n         */\r\n        Detector.prototype.getBrowserFeatures = function () {\r\n            if (this._features === null) {\r\n                this._features = this._loadBrowserFeatures();\r\n            }\r\n            return this._features;\r\n        };\r\n        /**\r\n         * Report on non-critical browser support for debugging purposes.\r\n         * Use native browser console colors for visibility.\r\n         */\r\n        Detector.prototype.logBrowserFeatures = function () {\r\n            var msg = \'%cSUPPORTED BROWSER FEATURES\\n==========================%c\\n\';\r\n            var args = [\r\n                \'font-weight: bold; color: navy\',\r\n                \'font-weight: normal; color: inherit\'\r\n            ];\r\n            var supported = this.getBrowserFeatures();\r\n            for (var _i = 0, _a = Object.keys(REPORTED_FEATURES); _i < _a.length; _i++) {\r\n                var feature = _a[_i];\r\n                if (supported[feature]) {\r\n                    msg += \'(%c\\u2713%c)\'; // (✓)\r\n                    args.push(\'font-weight: bold; color: green\');\r\n                    args.push(\'font-weight: normal; color: inherit\');\r\n                }\r\n                else {\r\n                    msg += \'(%c\\u2717%c)\'; // (✗)\r\n                    args.push(\'font-weight: bold; color: red\');\r\n                    args.push(\'font-weight: normal; color: inherit\');\r\n                }\r\n                ;\r\n                msg += \' \' + REPORTED_FEATURES[feature] + \'\\n\';\r\n            }\r\n            args.unshift(msg);\r\n            console.log.apply(console, args);\r\n        };\r\n        /**\r\n         * Executes several IIFE\'s to get a constant reference to supported\r\n         * features within the current execution context.\r\n         */\r\n        Detector.prototype._loadBrowserFeatures = function () {\r\n            var _this = this;\r\n            return {\r\n                // IIFE to check canvas support\r\n                canvas: (function () {\r\n                    return _this._criticalTests.canvasSupport();\r\n                })(),\r\n                // IIFE to check arraybuffer support\r\n                arraybuffer: (function () {\r\n                    return _this._criticalTests.arrayBufferSupport();\r\n                })(),\r\n                // IIFE to check dataurl support\r\n                dataurl: (function () {\r\n                    return _this._criticalTests.dataUrlSupport();\r\n                })(),\r\n                // IIFE to check objecturl support\r\n                objecturl: (function () {\r\n                    return _this._criticalTests.objectUrlSupport();\r\n                })(),\r\n                // IIFE to check rgba support\r\n                rgba: (function () {\r\n                    return _this._criticalTests.rgbaSupport();\r\n                })(),\r\n                // IIFE to check webaudio support\r\n                webaudio: (function () {\r\n                    return _this._warningTest.webAudioSupport();\r\n                })(),\r\n                // IIFE to check webgl support\r\n                webgl: (function () {\r\n                    return _this._warningTest.webglSupport();\r\n                })(),\r\n                // IIFE to check gamepadapi support\r\n                gamepadapi: (function () {\r\n                    return !!navigator.getGamepads;\r\n                })()\r\n            };\r\n        };\r\n        Detector.prototype.test = function () {\r\n            // Critical test will for ex not to run\r\n            var failedCritical = false;\r\n            for (var test in this._criticalTests) {\r\n                if (!this._criticalTests[test].call(this)) {\r\n                    this.failedTests.push(test);\r\n                    Log_12.Logger.getInstance().error(\'Critical browser feature missing, Excalibur requires:\', test);\r\n                    failedCritical = true;\r\n                }\r\n            }\r\n            if (failedCritical) {\r\n                return false;\r\n            }\r\n            // Warning tests do not for ex to return false to compatibility\r\n            for (var warning in this._warningTest) {\r\n                if (!this._warningTest[warning]()) {\r\n                    Log_12.Logger.getInstance().warn(\'Warning browser feature missing, Excalibur will have reduced performance:\', warning);\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        return Detector;\r\n    }());\r\n    exports.Detector = Detector;\r\n});\r\ndefine("Util/SortedList", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * A sorted list implementation. NOTE: this implementation is not self-balancing\r\n     */\r\n    var SortedList = (function () {\r\n        function SortedList(getComparable) {\r\n            this._getComparable = getComparable;\r\n        }\r\n        SortedList.prototype.find = function (element) {\r\n            return this._find(this._root, element);\r\n        };\r\n        SortedList.prototype._find = function (node, element) {\r\n            if (node == null) {\r\n                return false;\r\n            }\r\n            else if (this._getComparable.call(element) === node.getKey()) {\r\n                if (node.getData().indexOf(element) > -1) {\r\n                    return true;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n            else if (this._getComparable.call(element) < node.getKey()) {\r\n                return this._find(node.getLeft(), element);\r\n            }\r\n            else {\r\n                return this._find(node.getRight(), element);\r\n            }\r\n        };\r\n        // returns the array of elements at a specific key value\r\n        SortedList.prototype.get = function (key) {\r\n            return this._get(this._root, key);\r\n        };\r\n        SortedList.prototype._get = function (node, key) {\r\n            if (node == null) {\r\n                return [];\r\n            }\r\n            else if (key === node.getKey()) {\r\n                return node.getData();\r\n            }\r\n            else if (key < node.getKey()) {\r\n                return this._get(node.getLeft(), key);\r\n            }\r\n            else {\r\n                return this._get(node.getRight(), key);\r\n            }\r\n        };\r\n        SortedList.prototype.add = function (element) {\r\n            if (this._root == null) {\r\n                this._root = new BinaryTreeNode(this._getComparable.call(element), [element], null, null);\r\n                return true;\r\n            }\r\n            else {\r\n                return this._insert(this._root, element);\r\n            }\r\n        };\r\n        SortedList.prototype._insert = function (node, element) {\r\n            if (node != null) {\r\n                if (this._getComparable.call(element) === node.getKey()) {\r\n                    if (node.getData().indexOf(element) > -1) {\r\n                        return false; // the element we\'re trying to insert already exists\r\n                    }\r\n                    else {\r\n                        node.getData().push(element);\r\n                        return true;\r\n                    }\r\n                }\r\n                else if (this._getComparable.call(element) < node.getKey()) {\r\n                    if (node.getLeft() == null) {\r\n                        node.setLeft(new BinaryTreeNode(this._getComparable.call(element), [element], null, null));\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        return this._insert(node.getLeft(), element);\r\n                    }\r\n                }\r\n                else {\r\n                    if (node.getRight() == null) {\r\n                        node.setRight(new BinaryTreeNode(this._getComparable.call(element), [element], null, null));\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        return this._insert(node.getRight(), element);\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        SortedList.prototype.removeByComparable = function (element) {\r\n            this._root = this._remove(this._root, element);\r\n        };\r\n        SortedList.prototype._remove = function (node, element) {\r\n            if (node == null) {\r\n                return null;\r\n            }\r\n            else if (this._getComparable.call(element) === node.getKey()) {\r\n                var elementIndex = node.getData().indexOf(element);\r\n                // if the node contains the element, remove the element\r\n                if (elementIndex > -1) {\r\n                    node.getData().splice(elementIndex, 1);\r\n                    // if we have removed the last element at this node, remove the node\r\n                    if (node.getData().length === 0) {\r\n                        // if the node is a leaf\r\n                        if (node.getLeft() == null && node.getRight() == null) {\r\n                            return null;\r\n                        }\r\n                        else if (node.getLeft() == null) {\r\n                            return node.getRight();\r\n                        }\r\n                        else if (node.getRight() == null) {\r\n                            return node.getLeft();\r\n                        }\r\n                        // if node has 2 children\r\n                        var temp = this._findMinNode(node.getRight());\r\n                        node.setKey(temp.getKey());\r\n                        node.setData(temp.getData());\r\n                        node.setRight(this._cleanup(node.getRight(), temp)); //"cleanup nodes" (move them up recursively)\r\n                        return node;\r\n                    }\r\n                    else {\r\n                        // this prevents the node from being removed since it still contains elements\r\n                        return node;\r\n                    }\r\n                }\r\n            }\r\n            else if (this._getComparable.call(element) < node.getKey()) {\r\n                node.setLeft(this._remove(node.getLeft(), element));\r\n                return node;\r\n            }\r\n            else {\r\n                node.setRight(this._remove(node.getRight(), element));\r\n                return node;\r\n            }\r\n            return null;\r\n        };\r\n        // called once we have successfully removed the element we wanted, recursively corrects the part of the tree below the removed node\r\n        SortedList.prototype._cleanup = function (node, element) {\r\n            var comparable = element.getKey();\r\n            if (node == null) {\r\n                return null;\r\n            }\r\n            else if (comparable === node.getKey()) {\r\n                // if the node is a leaf\r\n                if (node.getLeft() == null && node.getRight() == null) {\r\n                    return null;\r\n                }\r\n                else if (node.getLeft() == null) {\r\n                    return node.getRight();\r\n                }\r\n                else if (node.getRight() == null) {\r\n                    return node.getLeft();\r\n                }\r\n                // if node has 2 children\r\n                var temp = this._findMinNode(node.getRight());\r\n                node.setKey(temp.getKey());\r\n                node.setData(temp.getData());\r\n                node.setRight(this._cleanup(node.getRight(), temp));\r\n                return node;\r\n            }\r\n            else if (this._getComparable.call(element) < node.getKey()) {\r\n                node.setLeft(this._cleanup(node.getLeft(), element));\r\n                return node;\r\n            }\r\n            else {\r\n                node.setRight(this._cleanup(node.getRight(), element));\r\n                return node;\r\n            }\r\n        };\r\n        SortedList.prototype._findMinNode = function (node) {\r\n            var current = node;\r\n            while (current.getLeft() != null) {\r\n                current = current.getLeft();\r\n            }\r\n            return current;\r\n        };\r\n        SortedList.prototype.list = function () {\r\n            var results = new Array();\r\n            this._list(this._root, results);\r\n            return results;\r\n        };\r\n        SortedList.prototype._list = function (treeNode, results) {\r\n            if (treeNode != null) {\r\n                this._list(treeNode.getLeft(), results);\r\n                treeNode.getData().forEach(function (element) {\r\n                    results.push(element);\r\n                });\r\n                this._list(treeNode.getRight(), results);\r\n            }\r\n        };\r\n        return SortedList;\r\n    }());\r\n    exports.SortedList = SortedList;\r\n    /**\r\n     * A tree node part of [[SortedList]]\r\n     */\r\n    var BinaryTreeNode = (function () {\r\n        function BinaryTreeNode(key, data, left, right) {\r\n            this._key = key;\r\n            this._data = data;\r\n            this._left = left;\r\n            this._right = right;\r\n        }\r\n        BinaryTreeNode.prototype.getKey = function () {\r\n            return this._key;\r\n        };\r\n        BinaryTreeNode.prototype.setKey = function (key) {\r\n            this._key = key;\r\n        };\r\n        BinaryTreeNode.prototype.getData = function () {\r\n            return this._data;\r\n        };\r\n        BinaryTreeNode.prototype.setData = function (data) {\r\n            this._data = data;\r\n        };\r\n        BinaryTreeNode.prototype.getLeft = function () {\r\n            return this._left;\r\n        };\r\n        BinaryTreeNode.prototype.setLeft = function (left) {\r\n            this._left = left;\r\n        };\r\n        BinaryTreeNode.prototype.getRight = function () {\r\n            return this._right;\r\n        };\r\n        BinaryTreeNode.prototype.setRight = function (right) {\r\n            this._right = right;\r\n        };\r\n        return BinaryTreeNode;\r\n    }());\r\n    exports.BinaryTreeNode = BinaryTreeNode;\r\n    /**\r\n     * Mock element for testing\r\n     *\r\n     * @internal\r\n     */\r\n    var MockedElement = (function () {\r\n        function MockedElement(key) {\r\n            this._key = 0;\r\n            this._key = key;\r\n        }\r\n        MockedElement.prototype.getTheKey = function () {\r\n            return this._key;\r\n        };\r\n        MockedElement.prototype.setKey = function (key) {\r\n            this._key = key;\r\n        };\r\n        return MockedElement;\r\n    }());\r\n    exports.MockedElement = MockedElement;\r\n});\r\ndefine("Index", ["require", "exports", "Actor", "Algebra", "Camera", "Class", "Debug", "Engine", "EventDispatcher", "Events", "Group", "Label", "Loader", "Particles", "Physics", "Promises", "Scene", "TileMap", "Timer", "Trigger", "UIActor", "Actions/Index", "Collision/Index", "Drawing/Index", "Math/Index", "PostProcessing/Index", "Resources/Index", "Events", "Input/Index", "Traits/Index", "Util/Index", "Util/Decorators", "Util/Detector", "Util/CullingBox", "Util/EasingFunctions", "Util/Log", "Util/SortedList"], function (require, exports, Actor_11, Algebra_21, Camera_1, Class_8, Debug_1, Engine_2, EventDispatcher_2, Events_11, Group_1, Label_2, Loader_1, Particles_1, Physics_11, Promises_7, Scene_1, TileMap_1, Timer_1, Trigger_1, UIActor_2, Index_1, Index_2, Index_3, Index_4, Index_5, Index_6, events, input, traits, util, Decorators_2, Detector_1, CullingBox_2, EasingFunctions_3, Log_13, SortedList_1) {\r\n    "use strict";\r\n    function __export(m) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * The current Excalibur version string\r\n     */\r\n    exports.EX_VERSION = \'0.14.0\';\r\n    // This file is used as the bundle entrypoint and exports everything\r\n    // that will be exposed as the `ex` global variable.\r\n    __export(Actor_11);\r\n    __export(Algebra_21);\r\n    __export(Camera_1);\r\n    __export(Class_8);\r\n    __export(Debug_1);\r\n    __export(Engine_2);\r\n    __export(EventDispatcher_2);\r\n    __export(Events_11);\r\n    __export(Group_1);\r\n    __export(Label_2);\r\n    __export(Loader_1);\r\n    __export(Particles_1);\r\n    __export(Physics_11);\r\n    __export(Promises_7);\r\n    __export(Scene_1);\r\n    __export(TileMap_1);\r\n    __export(Timer_1);\r\n    __export(Trigger_1);\r\n    __export(UIActor_2);\r\n    __export(Index_1);\r\n    __export(Index_2);\r\n    __export(Index_3);\r\n    __export(Index_4);\r\n    __export(Index_5);\r\n    __export(Index_6);\r\n    exports.Events = events;\r\n    exports.Input = input;\r\n    exports.Traits = traits;\r\n    exports.Util = util;\r\n    __export(Decorators_2);\r\n    __export(Detector_1);\r\n    __export(CullingBox_2);\r\n    __export(EasingFunctions_3);\r\n    __export(Log_13);\r\n    __export(SortedList_1);\r\n});\r\ndefine("Engine", ["require", "exports", "Index", "Promises", "Algebra", "UIActor", "Actor", "Timer", "TileMap", "Loader", "Util/Detector", "Events", "Util/Log", "Drawing/Color", "Scene", "Debug", "Class", "Input/Index", "Util/Util", "Collision/BoundingBox"], function (require, exports, Index_7, Promises_8, Algebra_22, UIActor_3, Actor_12, Timer_2, TileMap_2, Loader_2, Detector_2, Events_12, Log_14, Color_19, Scene_2, Debug_2, Class_9, Input, Util, BoundingBox_7) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Enum representing the different display modes available to Excalibur\r\n     */\r\n    var DisplayMode;\r\n    (function (DisplayMode) {\r\n        /**\r\n         * Show the game as full screen\r\n         */\r\n        DisplayMode[DisplayMode["FullScreen"] = 0] = "FullScreen";\r\n        /**\r\n         * Scale the game to the parent DOM container\r\n         */\r\n        DisplayMode[DisplayMode["Container"] = 1] = "Container";\r\n        /**\r\n         * Show the game as a fixed size\r\n         */\r\n        DisplayMode[DisplayMode["Fixed"] = 2] = "Fixed";\r\n        /**\r\n         * Allow the game to be positioned with the [[IEngineOptions.position]] option\r\n         */\r\n        DisplayMode[DisplayMode["Position"] = 3] = "Position";\r\n    })(DisplayMode = exports.DisplayMode || (exports.DisplayMode = {}));\r\n    /**\r\n     * Enum representing the different mousewheel event bubble prevention\r\n     */\r\n    var ScrollPreventionMode;\r\n    (function (ScrollPreventionMode) {\r\n        /**\r\n         * Do not prevent any page scrolling\r\n         */\r\n        ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";\r\n        /**\r\n         * Prevent page scroll if mouse is over the game canvas\r\n         */\r\n        ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";\r\n        /**\r\n         * Prevent all page scrolling via mouse wheel\r\n         */\r\n        ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";\r\n    })(ScrollPreventionMode = exports.ScrollPreventionMode || (exports.ScrollPreventionMode = {}));\r\n    /**\r\n     * The Excalibur Engine\r\n     *\r\n     * The [[Engine]] is the main driver for a game. It is responsible for\r\n     * starting/stopping the game, maintaining state, transmitting events,\r\n     * loading resources, and managing the scene.\r\n     *\r\n     * [[include:Engine.md]]\r\n     */\r\n    var Engine = (function (_super) {\r\n        __extends(Engine, _super);\r\n        /**\r\n         * Creates a new game using the given [[IEngineOptions]]. By default, if no options are provided,\r\n         * the game will be rendered full screen (taking up all available browser window space).\r\n         * You can customize the game rendering through [[IEngineOptions]].\r\n         *\r\n         * Example:\r\n         *\r\n         * ```js\r\n         * var game = new ex.Engine({\r\n         *   width: 0, // the width of the canvas\r\n         *   height: 0, // the height of the canvas\r\n         *   canvasElementId: \'\', // the DOM canvas element ID, if you are providing your own\r\n         *   displayMode: ex.DisplayMode.FullScreen, // the display mode\r\n         *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events\r\n         *   backgroundColor: ex.Color.fromHex(\'#2185d0\') // background color of the engine\r\n         * });\r\n         *\r\n         * // call game.start, which is a Promise\r\n         * game.start().then(function () {\r\n         *   // ready, set, go!\r\n         * });\r\n         * ```\r\n         */\r\n        function Engine(options) {\r\n            var _this = _super.call(this) || this;\r\n            _this._hasStarted = false;\r\n            /**\r\n             * Access Excalibur debugging functionality.\r\n             */\r\n            _this.debug = new Debug_2.Debug();\r\n            /**\r\n             * Gets or sets the list of post processors to apply at the end of drawing a frame (such as [[ColorBlindCorrector]])\r\n             */\r\n            _this.postProcessors = [];\r\n            /**\r\n             * Contains all the scenes currently registered with Excalibur\r\n             */\r\n            _this.scenes = {};\r\n            _this._animations = [];\r\n            /**\r\n             * Indicates whether the engine is set to fullscreen or not\r\n             */\r\n            _this.isFullscreen = false;\r\n            /**\r\n             * Indicates the current [[DisplayMode]] of the engine.\r\n             */\r\n            _this.displayMode = DisplayMode.FullScreen;\r\n            /**\r\n             * Indicates whether audio should be paused when the game is no longer visible.\r\n             */\r\n            _this.pauseAudioWhenHidden = true;\r\n            /**\r\n             * Indicates whether the engine should draw with debug information\r\n             */\r\n            _this.isDebug = false;\r\n            _this.debugColor = new Color_19.Color(255, 255, 255);\r\n            /**\r\n             * The action to take when a fatal exception is thrown\r\n             */\r\n            _this.onFatalException = function (e) { Log_14.Logger.getInstance().fatal(e); };\r\n            _this._isSmoothingEnabled = true;\r\n            _this._timescale = 1.0;\r\n            _this._isLoading = false;\r\n            options = Util.extend({}, Engine._DefaultEngineOptions, options);\r\n            // Check compatibility \r\n            var detector = new Detector_2.Detector();\r\n            if (!options.suppressMinimumBrowserFeatureDetection && !(_this._compatible = detector.test())) {\r\n                var message = document.createElement(\'div\');\r\n                message.innerText = \'Sorry, your browser does not support all the features needed for Excalibur\';\r\n                document.body.appendChild(message);\r\n                detector.failedTests.forEach(function (test) {\r\n                    var testMessage = document.createElement(\'div\');\r\n                    testMessage.innerText = \'Browser feature missing \' + test;\r\n                    document.body.appendChild(testMessage);\r\n                });\r\n                if (options.canvasElementId) {\r\n                    var canvas = document.getElementById(options.canvasElementId);\r\n                    if (canvas) {\r\n                        canvas.parentElement.removeChild(canvas);\r\n                    }\r\n                }\r\n                return _this;\r\n            }\r\n            else {\r\n                _this._compatible = true;\r\n            }\r\n            // Use native console API for color fun\r\n            if (console.log && !options.suppressConsoleBootMessage) {\r\n                console.log("%cPowered by Excalibur.js (v" + Index_7.EX_VERSION + ")", \'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;\');\r\n                console.log(\'\\n\\\r\n      /| ________________\\n\\\r\nO|===|* >________________>\\n\\\r\n      \\\\|\');\r\n                console.log(\'Visit\', \'http://excaliburjs.com\', \'for more information\');\r\n            }\r\n            _this._logger = Log_14.Logger.getInstance();\r\n            // If debug is enabled, let\'s log browser features to the console.\r\n            if (_this._logger.defaultLevel === Log_14.LogLevel.Debug) {\r\n                detector.logBrowserFeatures();\r\n            }\r\n            _this._logger.debug(\'Building engine...\');\r\n            _this.canvasElementId = options.canvasElementId;\r\n            if (options.canvasElementId) {\r\n                _this._logger.debug(\'Using Canvas element specified: \' + options.canvasElementId);\r\n                _this.canvas = document.getElementById(options.canvasElementId);\r\n            }\r\n            else {\r\n                _this._logger.debug(\'Using generated canvas element\');\r\n                _this.canvas = document.createElement(\'canvas\');\r\n            }\r\n            if (options.width && options.height) {\r\n                if (options.displayMode === undefined) {\r\n                    _this.displayMode = DisplayMode.Fixed;\r\n                }\r\n                _this._logger.debug(\'Engine viewport is size \' + options.width + \' x \' + options.height);\r\n                _this.canvas.width = options.width;\r\n                _this.canvas.height = options.height;\r\n            }\r\n            else if (!options.displayMode) {\r\n                _this._logger.debug(\'Engine viewport is fullscreen\');\r\n                _this.displayMode = DisplayMode.FullScreen;\r\n            }\r\n            if (options.backgroundColor) {\r\n                _this.backgroundColor = options.backgroundColor.clone();\r\n            }\r\n            _this._loader = new Loader_2.Loader();\r\n            _this._initialize(options);\r\n            _this.rootScene = _this.currentScene = new Scene_2.Scene(_this);\r\n            _this.addScene(\'root\', _this.rootScene);\r\n            _this.goToScene(\'root\');\r\n            return _this;\r\n        }\r\n        Object.defineProperty(Engine.prototype, "canvasWidth", {\r\n            /**\r\n             * The width of the game canvas in pixels (physical width component of the\r\n             * resolution of the canvas element)\r\n             */\r\n            get: function () {\r\n                return this.canvas.width;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Engine.prototype, "halfCanvasWidth", {\r\n            /**\r\n             * Returns half width of the game canvas in pixels (half physical width component)\r\n             */\r\n            get: function () {\r\n                return this.canvas.width / 2;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Engine.prototype, "canvasHeight", {\r\n            /**\r\n             * The height of the game canvas in pixels, (physical height component of\r\n             * the resolution of the canvas element)\r\n             */\r\n            get: function () {\r\n                return this.canvas.height;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Engine.prototype, "halfCanvasHeight", {\r\n            /**\r\n             * Returns half height of the game canvas in pixels (half physical height component)\r\n             */\r\n            get: function () {\r\n                return this.canvas.height / 2;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Engine.prototype, "drawWidth", {\r\n            /**\r\n             * Returns the width of the engine\'s visible drawing surface in pixels including zoom and device pixel ratio.\r\n             */\r\n            get: function () {\r\n                if (this.currentScene && this.currentScene.camera) {\r\n                    return (this.canvasWidth / this.currentScene.camera.getZoom()) / this.pixelRatio;\r\n                }\r\n                return this.canvasWidth / this.pixelRatio;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Engine.prototype, "halfDrawWidth", {\r\n            /**\r\n             * Returns half the width of the engine\'s visible drawing surface in pixels including zoom and device pixel ratio.\r\n             */\r\n            get: function () {\r\n                return this.drawWidth / 2;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Engine.prototype, "drawHeight", {\r\n            /**\r\n             * Returns the height of the engine\'s visible drawing surface in pixels including zoom and device pixel ratio.\r\n             */\r\n            get: function () {\r\n                if (this.currentScene && this.currentScene.camera) {\r\n                    return (this.canvasHeight / this.currentScene.camera.getZoom()) / this.pixelRatio;\r\n                }\r\n                return this.canvasHeight / this.pixelRatio;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Engine.prototype, "halfDrawHeight", {\r\n            /**\r\n             * Returns half the height of the engine\'s visible drawing surface in pixels including zoom and device pixel ratio.\r\n             */\r\n            get: function () {\r\n                return this.drawHeight / 2;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Engine.prototype, "isHiDpi", {\r\n            /**\r\n             * Returns whether excalibur detects the current screen to be HiDPI\r\n             */\r\n            get: function () {\r\n                return this.pixelRatio !== 1;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Engine.prototype, "stats", {\r\n            /**\r\n             * Access [[stats]] that holds frame statistics.\r\n             */\r\n            get: function () {\r\n                return this.debug.stats;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Engine.prototype, "pixelRatio", {\r\n            /**\r\n             * Returns the calculated pixel ration for use in rendering\r\n             */\r\n            get: function () {\r\n                var devicePixelRatio = window.devicePixelRatio || 1;\r\n                var pixelRatio = devicePixelRatio;\r\n                return pixelRatio;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Engine.prototype.on = function (eventName, handler) {\r\n            _super.prototype.on.call(this, eventName, handler);\r\n        };\r\n        /**\r\n         * Returns a BoundingBox of the top left corner of the screen\r\n         * and the bottom right corner of the screen.\r\n         */\r\n        Engine.prototype.getWorldBounds = function () {\r\n            var left = this.screenToWorldCoordinates(Algebra_22.Vector.Zero).x;\r\n            var top = this.screenToWorldCoordinates(Algebra_22.Vector.Zero).y;\r\n            var right = left + this.drawWidth;\r\n            var bottom = top + this.drawHeight;\r\n            return new BoundingBox_7.BoundingBox(left, top, right, bottom);\r\n        };\r\n        Object.defineProperty(Engine.prototype, "timescale", {\r\n            /**\r\n             * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)\r\n             */\r\n            get: function () {\r\n                return this._timescale;\r\n            },\r\n            /**\r\n             * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects\r\n             * when using time-based movement.\r\n             */\r\n            set: function (value) {\r\n                if (value <= 0) {\r\n                    Log_14.Logger.getInstance().error(\'Cannot set engine.timescale to a value of 0 or less than 0.\');\r\n                    return;\r\n                }\r\n                this._timescale = value;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Plays a sprite animation on the screen at the specified `x` and `y`\r\n         * (in game coordinates, not screen pixels). These animations play\r\n         * independent of actors, and will be cleaned up internally as soon\r\n         * as they are complete. Note animations that loop will never be\r\n         * cleaned up.\r\n         *\r\n         * @param animation  Animation to play\r\n         * @param x          x game coordinate to play the animation\r\n         * @param y          y game coordinate to play the animation\r\n         */\r\n        Engine.prototype.playAnimation = function (animation, x, y) {\r\n            this._animations.push(new AnimationNode(animation, x, y));\r\n        };\r\n        /**\r\n         * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap\r\n         * will be drawn and updated.\r\n         */\r\n        Engine.prototype.addTileMap = function (tileMap) {\r\n            this.currentScene.addTileMap(tileMap);\r\n        };\r\n        /**\r\n         * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.\r\n         */\r\n        Engine.prototype.removeTileMap = function (tileMap) {\r\n            this.currentScene.removeTileMap(tileMap);\r\n        };\r\n        /**\r\n         * Adds a [[Timer]] to the [[currentScene]].\r\n         * @param timer  The timer to add to the [[currentScene]].\r\n         */\r\n        Engine.prototype.addTimer = function (timer) {\r\n            return this.currentScene.addTimer(timer);\r\n        };\r\n        /**\r\n         * Removes a [[Timer]] from the [[currentScene]].\r\n         * @param timer  The timer to remove to the [[currentScene]].\r\n         */\r\n        Engine.prototype.removeTimer = function (timer) {\r\n            return this.currentScene.removeTimer(timer);\r\n        };\r\n        /**\r\n         * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n         * would levels or menus.\r\n         *\r\n         * @param key  The name of the scene, must be unique\r\n         * @param scene The scene to add to the engine\r\n         */\r\n        Engine.prototype.addScene = function (key, scene) {\r\n            if (this.scenes[key]) {\r\n                this._logger.warn(\'Scene\', key, \'already exists overwriting\');\r\n            }\r\n            this.scenes[key] = scene;\r\n            scene.engine = this;\r\n        };\r\n        /**\r\n         * @internal\r\n         */\r\n        Engine.prototype.removeScene = function (entity) {\r\n            if (entity instanceof Scene_2.Scene) {\r\n                // remove scene\r\n                for (var key in this.scenes) {\r\n                    if (this.scenes.hasOwnProperty(key)) {\r\n                        if (this.scenes[key] === entity) {\r\n                            delete this.scenes[key];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (typeof entity === \'string\') {\r\n                // remove scene\r\n                delete this.scenes[entity];\r\n            }\r\n        };\r\n        Engine.prototype.add = function (entity) {\r\n            if (entity instanceof UIActor_3.UIActor) {\r\n                this.currentScene.addUIActor(entity);\r\n                return;\r\n            }\r\n            if (entity instanceof Actor_12.Actor) {\r\n                this._addChild(entity);\r\n            }\r\n            if (entity instanceof Timer_2.Timer) {\r\n                this.addTimer(entity);\r\n            }\r\n            if (entity instanceof TileMap_2.TileMap) {\r\n                this.addTileMap(entity);\r\n            }\r\n            if (arguments.length === 2) {\r\n                this.addScene(arguments[0], arguments[1]);\r\n            }\r\n        };\r\n        Engine.prototype.remove = function (entity) {\r\n            if (entity instanceof UIActor_3.UIActor) {\r\n                this.currentScene.removeUIActor(entity);\r\n                return;\r\n            }\r\n            if (entity instanceof Actor_12.Actor) {\r\n                this._removeChild(entity);\r\n            }\r\n            if (entity instanceof Timer_2.Timer) {\r\n                this.removeTimer(entity);\r\n            }\r\n            if (entity instanceof TileMap_2.TileMap) {\r\n                this.removeTileMap(entity);\r\n            }\r\n            if (entity instanceof Scene_2.Scene) {\r\n                this.removeScene(entity);\r\n            }\r\n            if (typeof entity === \'string\') {\r\n                this.removeScene(entity);\r\n            }\r\n        };\r\n        /**\r\n         * Adds an actor to the [[currentScene]] of the game. This is synonymous\r\n         * to calling `engine.currentScene.add(actor)`.\r\n         *\r\n         * Actors can only be drawn if they are a member of a scene, and only\r\n         * the [[currentScene]] may be drawn or updated.\r\n         *\r\n         * @param actor  The actor to add to the [[currentScene]]\r\n         */\r\n        Engine.prototype._addChild = function (actor) {\r\n            this.currentScene.add(actor);\r\n        };\r\n        /**\r\n         * Removes an actor from the [[currentScene]] of the game. This is synonymous\r\n         * to calling `engine.currentScene.remove(actor)`.\r\n         * Actors that are removed from a scene will no longer be drawn or updated.\r\n         *\r\n         * @param actor  The actor to remove from the [[currentScene]].\r\n         */\r\n        Engine.prototype._removeChild = function (actor) {\r\n            this.currentScene.remove(actor);\r\n        };\r\n        /**\r\n         * Changes the currently updating and drawing scene to a different,\r\n         * named scene. Calls the [[Scene]] lifecycle events.\r\n         * @param key  The key of the scene to transition to.\r\n         */\r\n        Engine.prototype.goToScene = function (key) {\r\n            if (this.scenes[key]) {\r\n                var oldScene = this.currentScene;\r\n                var newScene = this.scenes[key];\r\n                this._logger.debug(\'Going to scene:\', key);\r\n                // only deactivate when initialized\r\n                if (this.currentScene.isInitialized) {\r\n                    this.currentScene.onDeactivate.call(this.currentScene);\r\n                    this.currentScene.eventDispatcher.emit(\'deactivate\', new Events_12.DeactivateEvent(newScene, this.currentScene));\r\n                }\r\n                // set current scene to new one\r\n                this.currentScene = newScene;\r\n                // initialize the current scene if has not been already\r\n                this.currentScene._initialize(this);\r\n                this.currentScene.onActivate.call(this.currentScene);\r\n                this.currentScene.eventDispatcher.emit(\'activate\', new Events_12.ActivateEvent(oldScene, this.currentScene));\r\n            }\r\n            else {\r\n                this._logger.error(\'Scene\', key, \'does not exist!\');\r\n            }\r\n        };\r\n        /**\r\n         * Transforms the current x, y from screen coordinates to world coordinates\r\n         * @param point  Screen coordinate to convert\r\n         */\r\n        Engine.prototype.screenToWorldCoordinates = function (point) {\r\n            var newX = point.x;\r\n            var newY = point.y;\r\n            // transform back to world space\r\n            newX = (newX / this.canvas.clientWidth) * this.drawWidth;\r\n            newY = (newY / this.canvas.clientHeight) * this.drawHeight;\r\n            // transform based on zoom\r\n            newX = newX - this.halfDrawWidth;\r\n            newY = newY - this.halfDrawHeight;\r\n            // shift by focus\r\n            if (this.currentScene && this.currentScene.camera) {\r\n                var focus = this.currentScene.camera.getFocus();\r\n                newX += focus.x;\r\n                newY += focus.y;\r\n            }\r\n            return new Algebra_22.Vector(Math.floor(newX), Math.floor(newY));\r\n        };\r\n        /**\r\n         * Transforms a world coordinate, to a screen coordinate\r\n         * @param point  World coordinate to convert\r\n         */\r\n        Engine.prototype.worldToScreenCoordinates = function (point) {\r\n            var screenX = point.x;\r\n            var screenY = point.y;\r\n            // shift by focus\r\n            if (this.currentScene && this.currentScene.camera) {\r\n                var focus = this.currentScene.camera.getFocus();\r\n                screenX -= focus.x;\r\n                screenY -= focus.y;\r\n            }\r\n            // transform back on zoom\r\n            screenX = screenX + this.halfDrawWidth;\r\n            screenY = screenY + this.halfDrawHeight;\r\n            // transform back to screen space\r\n            screenX = (screenX * this.canvas.clientWidth) / this.drawWidth;\r\n            screenY = (screenY * this.canvas.clientHeight) / this.drawHeight;\r\n            return new Algebra_22.Vector(Math.floor(screenX), Math.floor(screenY));\r\n        };\r\n        /**\r\n         * Sets the internal canvas height based on the selected display mode.\r\n         */\r\n        Engine.prototype._setHeightByDisplayMode = function (parent) {\r\n            if (this.displayMode === DisplayMode.Container) {\r\n                this.canvas.width = parent.clientWidth;\r\n                this.canvas.height = parent.clientHeight;\r\n            }\r\n            if (this.displayMode === DisplayMode.FullScreen) {\r\n                document.body.style.margin = \'0px\';\r\n                document.body.style.overflow = \'hidden\';\r\n                this.canvas.width = parent.innerWidth;\r\n                this.canvas.height = parent.innerHeight;\r\n            }\r\n        };\r\n        /**\r\n         * Initializes the internal canvas, rendering context, displaymode, and native event listeners\r\n         */\r\n        Engine.prototype._initialize = function (options) {\r\n            var _this = this;\r\n            if (options.displayMode) {\r\n                this.displayMode = options.displayMode;\r\n            }\r\n            if (this.displayMode === DisplayMode.FullScreen || this.displayMode === DisplayMode.Container) {\r\n                var parent = (this.displayMode === DisplayMode.Container ?\r\n                    (this.canvas.parentElement || document.body) : window);\r\n                this._setHeightByDisplayMode(parent);\r\n                window.addEventListener(\'resize\', function () {\r\n                    _this._logger.debug(\'View port resized\');\r\n                    _this._setHeightByDisplayMode(parent);\r\n                    _this._logger.info(\'parent.clientHeight \' + parent.clientHeight);\r\n                    _this.setAntialiasing(_this._isSmoothingEnabled);\r\n                });\r\n            }\r\n            else if (this.displayMode === DisplayMode.Position) {\r\n                this._intializeDisplayModePosition(options);\r\n            }\r\n            // initialize inputs\r\n            this.input = {\r\n                keyboard: new Input.Keyboard(this),\r\n                pointers: new Input.Pointers(this),\r\n                gamepads: new Input.Gamepads(this)\r\n            };\r\n            this.input.keyboard.init();\r\n            this.input.pointers.init(options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas);\r\n            this.input.gamepads.init();\r\n            this.pageScrollPreventionMode = options.scrollPreventionMode;\r\n            // Issue #385 make use of the visibility api\r\n            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API\r\n            var hidden, visibilityChange;\r\n            if (typeof document.hidden !== \'undefined\') {\r\n                hidden = \'hidden\';\r\n                visibilityChange = \'visibilitychange\';\r\n            }\r\n            else if (\'msHidden\' in document) {\r\n                hidden = \'msHidden\';\r\n                visibilityChange = \'msvisibilitychange\';\r\n            }\r\n            else if (\'webkitHidden\' in document) {\r\n                hidden = \'webkitHidden\';\r\n                visibilityChange = \'webkitvisibilitychange\';\r\n            }\r\n            document.addEventListener(visibilityChange, function () {\r\n                if (document[hidden]) {\r\n                    _this.eventDispatcher.emit(\'hidden\', new Events_12.HiddenEvent(_this));\r\n                    _this._logger.debug(\'Window hidden\');\r\n                }\r\n                else {\r\n                    _this.eventDispatcher.emit(\'visible\', new Events_12.VisibleEvent(_this));\r\n                    _this._logger.debug(\'Window visible\');\r\n                }\r\n            });\r\n            this.ctx = this.canvas.getContext(\'2d\');\r\n            if (!options.suppressHiDPIScaling) {\r\n                this._initializeHiDpi();\r\n            }\r\n            if (!this.canvasElementId) {\r\n                document.body.appendChild(this.canvas);\r\n            }\r\n        };\r\n        Engine.prototype._intializeDisplayModePosition = function (options) {\r\n            if (!options.position) {\r\n                throw new Error(\'DisplayMode of Position was selected but no position option was given\');\r\n            }\r\n            else {\r\n                this.canvas.style.display = \'block\';\r\n                this.canvas.style.position = \'absolute\';\r\n                if (typeof options.position === \'string\') {\r\n                    var specifiedPosition = options.position.split(\' \');\r\n                    switch (specifiedPosition[0]) {\r\n                        case \'top\':\r\n                            this.canvas.style.top = \'0px\';\r\n                            break;\r\n                        case \'bottom\':\r\n                            this.canvas.style.bottom = \'0px\';\r\n                            break;\r\n                        case \'middle\':\r\n                            this.canvas.style.top = \'50%\';\r\n                            var offsetY = -this.halfDrawHeight;\r\n                            this.canvas.style.marginTop = offsetY.toString();\r\n                            break;\r\n                        default:\r\n                            throw new Error(\'Invalid Position Given\');\r\n                    }\r\n                    if (specifiedPosition[1]) {\r\n                        switch (specifiedPosition[1]) {\r\n                            case \'left\':\r\n                                this.canvas.style.left = \'0px\';\r\n                                break;\r\n                            case \'right\':\r\n                                this.canvas.style.right = \'0px\';\r\n                                break;\r\n                            case \'center\':\r\n                                this.canvas.style.left = \'50%\';\r\n                                var offsetX = -this.halfDrawWidth;\r\n                                this.canvas.style.marginLeft = offsetX.toString();\r\n                                break;\r\n                            default:\r\n                                throw new Error(\'Invalid Position Given\');\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (options.position.top) {\r\n                        typeof options.position.top === \'number\' ?\r\n                            this.canvas.style.top = options.position.top.toString() + \'px\' :\r\n                            this.canvas.style.top = options.position.top;\r\n                    }\r\n                    if (options.position.right) {\r\n                        typeof options.position.right === \'number\' ?\r\n                            this.canvas.style.right = options.position.right.toString() + \'px\' :\r\n                            this.canvas.style.right = options.position.right;\r\n                    }\r\n                    if (options.position.bottom) {\r\n                        typeof options.position.bottom === \'number\' ?\r\n                            this.canvas.style.bottom = options.position.bottom.toString() + \'px\' :\r\n                            this.canvas.style.bottom = options.position.bottom;\r\n                    }\r\n                    if (options.position.left) {\r\n                        typeof options.position.left === \'number\' ?\r\n                            this.canvas.style.left = options.position.left.toString() + \'px\' :\r\n                            this.canvas.style.left = options.position.left;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Engine.prototype._initializeHiDpi = function () {\r\n            // Scale the canvas if needed\r\n            if (this.isHiDpi) {\r\n                var oldWidth = this.canvas.width;\r\n                var oldHeight = this.canvas.height;\r\n                this.canvas.width = oldWidth * this.pixelRatio;\r\n                this.canvas.height = oldHeight * this.pixelRatio;\r\n                this.canvas.style.width = oldWidth + \'px\';\r\n                this.canvas.style.height = oldHeight + \'px\';\r\n                this._logger.warn("Hi DPI screen detected, resetting canvas resolution from \\n                           " + oldWidth + "x" + oldHeight + " to " + this.canvas.width + "x" + this.canvas.height + " \\n                           css size will remain " + oldWidth + "x" + oldHeight);\r\n                this.ctx.scale(this.pixelRatio, this.pixelRatio);\r\n                this._logger.warn("Canvas drawing context was scaled by " + this.pixelRatio);\r\n            }\r\n        };\r\n        /**\r\n         * If supported by the browser, this will set the antialiasing flag on the\r\n         * canvas. Set this to `false` if you want a \'jagged\' pixel art look to your\r\n         * image resources.\r\n         * @param isSmooth  Set smoothing to true or false\r\n         */\r\n        Engine.prototype.setAntialiasing = function (isSmooth) {\r\n            this._isSmoothingEnabled = isSmooth;\r\n            var ctx = this.ctx;\r\n            ctx.imageSmoothingEnabled = isSmooth;\r\n            for (var _i = 0, _a = [\'webkitImageSmoothingEnabled\', \'mozImageSmoothingEnabled\', \'msImageSmoothingEnabled\']; _i < _a.length; _i++) {\r\n                var smoothing = _a[_i];\r\n                if (smoothing in ctx) {\r\n                    ctx[smoothing] = isSmooth;\r\n                }\r\n            }\r\n            ;\r\n        };\r\n        /**\r\n         * Return the current smoothing status of the canvas\r\n         */\r\n        Engine.prototype.getAntialiasing = function () {\r\n            return this.ctx.imageSmoothingEnabled ||\r\n                this.ctx.webkitImageSmoothingEnabled ||\r\n                this.ctx.mozImageSmoothingEnabled ||\r\n                this.ctx.msImageSmoothingEnabled;\r\n        };\r\n        /**\r\n         * Updates the entire state of the game\r\n         * @param delta  Number of milliseconds elapsed since the last update.\r\n         */\r\n        Engine.prototype._update = function (delta) {\r\n            if (this._isLoading) {\r\n                // suspend updates untill loading is finished\r\n                this._loader.update(this, delta);\r\n                // Update input listeners\r\n                this.input.keyboard.update();\r\n                this.input.pointers.update();\r\n                this.input.gamepads.update();\r\n                return;\r\n            }\r\n            this.emit(\'preupdate\', new Events_12.PreUpdateEvent(this, delta, this));\r\n            // process engine level events\r\n            this.currentScene.update(this, delta);\r\n            // update animations\r\n            this._animations = this._animations.filter(function (a) {\r\n                return !a.animation.isDone();\r\n            });\r\n            // Update input listeners\r\n            this.input.keyboard.update();\r\n            this.input.pointers.update();\r\n            this.input.gamepads.update();\r\n            // Publish update event\r\n            this.emit(\'postupdate\', new Events_12.PostUpdateEvent(this, delta, this));\r\n        };\r\n        /**\r\n         * Draws the entire game\r\n         * @param delta  Number of milliseconds elapsed since the last draw.\r\n         */\r\n        Engine.prototype._draw = function (delta) {\r\n            var ctx = this.ctx;\r\n            this.emit(\'predraw\', new Events_12.PreDrawEvent(ctx, delta, this));\r\n            if (this._isLoading) {\r\n                this._loader.draw(ctx, delta);\r\n                // Drawing nothing else while loading\r\n                return;\r\n            }\r\n            ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\r\n            ctx.fillStyle = this.backgroundColor.toString();\r\n            ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\r\n            this.currentScene.draw(this.ctx, delta);\r\n            // todo needs to be a better way of doing this\r\n            var a = 0, len = this._animations.length;\r\n            for (a; a < len; a++) {\r\n                this._animations[a].animation.draw(ctx, this._animations[a].x, this._animations[a].y);\r\n            }\r\n            // Draw debug information\r\n            if (this.isDebug) {\r\n                this.ctx.font = \'Consolas\';\r\n                this.ctx.fillStyle = this.debugColor.toString();\r\n                var keys = this.input.keyboard.getKeys();\r\n                for (var j = 0; j < keys.length; j++) {\r\n                    this.ctx.fillText(keys[j].toString() + \' : \' + (Input.Keys[keys[j]] ? Input.Keys[keys[j]] : \'Not Mapped\'), 100, 10 * j + 10);\r\n                }\r\n                this.ctx.fillText(\'FPS:\' + this.stats.currFrame.fps.toFixed(2).toString(), 10, 10);\r\n            }\r\n            // Post processing\r\n            for (var i = 0; i < this.postProcessors.length; i++) {\r\n                this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight), this.ctx);\r\n            }\r\n            this.emit(\'postdraw\', new Events_12.PostDrawEvent(ctx, delta, this));\r\n        };\r\n        /**\r\n         * Starts the internal game loop for Excalibur after loading\r\n         * any provided assets.\r\n         * @param loader  Optional [[ILoader]] to use to load resources. The default loader is [[Loader]], override to provide your own\r\n         * custom loader.\r\n         */\r\n        Engine.prototype.start = function (loader) {\r\n            var _this = this;\r\n            if (!this._compatible) {\r\n                var promise = new Promises_8.Promise();\r\n                return promise.reject(\'Excalibur is incompatible with your browser\');\r\n            }\r\n            var loadingComplete;\r\n            if (loader) {\r\n                this._loader = loader;\r\n                this._loader.wireEngine(this);\r\n                loadingComplete = this.load(this._loader);\r\n            }\r\n            else {\r\n                loadingComplete = Promises_8.Promise.resolve();\r\n            }\r\n            loadingComplete.then(function () {\r\n                _this.emit(\'start\', new Events_12.GameStartEvent(_this));\r\n            });\r\n            if (!this._hasStarted) {\r\n                this._hasStarted = true;\r\n                this._logger.debug(\'Starting game...\');\r\n                Engine.createMainLoop(this, window.requestAnimationFrame, Date.now)();\r\n                this._logger.debug(\'Game started\');\r\n            }\r\n            else {\r\n                // Game already started;\r\n            }\r\n            return loadingComplete;\r\n        };\r\n        Engine.createMainLoop = function (game, raf, nowFn) {\r\n            var lastTime = nowFn();\r\n            return function mainloop() {\r\n                if (!game._hasStarted) {\r\n                    return;\r\n                }\r\n                try {\r\n                    game._requestId = raf(mainloop);\r\n                    game.emit(\'preframe\', new Events_12.PreFrameEvent(game, game.stats.prevFrame));\r\n                    // Get the time to calculate time-elapsed\r\n                    var now = nowFn();\r\n                    var elapsed = Math.floor(now - lastTime) || 1;\r\n                    // Resolves issue #138 if the game has been paused, or blurred for \r\n                    // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability \r\n                    // and provides more expected behavior when the engine comes back\r\n                    // into focus\r\n                    if (elapsed > 200) {\r\n                        elapsed = 1;\r\n                    }\r\n                    var delta = elapsed * game.timescale;\r\n                    // reset frame stats (reuse existing instances)\r\n                    var frameId = game.stats.prevFrame.id + 1;\r\n                    game.stats.prevFrame.reset(game.stats.currFrame);\r\n                    game.stats.currFrame.reset();\r\n                    game.stats.currFrame.id = frameId;\r\n                    game.stats.currFrame.delta = delta;\r\n                    game.stats.currFrame.fps = 1.0 / (delta / 1000);\r\n                    var beforeUpdate = nowFn();\r\n                    game._update(delta);\r\n                    var afterUpdate = nowFn();\r\n                    game._draw(delta);\r\n                    var afterDraw = nowFn();\r\n                    game.stats.currFrame.duration.update = afterUpdate - beforeUpdate;\r\n                    game.stats.currFrame.duration.draw = afterDraw - afterUpdate;\r\n                    lastTime = now;\r\n                    game.emit(\'postframe\', new Events_12.PostFrameEvent(game, game.stats.currFrame));\r\n                }\r\n                catch (e) {\r\n                    window.cancelAnimationFrame(game._requestId);\r\n                    game.stop();\r\n                    game.onFatalException(e);\r\n                }\r\n            };\r\n        };\r\n        /**\r\n         * Stops Excalibur\'s main loop, useful for pausing the game.\r\n         */\r\n        Engine.prototype.stop = function () {\r\n            if (this._hasStarted) {\r\n                this.emit(\'stop\', new Events_12.GameStopEvent(this));\r\n                this._hasStarted = false;\r\n                this._logger.debug(\'Game stopped\');\r\n            }\r\n        };\r\n        /**\r\n         * Returns the Engine\'s Running status, Useful for checking whether engine is running or paused.\r\n         */\r\n        Engine.prototype.isPaused = function () {\r\n            return !(this._hasStarted);\r\n        };\r\n        /**\r\n         * Takes a screen shot of the current viewport and returns it as an\r\n         * HTML Image Element.\r\n         */\r\n        Engine.prototype.screenshot = function () {\r\n            var result = new Image();\r\n            var raw = this.canvas.toDataURL(\'image/png\');\r\n            result.src = raw;\r\n            return result;\r\n        };\r\n        /**\r\n         * Another option available to you to load resources into the game.\r\n         * Immediately after calling this the game will pause and the loading screen\r\n         * will appear.\r\n         * @param loader  Some [[ILoadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].\r\n         */\r\n        Engine.prototype.load = function (loader) {\r\n            var _this = this;\r\n            var complete = new Promises_8.Promise();\r\n            this._isLoading = true;\r\n            loader.load().then(function () {\r\n                setTimeout(function () {\r\n                    _this._isLoading = false;\r\n                    complete.resolve();\r\n                }, 500);\r\n            });\r\n            return complete;\r\n        };\r\n        return Engine;\r\n    }(Class_9.Class));\r\n    /**\r\n     * Default [[IEngineOptions]]\r\n     */\r\n    Engine._DefaultEngineOptions = {\r\n        width: 0,\r\n        height: 0,\r\n        canvasElementId: \'\',\r\n        pointerScope: Input.PointerScope.Document,\r\n        suppressConsoleBootMessage: null,\r\n        suppressMinimumBrowserFeatureDetection: null,\r\n        suppressHiDPIScaling: null,\r\n        scrollPreventionMode: ScrollPreventionMode.Canvas,\r\n        backgroundColor: Color_19.Color.fromHex(\'#2185d0\') // Excalibur blue\r\n    };\r\n    exports.Engine = Engine;\r\n    /**\r\n     * @internal\r\n     */\r\n    var AnimationNode = (function () {\r\n        function AnimationNode(animation, x, y) {\r\n            this.animation = animation;\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n        return AnimationNode;\r\n    }());\r\n});\r\ndefine("UIActor", ["require", "exports", "Algebra", "Actor", "Traits/Index"], function (require, exports, Algebra_23, Actor_13, Traits) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Helper [[Actor]] primitive for drawing UI\'s, optimized for UI drawing. Does\r\n     * not participate in collisions. Drawn on top of all other actors.\r\n     */\r\n    var UIActor = (function (_super) {\r\n        __extends(UIActor, _super);\r\n        /**\r\n         * @param x       The starting x coordinate of the actor\r\n         * @param y       The starting y coordinate of the actor\r\n         * @param width   The starting width of the actor\r\n         * @param height  The starting height of the actor\r\n         */\r\n        function UIActor(x, y, width, height) {\r\n            var _this = _super.call(this, x, y, width, height) || this;\r\n            _this.traits = [];\r\n            _this.traits.push(new Traits.CapturePointer());\r\n            _this.anchor.setTo(0, 0);\r\n            _this.collisionType = Actor_13.CollisionType.PreventCollision;\r\n            _this.enableCapturePointer = true;\r\n            return _this;\r\n        }\r\n        UIActor.prototype.onInitialize = function (engine) {\r\n            this._engine = engine;\r\n        };\r\n        UIActor.prototype.contains = function (x, y, useWorld) {\r\n            if (useWorld === void 0) { useWorld = true; }\r\n            if (useWorld) {\r\n                return _super.prototype.contains.call(this, x, y);\r\n            }\r\n            var coords = this._engine.worldToScreenCoordinates(new Algebra_23.Vector(x, y));\r\n            return _super.prototype.contains.call(this, coords.x, coords.y);\r\n        };\r\n        return UIActor;\r\n    }(Actor_13.Actor));\r\n    exports.UIActor = UIActor;\r\n});\r\ndefine("Util/Actors", ["require", "exports", "UIActor", "Label", "Trigger"], function (require, exports, UIActor_4, Label_3, Trigger_2) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    function isVanillaActor(actor) {\r\n        return !(actor instanceof UIActor_4.UIActor) &&\r\n            !(actor instanceof Trigger_2.Trigger) &&\r\n            !(actor instanceof Label_3.Label);\r\n    }\r\n    exports.isVanillaActor = isVanillaActor;\r\n    function isUIActor(actor) {\r\n        return actor instanceof UIActor_4.UIActor;\r\n    }\r\n    exports.isUIActor = isUIActor;\r\n});\r\ndefine("Scene", ["require", "exports", "UIActor", "Physics", "Events", "Util/Log", "Timer", "Collision/DynamicTreeCollisionBroadphase", "Util/SortedList", "Group", "TileMap", "Camera", "Actor", "Class", "Util/Util", "Util/Actors", "Trigger"], function (require, exports, UIActor_5, Physics_12, Events_13, Log_15, Timer_3, DynamicTreeCollisionBroadphase_2, SortedList_2, Group_2, TileMap_3, Camera_2, Actor_14, Class_10, Util, ActorUtils, Trigger_3) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * [[Actor|Actors]] are composed together into groupings called Scenes in\r\n     * Excalibur. The metaphor models the same idea behind real world\r\n     * actors in a scene. Only actors in scenes will be updated and drawn.\r\n     *\r\n     * Typical usages of a scene include: levels, menus, loading screens, etc.\r\n     *\r\n     * [[include:Scenes.md]]\r\n     */\r\n    var Scene = (function (_super) {\r\n        __extends(Scene, _super);\r\n        function Scene(engine) {\r\n            var _this = _super.call(this) || this;\r\n            /**\r\n             * The actors in the current scene\r\n             */\r\n            _this.actors = [];\r\n            /**\r\n             * The triggers in the current scene\r\n             */\r\n            _this.triggers = [];\r\n            /**\r\n             * The [[TileMap]]s in the scene, if any\r\n             */\r\n            _this.tileMaps = [];\r\n            /**\r\n             * The [[Group]]s in the scene, if any\r\n             */\r\n            _this.groups = {};\r\n            /**\r\n             * The [[UIActor]]s in a scene, if any; these are drawn last\r\n             */\r\n            _this.uiActors = [];\r\n            _this._isInitialized = false;\r\n            _this._sortedDrawingTree = new SortedList_2.SortedList(Actor_14.Actor.prototype.getZIndex);\r\n            _this._broadphase = new DynamicTreeCollisionBroadphase_2.DynamicTreeCollisionBroadphase();\r\n            _this._killQueue = [];\r\n            _this._triggerKillQueue = [];\r\n            _this._timers = [];\r\n            _this._cancelQueue = [];\r\n            _this._logger = Log_15.Logger.getInstance();\r\n            _this.camera = new Camera_2.BaseCamera();\r\n            if (engine) {\r\n                _this.camera.x = engine.halfDrawWidth;\r\n                _this.camera.y = engine.halfDrawHeight;\r\n            }\r\n            return _this;\r\n        }\r\n        Scene.prototype.on = function (eventName, handler) {\r\n            _super.prototype.on.call(this, eventName, handler);\r\n        };\r\n        /**\r\n         * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be\r\n         * overridden. This is where initialization of child actors should take place.\r\n         */\r\n        Scene.prototype.onInitialize = function (engine) {\r\n            // will be overridden\r\n            if (this.camera) {\r\n                this.camera.x = engine.halfDrawWidth;\r\n                this.camera.y = engine.halfDrawHeight;\r\n            }\r\n            this._logger.debug(\'Scene.onInitialize\', this, engine);\r\n        };\r\n        /**\r\n         * This is called when the scene is made active and started. It is meant to be overriden,\r\n         * this is where you should setup any DOM UI or event handlers needed for the scene.\r\n         */\r\n        Scene.prototype.onActivate = function () {\r\n            // will be overridden\r\n            this._logger.debug(\'Scene.onActivate\', this);\r\n        };\r\n        /**\r\n         * This is called when the scene is made transitioned away from and stopped. It is meant to be overriden,\r\n         * this is where you should cleanup any DOM UI or event handlers needed for the scene.\r\n         */\r\n        Scene.prototype.onDeactivate = function () {\r\n            // will be overridden\r\n            this._logger.debug(\'Scene.onDeactivate\', this);\r\n        };\r\n        /**\r\n         * Initializes actors in the scene\r\n         */\r\n        Scene.prototype._initializeChildren = function () {\r\n            for (var _i = 0, _a = this.actors; _i < _a.length; _i++) {\r\n                var child = _a[_i];\r\n                child._initialize(this.engine);\r\n            }\r\n        };\r\n        Object.defineProperty(Scene.prototype, "isInitialized", {\r\n            /**\r\n             * Gets whether or not the [[Scene]] has been initialized\r\n             */\r\n            get: function () {\r\n                return this._isInitialized;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Initializes the scene before the first update, meant to be called by engine not by users of\r\n         * Excalibur\r\n         * @internal\r\n         */\r\n        Scene.prototype._initialize = function (engine) {\r\n            if (!this.isInitialized) {\r\n                this.onInitialize.call(this, engine);\r\n                this.eventDispatcher.emit(\'initialize\', new Events_13.InitializeEvent(engine, this));\r\n                this._initializeChildren();\r\n                this._isInitialized = true;\r\n            }\r\n        };\r\n        /**\r\n         * Updates all the actors and timers in the scene. Called by the [[Engine]].\r\n         * @param engine  Reference to the current Engine\r\n         * @param delta   The number of milliseconds since the last update\r\n         */\r\n        Scene.prototype.update = function (engine, delta) {\r\n            this.emit(\'preupdate\', new Events_13.PreUpdateEvent(engine, delta, this));\r\n            var i, len;\r\n            // Remove timers in the cancel queue before updating them\r\n            for (i = 0, len = this._cancelQueue.length; i < len; i++) {\r\n                this.removeTimer(this._cancelQueue[i]);\r\n            }\r\n            this._cancelQueue.length = 0;\r\n            // Cycle through timers updating timers\r\n            for (var _i = 0, _a = this._timers; _i < _a.length; _i++) {\r\n                var timer = _a[_i];\r\n                timer.update(delta);\r\n            }\r\n            ;\r\n            // Cycle through actors updating UI actors\r\n            for (i = 0, len = this.uiActors.length; i < len; i++) {\r\n                this.uiActors[i].update(engine, delta);\r\n            }\r\n            // Cycle through actors updating tile maps\r\n            for (i = 0, len = this.tileMaps.length; i < len; i++) {\r\n                this.tileMaps[i].update(engine, delta);\r\n            }\r\n            // Cycle through actors updating actors\r\n            for (i = 0, len = this.actors.length; i < len; i++) {\r\n                this.actors[i].update(engine, delta);\r\n            }\r\n            // Cycle through triggers updating\r\n            for (i = 0, len = this.triggers.length; i < len; i++) {\r\n                this.triggers[i].update(engine, delta);\r\n            }\r\n            this._collectActorStats(engine);\r\n            // Run the broadphase and narrowphase\r\n            if (this._broadphase && Physics_12.Physics.enabled) {\r\n                var beforeBroadphase = Date.now();\r\n                this._broadphase.update(this.actors, delta);\r\n                var pairs = this._broadphase.broadphase(this.actors, delta, engine.stats.currFrame);\r\n                var afterBroadphase = Date.now();\r\n                var beforeNarrowphase = Date.now();\r\n                var iter = Physics_12.Physics.collisionPasses;\r\n                var collisionDelta = delta / iter;\r\n                while (iter > 0) {\r\n                    // Run the narrowphase\r\n                    pairs = this._broadphase.narrowphase(pairs, engine.stats.currFrame);\r\n                    // Run collision resolution strategy\r\n                    pairs = this._broadphase.resolve(pairs, collisionDelta, Physics_12.Physics.collisionResolutionStrategy);\r\n                    this._broadphase.runCollisionStartEnd(pairs);\r\n                    iter--;\r\n                }\r\n                var afterNarrowphase = Date.now();\r\n                engine.stats.currFrame.physics.broadphase = afterBroadphase - beforeBroadphase;\r\n                engine.stats.currFrame.physics.narrowphase = afterNarrowphase - beforeNarrowphase;\r\n            }\r\n            engine.stats.currFrame.actors.killed = this._killQueue.length + this._triggerKillQueue.length;\r\n            this._processKillQueue(this._killQueue, this.actors);\r\n            this._processKillQueue(this._triggerKillQueue, this.triggers);\r\n            if (this.camera) {\r\n                this.camera.update(engine, delta);\r\n            }\r\n            this.emit(\'postupdate\', new Events_13.PostUpdateEvent(engine, delta, this));\r\n        };\r\n        Scene.prototype._processKillQueue = function (killQueue, collection) {\r\n            // Remove actors from scene graph after being killed\r\n            var actorIndex;\r\n            for (var _i = 0, killQueue_1 = killQueue; _i < killQueue_1.length; _i++) {\r\n                var killed = killQueue_1[_i];\r\n                actorIndex = collection.indexOf(killed);\r\n                if (actorIndex > -1) {\r\n                    this._sortedDrawingTree.removeByComparable(killed);\r\n                    collection.splice(actorIndex, 1);\r\n                }\r\n            }\r\n            killQueue.length = 0;\r\n        };\r\n        /**\r\n         * Draws all the actors in the Scene. Called by the [[Engine]].\r\n         * @param ctx    The current rendering context\r\n         * @param delta  The number of milliseconds since the last draw\r\n         */\r\n        Scene.prototype.draw = function (ctx, delta) {\r\n            this.emit(\'predraw\', new Events_13.PreDrawEvent(ctx, delta, this));\r\n            ctx.save();\r\n            if (this.camera) {\r\n                this.camera.draw(ctx);\r\n            }\r\n            var i, len;\r\n            for (i = 0, len = this.tileMaps.length; i < len; i++) {\r\n                this.tileMaps[i].draw(ctx, delta);\r\n            }\r\n            var sortedChildren = this._sortedDrawingTree.list();\r\n            for (i = 0, len = sortedChildren.length; i < len; i++) {\r\n                // only draw actors that are visible and on screen\r\n                if (sortedChildren[i].visible && !sortedChildren[i].isOffScreen) {\r\n                    sortedChildren[i].draw(ctx, delta);\r\n                }\r\n            }\r\n            if (this.engine && this.engine.isDebug) {\r\n                ctx.strokeStyle = \'yellow\';\r\n                this.debugDraw(ctx);\r\n            }\r\n            ctx.restore();\r\n            for (i = 0, len = this.uiActors.length; i < len; i++) {\r\n                // only draw ui actors that are visible and on screen\r\n                if (this.uiActors[i].visible) {\r\n                    this.uiActors[i].draw(ctx, delta);\r\n                }\r\n            }\r\n            if (this.engine && this.engine.isDebug) {\r\n                for (i = 0, len = this.uiActors.length; i < len; i++) {\r\n                    this.uiActors[i].debugDraw(ctx);\r\n                }\r\n            }\r\n            this.emit(\'postdraw\', new Events_13.PostDrawEvent(ctx, delta, this));\r\n        };\r\n        /**\r\n         * Draws all the actors\' debug information in the Scene. Called by the [[Engine]].\r\n         * @param ctx  The current rendering context\r\n         */\r\n        /* istanbul ignore next */\r\n        Scene.prototype.debugDraw = function (ctx) {\r\n            this.emit(\'predebugdraw\', new Events_13.PreDebugDrawEvent(ctx, this));\r\n            var i, len;\r\n            for (i = 0, len = this.tileMaps.length; i < len; i++) {\r\n                this.tileMaps[i].debugDraw(ctx);\r\n            }\r\n            for (i = 0, len = this.actors.length; i < len; i++) {\r\n                this.actors[i].debugDraw(ctx);\r\n            }\r\n            for (i = 0, len = this.triggers.length; i < len; i++) {\r\n                this.triggers[i].debugDraw(ctx);\r\n            }\r\n            this._broadphase.debugDraw(ctx, 20);\r\n            this.camera.debugDraw(ctx);\r\n            this.emit(\'postdebugdraw\', new Events_13.PostDebugDrawEvent(ctx, this));\r\n        };\r\n        /**\r\n         * Checks whether an actor is contained in this scene or not\r\n         */\r\n        Scene.prototype.contains = function (actor) {\r\n            return this.actors.indexOf(actor) > -1;\r\n        };\r\n        Scene.prototype.add = function (entity) {\r\n            if (entity instanceof Actor_14.Actor) {\r\n                entity.unkill();\r\n            }\r\n            if (entity instanceof UIActor_5.UIActor) {\r\n                if (!Util.contains(this.uiActors, entity)) {\r\n                    this.addUIActor(entity);\r\n                }\r\n                return;\r\n            }\r\n            if (entity instanceof Actor_14.Actor) {\r\n                if (!Util.contains(this.actors, entity)) {\r\n                    this._addChild(entity);\r\n                }\r\n                return;\r\n            }\r\n            if (entity instanceof Timer_3.Timer) {\r\n                if (!Util.contains(this._timers, entity)) {\r\n                    this.addTimer(entity);\r\n                }\r\n                return;\r\n            }\r\n            if (entity instanceof TileMap_3.TileMap) {\r\n                if (!Util.contains(this.tileMaps, entity)) {\r\n                    this.addTileMap(entity);\r\n                }\r\n            }\r\n        };\r\n        Scene.prototype.remove = function (entity) {\r\n            if (entity instanceof UIActor_5.UIActor) {\r\n                this.removeUIActor(entity);\r\n                return;\r\n            }\r\n            if (entity instanceof Actor_14.Actor) {\r\n                this._broadphase.untrack(entity.body);\r\n                this._removeChild(entity);\r\n            }\r\n            if (entity instanceof Timer_3.Timer) {\r\n                this.removeTimer(entity);\r\n            }\r\n            if (entity instanceof TileMap_3.TileMap) {\r\n                this.removeTileMap(entity);\r\n            }\r\n        };\r\n        /**\r\n         * Adds (any) actor to act as a piece of UI, meaning it is always positioned\r\n         * in screen coordinates. UI actors do not participate in collisions.\r\n         * @todo Should this be `UIActor` only?\r\n         */\r\n        Scene.prototype.addUIActor = function (actor) {\r\n            this.uiActors.push(actor);\r\n            actor.scene = this;\r\n        };\r\n        /**\r\n         * Removes an actor as a piece of UI\r\n         */\r\n        Scene.prototype.removeUIActor = function (actor) {\r\n            var index = this.uiActors.indexOf(actor);\r\n            if (index > -1) {\r\n                this.uiActors.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * Adds an actor to the scene, once this is done the actor will be drawn and updated.\r\n         */\r\n        Scene.prototype._addChild = function (actor) {\r\n            this._broadphase.track(actor.body);\r\n            actor.scene = this;\r\n            if (actor instanceof Trigger_3.Trigger) {\r\n                this.triggers.push(actor);\r\n            }\r\n            else {\r\n                this.actors.push(actor);\r\n            }\r\n            this._sortedDrawingTree.add(actor);\r\n        };\r\n        /**\r\n         * Adds a [[TileMap]] to the scene, once this is done the TileMap will be drawn and updated.\r\n         */\r\n        Scene.prototype.addTileMap = function (tileMap) {\r\n            this.tileMaps.push(tileMap);\r\n        };\r\n        /**\r\n         * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.\r\n         */\r\n        Scene.prototype.removeTileMap = function (tileMap) {\r\n            var index = this.tileMaps.indexOf(tileMap);\r\n            if (index > -1) {\r\n                this.tileMaps.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * Removes an actor from the scene, it will no longer be drawn or updated.\r\n         */\r\n        Scene.prototype._removeChild = function (actor) {\r\n            this._broadphase.untrack(actor.body);\r\n            if (actor instanceof Trigger_3.Trigger) {\r\n                this._triggerKillQueue.push(actor);\r\n            }\r\n            else {\r\n                this._killQueue.push(actor);\r\n            }\r\n            actor.parent = null;\r\n        };\r\n        /**\r\n         * Adds a [[Timer]] to the scene\r\n         * @param timer  The timer to add\r\n         */\r\n        Scene.prototype.addTimer = function (timer) {\r\n            this._timers.push(timer);\r\n            timer.scene = this;\r\n            return timer;\r\n        };\r\n        /**\r\n         * Removes a [[Timer]] from the scene.\r\n         * @warning Can be dangerous, use [[cancelTimer]] instead\r\n         * @param timer  The timer to remove\r\n         */\r\n        Scene.prototype.removeTimer = function (timer) {\r\n            var i = this._timers.indexOf(timer);\r\n            if (i !== -1) {\r\n                this._timers.splice(i, 1);\r\n            }\r\n            return timer;\r\n        };\r\n        /**\r\n         * Cancels a [[Timer]], removing it from the scene nicely\r\n         * @param timer  The timer to cancel\r\n         */\r\n        Scene.prototype.cancelTimer = function (timer) {\r\n            this._cancelQueue.push(timer);\r\n            return timer;\r\n        };\r\n        /**\r\n         * Tests whether a [[Timer]] is active in the scene\r\n         */\r\n        Scene.prototype.isTimerActive = function (timer) {\r\n            return (this._timers.indexOf(timer) > -1 && !timer.complete);\r\n        };\r\n        /**\r\n         * Creates and adds a [[Group]] to the scene with a name\r\n         */\r\n        Scene.prototype.createGroup = function (name) {\r\n            return new Group_2.Group(name, this);\r\n        };\r\n        /**\r\n         * Returns a [[Group]] by name\r\n         */\r\n        Scene.prototype.getGroup = function (name) {\r\n            return this.groups[name];\r\n        };\r\n        Scene.prototype.removeGroup = function (group) {\r\n            if (typeof group === \'string\') {\r\n                delete this.groups[group];\r\n            }\r\n            else if (group instanceof Group_2.Group) {\r\n                delete this.groups[group.name];\r\n            }\r\n            else {\r\n                this._logger.error(\'Invalid arguments to removeGroup\', group);\r\n            }\r\n        };\r\n        /**\r\n         * Removes the given actor from the sorted drawing tree\r\n         */\r\n        Scene.prototype.cleanupDrawTree = function (actor) {\r\n            this._sortedDrawingTree.removeByComparable(actor);\r\n        };\r\n        /**\r\n         * Updates the given actor\'s position in the sorted drawing tree\r\n         */\r\n        Scene.prototype.updateDrawTree = function (actor) {\r\n            this._sortedDrawingTree.add(actor);\r\n        };\r\n        Scene.prototype._collectActorStats = function (engine) {\r\n            for (var _i = 0, _a = this.uiActors; _i < _a.length; _i++) {\r\n                var _ui = _a[_i];\r\n                engine.stats.currFrame.actors.ui++;\r\n            }\r\n            for (var _b = 0, _c = this.actors; _b < _c.length; _b++) {\r\n                var actor = _c[_b];\r\n                engine.stats.currFrame.actors.alive++;\r\n                for (var _d = 0, _e = actor.children; _d < _e.length; _d++) {\r\n                    var child = _e[_d];\r\n                    if (ActorUtils.isUIActor(child)) {\r\n                        engine.stats.currFrame.actors.ui++;\r\n                    }\r\n                    else {\r\n                        engine.stats.currFrame.actors.alive++;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        return Scene;\r\n    }(Class_10.Class));\r\n    exports.Scene = Scene;\r\n});\r\ndefine("Events", ["require", "exports"], function (require, exports) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,\r\n     * some events are unique to a type, others are not.\r\n     *\r\n     */\r\n    var GameEvent = (function () {\r\n        function GameEvent() {\r\n        }\r\n        return GameEvent;\r\n    }());\r\n    exports.GameEvent = GameEvent;\r\n    /**\r\n     * The \'kill\' event is emitted on actors when it is killed. The target is the actor that was killed.\r\n     */\r\n    var KillEvent = (function (_super) {\r\n        __extends(KillEvent, _super);\r\n        function KillEvent(target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return KillEvent;\r\n    }(GameEvent));\r\n    exports.KillEvent = KillEvent;\r\n    /**\r\n     * The \'start\' event is emitted on engine when has started and is ready for interaction.\r\n     */\r\n    var GameStartEvent = (function (_super) {\r\n        __extends(GameStartEvent, _super);\r\n        function GameStartEvent(target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return GameStartEvent;\r\n    }(GameEvent));\r\n    exports.GameStartEvent = GameStartEvent;\r\n    /**\r\n     * The \'stop\' event is emitted on engine when has been stopped and will no longer take input, update or draw.\r\n     */\r\n    var GameStopEvent = (function (_super) {\r\n        __extends(GameStopEvent, _super);\r\n        function GameStopEvent(target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return GameStopEvent;\r\n    }(GameEvent));\r\n    exports.GameStopEvent = GameStopEvent;\r\n    /**\r\n     * The \'predraw\' event is emitted on actors, scenes, and engine before drawing starts. Actors\' predraw happens inside their graphics\r\n     * transform so that all drawing takes place with the actor as the origin.\r\n     *\r\n     */\r\n    var PreDrawEvent = (function (_super) {\r\n        __extends(PreDrawEvent, _super);\r\n        function PreDrawEvent(ctx, delta, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.ctx = ctx;\r\n            _this.delta = delta;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return PreDrawEvent;\r\n    }(GameEvent));\r\n    exports.PreDrawEvent = PreDrawEvent;\r\n    /**\r\n     * The \'postdraw\' event is emitted on actors, scenes, and engine after drawing finishes. Actors\' postdraw happens inside their graphics\r\n     * transform so that all drawing takes place with the actor as the origin.\r\n     *\r\n     */\r\n    var PostDrawEvent = (function (_super) {\r\n        __extends(PostDrawEvent, _super);\r\n        function PostDrawEvent(ctx, delta, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.ctx = ctx;\r\n            _this.delta = delta;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return PostDrawEvent;\r\n    }(GameEvent));\r\n    exports.PostDrawEvent = PostDrawEvent;\r\n    /**\r\n     * The \'predebugdraw\' event is emitted on actors, scenes, and engine before debug drawing starts.\r\n     */\r\n    var PreDebugDrawEvent = (function (_super) {\r\n        __extends(PreDebugDrawEvent, _super);\r\n        function PreDebugDrawEvent(ctx, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.ctx = ctx;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return PreDebugDrawEvent;\r\n    }(GameEvent));\r\n    exports.PreDebugDrawEvent = PreDebugDrawEvent;\r\n    /**\r\n     * The \'postdebugdraw\' event is emitted on actors, scenes, and engine after debug drawing starts.\r\n     */\r\n    var PostDebugDrawEvent = (function (_super) {\r\n        __extends(PostDebugDrawEvent, _super);\r\n        function PostDebugDrawEvent(ctx, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.ctx = ctx;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return PostDebugDrawEvent;\r\n    }(GameEvent));\r\n    exports.PostDebugDrawEvent = PostDebugDrawEvent;\r\n    /**\r\n     * The \'preupdate\' event is emitted on actors, scenes, and engine before the update starts.\r\n     */\r\n    var PreUpdateEvent = (function (_super) {\r\n        __extends(PreUpdateEvent, _super);\r\n        function PreUpdateEvent(engine, delta, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.engine = engine;\r\n            _this.delta = delta;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return PreUpdateEvent;\r\n    }(GameEvent));\r\n    exports.PreUpdateEvent = PreUpdateEvent;\r\n    /**\r\n     * The \'postupdate\' event is emitted on actors, scenes, and engine after the update ends.\r\n     */\r\n    var PostUpdateEvent = (function (_super) {\r\n        __extends(PostUpdateEvent, _super);\r\n        function PostUpdateEvent(engine, delta, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.engine = engine;\r\n            _this.delta = delta;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return PostUpdateEvent;\r\n    }(GameEvent));\r\n    exports.PostUpdateEvent = PostUpdateEvent;\r\n    /**\r\n     * The \'preframe\' event is emitted on the engine, before the frame begins.\r\n     */\r\n    var PreFrameEvent = (function (_super) {\r\n        __extends(PreFrameEvent, _super);\r\n        function PreFrameEvent(engine, prevStats) {\r\n            var _this = _super.call(this) || this;\r\n            _this.engine = engine;\r\n            _this.prevStats = prevStats;\r\n            _this.target = engine;\r\n            return _this;\r\n        }\r\n        return PreFrameEvent;\r\n    }(GameEvent));\r\n    exports.PreFrameEvent = PreFrameEvent;\r\n    /**\r\n     * The \'postframe\' event is emitted on the engine, after a frame ends.\r\n     */\r\n    var PostFrameEvent = (function (_super) {\r\n        __extends(PostFrameEvent, _super);\r\n        function PostFrameEvent(engine, stats) {\r\n            var _this = _super.call(this) || this;\r\n            _this.engine = engine;\r\n            _this.stats = stats;\r\n            _this.target = engine;\r\n            return _this;\r\n        }\r\n        return PostFrameEvent;\r\n    }(GameEvent));\r\n    exports.PostFrameEvent = PostFrameEvent;\r\n    /**\r\n     * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.\r\n     */\r\n    var GamepadConnectEvent = (function (_super) {\r\n        __extends(GamepadConnectEvent, _super);\r\n        function GamepadConnectEvent(index, gamepad) {\r\n            var _this = _super.call(this) || this;\r\n            _this.index = index;\r\n            _this.gamepad = gamepad;\r\n            _this.target = gamepad;\r\n            return _this;\r\n        }\r\n        return GamepadConnectEvent;\r\n    }(GameEvent));\r\n    exports.GamepadConnectEvent = GamepadConnectEvent;\r\n    /**\r\n     * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.\r\n     */\r\n    var GamepadDisconnectEvent = (function (_super) {\r\n        __extends(GamepadDisconnectEvent, _super);\r\n        function GamepadDisconnectEvent(index, gamepad) {\r\n            var _this = _super.call(this) || this;\r\n            _this.index = index;\r\n            _this.gamepad = gamepad;\r\n            _this.target = gamepad;\r\n            return _this;\r\n        }\r\n        return GamepadDisconnectEvent;\r\n    }(GameEvent));\r\n    exports.GamepadDisconnectEvent = GamepadDisconnectEvent;\r\n    /**\r\n     * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n     */\r\n    var GamepadButtonEvent = (function (_super) {\r\n        __extends(GamepadButtonEvent, _super);\r\n        /**\r\n         * @param button  The Gamepad button\r\n         * @param value   A numeric value between 0 and 1\r\n         */\r\n        function GamepadButtonEvent(button, value, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.button = button;\r\n            _this.value = value;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return GamepadButtonEvent;\r\n    }(GameEvent));\r\n    exports.GamepadButtonEvent = GamepadButtonEvent;\r\n    /**\r\n     * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n     */\r\n    var GamepadAxisEvent = (function (_super) {\r\n        __extends(GamepadAxisEvent, _super);\r\n        /**\r\n         * @param axis  The Gamepad axis\r\n         * @param value A numeric value between -1 and 1\r\n         */\r\n        function GamepadAxisEvent(axis, value, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.axis = axis;\r\n            _this.value = value;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return GamepadAxisEvent;\r\n    }(GameEvent));\r\n    exports.GamepadAxisEvent = GamepadAxisEvent;\r\n    /**\r\n     * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by\r\n     * [[EventDispatcher|event dispatchers]].\r\n     */\r\n    var SubscribeEvent = (function (_super) {\r\n        __extends(SubscribeEvent, _super);\r\n        function SubscribeEvent(topic, handler) {\r\n            var _this = _super.call(this) || this;\r\n            _this.topic = topic;\r\n            _this.handler = handler;\r\n            return _this;\r\n        }\r\n        return SubscribeEvent;\r\n    }(GameEvent));\r\n    exports.SubscribeEvent = SubscribeEvent;\r\n    /**\r\n     * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by\r\n     * [[EventDispatcher|event dispatchers]].\r\n     */\r\n    var UnsubscribeEvent = (function (_super) {\r\n        __extends(UnsubscribeEvent, _super);\r\n        function UnsubscribeEvent(topic, handler) {\r\n            var _this = _super.call(this) || this;\r\n            _this.topic = topic;\r\n            _this.handler = handler;\r\n            return _this;\r\n        }\r\n        return UnsubscribeEvent;\r\n    }(GameEvent));\r\n    exports.UnsubscribeEvent = UnsubscribeEvent;\r\n    /**\r\n     * Event received by the [[Engine]] when the browser window is visible on a screen.\r\n     */\r\n    var VisibleEvent = (function (_super) {\r\n        __extends(VisibleEvent, _super);\r\n        function VisibleEvent(target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return VisibleEvent;\r\n    }(GameEvent));\r\n    exports.VisibleEvent = VisibleEvent;\r\n    /**\r\n     * Event received by the [[Engine]] when the browser window is hidden from all screens.\r\n     */\r\n    var HiddenEvent = (function (_super) {\r\n        __extends(HiddenEvent, _super);\r\n        function HiddenEvent(target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return HiddenEvent;\r\n    }(GameEvent));\r\n    exports.HiddenEvent = HiddenEvent;\r\n    /**\r\n     * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves\r\n     */\r\n    var PreCollisionEvent = (function (_super) {\r\n        __extends(PreCollisionEvent, _super);\r\n        /**\r\n         * @param actor         The actor the event was thrown on\r\n         * @param other         The actor that will collided with the current actor\r\n         * @param side          The side that will be collided with the current actor\r\n         * @param intersection  Intersection vector\r\n         */\r\n        function PreCollisionEvent(actor, other, side, intersection) {\r\n            var _this = _super.call(this) || this;\r\n            _this.actor = actor;\r\n            _this.other = other;\r\n            _this.side = side;\r\n            _this.intersection = intersection;\r\n            _this.target = actor;\r\n            return _this;\r\n        }\r\n        return PreCollisionEvent;\r\n    }(GameEvent));\r\n    exports.PreCollisionEvent = PreCollisionEvent;\r\n    /**\r\n     * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame\r\n     */\r\n    var PostCollisionEvent = (function (_super) {\r\n        __extends(PostCollisionEvent, _super);\r\n        /**\r\n         * @param actor         The actor the event was thrown on\r\n         * @param other         The actor that did collide with the current actor\r\n         * @param side          The side that did collide with the current actor\r\n         * @param intersection  Intersection vector\r\n         */\r\n        function PostCollisionEvent(actor, other, side, intersection) {\r\n            var _this = _super.call(this) || this;\r\n            _this.actor = actor;\r\n            _this.other = other;\r\n            _this.side = side;\r\n            _this.intersection = intersection;\r\n            _this.target = actor;\r\n            return _this;\r\n        }\r\n        return PostCollisionEvent;\r\n    }(GameEvent));\r\n    exports.PostCollisionEvent = PostCollisionEvent;\r\n    /**\r\n     * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.\r\n     */\r\n    var CollisionStartEvent = (function (_super) {\r\n        __extends(CollisionStartEvent, _super);\r\n        /**\r\n         *\r\n         */\r\n        function CollisionStartEvent(actor, other, pair) {\r\n            var _this = _super.call(this) || this;\r\n            _this.actor = actor;\r\n            _this.other = other;\r\n            _this.pair = pair;\r\n            _this.target = actor;\r\n            return _this;\r\n        }\r\n        return CollisionStartEvent;\r\n    }(GameEvent));\r\n    exports.CollisionStartEvent = CollisionStartEvent;\r\n    /**\r\n     * Event thrown when the [[Actor|actor]] is no longer colliding with another\r\n     */\r\n    var CollisionEndEvent = (function (_super) {\r\n        __extends(CollisionEndEvent, _super);\r\n        /**\r\n         *\r\n         */\r\n        function CollisionEndEvent(actor, other) {\r\n            var _this = _super.call(this) || this;\r\n            _this.actor = actor;\r\n            _this.other = other;\r\n            _this.target = actor;\r\n            return _this;\r\n        }\r\n        return CollisionEndEvent;\r\n    }(GameEvent));\r\n    exports.CollisionEndEvent = CollisionEndEvent;\r\n    /**\r\n     * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call\r\n     */\r\n    var InitializeEvent = (function (_super) {\r\n        __extends(InitializeEvent, _super);\r\n        /**\r\n         * @param engine  The reference to the current engine\r\n         */\r\n        function InitializeEvent(engine, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.engine = engine;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return InitializeEvent;\r\n    }(GameEvent));\r\n    exports.InitializeEvent = InitializeEvent;\r\n    /**\r\n     * Event thrown on a [[Scene]] on activation\r\n     */\r\n    var ActivateEvent = (function (_super) {\r\n        __extends(ActivateEvent, _super);\r\n        /**\r\n         * @param oldScene  The reference to the old scene\r\n         */\r\n        function ActivateEvent(oldScene, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.oldScene = oldScene;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return ActivateEvent;\r\n    }(GameEvent));\r\n    exports.ActivateEvent = ActivateEvent;\r\n    /**\r\n     * Event thrown on a [[Scene]] on deactivation\r\n     */\r\n    var DeactivateEvent = (function (_super) {\r\n        __extends(DeactivateEvent, _super);\r\n        /**\r\n         * @param newScene  The reference to the new scene\r\n         */\r\n        function DeactivateEvent(newScene, target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.newScene = newScene;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return DeactivateEvent;\r\n    }(GameEvent));\r\n    exports.DeactivateEvent = DeactivateEvent;\r\n    /**\r\n     * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n     */\r\n    var ExitViewPortEvent = (function (_super) {\r\n        __extends(ExitViewPortEvent, _super);\r\n        function ExitViewPortEvent(target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return ExitViewPortEvent;\r\n    }(GameEvent));\r\n    exports.ExitViewPortEvent = ExitViewPortEvent;\r\n    /**\r\n     * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n     */\r\n    var EnterViewPortEvent = (function (_super) {\r\n        __extends(EnterViewPortEvent, _super);\r\n        function EnterViewPortEvent(target) {\r\n            var _this = _super.call(this) || this;\r\n            _this.target = target;\r\n            return _this;\r\n        }\r\n        return EnterViewPortEvent;\r\n    }(GameEvent));\r\n    exports.EnterViewPortEvent = EnterViewPortEvent;\r\n    var EnterTriggerEvent = (function (_super) {\r\n        __extends(EnterTriggerEvent, _super);\r\n        function EnterTriggerEvent(target, actor) {\r\n            var _this = _super.call(this) || this;\r\n            _this.target = target;\r\n            _this.actor = actor;\r\n            return _this;\r\n        }\r\n        return EnterTriggerEvent;\r\n    }(GameEvent));\r\n    exports.EnterTriggerEvent = EnterTriggerEvent;\r\n    var ExitTriggerEvent = (function (_super) {\r\n        __extends(ExitTriggerEvent, _super);\r\n        function ExitTriggerEvent(target, actor) {\r\n            var _this = _super.call(this) || this;\r\n            _this.target = target;\r\n            _this.actor = actor;\r\n            return _this;\r\n        }\r\n        return ExitTriggerEvent;\r\n    }(GameEvent));\r\n    exports.ExitTriggerEvent = ExitTriggerEvent;\r\n});\r\ndefine("Class", ["require", "exports", "EventDispatcher"], function (require, exports, EventDispatcher_3) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * Excalibur base class that provides basic functionality such as [[EventDispatcher]]\r\n     * and extending abilities for vanilla Javascript projects\r\n     */\r\n    var Class = (function () {\r\n        function Class() {\r\n            this.eventDispatcher = new EventDispatcher_3.EventDispatcher(this);\r\n        }\r\n        /**\r\n         * Alias for `addEventListener`. You can listen for a variety of\r\n         * events off of the engine; see the events section below for a complete list.\r\n         * @param eventName  Name of the event to listen for\r\n         * @param handler    Event handler for the thrown event\r\n         */\r\n        Class.prototype.on = function (eventName, handler) {\r\n            this.eventDispatcher.on(eventName, handler);\r\n        };\r\n        /**\r\n         * Alias for `removeEventListener`. If only the eventName is specified\r\n         * it will remove all handlers registered for that specific event. If the eventName\r\n         * and the handler instance are specified only that handler will be removed.\r\n         *\r\n         * @param eventName  Name of the event to listen for\r\n         * @param handler    Event handler for the thrown event\r\n         */\r\n        Class.prototype.off = function (eventName, handler) {\r\n            this.eventDispatcher.off(eventName, handler);\r\n        };\r\n        /**\r\n         * Emits a new event\r\n         * @param eventName   Name of the event to emit\r\n         * @param eventObject Data associated with this event\r\n         */\r\n        Class.prototype.emit = function (eventName, eventObject) {\r\n            this.eventDispatcher.emit(eventName, eventObject);\r\n        };\r\n        /**\r\n         * Once listens to an event one time, then unsubscribes from that event\r\n         *\r\n         * @param eventName The name of the event to subscribe to once\r\n         * @param handler   The handler of the event that will be auto unsubscribed\r\n         */\r\n        Class.prototype.once = function (eventName, handler) {\r\n            this.eventDispatcher.once(eventName, handler);\r\n        };\r\n        /**\r\n         * You may wish to extend native Excalibur functionality in vanilla Javascript.\r\n         * Any method on a class inheriting [[Class]] may be extended to support\r\n         * additional functionality. In the example below we create a new type called `MyActor`.\r\n         *\r\n         *\r\n         * ```js\r\n         * var MyActor = Actor.extend({\r\n         *\r\n         *    constructor: function() {\r\n         *       this.newprop = \'something\';\r\n         *       Actor.apply(this, arguments);\r\n         *    },\r\n         *\r\n         *    update: function(engine, delta) {\r\n         *       // Implement custom update\r\n         *       // Call super constructor update\r\n         *       Actor.prototype.update.call(this, engine, delta);\r\n         *\r\n         *       console.log("Something cool!");\r\n         *    }\r\n         * });\r\n         *\r\n         * var myActor = new MyActor(100, 100, 100, 100, Color.Azure);\r\n         * ```\r\n         *\r\n         * In TypeScript, you only need to use the `extends` syntax, you do not need\r\n         * to use this method of extension.\r\n         *\r\n         * @param methods A JSON object contain any methods/properties you want to extend\r\n         */\r\n        Class.extend = function (methods) {\r\n            var parent = this;\r\n            var child;\r\n            if (methods && methods.hasOwnProperty(\'constructor\')) {\r\n                child = methods.constructor;\r\n            }\r\n            else {\r\n                child = function () { return parent.apply(this, arguments); };\r\n            }\r\n            // Using constructor allows JS to lazily instantiate super classes\r\n            var Super = function () { this.constructor = child; };\r\n            Super.prototype = parent.prototype;\r\n            child.prototype = new Super;\r\n            if (methods) {\r\n                for (var prop in methods) {\r\n                    if (methods.hasOwnProperty(prop)) {\r\n                        child.prototype[prop] = methods[prop];\r\n                    }\r\n                }\r\n            }\r\n            // Make subclasses extendable\r\n            child.extend = Class.extend;\r\n            return child;\r\n        };\r\n        return Class;\r\n    }());\r\n    exports.Class = Class;\r\n});\r\ndefine("Actor", ["require", "exports", "Physics", "Class", "Collision/BoundingBox", "Resources/Texture", "Events", "Drawing/Color", "Drawing/Sprite", "Util/Log", "Actions/ActionContext", "Actions/Action", "Algebra", "Collision/Body", "Collision/Side", "Traits/Index", "Drawing/SpriteEffects", "Util/Util"], function (require, exports, Physics_13, Class_11, BoundingBox_8, Texture_2, Events_14, Color_20, Sprite_4, Log_16, ActionContext_3, Action_2, Algebra_24, Body_2, Side_4, Traits, Effects, Util) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    /**\r\n     * The most important primitive in Excalibur is an `Actor`. Anything that\r\n     * can move on the screen, collide with another `Actor`, respond to events,\r\n     * or interact with the current scene, must be an actor. An `Actor` **must**\r\n     * be part of a [[Scene]] for it to be drawn to the screen.\r\n     *\r\n     * [[include:Actors.md]]\r\n     *\r\n     */\r\n    var Actor = (function (_super) {\r\n        __extends(Actor, _super);\r\n        /**\r\n         * @param x       The starting x coordinate of the actor\r\n         * @param y       The starting y coordinate of the actor\r\n         * @param width   The starting width of the actor\r\n         * @param height  The starting height of the actor\r\n         * @param color   The starting color of the actor. Leave null to draw a transparent actor. The opacity of the color will be used as the\r\n         * initial [[opacity]].\r\n         */\r\n        function Actor(x, y, width, height, color) {\r\n            var _this = _super.call(this) || this;\r\n            /**\r\n             * The unique identifier for the actor\r\n             */\r\n            _this.id = Actor.maxId++;\r\n            /**\r\n             * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,\r\n             * acceleration, mass, inertia, etc.\r\n             */\r\n            _this.body = new Body_2.Body(_this);\r\n            _this._height = 0;\r\n            _this._width = 0;\r\n            /**\r\n             * The scale vector of the actor\r\n             */\r\n            _this.scale = new Algebra_24.Vector(1, 1);\r\n            /**\r\n             * The x scalar velocity of the actor in scale/second\r\n             */\r\n            _this.sx = 0; //scale/sec\r\n            /**\r\n             * The y scalar velocity of the actor in scale/second\r\n             */\r\n            _this.sy = 0; //scale/sec\r\n            /**\r\n             * Indicates whether the actor is physically in the viewport\r\n             */\r\n            _this.isOffScreen = false;\r\n            /**\r\n             * The visibility of an actor\r\n             */\r\n            _this.visible = true;\r\n            /**\r\n             * The opacity of an actor. Passing in a color in the [[constructor]] will use the\r\n             * color\'s opacity.\r\n             */\r\n            _this.opacity = 1;\r\n            _this.previousOpacity = 1;\r\n            /**\r\n             * Convenience reference to the global logger\r\n             */\r\n            _this.logger = Log_16.Logger.getInstance();\r\n            /**\r\n             * The scene that the actor is in\r\n             */\r\n            _this.scene = null;\r\n            /**\r\n             * The parent of this actor\r\n             */\r\n            _this.parent = null;\r\n            // TODO: Replace this with the new actor collection once z-indexing is built\r\n            /**\r\n             * The children of this actor\r\n             */\r\n            _this.children = [];\r\n            /**\r\n             * Gets or sets the current collision type of this actor. By\r\n             * default it is ([[CollisionType.PreventCollision]]).\r\n             */\r\n            _this.collisionType = CollisionType.PreventCollision;\r\n            _this.collisionGroups = [];\r\n            _this._collisionHandlers = {};\r\n            _this._isInitialized = false;\r\n            _this.frames = {};\r\n            _this._effectsDirty = false;\r\n            /**\r\n             * Access to the current drawing for the actor, this can be\r\n             * an [[Animation]], [[Sprite]], or [[Polygon]].\r\n             * Set drawings with [[setDrawing]].\r\n             */\r\n            _this.currentDrawing = null;\r\n            /**\r\n             * Modify the current actor update pipeline.\r\n             */\r\n            _this.traits = [];\r\n            /**\r\n             * Whether or not to enable the [[CapturePointer]] trait that propagates\r\n             * pointer events to this actor\r\n             */\r\n            _this.enableCapturePointer = false;\r\n            /**\r\n             * Configuration for [[CapturePointer]] trait\r\n             */\r\n            _this.capturePointer = {\r\n                captureMoveEvents: false\r\n            };\r\n            _this._zIndex = 0;\r\n            _this._isKilled = false;\r\n            _this._opacityFx = new Effects.Opacity(_this.opacity);\r\n            _this.pos.x = x || 0;\r\n            _this.pos.y = y || 0;\r\n            _this._width = width || 0;\r\n            _this._height = height || 0;\r\n            if (color) {\r\n                _this.color = color;\r\n                // set default opacity of an actor to the color\r\n                _this.opacity = color.a;\r\n            }\r\n            // Build default pipeline\r\n            //this.traits.push(new ex.Traits.EulerMovement());\r\n            // TODO: TileMaps should be converted to a collision area\r\n            _this.traits.push(new Traits.TileMapCollisionDetection());\r\n            _this.traits.push(new Traits.OffscreenCulling());\r\n            _this.traits.push(new Traits.CapturePointer());\r\n            // Build the action queue\r\n            _this.actionQueue = new Action_2.ActionQueue(_this);\r\n            _this.actions = new ActionContext_3.ActionContext(_this);\r\n            // default anchor is in the middle\r\n            _this.anchor = new Algebra_24.Vector(.5, .5);\r\n            // Initialize default collision area to be box\r\n            _this.body.useBoxCollision();\r\n            return _this;\r\n        }\r\n        Object.defineProperty(Actor.prototype, "collisionArea", {\r\n            /**\r\n             * Gets the collision area shape to use for collision possible options are [CircleArea|circles], [PolygonArea|polygons], and\r\n             * [EdgeArea|edges].\r\n             */\r\n            get: function () {\r\n                return this.body.collisionArea;\r\n            },\r\n            /**\r\n             * Gets the collision area shape to use for collision possible options are [CircleArea|circles], [PolygonArea|polygons], and\r\n             * [EdgeArea|edges].\r\n             */\r\n            set: function (area) {\r\n                this.body.collisionArea = area;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "x", {\r\n            /**\r\n             * Gets the x position of the actor relative to it\'s parent (if any)\r\n             */\r\n            get: function () {\r\n                return this.body.pos.x;\r\n            },\r\n            /**\r\n             * Sets the x position of the actor relative to it\'s parent (if any)\r\n             */\r\n            set: function (theX) {\r\n                this.body.pos.x = theX;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "y", {\r\n            /**\r\n             * Gets the y position of the actor relative to it\'s parent (if any)\r\n             */\r\n            get: function () {\r\n                return this.body.pos.y;\r\n            },\r\n            /**\r\n             * Sets the y position of the actor relative to it\'s parent (if any)\r\n             */\r\n            set: function (theY) {\r\n                this.body.pos.y = theY;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "pos", {\r\n            /**\r\n             * Gets the position vector of the actor in pixels\r\n             */\r\n            get: function () {\r\n                return this.body.pos;\r\n            },\r\n            /**\r\n             * Sets the position vector of the actor in pixels\r\n             */\r\n            set: function (thePos) {\r\n                this.body.pos.setTo(thePos.x, thePos.y);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "oldPos", {\r\n            /**\r\n             * Gets the position vector of the actor from the last frame\r\n             */\r\n            get: function () {\r\n                return this.body.oldPos;\r\n            },\r\n            /**\r\n             * Sets the position vector of the actor in the last frame\r\n             */\r\n            set: function (thePos) {\r\n                this.body.oldPos.setTo(thePos.x, thePos.y);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "vel", {\r\n            /**\r\n             * Gets the velocity vector of the actor in pixels/sec\r\n             */\r\n            get: function () {\r\n                return this.body.vel;\r\n            },\r\n            /**\r\n             * Sets the velocity vector of the actor in pixels/sec\r\n             */\r\n            set: function (theVel) {\r\n                this.body.vel.setTo(theVel.x, theVel.y);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "oldVel", {\r\n            /**\r\n             * Gets the velocity vector of the actor from the last frame\r\n             */\r\n            get: function () {\r\n                return this.body.oldVel;\r\n            },\r\n            /**\r\n             * Sets the velocity vector of the actor from the last frame\r\n             */\r\n            set: function (theVel) {\r\n                this.body.oldVel.setTo(theVel.x, theVel.y);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "acc", {\r\n            /**\r\n             * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be\r\n             * useful to simulate a gravitational effect.\r\n             */\r\n            get: function () {\r\n                return this.body.acc;\r\n            },\r\n            /**\r\n             * Sets the acceleration vector of teh actor in pixels/second/second\r\n             */\r\n            set: function (theAcc) {\r\n                this.body.acc.setTo(theAcc.x, theAcc.y);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "rotation", {\r\n            /**\r\n             * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n             */\r\n            get: function () {\r\n                return this.body.rotation;\r\n            },\r\n            /**\r\n             * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n             */\r\n            set: function (theAngle) {\r\n                this.body.rotation = theAngle;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "rx", {\r\n            /**\r\n             * Gets the rotational velocity of the actor in radians/second\r\n             */\r\n            get: function () {\r\n                return this.body.rx;\r\n            },\r\n            /**\r\n             * Sets the rotational velocity of the actor in radians/sec\r\n             */\r\n            set: function (angularVelocity) {\r\n                this.body.rx = angularVelocity;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "torque", {\r\n            /**\r\n             * Gets the current torque applied to the actor. Torque can be thought of as rotational force\r\n             */\r\n            get: function () {\r\n                return this.body.torque;\r\n            },\r\n            /**\r\n             * Sets the current torque applied to the actor. Torque can be thought of as rotational force\r\n             */\r\n            set: function (theTorque) {\r\n                this.body.torque = theTorque;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "mass", {\r\n            /**\r\n             * Get the current mass of the actor, mass can be thought of as the resistance to acceleration.\r\n             */\r\n            get: function () {\r\n                return this.body.mass;\r\n            },\r\n            /**\r\n             * Sets the mass of the actor, mass can be thought of as the resistance to acceleration.\r\n             */\r\n            set: function (theMass) {\r\n                this.body.mass = theMass;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "moi", {\r\n            /**\r\n             * Gets the current moment of inertia, moi can be thought of as the resistance to rotation.\r\n             */\r\n            get: function () {\r\n                return this.body.moi;\r\n            },\r\n            /**\r\n             * Sets the current moment of inertia, moi can be thought of as the resistance to rotation.\r\n             */\r\n            set: function (theMoi) {\r\n                this.body.moi = theMoi;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "friction", {\r\n            /**\r\n             * Gets the coefficient of friction on this actor, this can be thought of as how sticky or slippery an object is.\r\n             */\r\n            get: function () {\r\n                return this.body.friction;\r\n            },\r\n            /**\r\n             * Sets the coefficient of friction of this actor, this can ve thought of as how stick or slippery an object is.\r\n             */\r\n            set: function (theFriction) {\r\n                this.body.friction = theFriction;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "restitution", {\r\n            /**\r\n             * Gets the coefficient of restitution of this actor, represents the amount of energy preserved after collision. Think of this\r\n             * as bounciness.\r\n             */\r\n            get: function () {\r\n                return this.body.restitution;\r\n            },\r\n            /**\r\n             * Sets the coefficient of restitution of this actor, represents the amount of energy preserved after collision. Think of this\r\n             * as bounciness.\r\n             */\r\n            set: function (theRestitution) {\r\n                this.body.restitution = theRestitution;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Actor.prototype, "color", {\r\n            /**\r\n             * Sets the color of the actor. A rectangle of this color will be\r\n             * drawn if no [[IDrawable]] is specified as the actors drawing.\r\n             *\r\n             * The default is `null` which prevents a rectangle from being drawn.\r\n             */\r\n            get: function () {\r\n                return this._color;\r\n            },\r\n            set: function (v) {\r\n                this._color = v.clone();\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * This is called before the first update of the actor. This method is meant to be\r\n         * overridden. This is where initialization of child actors should take place.\r\n         */\r\n        Actor.prototype.onInitialize = function (_engine) {\r\n            // Override me\r\n        };\r\n        Object.defineProperty(Actor.prototype, "isInitialized", {\r\n            /**\r\n             * Gets wether the actor is Initialized\r\n             */\r\n            get: function () {\r\n                return this._isInitialized;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Initializes this actor and all it\'s child actors, meant to be called by the Scene before first update not by users of Excalibur.\r\n         * @internal\r\n         */\r\n        Actor.prototype._initialize = function (engine) {\r\n            if (!this.isInitialized) {\r\n                this.onInitialize(engine);\r\n                this.eventDispatcher.emit(\'initialize\', new Events_14.InitializeEvent(engine, this));\r\n                this._isInitialized = true;\r\n            }\r\n            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\r\n                var child = _a[_i];\r\n                child._initialize(engine);\r\n            }\r\n        };\r\n        Actor.prototype._checkForPointerOptIn = function (eventName) {\r\n            if (eventName) {\r\n                var normalized = eventName.toLowerCase();\r\n                if (normalized === \'pointerup\' || normalized === \'pointerdown\' || normalized === \'pointermove\') {\r\n                    this.enableCapturePointer = true;\r\n                    if (normalized === \'pointermove\') {\r\n                        this.capturePointer.captureMoveEvents = true;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Actor.prototype.on = function (eventName, handler) {\r\n            this._checkForPointerOptIn(eventName);\r\n            this.eventDispatcher.on(eventName, handler);\r\n        };\r\n        Actor.prototype.once = function (eventName, handler) {\r\n            this._checkForPointerOptIn(eventName);\r\n            this.eventDispatcher.once(eventName, handler);\r\n        };\r\n        /**\r\n         * If the current actor is a member of the scene, this will remove\r\n         * it from the scene graph. It will no longer be drawn or updated.\r\n         */\r\n        Actor.prototype.kill = function () {\r\n            if (this.scene) {\r\n                this.emit(\'kill\', new Events_14.KillEvent(this));\r\n                this.scene.remove(this);\r\n                this._isKilled = true;\r\n            }\r\n            else {\r\n                this.logger.warn(\'Cannot kill actor, it was never added to the Scene\');\r\n            }\r\n        };\r\n        /**\r\n         * If the current actor is killed, it will now not be killed.\r\n         */\r\n        Actor.prototype.unkill = function () {\r\n            this._isKilled = false;\r\n        };\r\n        /**\r\n         * Indicates wether the actor has been killed.\r\n         */\r\n        Actor.prototype.isKilled = function () {\r\n            return this._isKilled;\r\n        };\r\n        /**\r\n         * Adds a child actor to this actor. All movement of the child actor will be\r\n         * relative to the parent actor. Meaning if the parent moves the child will\r\n         * move with it.\r\n         * @param actor The child actor to add\r\n         */\r\n        Actor.prototype.add = function (actor) {\r\n            actor.collisionType = CollisionType.PreventCollision;\r\n            if (Util.addItemToArray(actor, this.children)) {\r\n                actor.parent = this;\r\n            }\r\n        };\r\n        /**\r\n         * Removes a child actor from this actor.\r\n         * @param actor The child actor to remove\r\n         */\r\n        Actor.prototype.remove = function (actor) {\r\n            if (Util.removeItemFromArray(actor, this.children)) {\r\n                actor.parent = null;\r\n            }\r\n        };\r\n        Actor.prototype.setDrawing = function (key) {\r\n            key = key.toString();\r\n            if (this.currentDrawing !== this.frames[key]) {\r\n                if (this.frames[key] != null) {\r\n                    this.frames[key].reset();\r\n                    this.currentDrawing = this.frames[key];\r\n                }\r\n                else {\r\n                    Log_16.Logger.getInstance().error(\'the specified drawing key \\\'\' + key + \'\\\' does not exist\');\r\n                }\r\n            }\r\n        };\r\n        Actor.prototype.addDrawing = function () {\r\n            if (arguments.length === 2) {\r\n                this.frames[arguments[0]] = arguments[1];\r\n                if (!this.currentDrawing) {\r\n                    this.currentDrawing = arguments[1];\r\n                }\r\n                this._effectsDirty = true;\r\n            }\r\n            else {\r\n                if (arguments[0] instanceof Sprite_4.Sprite) {\r\n                    this.addDrawing(\'default\', arguments[0]);\r\n                }\r\n                if (arguments[0] instanceof Texture_2.Texture) {\r\n                    this.addDrawing(\'default\', arguments[0].asSprite());\r\n                }\r\n            }\r\n        };\r\n        Object.defineProperty(Actor.prototype, "z", {\r\n            get: function () {\r\n                return this.getZIndex();\r\n            },\r\n            set: function (newZ) {\r\n                this.setZIndex(newZ);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.\r\n         * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n         */\r\n        Actor.prototype.getZIndex = function () {\r\n            return this._zIndex;\r\n        };\r\n        /**\r\n         * Sets the z-index of an actor and updates it in the drawing list for the scene.\r\n         * The z-index determines the relative order an actor is drawn in.\r\n         * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n         * @param newIndex new z-index to assign\r\n         */\r\n        Actor.prototype.setZIndex = function (newIndex) {\r\n            this.scene.cleanupDrawTree(this);\r\n            this._zIndex = newIndex;\r\n            this.scene.updateDrawTree(this);\r\n        };\r\n        /**\r\n         * Adds an actor to a collision group. Actors with no named collision groups are\r\n         * considered to be in every collision group.\r\n         *\r\n         * Once in a collision group(s) actors will only collide with other actors in\r\n         * that group.\r\n         *\r\n         * @param name The name of the collision group\r\n         */\r\n        Actor.prototype.addCollisionGroup = function (name) {\r\n            this.collisionGroups.push(name);\r\n        };\r\n        /**\r\n         * Removes an actor from a collision group.\r\n         * @param name The name of the collision group\r\n         */\r\n        Actor.prototype.removeCollisionGroup = function (name) {\r\n            var index = this.collisionGroups.indexOf(name);\r\n            if (index !== -1) {\r\n                this.collisionGroups.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * Get the center point of an actor\r\n         */\r\n        Actor.prototype.getCenter = function () {\r\n            return new Algebra_24.Vector(this.pos.x + this.getWidth() / 2 - this.anchor.x * this.getWidth(), this.pos.y + this.getHeight() / 2 - this.anchor.y * this.getHeight());\r\n        };\r\n        /**\r\n         * Gets the calculated width of an actor, factoring in scale\r\n         */\r\n        Actor.prototype.getWidth = function () {\r\n            return this._width * this.getGlobalScale().x;\r\n        };\r\n        /**\r\n         * Sets the width of an actor, factoring in the current scale\r\n         */\r\n        Actor.prototype.setWidth = function (width) {\r\n            this._width = width / this.scale.x;\r\n        };\r\n        /**\r\n         * Gets the calculated height of an actor, factoring in scale\r\n         */\r\n        Actor.prototype.getHeight = function () {\r\n            return this._height * this.getGlobalScale().y;\r\n        };\r\n        /**\r\n         * Sets the height of an actor, factoring in the current scale\r\n         */\r\n        Actor.prototype.setHeight = function (height) {\r\n            this._height = height / this.scale.y;\r\n        };\r\n        /**\r\n         * Gets the left edge of the actor\r\n         */\r\n        Actor.prototype.getLeft = function () {\r\n            return this.getBounds().left;\r\n        };\r\n        /**\r\n         * Gets the right edge of the actor\r\n         */\r\n        Actor.prototype.getRight = function () {\r\n            return this.getBounds().right;\r\n        };\r\n        /**\r\n         * Gets the top edge of the actor\r\n         */\r\n        Actor.prototype.getTop = function () {\r\n            return this.getBounds().top;\r\n        };\r\n        /**\r\n         * Gets the bottom edge of the actor\r\n         */\r\n        Actor.prototype.getBottom = function () {\r\n            return this.getBounds().bottom;\r\n        };\r\n        /**\r\n         * Gets this actor\'s rotation taking into account any parent relationships\r\n         *\r\n         * @returns Rotation angle in radians\r\n         */\r\n        Actor.prototype.getWorldRotation = function () {\r\n            if (!this.parent) {\r\n                return this.rotation;\r\n            }\r\n            return this.rotation + this.parent.getWorldRotation();\r\n        };\r\n        /**\r\n         * Gets an actor\'s world position taking into account parent relationships, scaling, rotation, and translation\r\n         *\r\n         * @returns Position in world coordinates\r\n         */\r\n        Actor.prototype.getWorldPos = function () {\r\n            if (!this.parent) {\r\n                return this.pos.clone();\r\n            }\r\n            // collect parents                  \r\n            var parents = [];\r\n            var root = this;\r\n            parents.push(this);\r\n            // find parents\r\n            while (root.parent) {\r\n                root = root.parent;\r\n                parents.push(root);\r\n            }\r\n            // calculate position       \r\n            var x = parents.reduceRight(function (px, p) {\r\n                if (p.parent) {\r\n                    return px + (p.pos.x * p.getGlobalScale().x);\r\n                }\r\n                return px + p.pos.x;\r\n            }, 0);\r\n            var y = parents.reduceRight(function (py, p) {\r\n                if (p.parent) {\r\n                    return py + (p.pos.y * p.getGlobalScale().y);\r\n                }\r\n                return py + p.pos.y;\r\n            }, 0);\r\n            // rotate around root anchor\r\n            var ra = root.getWorldPos(); // 10, 10\r\n            var r = this.getWorldRotation();\r\n            return new Algebra_24.Vector(x, y).rotate(r, ra);\r\n        };\r\n        /**\r\n         * Gets the global scale of the Actor\r\n         */\r\n        Actor.prototype.getGlobalScale = function () {\r\n            if (!this.parent) {\r\n                return new Algebra_24.Vector(this.scale.x, this.scale.y);\r\n            }\r\n            var parentScale = this.parent.getGlobalScale();\r\n            return new Algebra_24.Vector(this.scale.x * parentScale.x, this.scale.y * parentScale.y);\r\n        };\r\n        /**\r\n         * Returns the actor\'s [[BoundingBox]] calculated for this instant in world space.\r\n         */\r\n        Actor.prototype.getBounds = function () {\r\n            // todo cache bounding box\r\n            var anchor = this._getCalculatedAnchor();\r\n            var pos = this.getWorldPos();\r\n            return new BoundingBox_8.BoundingBox(pos.x - anchor.x, pos.y - anchor.y, pos.x + this.getWidth() - anchor.x, pos.y + this.getHeight() - anchor.y).rotate(this.rotation, pos);\r\n        };\r\n        /**\r\n         * Returns the actor\'s [[BoundingBox]] relative to the actors position.\r\n         */\r\n        Actor.prototype.getRelativeBounds = function () {\r\n            // todo cache bounding box\r\n            var anchor = this._getCalculatedAnchor();\r\n            return new BoundingBox_8.BoundingBox(-anchor.x, -anchor.y, this.getWidth() - anchor.x, this.getHeight() - anchor.y).rotate(this.rotation);\r\n        };\r\n        /**\r\n         * Tests whether the x/y specified are contained in the actor\r\n         * @param x  X coordinate to test (in world coordinates)\r\n         * @param y  Y coordinate to test (in world coordinates)\r\n         * @param recurse checks whether the x/y are contained in any child actors (if they exist).\r\n         */\r\n        Actor.prototype.contains = function (x, y, recurse) {\r\n            if (recurse === void 0) { recurse = false; }\r\n            var containment = this.getBounds().contains(new Algebra_24.Vector(x, y));\r\n            if (recurse) {\r\n                return containment || this.children.some(function (child) {\r\n                    return child.contains(x, y, true);\r\n                });\r\n            }\r\n            return containment;\r\n        };\r\n        /**\r\n         * Returns the side of the collision based on the intersection\r\n         * @param intersect The displacement vector returned by a collision\r\n         */\r\n        Actor.prototype.getSideFromIntersect = function (intersect) {\r\n            if (intersect) {\r\n                if (Math.abs(intersect.x) > Math.abs(intersect.y)) {\r\n                    if (intersect.x < 0) {\r\n                        return Side_4.Side.Right;\r\n                    }\r\n                    return Side_4.Side.Left;\r\n                }\r\n                else {\r\n                    if (intersect.y < 0) {\r\n                        return Side_4.Side.Bottom;\r\n                    }\r\n                    return Side_4.Side.Top;\r\n                }\r\n            }\r\n            return Side_4.Side.None;\r\n        };\r\n        /**\r\n         * Test whether the actor has collided with another actor, returns the side of the current actor that collided.\r\n         * @param actor The other actor to test\r\n         */\r\n        Actor.prototype.collidesWithSide = function (actor) {\r\n            var separationVector = this.collides(actor);\r\n            if (!separationVector) {\r\n                return Side_4.Side.None;\r\n            }\r\n            if (Math.abs(separationVector.x) > Math.abs(separationVector.y)) {\r\n                if (this.pos.x < actor.pos.x) {\r\n                    return Side_4.Side.Right;\r\n                }\r\n                else {\r\n                    return Side_4.Side.Left;\r\n                }\r\n            }\r\n            else {\r\n                if (this.pos.y < actor.pos.y) {\r\n                    return Side_4.Side.Bottom;\r\n                }\r\n                else {\r\n                    return Side_4.Side.Top;\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * Test whether the actor has collided with another actor, returns the intersection vector on collision. Returns\r\n         * `null` when there is no collision;\r\n         * @param actor The other actor to test\r\n         */\r\n        Actor.prototype.collides = function (actor) {\r\n            var bounds = this.getBounds();\r\n            var otherBounds = actor.getBounds();\r\n            var intersect = bounds.collides(otherBounds);\r\n            return intersect;\r\n        };\r\n        /**\r\n         * Register a handler to fire when this actor collides with another in a specified group\r\n         * @param group The group name to listen for\r\n         * @param func The callback to fire on collision with another actor from the group. The callback is passed the other actor.\r\n         */\r\n        Actor.prototype.onCollidesWith = function (group, func) {\r\n            if (!this._collisionHandlers[group]) {\r\n                this._collisionHandlers[group] = [];\r\n            }\r\n            this._collisionHandlers[group].push(func);\r\n        };\r\n        Actor.prototype.getCollisionHandlers = function () {\r\n            return this._collisionHandlers;\r\n        };\r\n        /**\r\n         * Removes all collision handlers for this group on this actor\r\n         * @param group Group to remove all handlers for on this actor.\r\n         */\r\n        Actor.prototype.removeCollidesWith = function (group) {\r\n            this._collisionHandlers[group] = [];\r\n        };\r\n        /**\r\n         * Returns true if the two actors are less than or equal to the distance specified from each other\r\n         * @param actor     Actor to test\r\n         * @param distance  Distance in pixels to test\r\n         */\r\n        Actor.prototype.within = function (actor, distance) {\r\n            return Math.sqrt(Math.pow(this.pos.x - actor.pos.x, 2) + Math.pow(this.pos.y - actor.pos.y, 2)) <= distance;\r\n        };\r\n        Actor.prototype._getCalculatedAnchor = function () {\r\n            return new Algebra_24.Vector(this.getWidth() * this.anchor.x, this.getHeight() * this.anchor.y);\r\n        };\r\n        Actor.prototype._reapplyEffects = function (drawing) {\r\n            drawing.removeEffect(this._opacityFx);\r\n            drawing.addEffect(this._opacityFx);\r\n        };\r\n        /**\r\n         * Perform euler integration at the specified time step\r\n         */\r\n        Actor.prototype.integrate = function (delta) {\r\n            // Update placements based on linear algebra\r\n            var seconds = delta / 1000;\r\n            var totalAcc = this.acc.clone();\r\n            // Only active vanilla actors are affected by global acceleration\r\n            if (this.collisionType === CollisionType.Active) {\r\n                totalAcc.addEqual(Physics_13.Physics.acc);\r\n            }\r\n            this.vel.addEqual(totalAcc.scale(seconds));\r\n            this.pos.addEqual(this.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));\r\n            this.rx += this.torque * (1.0 / this.moi) * seconds;\r\n            this.rotation += this.rx * seconds;\r\n            this.scale.x += this.sx * delta / 1000;\r\n            this.scale.y += this.sy * delta / 1000;\r\n            // Update physics body\r\n            this.body.update();\r\n        };\r\n        /**\r\n         * Called by the Engine, updates the state of the actor\r\n         * @param engine The reference to the current game engine\r\n         * @param delta  The time elapsed since the last update in milliseconds\r\n         */\r\n        Actor.prototype.update = function (engine, delta) {\r\n            this._initialize(engine);\r\n            this.emit(\'preupdate\', new Events_14.PreUpdateEvent(engine, delta, this));\r\n            // Update action queue\r\n            this.actionQueue.update(delta);\r\n            // Update color only opacity\r\n            if (this.color) {\r\n                this.color.a = this.opacity;\r\n            }\r\n            // calculate changing opacity\r\n            if (this.previousOpacity !== this.opacity) {\r\n                this.previousOpacity = this.opacity;\r\n                this._opacityFx.opacity = this.opacity;\r\n                this._effectsDirty = true;\r\n            }\r\n            // Capture old values before integration step updates them\r\n            this.oldVel.setTo(this.vel.x, this.vel.y);\r\n            this.oldPos.setTo(this.pos.x, this.pos.y);\r\n            // Run Euler integration\r\n            this.integrate(delta);\r\n            // Update actor pipeline (movement, collision detection, event propagation, offscreen culling)\r\n            for (var _i = 0, _a = this.traits; _i < _a.length; _i++) {\r\n                var trait = _a[_i];\r\n                trait.update(this, engine, delta);\r\n            }\r\n            // Update child actors\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                this.children[i].update(engine, delta);\r\n            }\r\n            this.emit(\'postupdate\', new Events_14.PostUpdateEvent(engine, delta, this));\r\n        };\r\n        /**\r\n         * Called by the Engine, draws the actor to the screen\r\n         * @param ctx   The rendering context\r\n         * @param delta The time since the last draw in milliseconds\r\n         */\r\n        Actor.prototype.draw = function (ctx, delta) {\r\n            ctx.save();\r\n            ctx.translate(this.pos.x, this.pos.y);\r\n            ctx.rotate(this.rotation);\r\n            ctx.scale(this.scale.x, this.scale.y);\r\n            // translate canvas by anchor offset\r\n            ctx.save();\r\n            ctx.translate(-(this._width * this.anchor.x), -(this._height * this.anchor.y));\r\n            this.emit(\'predraw\', new Events_14.PreDrawEvent(ctx, delta, this));\r\n            if (this.currentDrawing) {\r\n                var drawing = this.currentDrawing;\r\n                // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula          \r\n                var offsetX = (this._width - drawing.naturalWidth * drawing.scale.x) * this.anchor.x;\r\n                var offsetY = (this._height - drawing.naturalHeight * drawing.scale.y) * this.anchor.y;\r\n                if (this._effectsDirty) {\r\n                    this._reapplyEffects(this.currentDrawing);\r\n                    this._effectsDirty = false;\r\n                }\r\n                this.currentDrawing.draw(ctx, offsetX, offsetY);\r\n            }\r\n            else {\r\n                if (this.color) {\r\n                    ctx.fillStyle = this.color.toString();\r\n                    ctx.fillRect(0, 0, this._width, this._height);\r\n                }\r\n            }\r\n            ctx.restore();\r\n            // Draw child actors\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                if (this.children[i].visible) {\r\n                    this.children[i].draw(ctx, delta);\r\n                }\r\n            }\r\n            this.emit(\'postdraw\', new Events_14.PostDrawEvent(ctx, delta, this));\r\n            ctx.restore();\r\n        };\r\n        /**\r\n         * Called by the Engine, draws the actors debugging to the screen\r\n         * @param ctx The rendering context\r\n         */\r\n        /* istanbul ignore next */\r\n        Actor.prototype.debugDraw = function (ctx) {\r\n            this.emit(\'predebugdraw\', new Events_14.PreDebugDrawEvent(ctx, this));\r\n            this.body.debugDraw(ctx);\r\n            // Draw actor bounding box\r\n            var bb = this.getBounds();\r\n            bb.debugDraw(ctx);\r\n            // Draw actor Id\r\n            ctx.fillText(\'id: \' + this.id, bb.left + 3, bb.top + 10);\r\n            // Draw actor anchor Vector\r\n            ctx.fillStyle = Color_20.Color.Yellow.toString();\r\n            ctx.beginPath();\r\n            ctx.arc(this.getWorldPos().x, this.getWorldPos().y, 3, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            // Culling Box debug draw\r\n            for (var j = 0; j < this.traits.length; j++) {\r\n                if (this.traits[j] instanceof Traits.OffscreenCulling) {\r\n                    this.traits[j].cullingBox.debugDraw(ctx);\r\n                }\r\n            }\r\n            // Unit Circle debug draw\r\n            ctx.strokeStyle = Color_20.Color.Yellow.toString();\r\n            ctx.beginPath();\r\n            var radius = Math.min(this.getWidth(), this.getHeight());\r\n            ctx.arc(this.getWorldPos().x, this.getWorldPos().y, radius, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n            var ticks = {\r\n                \'0 Pi\': 0,\r\n                \'Pi/2\': Math.PI / 2,\r\n                \'Pi\': Math.PI,\r\n                \'3/2 Pi\': 3 * Math.PI / 2\r\n            };\r\n            var oldFont = ctx.font;\r\n            for (var tick in ticks) {\r\n                ctx.fillStyle = Color_20.Color.Yellow.toString();\r\n                ctx.font = \'14px\';\r\n                ctx.textAlign = \'center\';\r\n                ctx.fillText(tick, this.getWorldPos().x + Math.cos(ticks[tick]) * (radius + 10), this.getWorldPos().y + Math.sin(ticks[tick]) * (radius + 10));\r\n            }\r\n            ctx.font = oldFont;\r\n            // Draw child actors\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                this.children[i].debugDraw(ctx);\r\n            }\r\n            this.emit(\'postdebugdraw\', new Events_14.PostDebugDrawEvent(ctx, this));\r\n        };\r\n        return Actor;\r\n    }(Class_11.Class));\r\n    /**\r\n     * Indicates the next id to be set\r\n     */\r\n    Actor.maxId = 0;\r\n    exports.Actor = Actor;\r\n    /**\r\n     * An enum that describes the types of collisions actors can participate in\r\n     */\r\n    var CollisionType;\r\n    (function (CollisionType) {\r\n        /**\r\n         * Actors with the `PreventCollision` setting do not participate in any\r\n         * collisions and do not raise collision events.\r\n         */\r\n        CollisionType[CollisionType["PreventCollision"] = 0] = "PreventCollision";\r\n        /**\r\n         * Actors with the `Passive` setting only raise collision events, but are not\r\n         * influenced or moved by other actors and do not influence or move other actors.\r\n         */\r\n        CollisionType[CollisionType["Passive"] = 1] = "Passive";\r\n        /**\r\n         * Actors with the `Active` setting raise collision events and participate\r\n         * in collisions with other actors and will be push or moved by actors sharing\r\n         * the `Active` or `Fixed` setting.\r\n         */\r\n        CollisionType[CollisionType["Active"] = 2] = "Active";\r\n        /**\r\n         * Actors with the `Fixed` setting raise collision events and participate in\r\n         * collisions with other actors. Actors with the `Fixed` setting will not be\r\n         * pushed or moved by other actors sharing the `Fixed`. Think of Fixed\r\n         * actors as "immovable/onstoppable" objects. If two `Fixed` actors meet they will\r\n         * not be pushed or moved by each other, they will not interact except to throw\r\n         * collision events.\r\n         */\r\n        CollisionType[CollisionType["Fixed"] = 3] = "Fixed";\r\n    })(CollisionType = exports.CollisionType || (exports.CollisionType = {}));\r\n});\r\ndefine("Actions/Action", ["require", "exports", "Actions/RotationType", "Algebra", "Util/Log", "Util/Util"], function (require, exports, RotationType_2, Algebra_25, Log_17, Util) {\r\n    "use strict";\r\n    Object.defineProperty(exports, "__esModule", { value: true });\r\n    var EaseTo = (function () {\r\n        function EaseTo(actor, x, y, duration, easingFcn) {\r\n            this.actor = actor;\r\n            this.easingFcn = easingFcn;\r\n            this._currentLerpTime = 0;\r\n            this._lerpDuration = 1 * 1000; // 1 second\r\n            this._lerpStart = new Algebra_25.Vector(0, 0);\r\n            this._lerpEnd = new Algebra_25.Vector(0, 0);\r\n            this._initialized = false;\r\n            this._stopped = false;\r\n            this._distance = 0;\r\n            this._lerpDuration = duration;\r\n            this._lerpEnd = new Algebra_25.Vector(x, y);\r\n        }\r\n        EaseTo.prototype._initialize = function () {\r\n            this._lerpStart = new Algebra_25.Vector(this.actor.pos.x, this.actor.pos.y);\r\n            this._currentLerpTime = 0;\r\n            this._distance = this._lerpStart.distance(this._lerpEnd);\r\n        };\r\n        EaseTo.prototype.update = function (delta) {\r\n            if (!this._initialized) {\r\n                this._initialize();\r\n                this._initialized = true;\r\n            }\r\n            var newX = this.actor.pos.x;\r\n            var newY = this.actor.pos.y;\r\n            if (this._currentLerpTime < this._lerpDuration) {\r\n                if (this._lerpEnd.x < this._lerpStart.x) {\r\n                    newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\r\n                }\r\n                else {\r\n                    newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\r\n                }\r\n                if (this._lerpEnd.y < this._lerpStart.y) {\r\n                    newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\r\n                }\r\n                else {\r\n                    newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\r\n                }\r\n                this.actor.pos.x = newX;\r\n                this.actor.pos.y = newY;\r\n                this._currentLerpTime += delta;\r\n            }\r\n            else {\r\n                this.actor.pos.x = this._lerpEnd.x;\r\n                this.actor.pos.y = this._lerpEnd.y;\r\n                //this._lerpStart = null;\r\n                //this._lerpEnd = null;\r\n                //this._currentLerpTime = 0;\r\n            }\r\n        };\r\n        EaseTo.prototype.isComplete = function (actor) {\r\n            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._lerpStart) >= this._distance;\r\n        };\r\n        EaseTo.prototype.reset = function () {\r\n            this._initialized = false;\r\n        };\r\n        EaseTo.prototype.stop = function () {\r\n            this._stopped = true;\r\n        };\r\n        return EaseTo;\r\n    }());\r\n    exports.EaseTo = EaseTo;\r\n    var MoveTo = (function () {\r\n        function MoveTo(actor, destx, desty, speed) {\r\n            this._started = false;\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._end = new Algebra_25.Vector(destx, desty);\r\n            this._speed = speed;\r\n        }\r\n        MoveTo.prototype.update = function (_delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n                this._start = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);\r\n                this._distance = this._start.distance(this._end);\r\n                this._dir = this._end.sub(this._start).normalize();\r\n            }\r\n            var m = this._dir.scale(this._speed);\r\n            this._actor.vel.x = m.x;\r\n            this._actor.vel.y = m.y;\r\n            if (this.isComplete(this._actor)) {\r\n                this._actor.pos.x = this._end.x;\r\n                this._actor.pos.y = this._end.y;\r\n                this._actor.vel.y = 0;\r\n                this._actor.vel.x = 0;\r\n            }\r\n        };\r\n        MoveTo.prototype.isComplete = function (actor) {\r\n            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._start) >= this._distance;\r\n        };\r\n        MoveTo.prototype.stop = function () {\r\n            this._actor.vel.y = 0;\r\n            this._actor.vel.x = 0;\r\n            this._stopped = true;\r\n        };\r\n        MoveTo.prototype.reset = function () {\r\n            this._started = false;\r\n        };\r\n        return MoveTo;\r\n    }());\r\n    exports.MoveTo = MoveTo;\r\n    var MoveBy = (function () {\r\n        function MoveBy(actor, destx, desty, time) {\r\n            this._started = false;\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._end = new Algebra_25.Vector(destx, desty);\r\n            if (time <= 0) {\r\n                Log_17.Logger.getInstance().error(\'Attempted to moveBy time less than or equal to zero : \' + time);\r\n                throw new Error(\'Cannot move in time <= 0\');\r\n            }\r\n            this._time = time;\r\n        }\r\n        MoveBy.prototype.update = function (_delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n                this._start = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);\r\n                this._distance = this._start.distance(this._end);\r\n                this._dir = this._end.sub(this._start).normalize();\r\n                this._speed = this._distance / (this._time / 1000);\r\n            }\r\n            var m = this._dir.scale(this._speed);\r\n            this._actor.vel.x = m.x;\r\n            this._actor.vel.y = m.y;\r\n            if (this.isComplete(this._actor)) {\r\n                this._actor.pos.x = this._end.x;\r\n                this._actor.pos.y = this._end.y;\r\n                this._actor.vel.y = 0;\r\n                this._actor.vel.x = 0;\r\n            }\r\n        };\r\n        MoveBy.prototype.isComplete = function (actor) {\r\n            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._start) >= this._distance;\r\n        };\r\n        MoveBy.prototype.stop = function () {\r\n            this._actor.vel.y = 0;\r\n            this._actor.vel.x = 0;\r\n            this._stopped = true;\r\n        };\r\n        MoveBy.prototype.reset = function () {\r\n            this._started = false;\r\n        };\r\n        return MoveBy;\r\n    }());\r\n    exports.MoveBy = MoveBy;\r\n    var Follow = (function () {\r\n        function Follow(actor, actorToFollow, followDistance) {\r\n            this._started = false;\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._actorToFollow = actorToFollow;\r\n            this._current = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);\r\n            this._end = new Algebra_25.Vector(actorToFollow.pos.x, actorToFollow.pos.y);\r\n            this._maximumDistance = (followDistance !== undefined) ? followDistance : this._current.distance(this._end);\r\n            this._speed = 0;\r\n        }\r\n        Follow.prototype.update = function (_delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n                this._distanceBetween = this._current.distance(this._end);\r\n                this._dir = this._end.sub(this._current).normalize();\r\n            }\r\n            var actorToFollowSpeed = Math.sqrt(Math.pow(this._actorToFollow.vel.x, 2) + Math.pow(this._actorToFollow.vel.y, 2));\r\n            if (actorToFollowSpeed !== 0) {\r\n                this._speed = actorToFollowSpeed;\r\n            }\r\n            this._current.x = this._actor.pos.x;\r\n            this._current.y = this._actor.pos.y;\r\n            this._end.x = this._actorToFollow.pos.x;\r\n            this._end.y = this._actorToFollow.pos.y;\r\n            this._distanceBetween = this._current.distance(this._end);\r\n            this._dir = this._end.sub(this._current).normalize();\r\n            if (this._distanceBetween >= this._maximumDistance) {\r\n                var m = this._dir.scale(this._speed);\r\n                this._actor.vel.x = m.x;\r\n                this._actor.vel.y = m.y;\r\n            }\r\n            else {\r\n                this._actor.vel.x = 0;\r\n                this._actor.vel.y = 0;\r\n            }\r\n            if (this.isComplete()) {\r\n                // TODO this should never occur\r\n                this._actor.pos.x = this._end.x;\r\n                this._actor.pos.y = this._end.y;\r\n                this._actor.vel.y = 0;\r\n                this._actor.vel.x = 0;\r\n            }\r\n        };\r\n        Follow.prototype.stop = function () {\r\n            this._actor.vel.y = 0;\r\n            this._actor.vel.x = 0;\r\n            this._stopped = true;\r\n        };\r\n        Follow.prototype.isComplete = function () {\r\n            // the actor following should never stop unless specified to do so\r\n            return this._stopped;\r\n        };\r\n        Follow.prototype.reset = function () {\r\n            this._started = false;\r\n        };\r\n        return Follow;\r\n    }());\r\n    exports.Follow = Follow;\r\n    var Meet = (function () {\r\n        function Meet(actor, actorToMeet, speed) {\r\n            this._started = false;\r\n            this._stopped = false;\r\n            this._speedWasSpecified = false;\r\n            this._actor = actor;\r\n            this._actorToMeet = actorToMeet;\r\n            this._current = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);\r\n            this._end = new Algebra_25.Vector(actorToMeet.pos.x, actorToMeet.pos.y);\r\n            this._speed = speed || 0;\r\n            if (speed !== undefined) {\r\n                this._speedWasSpecified = true;\r\n            }\r\n        }\r\n        Meet.prototype.update = function (_delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n                this._distanceBetween = this._current.distance(this._end);\r\n                this._dir = this._end.sub(this._current).normalize();\r\n            }\r\n            var actorToMeetSpeed = Math.sqrt(Math.pow(this._actorToMeet.vel.x, 2) + Math.pow(this._actorToMeet.vel.y, 2));\r\n            if ((actorToMeetSpeed !== 0) && (!this._speedWasSpecified)) {\r\n                this._speed = actorToMeetSpeed;\r\n            }\r\n            this._current.x = this._actor.pos.x;\r\n            this._current.y = this._actor.pos.y;\r\n            this._end.x = this._actorToMeet.pos.x;\r\n            this._end.y = this._actorToMeet.pos.y;\r\n            this._distanceBetween = this._current.distance(this._end);\r\n            this._dir = this._end.sub(this._current).normalize();\r\n            var m = this._dir.scale(this._speed);\r\n            this._actor.vel.x = m.x;\r\n            this._actor.vel.y = m.y;\r\n            if (this.isComplete()) {\r\n                this._actor.pos.x = this._end.x;\r\n                this._actor.pos.y = this._end.y;\r\n                this._actor.vel.y = 0;\r\n                this._actor.vel.x = 0;\r\n            }\r\n        };\r\n        Meet.prototype.isComplete = function () {\r\n            return this._stopped || (this._distanceBetween <= 1);\r\n        };\r\n        Meet.prototype.stop = function () {\r\n            this._actor.vel.y = 0;\r\n            this._actor.vel.x = 0;\r\n            this._stopped = true;\r\n        };\r\n        Meet.prototype.reset = function () {\r\n            this._started = false;\r\n        };\r\n        return Meet;\r\n    }());\r\n    exports.Meet = Meet;\r\n    var RotateTo = (function () {\r\n        function RotateTo(actor, angleRadians, speed, rotationType) {\r\n            this._started = false;\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._end = angleRadians;\r\n            this._speed = speed;\r\n            this._rotationType = rotationType || RotationType_2.RotationType.ShortestPath;\r\n        }\r\n        RotateTo.prototype.update = function (_delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n                this._start = this._actor.rotation;\r\n                var distance1 = Math.abs(this._end - this._start);\r\n                var distance2 = Util.TwoPI - distance1;\r\n                if (distance1 > distance2) {\r\n                    this._shortDistance = distance2;\r\n                    this._longDistance = distance1;\r\n                }\r\n                else {\r\n                    this._shortDistance = distance1;\r\n                    this._longDistance = distance2;\r\n                }\r\n                this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;\r\n                switch (this._rotationType) {\r\n                    case RotationType_2.RotationType.ShortestPath:\r\n                        this._distance = this._shortDistance;\r\n                        if (this._shortestPathIsPositive) {\r\n                            this._direction = 1;\r\n                        }\r\n                        else {\r\n                            this._direction = -1;\r\n                        }\r\n                        break;\r\n                    case RotationType_2.RotationType.LongestPath:\r\n                        this._distance = this._longDistance;\r\n                        if (this._shortestPathIsPositive) {\r\n                            this._direction = -1;\r\n                        }\r\n                        else {\r\n                            this._direction = 1;\r\n                        }\r\n                        break;\r\n                    case RotationType_2.RotationType.Clockwise:\r\n                        this._direction = 1;\r\n                        if (this._shortestPathIsPositive) {\r\n                            this._distance = this._shortDistance;\r\n                        }\r\n                        else {\r\n                            this._distance = this._longDistance;\r\n                        }\r\n                        break;\r\n                    case RotationType_2.RotationType.CounterClockwise:\r\n                        this._direction = -1;\r\n                        if (!this._shortestPathIsPositive) {\r\n                            this._distance = this._shortDistance;\r\n                        }\r\n                        else {\r\n                            this._distance = this._longDistance;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            this._actor.rx = this._direction * this._speed;\r\n            if (this.isComplete()) {\r\n                this._actor.rotation = this._end;\r\n                this._actor.rx = 0;\r\n                this._stopped = true;\r\n            }\r\n        };\r\n        RotateTo.prototype.isComplete = function () {\r\n            var distanceTravelled = Math.abs(this._actor.rotation - this._start);\r\n            return this._stopped || (distanceTravelled >= Math.abs(this._distance));\r\n        };\r\n        RotateTo.prototype.stop = function () {\r\n            this._actor.rx = 0;\r\n            this._stopped = true;\r\n        };\r\n        RotateTo.prototype.reset = function () {\r\n            this._started = false;\r\n        };\r\n        return RotateTo;\r\n    }());\r\n    exports.RotateTo = RotateTo;\r\n    var RotateBy = (function () {\r\n        function RotateBy(actor, angleRadians, time, rotationType) {\r\n            this._started = false;\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._end = angleRadians;\r\n            this._time = time;\r\n            this._rotationType = rotationType || RotationType_2.RotationType.ShortestPath;\r\n        }\r\n        RotateBy.prototype.update = function (_delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n                this._start = this._actor.rotation;\r\n                var distance1 = Math.abs(this._end - this._start);\r\n                var distance2 = Util.TwoPI - distance1;\r\n                if (distance1 > distance2) {\r\n                    this._shortDistance = distance2;\r\n                    this._longDistance = distance1;\r\n                }\r\n                else {\r\n                    this._shortDistance = distance1;\r\n                    this._longDistance = distance2;\r\n                }\r\n                this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;\r\n                switch (this._rotationType) {\r\n                    case RotationType_2.RotationType.ShortestPath:\r\n                        this._distance = this._shortDistance;\r\n                        if (this._shortestPathIsPositive) {\r\n                            this._direction = 1;\r\n                        }\r\n                        else {\r\n                            this._direction = -1;\r\n                        }\r\n                        break;\r\n                    case RotationType_2.RotationType.LongestPath:\r\n                        this._distance = this._longDistance;\r\n                        if (this._shortestPathIsPositive) {\r\n                            this._direction = -1;\r\n                        }\r\n                        else {\r\n                            this._direction = 1;\r\n                        }\r\n                        break;\r\n                    case RotationType_2.RotationType.Clockwise:\r\n                        this._direction = 1;\r\n                        if (this._shortDistance >= 0) {\r\n                            this._distance = this._shortDistance;\r\n                        }\r\n                        else {\r\n                            this._distance = this._longDistance;\r\n                        }\r\n                        break;\r\n                    case RotationType_2.RotationType.CounterClockwise:\r\n                        this._direction = -1;\r\n                        if (this._shortDistance <= 0) {\r\n                            this._distance = this._shortDistance;\r\n                        }\r\n                        else {\r\n                            this._distance = this._longDistance;\r\n                        }\r\n                        break;\r\n                }\r\n                this._speed = Math.abs(this._distance / this._time * 1000);\r\n            }\r\n            this._actor.rx = this._direction * this._speed;\r\n            if (this.isComplete()) {\r\n                this._actor.rotation = this._end;\r\n                this._actor.rx = 0;\r\n                this._stopped = true;\r\n            }\r\n        };\r\n        RotateBy.prototype.isComplete = function () {\r\n            var distanceTravelled = Math.abs(this._actor.rotation - this._start);\r\n            return this._stopped || (distanceTravelled >= Math.abs(this._distance));\r\n        };\r\n        RotateBy.prototype.stop = function () {\r\n            this._actor.rx = 0;\r\n            this._stopped = true;\r\n        };\r\n        RotateBy.prototype.reset = function () {\r\n            this._started = false;\r\n        };\r\n        return RotateBy;\r\n    }());\r\n    exports.RotateBy = RotateBy;\r\n    var ScaleTo = (function () {\r\n        function ScaleTo(actor, scaleX, scaleY, speedX, speedY) {\r\n            this._started = false;\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._endX = scaleX;\r\n            this._endY = scaleY;\r\n            this._speedX = speedX;\r\n            this._speedY = speedY;\r\n        }\r\n        ScaleTo.prototype.update = function (_delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n                this._startX = this._actor.scale.x;\r\n                this._startY = this._actor.scale.y;\r\n                this._distanceX = Math.abs(this._endX - this._startX);\r\n                this._distanceY = Math.abs(this._endY - this._startY);\r\n            }\r\n            if (!(Math.abs(this._actor.scale.x - this._startX) >= this._distanceX)) {\r\n                var directionX = this._endY < this._startY ? -1 : 1;\r\n                this._actor.sx = this._speedX * directionX;\r\n            }\r\n            else {\r\n                this._actor.sx = 0;\r\n            }\r\n            if (!(Math.abs(this._actor.scale.y - this._startY) >= this._distanceY)) {\r\n                var directionY = this._endY < this._startY ? -1 : 1;\r\n                this._actor.sy = this._speedY * directionY;\r\n            }\r\n            else {\r\n                this._actor.sy = 0;\r\n            }\r\n            if (this.isComplete()) {\r\n                this._actor.scale.x = this._endX;\r\n                this._actor.scale.y = this._endY;\r\n                this._actor.sx = 0;\r\n                this._actor.sy = 0;\r\n            }\r\n        };\r\n        ScaleTo.prototype.isComplete = function () {\r\n            return this._stopped || ((Math.abs(this._actor.scale.y - this._startX) >= this._distanceX) &&\r\n                (Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));\r\n        };\r\n        ScaleTo.prototype.stop = function () {\r\n            this._actor.sx = 0;\r\n            this._actor.sy = 0;\r\n            this._stopped = true;\r\n        };\r\n        ScaleTo.prototype.reset = function () {\r\n            this._started = false;\r\n        };\r\n        return ScaleTo;\r\n    }());\r\n    exports.ScaleTo = ScaleTo;\r\n    var ScaleBy = (function () {\r\n        function ScaleBy(actor, scaleX, scaleY, time) {\r\n            this._started = false;\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._endX = scaleX;\r\n            this._endY = scaleY;\r\n            this._time = time;\r\n            this._speedX = (this._endX - this._actor.scale.x) / time * 1000;\r\n            this._speedY = (this._endY - this._actor.scale.y) / time * 1000;\r\n        }\r\n        ScaleBy.prototype.update = function (_delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n                this._startX = this._actor.scale.x;\r\n                this._startY = this._actor.scale.y;\r\n                this._distanceX = Math.abs(this._endX - this._startX);\r\n                this._distanceY = Math.abs(this._endY - this._startY);\r\n            }\r\n            var directionX = this._endX < this._startX ? -1 : 1;\r\n            var directionY = this._endY < this._startY ? -1 : 1;\r\n            this._actor.sx = this._speedX * directionX;\r\n            this._actor.sy = this._speedY * directionY;\r\n            if (this.isComplete()) {\r\n                this._actor.scale.x = this._endX;\r\n                this._actor.scale.y = this._endY;\r\n                this._actor.sx = 0;\r\n                this._actor.sy = 0;\r\n            }\r\n        };\r\n        ScaleBy.prototype.isComplete = function () {\r\n            return this._stopped || ((Math.abs(this._actor.scale.x - this._startX) >= this._distanceX) &&\r\n                (Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));\r\n        };\r\n        ScaleBy.prototype.stop = function () {\r\n            this._actor.sx = 0;\r\n            this._actor.sy = 0;\r\n            this._stopped = true;\r\n        };\r\n        ScaleBy.prototype.reset = function () {\r\n            this._started = false;\r\n        };\r\n        return ScaleBy;\r\n    }());\r\n    exports.ScaleBy = ScaleBy;\r\n    var Delay = (function () {\r\n        function Delay(actor, delay) {\r\n            this._elapsedTime = 0;\r\n            this._started = false;\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._delay = delay;\r\n        }\r\n        Delay.prototype.update = function (delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n            }\r\n            this.x = this._actor.pos.x;\r\n            this.y = this._actor.pos.y;\r\n            this._elapsedTime += delta;\r\n        };\r\n        Delay.prototype.isComplete = function () {\r\n            return this._stopped || (this._elapsedTime >= this._delay);\r\n        };\r\n        Delay.prototype.stop = function () {\r\n            this._stopped = true;\r\n        };\r\n        Delay.prototype.reset = function () {\r\n            this._elapsedTime = 0;\r\n            this._started = false;\r\n        };\r\n        return Delay;\r\n    }());\r\n    exports.Delay = Delay;\r\n    var Blink = (function () {\r\n        function Blink(actor, timeVisible, timeNotVisible, numBlinks) {\r\n            if (numBlinks === void 0) { numBlinks = 1; }\r\n            this._timeVisible = 0;\r\n            this._timeNotVisible = 0;\r\n            this._elapsedTime = 0;\r\n            this._totalTime = 0;\r\n            this._stopped = false;\r\n            this._started = false;\r\n            this._actor = actor;\r\n            this._timeVisible = timeVisible;\r\n            this._timeNotVisible = timeNotVisible;\r\n            this._duration = (timeVisible + timeNotVisible) * numBlinks;\r\n        }\r\n        Blink.prototype.update = function (delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n            }\r\n            this._elapsedTime += delta;\r\n            this._totalTime += delta;\r\n            if (this._actor.visible && this._elapsedTime >= this._timeVisible) {\r\n                this._actor.visible = false;\r\n                this._elapsedTime = 0;\r\n            }\r\n            if (!this._actor.visible && this._elapsedTime >= this._timeNotVisible) {\r\n                this._actor.visible = true;\r\n                this._elapsedTime = 0;\r\n            }\r\n            if (this.isComplete()) {\r\n                this._actor.visible = true;\r\n            }\r\n        };\r\n        Blink.prototype.isComplete = function () {\r\n            return this._stopped || (this._totalTime >= this._duration);\r\n        };\r\n        Blink.prototype.stop = function () {\r\n            this._actor.visible = true;\r\n            this._stopped = true;\r\n        };\r\n        Blink.prototype.reset = function () {\r\n            this._started = false;\r\n            this._elapsedTime = 0;\r\n            this._totalTime = 0;\r\n        };\r\n        return Blink;\r\n    }());\r\n    exports.Blink = Blink;\r\n    var Fade = (function () {\r\n        function Fade(actor, endOpacity, speed) {\r\n            this._multiplier = 1;\r\n            this._started = false;\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._endOpacity = endOpacity;\r\n            this._speed = speed;\r\n        }\r\n        Fade.prototype.update = function (delta) {\r\n            if (!this._started) {\r\n                this._started = true;\r\n                // determine direction when we start\r\n                if (this._endOpacity < this._actor.opacity) {\r\n                    this._multiplier = -1;\r\n                }\r\n                else {\r\n                    this._multiplier = 1;\r\n                }\r\n            }\r\n            if (this._speed > 0) {\r\n                this._actor.opacity += this._multiplier * (Math.abs(this._actor.opacity - this._endOpacity) * delta) / this._speed;\r\n            }\r\n            this._speed -= delta;\r\n            if (this.isComplete()) {\r\n                this._actor.opacity = this._endOpacity;\r\n            }\r\n            Log_17.Logger.getInstance().debug(\'[Action fade] Actor opacity:\', this._actor.opacity);\r\n        };\r\n        Fade.prototype.isComplete = function () {\r\n            return this._stopped || (Math.abs(this._actor.opacity - this._endOpacity) < 0.05);\r\n        };\r\n        Fade.prototype.stop = function () {\r\n            this._stopped = true;\r\n        };\r\n        Fade.prototype.reset = function () {\r\n            this._started = false;\r\n        };\r\n        return Fade;\r\n    }());\r\n    exports.Fade = Fade;\r\n    var Die = (function () {\r\n        function Die(actor) {\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n        }\r\n        Die.prototype.update = function (_delta) {\r\n            this._actor.actionQueue.clearActions();\r\n            this._actor.kill();\r\n            this._stopped = true;\r\n        };\r\n        Die.prototype.isComplete = function () {\r\n            return this._stopped;\r\n        };\r\n        Die.prototype.stop = function () { return; };\r\n        Die.prototype.reset = function () { return; };\r\n        return Die;\r\n    }());\r\n    exports.Die = Die;\r\n    var CallMethod = (function () {\r\n        function CallMethod(actor, method) {\r\n            this._method = null;\r\n            this._actor = null;\r\n            this._hasBeenCalled = false;\r\n            this._actor = actor;\r\n            this._method = method;\r\n        }\r\n        CallMethod.prototype.update = function (_delta) {\r\n            this._method.call(this._actor);\r\n            this._hasBeenCalled = true;\r\n        };\r\n        CallMethod.prototype.isComplete = function () {\r\n            return this._hasBeenCalled;\r\n        };\r\n        CallMethod.prototype.reset = function () {\r\n            this._hasBeenCalled = false;\r\n        };\r\n        CallMethod.prototype.stop = function () {\r\n            this._hasBeenCalled = true;\r\n        };\r\n        return CallMethod;\r\n    }());\r\n    exports.CallMethod = CallMethod;\r\n    var Repeat = (function () {\r\n        function Repeat(actor, repeat, actions) {\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._actionQueue = new ActionQueue(actor);\r\n            this._repeat = repeat;\r\n            this._originalRepeat = repeat;\r\n            var i = 0, len = actions.length;\r\n            for (i; i < len; i++) {\r\n                actions[i].reset();\r\n                this._actionQueue.add(actions[i]);\r\n            }\r\n            ;\r\n        }\r\n        Repeat.prototype.update = function (delta) {\r\n            this.x = this._actor.pos.x;\r\n            this.y = this._actor.pos.y;\r\n            if (!this._actionQueue.hasNext()) {\r\n                this._actionQueue.reset();\r\n                this._repeat--;\r\n            }\r\n            this._actionQueue.update(delta);\r\n        };\r\n        Repeat.prototype.isComplete = function () {\r\n            return this._stopped || (this._repeat <= 0);\r\n        };\r\n        Repeat.prototype.stop = function () {\r\n            this._stopped = true;\r\n        };\r\n        Repeat.prototype.reset = function () {\r\n            this._repeat = this._originalRepeat;\r\n        };\r\n        return Repeat;\r\n    }());\r\n    exports.Repeat = Repeat;\r\n    var RepeatForever = (function () {\r\n        function RepeatForever(actor, actions) {\r\n            this._stopped = false;\r\n            this._actor = actor;\r\n            this._actionQueue = new ActionQueue(actor);\r\n            var i = 0, len = actions.length;\r\n            for (i; i < len; i++) {\r\n                actions[i].reset();\r\n                this._actionQueue.add(actions[i]);\r\n            }\r\n            ;\r\n        }\r\n        RepeatForever.prototype.update = function (delta) {\r\n            this.x = this._actor.pos.x;\r\n            this.y = this._actor.pos.y;\r\n            if (this._stopped) {\r\n                return;\r\n            }\r\n            if (!this._actionQueue.hasNext()) {\r\n                this._actionQueue.reset();\r\n            }\r\n            this._actionQueue.update(delta);\r\n        };\r\n        RepeatForever.prototype.isComplete = function () {\r\n            return this._stopped;\r\n        };\r\n        RepeatForever.prototype.stop = function () {\r\n            this._stopped = true;\r\n            this._actionQueue.clearActions();\r\n        };\r\n        RepeatForever.prototype.reset = function () { return; };\r\n        return RepeatForever;\r\n    }());\r\n    exports.RepeatForever = RepeatForever;\r\n    /**\r\n     * Action Queues\r\n     *\r\n     * Action queues are part of the [[ActionContext|Action API]] and\r\n     * store the list of actions to be executed for an [[Actor]].\r\n     *\r\n     * Actors implement [[Actor.actions]] which can be manipulated by\r\n     * advanced users to adjust the actions currently being executed in the\r\n     * queue.\r\n     */\r\n    var ActionQueue = (function () {\r\n        function ActionQueue(actor) {\r\n            this._actions = [];\r\n            this._completedActions = [];\r\n            this._actor = actor;\r\n        }\r\n        ActionQueue.prototype.add = function (action) {\r\n            this._actions.push(action);\r\n        };\r\n        ActionQueue.prototype.remove = function (action) {\r\n            var index = this._actions.indexOf(action);\r\n            this._actions.splice(index, 1);\r\n        };\r\n        ActionQueue.prototype.clearActions = function () {\r\n            this._actions.length = 0;\r\n            this._completedActions.length = 0;\r\n            if (this._currentAction) {\r\n                this._currentAction.stop();\r\n            }\r\n        };\r\n        ActionQueue.prototype.getActions = function () {\r\n            return this._actions.concat(this._completedActions);\r\n        };\r\n        ActionQueue.prototype.hasNext = function () {\r\n            return this._actions.length > 0;\r\n        };\r\n        ActionQueue.prototype.reset = function () {\r\n            this._actions = this.getActions();\r\n            var i = 0, len = this._actions.length;\r\n            for (i; i < len; i++) {\r\n                this._actions[i].reset();\r\n            }\r\n            this._completedActions = [];\r\n        };\r\n        ActionQueue.prototype.update = function (delta) {\r\n            if (this._actions.length > 0) {\r\n                this._currentAction = this._actions[0];\r\n                this._currentAction.update(delta);\r\n                if (this._currentAction.isComplete(this._actor)) {\r\n                    this._completedActions.push(this._actions.shift());\r\n                }\r\n            }\r\n        };\r\n        return ActionQueue;\r\n    }());\r\n    exports.ActionQueue = ActionQueue;\r\n});\r\n/* istanbul ignore next */\r\nif (typeof window === \'undefined\') {\r\n    window = { audioContext: function () { return; } };\r\n}\r\n/* istanbul ignore next */\r\nif (typeof window !== \'undefined\' && !window.requestAnimationFrame) {\r\n    window.requestAnimationFrame =\r\n        window.webkitRequestAnimationFrame ||\r\n            window.mozRequestAnimationFrame ||\r\n            function (callback) { window.setInterval(callback, 1000 / 60); };\r\n}\r\n/* istanbul ignore next */\r\nif (typeof window !== \'undefined\' && !window.cancelAnimationFrame) {\r\n    window.cancelAnimationFrame =\r\n        window.webkitCancelAnimationFrame ||\r\n            window.mozCancelAnimationFrame ||\r\n            function () { return; };\r\n}\r\n/* istanbul ignore next */\r\nif (typeof window !== \'undefined\' && !window.AudioContext) {\r\n    window.AudioContext = window.AudioContext ||\r\n        window.webkitAudioContext ||\r\n        window.mozAudioContext ||\r\n        window.msAudioContext ||\r\n        window.oAudioContext;\r\n}\r\nif (typeof window !== \'undefined\' && !window.devicePixelRatio) {\r\n    window.devicePixelRatio = window.devicePixelRatio || 1;\r\n}\r\n// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n// Production steps of ECMA-262, Edition 5, 15.4.4.18\r\n// Reference: http://es5.github.io/#x15.4.4.18\r\n/* istanbul ignore next */\r\nif (!Array.prototype.forEach) {\r\n    Array.prototype.forEach = function (callback, thisArg) {\r\n        var T, k;\r\n        if (this == null) {\r\n            throw new TypeError(\'this is null or not defined\');\r\n        }\r\n        // 1. Let O be the result of calling ToObject passing the |this| value as the argument. \r\n        var O = Object(this);\r\n        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".\r\n        // 3. Let len be ToUint32(lenValue).\r\n        var len = O.length >>> 0;\r\n        // 4. If IsCallable(callback) is false, throw a TypeError exception.\r\n        // See: http://es5.github.com/#x9.11\r\n        if (typeof callback !== \'function\') {\r\n            throw new TypeError(callback + \' is not a function\');\r\n        }\r\n        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\r\n        if (arguments.length > 1) {\r\n            T = thisArg;\r\n        }\r\n        // 6. Let k be 0\r\n        k = 0;\r\n        // 7. Repeat, while k < len\r\n        while (k < len) {\r\n            var kValue;\r\n            // a. Let Pk be ToString(k).\r\n            //   This is implicit for LHS operands of the in operator\r\n            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.\r\n            //   This step can be combined with c\r\n            // c. If kPresent is true, then\r\n            if (k in O) {\r\n                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.\r\n                kValue = O[k];\r\n                // ii. Call the Call internal method of callback with T as the this value and\r\n                // argument list containing kValue, k, and O.\r\n                callback.call(T, kValue, k, O);\r\n            }\r\n            // d. Increase k by 1.\r\n            k++;\r\n        }\r\n        // 8. return undefined\r\n    };\r\n}\r\n// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some\r\n/* istanbul ignore next */\r\nif (!Array.prototype.some) {\r\n    Array.prototype.some = function (fun /*, thisArg */) {\r\n        \'use strict\';\r\n        if (this === void 0 || this === null) {\r\n            throw new TypeError();\r\n        }\r\n        var t = Object(this);\r\n        var len = t.length >>> 0;\r\n        if (typeof fun !== \'function\') {\r\n            throw new TypeError();\r\n        }\r\n        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\r\n        for (var i = 0; i < len; i++) {\r\n            if (i in t && fun.call(thisArg, t[i], i, t)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n}\r\n// Polyfill from  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill\r\n/* istanbul ignore next */\r\nif (!Function.prototype.bind) {\r\n    Function.prototype.bind = function (oThis) {\r\n        if (typeof this !== \'function\') {\r\n            // closest thing possible to the ECMAScript 5\r\n            // internal IsCallable function\r\n            throw new TypeError(\'Function.prototype.bind - what is trying to be bound is not callable\');\r\n        }\r\n        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () { return; }, fBound = function () {\r\n            return fToBind.apply(this instanceof fNOP && oThis\r\n                ? this\r\n                : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\r\n        };\r\n        fNOP.prototype = this.prototype;\r\n        fBound.prototype = new fNOP();\r\n        return fBound;\r\n    };\r\n}\r\n    //The modules for your project will be inlined above\r\n    //this snippet. Ask almond to synchronously require the\r\n    //module value for \'main\' here and return it as the\r\n    //value to use for the public API for the built file.\r\n    return require(\'Index\');\r\n}));\r\n//# sourceMappingURL=excalibur.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vbm9kZV9tb2R1bGVzL2V4Y2FsaWJ1ci9kaXN0L2V4Y2FsaWJ1ci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQUE7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMENBQTBDO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix1RkFBdUY7QUFDdkY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssbUVBQW1FO0FBQ3hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnSEFBZ0g7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUZBQXFGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkRBQTZEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1FQUFtRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJDQUEyQztBQUNoRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0NBQXNDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkRBQTZEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFDQUFxQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQywyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVO0FBQzVDLGlDQUFpQyxTQUFTO0FBQzFDLG1DQUFtQyxXQUFXO0FBQzlDLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1Q0FBdUM7QUFDMUUsNERBQTRELCtCQUErQixFQUFFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4QkFBOEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEUsbUNBQW1DLGVBQWU7QUFDbEQsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUMsZ0NBQWdDLDhCQUE4QjtBQUM5RCw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1REFBdUQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUcsaUdBQWlHO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQkFBK0IsMEVBQTBFO0FBQ3pHO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzREFBc0Q7QUFDN0Y7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsc0JBQXNCLEVBQUU7QUFDL0U7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCw0Q0FBNEMsUUFBUTtBQUNwRCx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakMsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1REFBdUQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywwREFBMEQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMERBQTBEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDBEQUEwRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQsMkNBQTJDLFFBQVE7QUFDbkQsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNCQUFzQixFQUFFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCLDRCQUE0QixFQUFFO0FBQ25FLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3QkFBd0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELCtCQUErQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwrQkFBK0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQseUNBQXlDLFFBQVE7QUFDakQsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxnQ0FBZ0M7QUFDaEMscUJBQXFCLEdBQUcsd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUNBQXlDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0VBQWdFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3QkFBd0IsRUFBRTtBQUMzRSxxREFBcUQseUNBQXlDLEVBQUU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQkFBb0IsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckMsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RCw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3Qix1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEsRUFBRTtBQUN2Qyw2QkFBNkIsYUFBYSxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUI7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVIQUF1SDtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxrQ0FBa0M7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvQkFBb0IsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQixFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseUJBQXlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkMsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0VBQWdFO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlFQUF5RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQsdUNBQXVDLHNDQUFzQztBQUM3RTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQyx5Q0FBeUM7QUFDekMsOEJBQThCO0FBQzlCO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esa0RBQWtEO0FBQ2xELG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLGtCQUFrQjtBQUNsQiw0REFBNEQ7QUFDNUQ7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsOEJBQThCO0FBQzlCLDBEQUEwRDtBQUMxRDtBQUNBLCtFQUErRTtBQUMvRSwrRUFBK0U7QUFDL0Usa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxzRUFBc0U7QUFDdEUsNkRBQTZEO0FBQzdEO0FBQ0EsNEJBQTRCO0FBQzVCLHVGQUF1RjtBQUN2Rix5RkFBeUY7QUFDekYsNEZBQTRGO0FBQzVGLCtCQUErQjtBQUMvQix1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDLG9DQUFvQztBQUNwQyxpRUFBaUU7QUFDakUsaUVBQWlFO0FBQ2pFLDZDQUE2QztBQUM3QyxvQ0FBb0M7QUFDcEM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDhCQUE4QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsK0RBQStEO0FBQy9ELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Qsd0VBQXdFO0FBQ3hFLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsK0RBQStEO0FBQy9ELDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HO0FBQ0E7QUFDQSxvSEFBb0g7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usb0JBQW9CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9CQUFvQixFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9EQUFvRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJDQUEyQztBQUNoRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0VBQWdFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0VBQXNFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlFQUF5RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtRUFBbUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUNBQWlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyQ0FBMkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsaURBQWlEO0FBQ2pELG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGlEQUFpRDtBQUNqRCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdFQUFnRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyRkFBMkY7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNDQUFzQztBQUN6RjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsY0FBYyxvQkFBb0IsZUFBZSxrQkFBa0IsbUJBQW1CO0FBQ2xNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlILGdCQUFnQjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx5QkFBeUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQ0FBc0M7QUFDM0U7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0VBQXNFO0FBQzNFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QixRQUFRLEVBQUU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csUUFBUSxFQUFFO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBleGNhbGlidXIgLSB2MC4xNC4wIC0gMjAxNy0xMi0wMlxyXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXJcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTcgRXhjYWxpYnVyLmpzIDxodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyL2dyYXBocy9jb250cmlidXRvcnM+OyBMaWNlbnNlZCBCU0QtMi1DbGF1c2VcclxuKiBAcHJlc2VydmUgKi9cclxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChyb290LmV4ID0gZmFjdG9yeShiKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XHJcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXHJcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcclxuICAgICAgICByb290LmV4ID0gZmFjdG9yeSgpO1xyXG4gICAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuICAgIC8vYWxtb25kLCBhbmQgeW91ciBtb2R1bGVzIHdpbGwgYmUgaW5saW5lZCBoZXJlXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBhbG1vbmQgMC4zLjMgQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMuXHJcbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLCBodHRwOi8vZ2l0aHViLmNvbS9yZXF1aXJlanMvYWxtb25kL0xJQ0VOU0VcclxuICovXHJcbi8vR29pbmcgc2xvcHB5IHRvIGF2b2lkICd1c2Ugc3RyaWN0JyBzdHJpbmcgY29zdCwgYnV0IHN0cmljdCBwcmFjdGljZXMgc2hvdWxkXHJcbi8vYmUgZm9sbG93ZWQuXHJcbi8qZ2xvYmFsIHNldFRpbWVvdXQ6IGZhbHNlICovXHJcblxyXG52YXIgcmVxdWlyZWpzLCByZXF1aXJlLCBkZWZpbmU7XHJcbihmdW5jdGlvbiAodW5kZWYpIHtcclxuICAgIHZhciBtYWluLCByZXEsIG1ha2VNYXAsIGhhbmRsZXJzLFxyXG4gICAgICAgIGRlZmluZWQgPSB7fSxcclxuICAgICAgICB3YWl0aW5nID0ge30sXHJcbiAgICAgICAgY29uZmlnID0ge30sXHJcbiAgICAgICAgZGVmaW5pbmcgPSB7fSxcclxuICAgICAgICBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxyXG4gICAgICAgIGFwcyA9IFtdLnNsaWNlLFxyXG4gICAgICAgIGpzU3VmZml4UmVnRXhwID0gL1xcLmpzJC87XHJcblxyXG4gICAgZnVuY3Rpb24gaGFzUHJvcChvYmosIHByb3ApIHtcclxuICAgICAgICByZXR1cm4gaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgcmVsYXRpdmUgbW9kdWxlIG5hbWUsIGxpa2UgLi9zb21ldGhpbmcsIG5vcm1hbGl6ZSBpdCB0b1xyXG4gICAgICogYSByZWFsIG5hbWUgdGhhdCBjYW4gYmUgbWFwcGVkIHRvIGEgcGF0aC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSByZWxhdGl2ZSBuYW1lXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYmFzZU5hbWUgYSByZWFsIG5hbWUgdGhhdCB0aGUgbmFtZSBhcmcgaXMgcmVsYXRpdmVcclxuICAgICAqIHRvLlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gbm9ybWFsaXplZCBuYW1lXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xyXG4gICAgICAgIHZhciBuYW1lUGFydHMsIG5hbWVTZWdtZW50LCBtYXBWYWx1ZSwgZm91bmRNYXAsIGxhc3RJbmRleCxcclxuICAgICAgICAgICAgZm91bmRJLCBmb3VuZFN0YXJNYXAsIHN0YXJJLCBpLCBqLCBwYXJ0LCBub3JtYWxpemVkQmFzZVBhcnRzLFxyXG4gICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlTmFtZSAmJiBiYXNlTmFtZS5zcGxpdChcIi9cIiksXHJcbiAgICAgICAgICAgIG1hcCA9IGNvbmZpZy5tYXAsXHJcbiAgICAgICAgICAgIHN0YXJNYXAgPSAobWFwICYmIG1hcFsnKiddKSB8fCB7fTtcclxuXHJcbiAgICAgICAgLy9BZGp1c3QgYW55IHJlbGF0aXZlIHBhdGhzLlxyXG4gICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IG5hbWUubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdhbnRpbmcgbm9kZSBJRCBjb21wYXRpYmlsaXR5LCBzdHJpcCAuanMgZnJvbSBlbmRcclxuICAgICAgICAgICAgLy8gb2YgSURzLiBIYXZlIHRvIGRvIHRoaXMgaGVyZSwgYW5kIG5vdCBpbiBuYW1lVG9VcmxcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBub2RlIGFsbG93cyBlaXRoZXIgLmpzIG9yIG5vbiAuanMgdG8gbWFwXHJcbiAgICAgICAgICAgIC8vIHRvIHNhbWUgZmlsZS5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5ub2RlSWRDb21wYXQgJiYganNTdWZmaXhSZWdFeHAudGVzdChuYW1lW2xhc3RJbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lW2xhc3RJbmRleF0gPSBuYW1lW2xhc3RJbmRleF0ucmVwbGFjZShqc1N1ZmZpeFJlZ0V4cCwgJycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdGFydHMgd2l0aCBhICcuJyBzbyBuZWVkIHRoZSBiYXNlTmFtZVxyXG4gICAgICAgICAgICBpZiAobmFtZVswXS5jaGFyQXQoMCkgPT09ICcuJyAmJiBiYXNlUGFydHMpIHtcclxuICAgICAgICAgICAgICAgIC8vQ29udmVydCBiYXNlTmFtZSB0byBhcnJheSwgYW5kIGxvcCBvZmYgdGhlIGxhc3QgcGFydCxcclxuICAgICAgICAgICAgICAgIC8vc28gdGhhdCAuIG1hdGNoZXMgdGhhdCAnZGlyZWN0b3J5JyBhbmQgbm90IG5hbWUgb2YgdGhlIGJhc2VOYW1lJ3NcclxuICAgICAgICAgICAgICAgIC8vbW9kdWxlLiBGb3IgaW5zdGFuY2UsIGJhc2VOYW1lIG9mICdvbmUvdHdvL3RocmVlJywgbWFwcyB0b1xyXG4gICAgICAgICAgICAgICAgLy8nb25lL3R3by90aHJlZS5qcycsIGJ1dCB3ZSB3YW50IHRoZSBkaXJlY3RvcnksICdvbmUvdHdvJyBmb3JcclxuICAgICAgICAgICAgICAgIC8vdGhpcyBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5zbGljZSgwLCBiYXNlUGFydHMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplZEJhc2VQYXJ0cy5jb25jYXQobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vc3RhcnQgdHJpbURvdHNcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhcnQgPSBuYW1lW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGF0IHRoZSBzdGFydCwgb3IgcHJldmlvdXMgdmFsdWUgaXMgc3RpbGwgLi4sXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCB0aGVtIHNvIHRoYXQgd2hlbiBjb252ZXJ0ZWQgdG8gYSBwYXRoIGl0IG1heVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIHdvcmsgd2hlbiBjb252ZXJ0ZWQgdG8gYSBwYXRoLCBldmVuIHRob3VnaFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGFuIElEIGl0IGlzIGxlc3MgdGhhbiBpZGVhbC4gSW4gbGFyZ2VyIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsZWFzZXMsIG1heSBiZSBiZXR0ZXIgdG8ganVzdCBraWNrIG91dCBhbiBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCAoaSA9PT0gMSAmJiBuYW1lWzJdID09PSAnLi4nKSB8fCBuYW1lW2kgLSAxXSA9PT0gJy4uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUuc3BsaWNlKGkgLSAxLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2VuZCB0cmltRG90c1xyXG5cclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuam9pbignLycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9BcHBseSBtYXAgY29uZmlnIGlmIGF2YWlsYWJsZS5cclxuICAgICAgICBpZiAoKGJhc2VQYXJ0cyB8fCBzdGFyTWFwKSAmJiBtYXApIHtcclxuICAgICAgICAgICAgbmFtZVBhcnRzID0gbmFtZS5zcGxpdCgnLycpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gbmFtZVBhcnRzLmxlbmd0aDsgaSA+IDA7IGkgLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZVNlZ21lbnQgPSBuYW1lUGFydHMuc2xpY2UoMCwgaSkuam9pbihcIi9cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VQYXJ0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRmluZCB0aGUgbG9uZ2VzdCBiYXNlTmFtZSBzZWdtZW50IG1hdGNoIGluIHRoZSBjb25maWcuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9TbywgZG8gam9pbnMgb24gdGhlIGJpZ2dlc3QgdG8gc21hbGxlc3QgbGVuZ3RocyBvZiBiYXNlUGFydHMuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gYmFzZVBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFtiYXNlUGFydHMuc2xpY2UoMCwgaikuam9pbignLycpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYmFzZU5hbWUgc2VnbWVudCBoYXMgIGNvbmZpZywgZmluZCBpZiBpdCBoYXMgb25lIGZvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgbmFtZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFZhbHVlW25hbWVTZWdtZW50XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTWF0Y2gsIHVwZGF0ZSBuYW1lIHRvIHRoZSBuZXcgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNYXAgPSBtYXBWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEkgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmb3VuZE1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgZm9yIGEgc3RhciBtYXAgbWF0Y2gsIGJ1dCBqdXN0IGhvbGQgb24gdG8gaXQsXHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIGEgc2hvcnRlciBzZWdtZW50IG1hdGNoIGxhdGVyIGluIGEgbWF0Y2hpbmdcclxuICAgICAgICAgICAgICAgIC8vY29uZmlnLCB0aGVuIGZhdm9yIG92ZXIgdGhpcyBzdGFyIG1hcC5cclxuICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFyTWFwICYmIHN0YXJNYXAgJiYgc3Rhck1hcFtuYW1lU2VnbWVudF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZFN0YXJNYXAgPSBzdGFyTWFwW25hbWVTZWdtZW50XTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFySSA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghZm91bmRNYXAgJiYgZm91bmRTdGFyTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZE1hcCA9IGZvdW5kU3Rhck1hcDtcclxuICAgICAgICAgICAgICAgIGZvdW5kSSA9IHN0YXJJO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZm91bmRNYXApIHtcclxuICAgICAgICAgICAgICAgIG5hbWVQYXJ0cy5zcGxpY2UoMCwgZm91bmRJLCBmb3VuZE1hcCk7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZVBhcnRzLmpvaW4oJy8nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZVJlcXVpcmUocmVsTmFtZSwgZm9yY2VTeW5jKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy9BIHZlcnNpb24gb2YgYSByZXF1aXJlIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIGEgbW9kdWxlTmFtZVxyXG4gICAgICAgICAgICAvL3ZhbHVlIGZvciBpdGVtcyB0aGF0IG1heSBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vbG9vayB1cCBwYXRocyByZWxhdGl2ZSB0byB0aGUgbW9kdWxlTmFtZVxyXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFwcy5jYWxsKGFyZ3VtZW50cywgMCk7XHJcblxyXG4gICAgICAgICAgICAvL0lmIGZpcnN0IGFyZyBpcyBub3QgcmVxdWlyZSgnc3RyaW5nJyksIGFuZCB0aGVyZSBpcyBvbmx5XHJcbiAgICAgICAgICAgIC8vb25lIGFyZywgaXQgaXMgdGhlIGFycmF5IGZvcm0gd2l0aG91dCBhIGNhbGxiYWNrLiBJbnNlcnRcclxuICAgICAgICAgICAgLy9hIG51bGwgc28gdGhhdCB0aGUgZm9sbG93aW5nIGNvbmNhdCBpcyBjb3JyZWN0LlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcS5hcHBseSh1bmRlZiwgYXJncy5jb25jYXQoW3JlbE5hbWUsIGZvcmNlU3luY10pKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VOb3JtYWxpemUocmVsTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZUxvYWQoZGVwTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgZGVmaW5lZFtkZXBOYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FsbERlcChuYW1lKSB7XHJcbiAgICAgICAgaWYgKGhhc1Byb3Aod2FpdGluZywgbmFtZSkpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSB3YWl0aW5nW25hbWVdO1xyXG4gICAgICAgICAgICBkZWxldGUgd2FpdGluZ1tuYW1lXTtcclxuICAgICAgICAgICAgZGVmaW5pbmdbbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICBtYWluLmFwcGx5KHVuZGVmLCBhcmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBuYW1lKSAmJiAhaGFzUHJvcChkZWZpbmluZywgbmFtZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyAnICsgbmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZpbmVkW25hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vVHVybnMgYSBwbHVnaW4hcmVzb3VyY2UgdG8gW3BsdWdpbiwgcmVzb3VyY2VdXHJcbiAgICAvL3dpdGggdGhlIHBsdWdpbiBiZWluZyB1bmRlZmluZWQgaWYgdGhlIG5hbWVcclxuICAgIC8vZGlkIG5vdCBoYXZlIGEgcGx1Z2luIHByZWZpeC5cclxuICAgIGZ1bmN0aW9uIHNwbGl0UHJlZml4KG5hbWUpIHtcclxuICAgICAgICB2YXIgcHJlZml4LFxyXG4gICAgICAgICAgICBpbmRleCA9IG5hbWUgPyBuYW1lLmluZGV4T2YoJyEnKSA6IC0xO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHByZWZpeCA9IG5hbWUuc3Vic3RyaW5nKDAsIGluZGV4KTtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKGluZGV4ICsgMSwgbmFtZS5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy9DcmVhdGVzIGEgcGFydHMgYXJyYXkgZm9yIGEgcmVsTmFtZSB3aGVyZSBmaXJzdCBwYXJ0IGlzIHBsdWdpbiBJRCxcclxuICAgIC8vc2Vjb25kIHBhcnQgaXMgcmVzb3VyY2UgSUQuIEFzc3VtZXMgcmVsTmFtZSBoYXMgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQuXHJcbiAgICBmdW5jdGlvbiBtYWtlUmVsUGFydHMocmVsTmFtZSkge1xyXG4gICAgICAgIHJldHVybiByZWxOYW1lID8gc3BsaXRQcmVmaXgocmVsTmFtZSkgOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIGEgbmFtZSBtYXAsIG5vcm1hbGl6aW5nIHRoZSBuYW1lLCBhbmQgdXNpbmcgYSBwbHVnaW5cclxuICAgICAqIGZvciBub3JtYWxpemF0aW9uIGlmIG5lY2Vzc2FyeS4gR3JhYnMgYSByZWYgdG8gcGx1Z2luXHJcbiAgICAgKiB0b28sIGFzIGFuIG9wdGltaXphdGlvbi5cclxuICAgICAqL1xyXG4gICAgbWFrZU1hcCA9IGZ1bmN0aW9uIChuYW1lLCByZWxQYXJ0cykge1xyXG4gICAgICAgIHZhciBwbHVnaW4sXHJcbiAgICAgICAgICAgIHBhcnRzID0gc3BsaXRQcmVmaXgobmFtZSksXHJcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdLFxyXG4gICAgICAgICAgICByZWxSZXNvdXJjZU5hbWUgPSByZWxQYXJ0c1sxXTtcclxuXHJcbiAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xyXG5cclxuICAgICAgICBpZiAocHJlZml4KSB7XHJcbiAgICAgICAgICAgIHByZWZpeCA9IG5vcm1hbGl6ZShwcmVmaXgsIHJlbFJlc291cmNlTmFtZSk7XHJcbiAgICAgICAgICAgIHBsdWdpbiA9IGNhbGxEZXAocHJlZml4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vTm9ybWFsaXplIGFjY29yZGluZ1xyXG4gICAgICAgIGlmIChwcmVmaXgpIHtcclxuICAgICAgICAgICAgaWYgKHBsdWdpbiAmJiBwbHVnaW4ubm9ybWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gcGx1Z2luLm5vcm1hbGl6ZShuYW1lLCBtYWtlTm9ybWFsaXplKHJlbFJlc291cmNlTmFtZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxSZXNvdXJjZU5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxSZXNvdXJjZU5hbWUpO1xyXG4gICAgICAgICAgICBwYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpO1xyXG4gICAgICAgICAgICBwcmVmaXggPSBwYXJ0c1swXTtcclxuICAgICAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xyXG4gICAgICAgICAgICBpZiAocHJlZml4KSB7XHJcbiAgICAgICAgICAgICAgICBwbHVnaW4gPSBjYWxsRGVwKHByZWZpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVXNpbmcgcmlkaWN1bG91cyBwcm9wZXJ0eSBuYW1lcyBmb3Igc3BhY2UgcmVhc29uc1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGY6IHByZWZpeCA/IHByZWZpeCArICchJyArIG5hbWUgOiBuYW1lLCAvL2Z1bGxOYW1lXHJcbiAgICAgICAgICAgIG46IG5hbWUsXHJcbiAgICAgICAgICAgIHByOiBwcmVmaXgsXHJcbiAgICAgICAgICAgIHA6IHBsdWdpblxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VDb25maWcobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoY29uZmlnICYmIGNvbmZpZy5jb25maWcgJiYgY29uZmlnLmNvbmZpZ1tuYW1lXSkgfHwge307XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVycyA9IHtcclxuICAgICAgICByZXF1aXJlOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUobmFtZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHBvcnRzOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IGRlZmluZWRbbmFtZV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChkZWZpbmVkW25hbWVdID0ge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb2R1bGU6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpZDogbmFtZSxcclxuICAgICAgICAgICAgICAgIHVyaTogJycsXHJcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBkZWZpbmVkW25hbWVdLFxyXG4gICAgICAgICAgICAgICAgY29uZmlnOiBtYWtlQ29uZmlnKG5hbWUpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtYWluID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKSB7XHJcbiAgICAgICAgdmFyIGNqc01vZHVsZSwgZGVwTmFtZSwgcmV0LCBtYXAsIGksIHJlbFBhcnRzLFxyXG4gICAgICAgICAgICBhcmdzID0gW10sXHJcbiAgICAgICAgICAgIGNhbGxiYWNrVHlwZSA9IHR5cGVvZiBjYWxsYmFjayxcclxuICAgICAgICAgICAgdXNpbmdFeHBvcnRzO1xyXG5cclxuICAgICAgICAvL1VzZSBuYW1lIGlmIG5vIHJlbE5hbWVcclxuICAgICAgICByZWxOYW1lID0gcmVsTmFtZSB8fCBuYW1lO1xyXG4gICAgICAgIHJlbFBhcnRzID0gbWFrZVJlbFBhcnRzKHJlbE5hbWUpO1xyXG5cclxuICAgICAgICAvL0NhbGwgdGhlIGNhbGxiYWNrIHRvIGRlZmluZSB0aGUgbW9kdWxlLCBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgaWYgKGNhbGxiYWNrVHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY2FsbGJhY2tUeXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vUHVsbCBvdXQgdGhlIGRlZmluZWQgZGVwZW5kZW5jaWVzIGFuZCBwYXNzIHRoZSBvcmRlcmVkXHJcbiAgICAgICAgICAgIC8vdmFsdWVzIHRvIHRoZSBjYWxsYmFjay5cclxuICAgICAgICAgICAgLy9EZWZhdWx0IHRvIFtyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGVdIGlmIG5vIGRlcHNcclxuICAgICAgICAgICAgZGVwcyA9ICFkZXBzLmxlbmd0aCAmJiBjYWxsYmFjay5sZW5ndGggPyBbJ3JlcXVpcmUnLCAnZXhwb3J0cycsICdtb2R1bGUnXSA6IGRlcHM7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBtYXAgPSBtYWtlTWFwKGRlcHNbaV0sIHJlbFBhcnRzKTtcclxuICAgICAgICAgICAgICAgIGRlcE5hbWUgPSBtYXAuZjtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0Zhc3QgcGF0aCBDb21tb25KUyBzdGFuZGFyZCBkZXBlbmRlbmNpZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVwTmFtZSA9PT0gXCJyZXF1aXJlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gaGFuZGxlcnMucmVxdWlyZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwTmFtZSA9PT0gXCJleHBvcnRzXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0NvbW1vbkpTIG1vZHVsZSBzcGVjIDEuMVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBoYW5kbGVycy5leHBvcnRzKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVzaW5nRXhwb3J0cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlcE5hbWUgPT09IFwibW9kdWxlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0NvbW1vbkpTIG1vZHVsZSBzcGVjIDEuMVxyXG4gICAgICAgICAgICAgICAgICAgIGNqc01vZHVsZSA9IGFyZ3NbaV0gPSBoYW5kbGVycy5tb2R1bGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1Byb3AoZGVmaW5lZCwgZGVwTmFtZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUHJvcCh3YWl0aW5nLCBkZXBOYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9wKGRlZmluaW5nLCBkZXBOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBjYWxsRGVwKGRlcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXAucCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcC5wLmxvYWQobWFwLm4sIG1ha2VSZXF1aXJlKHJlbE5hbWUsIHRydWUpLCBtYWtlTG9hZChkZXBOYW1lKSwge30pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBkZWZpbmVkW2RlcE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArICcgbWlzc2luZyAnICsgZGVwTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldCA9IGNhbGxiYWNrID8gY2FsbGJhY2suYXBwbHkoZGVmaW5lZFtuYW1lXSwgYXJncykgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgLy9JZiBzZXR0aW5nIGV4cG9ydHMgdmlhIFwibW9kdWxlXCIgaXMgaW4gcGxheSxcclxuICAgICAgICAgICAgICAgIC8vZmF2b3IgdGhhdCBvdmVyIHJldHVybiB2YWx1ZSBhbmQgZXhwb3J0cy4gQWZ0ZXIgdGhhdCxcclxuICAgICAgICAgICAgICAgIC8vZmF2b3IgYSBub24tdW5kZWZpbmVkIHJldHVybiB2YWx1ZSBvdmVyIGV4cG9ydHMgdXNlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNqc01vZHVsZSAmJiBjanNNb2R1bGUuZXhwb3J0cyAhPT0gdW5kZWYgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2pzTW9kdWxlLmV4cG9ydHMgIT09IGRlZmluZWRbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gY2pzTW9kdWxlLmV4cG9ydHM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJldCAhPT0gdW5kZWYgfHwgIXVzaW5nRXhwb3J0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVXNlIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAvL01heSBqdXN0IGJlIGFuIG9iamVjdCBkZWZpbml0aW9uIGZvciB0aGUgbW9kdWxlLiBPbmx5XHJcbiAgICAgICAgICAgIC8vd29ycnkgYWJvdXQgZGVmaW5pbmcgaWYgaGF2ZSBhIG1vZHVsZSBuYW1lLlxyXG4gICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gY2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXF1aXJlanMgPSByZXF1aXJlID0gcmVxID0gZnVuY3Rpb24gKGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lLCBmb3JjZVN5bmMsIGFsdCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnNbZGVwc10pIHtcclxuICAgICAgICAgICAgICAgIC8vY2FsbGJhY2sgaW4gdGhpcyBjYXNlIGlzIHJlYWxseSByZWxOYW1lXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcnNbZGVwc10oY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vSnVzdCByZXR1cm4gdGhlIG1vZHVsZSB3YW50ZWQuIEluIHRoaXMgc2NlbmFyaW8sIHRoZVxyXG4gICAgICAgICAgICAvL2RlcHMgYXJnIGlzIHRoZSBtb2R1bGUgbmFtZSwgYW5kIHNlY29uZCBhcmcgKGlmIHBhc3NlZClcclxuICAgICAgICAgICAgLy9pcyBqdXN0IHRoZSByZWxOYW1lLlxyXG4gICAgICAgICAgICAvL05vcm1hbGl6ZSBtb2R1bGUgbmFtZSwgaWYgaXQgY29udGFpbnMgLiBvciAuLlxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbERlcChtYWtlTWFwKGRlcHMsIG1ha2VSZWxQYXJ0cyhjYWxsYmFjaykpLmYpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWRlcHMuc3BsaWNlKSB7XHJcbiAgICAgICAgICAgIC8vZGVwcyBpcyBhIGNvbmZpZyBvYmplY3QsIG5vdCBhbiBhcnJheS5cclxuICAgICAgICAgICAgY29uZmlnID0gZGVwcztcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5kZXBzKSB7XHJcbiAgICAgICAgICAgICAgICByZXEoY29uZmlnLmRlcHMsIGNvbmZpZy5jYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suc3BsaWNlKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGlzIGFuIGFycmF5LCB3aGljaCBtZWFucyBpdCBpcyBhIGRlcGVuZGVuY3kgbGlzdC5cclxuICAgICAgICAgICAgICAgIC8vQWRqdXN0IGFyZ3MgaWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llc1xyXG4gICAgICAgICAgICAgICAgZGVwcyA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSByZWxOYW1lO1xyXG4gICAgICAgICAgICAgICAgcmVsTmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZXBzID0gdW5kZWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vU3VwcG9ydCByZXF1aXJlKFsnYSddKVxyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcblxyXG4gICAgICAgIC8vSWYgcmVsTmFtZSBpcyBhIGZ1bmN0aW9uLCBpdCBpcyBhbiBlcnJiYWNrIGhhbmRsZXIsXHJcbiAgICAgICAgLy9zbyByZW1vdmUgaXQuXHJcbiAgICAgICAgaWYgKHR5cGVvZiByZWxOYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJlbE5hbWUgPSBmb3JjZVN5bmM7XHJcbiAgICAgICAgICAgIGZvcmNlU3luYyA9IGFsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vU2ltdWxhdGUgYXN5bmMgY2FsbGJhY2s7XHJcbiAgICAgICAgaWYgKGZvcmNlU3luYykge1xyXG4gICAgICAgICAgICBtYWluKHVuZGVmLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9Vc2luZyBhIG5vbi16ZXJvIHZhbHVlIGJlY2F1c2Ugb2YgY29uY2VybiBmb3Igd2hhdCBvbGQgYnJvd3NlcnNcclxuICAgICAgICAgICAgLy9kbywgYW5kIGxhdGVzdCBicm93c2VycyBcInVwZ3JhZGVcIiB0byA0IGlmIGxvd2VyIHZhbHVlIGlzIHVzZWQ6XHJcbiAgICAgICAgICAgIC8vaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGltZXJzLmh0bWwjZG9tLXdpbmRvd3RpbWVycy1zZXR0aW1lb3V0OlxyXG4gICAgICAgICAgICAvL0lmIHdhbnQgYSB2YWx1ZSBpbW1lZGlhdGVseSwgdXNlIHJlcXVpcmUoJ2lkJykgaW5zdGVhZCAtLSBzb21ldGhpbmdcclxuICAgICAgICAgICAgLy90aGF0IHdvcmtzIGluIGFsbW9uZCBvbiB0aGUgZ2xvYmFsIGxldmVsLCBidXQgbm90IGd1YXJhbnRlZWQgYW5kXHJcbiAgICAgICAgICAgIC8vdW5saWtlbHkgdG8gd29yayBpbiBvdGhlciBBTUQgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIG1haW4odW5kZWYsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKTtcclxuICAgICAgICAgICAgfSwgNCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEp1c3QgZHJvcHMgdGhlIGNvbmZpZyBvbiB0aGUgZmxvb3IsIGJ1dCByZXR1cm5zIHJlcSBpbiBjYXNlXHJcbiAgICAgKiB0aGUgY29uZmlnIHJldHVybiB2YWx1ZSBpcyB1c2VkLlxyXG4gICAgICovXHJcbiAgICByZXEuY29uZmlnID0gZnVuY3Rpb24gKGNmZykge1xyXG4gICAgICAgIHJldHVybiByZXEoY2ZnKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBvc2UgbW9kdWxlIHJlZ2lzdHJ5IGZvciBkZWJ1Z2dpbmcgYW5kIHRvb2xpbmdcclxuICAgICAqL1xyXG4gICAgcmVxdWlyZWpzLl9kZWZpbmVkID0gZGVmaW5lZDtcclxuXHJcbiAgICBkZWZpbmUgPSBmdW5jdGlvbiAobmFtZSwgZGVwcywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VlIGFsbW9uZCBSRUFETUU6IGluY29ycmVjdCBtb2R1bGUgYnVpbGQsIG5vIG1vZHVsZSBuYW1lJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1RoaXMgbW9kdWxlIG1heSBub3QgaGF2ZSBkZXBlbmRlbmNpZXNcclxuICAgICAgICBpZiAoIWRlcHMuc3BsaWNlKSB7XHJcbiAgICAgICAgICAgIC8vZGVwcyBpcyBub3QgYW4gYXJyYXksIHNvIHByb2JhYmx5IG1lYW5zXHJcbiAgICAgICAgICAgIC8vYW4gb2JqZWN0IGxpdGVyYWwgb3IgZmFjdG9yeSBmdW5jdGlvbiBmb3JcclxuICAgICAgICAgICAgLy90aGUgdmFsdWUuIEFkanVzdCBhcmdzLlxyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGRlcHM7XHJcbiAgICAgICAgICAgIGRlcHMgPSBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBuYW1lKSAmJiAhaGFzUHJvcCh3YWl0aW5nLCBuYW1lKSkge1xyXG4gICAgICAgICAgICB3YWl0aW5nW25hbWVdID0gW25hbWUsIGRlcHMsIGNhbGxiYWNrXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGRlZmluZS5hbWQgPSB7XHJcbiAgICAgICAgalF1ZXJ5OiB0cnVlXHJcbiAgICB9O1xyXG59KCkpO1xyXG4vKiEgZXhjYWxpYnVyIC0gdjAuMTQuMCAtIDIwMTctMTItMDJcclxuKiBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyXHJcbiogQ29weXJpZ2h0IChjKSAyMDE3IEV4Y2FsaWJ1ci5qcyA8aHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9ncmFwaHMvY29udHJpYnV0b3JzPjsgTGljZW5zZWQgQlNELTItQ2xhdXNlXHJcbiogQHByZXNlcnZlICovXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5kZWZpbmUoXCJBY3Rpb25zL1JvdGF0aW9uVHlwZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSBzdHJhdGVnaWVzIHRoYXQgcm90YXRpb24gYWN0aW9ucyBjYW4gdXNlXHJcbiAgICAgKi9cclxuICAgIHZhciBSb3RhdGlvblR5cGU7XHJcbiAgICAoZnVuY3Rpb24gKFJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdGF0aW9uIHZpYSBgU2hvcnRlc3RQYXRoYCB3aWxsIHVzZSB0aGUgc21hbGxlc3QgYW5nbGVcclxuICAgICAgICAgKiBiZXR3ZWVuIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cy4gVGhpcyBzdHJhdGVneSBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiU2hvcnRlc3RQYXRoXCJdID0gMF0gPSBcIlNob3J0ZXN0UGF0aFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdGF0aW9uIHZpYSBgTG9uZ2VzdFBhdGhgIHdpbGwgdXNlIHRoZSBsYXJnZXN0IGFuZ2xlXHJcbiAgICAgICAgICogYmV0d2VlbiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUm90YXRpb25UeXBlW1JvdGF0aW9uVHlwZVtcIkxvbmdlc3RQYXRoXCJdID0gMV0gPSBcIkxvbmdlc3RQYXRoXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRpb24gdmlhIGBDbG9ja3dpc2VgIHdpbGwgdHJhdmVsIGluIGEgY2xvY2t3aXNlIGRpcmVjdGlvbixcclxuICAgICAgICAgKiByZWdhcmRsZXNzIG9mIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiQ2xvY2t3aXNlXCJdID0gMl0gPSBcIkNsb2Nrd2lzZVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdGF0aW9uIHZpYSBgQ291bnRlckNsb2Nrd2lzZWAgd2lsbCB0cmF2ZWwgaW4gYSBjb3VudGVyY2xvY2t3aXNlIGRpcmVjdGlvbixcclxuICAgICAgICAgKiByZWdhcmRsZXNzIG9mIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiQ291bnRlckNsb2Nrd2lzZVwiXSA9IDNdID0gXCJDb3VudGVyQ2xvY2t3aXNlXCI7XHJcbiAgICB9KShSb3RhdGlvblR5cGUgPSBleHBvcnRzLlJvdGF0aW9uVHlwZSB8fCAoZXhwb3J0cy5Sb3RhdGlvblR5cGUgPSB7fSkpO1xyXG59KTtcclxuZGVmaW5lKFwiQWxnZWJyYVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIDJEIHZlY3RvciBvbiBhIHBsYW5lLlxyXG4gICAgICovXHJcbiAgICB2YXIgVmVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geCAgWCBjb21wb25lbnQgb2YgdGhlIFZlY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB5ICBZIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVmVjdG9yKHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHZlY3RvciBvZiB1bml0IGxlbmd0aCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzcGVjaWZpZWQgYW5nbGUgaW4gUmFkaWFucy5cclxuICAgICAgICAgKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIHRvIGdlbmVyYXRlIHRoZSB2ZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IuZnJvbUFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKE1hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiB2ZWN0b3IgaXMgbm90IG51bGwsIHVuZGVmaW5lZCwgb3IgaWYgYW55IG9mIGl0cyBjb21wb25lbnRzIGFyZSBOYU4gb3IgSW5maW5pdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLmlzVmFsaWQgPSBmdW5jdGlvbiAodmVjKSB7XHJcbiAgICAgICAgICAgIGlmICh2ZWMgPT09IG51bGwgfHwgdmVjID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNOYU4odmVjLngpIHx8IGlzTmFOKHZlYy55KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2ZWMueCA9PT0gSW5maW5pdHkgfHxcclxuICAgICAgICAgICAgICAgIHZlYy55ID09PSBJbmZpbml0eSB8fFxyXG4gICAgICAgICAgICAgICAgdmVjLnggPT09IC1JbmZpbml0eSB8fFxyXG4gICAgICAgICAgICAgICAgdmVjLnkgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIGRpc3RhbmNlIGJldHdlZW4gdHdvIFZlY3RvcnNcclxuICAgICAgICAgKiBAcGFyYW0gdmVjMVxyXG4gICAgICAgICAqIEBwYXJhbSB2ZWMyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLmRpc3RhbmNlID0gZnVuY3Rpb24gKHZlYzEsIHZlYzIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2ZWMxLnggLSB2ZWMyLngsIDIpICsgTWF0aC5wb3codmVjMS55IC0gdmVjMi55LCAyKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB4IGFuZCB5IGNvbXBvbmVudHMgYXQgb25jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuc2V0VG8gPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tcGFyZXMgdGhpcyBwb2ludCBhZ2FpbnN0IGFub3RoZXIgYW5kIHRlc3RzIGZvciBlcXVhbGl0eVxyXG4gICAgICAgICAqIEBwYXJhbSBwb2ludCAgVGhlIG90aGVyIHBvaW50IHRvIGNvbXBhcmUgdG9cclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh2ZWN0b3IsIHRvbGVyYW5jZSkge1xyXG4gICAgICAgICAgICBpZiAodG9sZXJhbmNlID09PSB2b2lkIDApIHsgdG9sZXJhbmNlID0gLjAwMTsgfVxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdmVjdG9yLngpIDw9IHRvbGVyYW5jZSAmJiBNYXRoLmFicyh0aGlzLnkgLSB2ZWN0b3IueSkgPD0gdG9sZXJhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRpc3RhbmNlIHRvIGFub3RoZXIgdmVjdG9yLiBJZiBubyBvdGhlciBWZWN0b3IgaXMgc3BlY2lmaWVkLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBbW21hZ25pdHVkZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSB2ICBUaGUgb3RoZXIgdmVjdG9yLiBMZWF2ZSBibGFuayB0byB1c2Ugb3JpZ2luIHZlY3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgICAgICB2ID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSB2LngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gdi55LCAyKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFnbml0dWRlIChzaXplKSBvZiB0aGUgVmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5tYWduaXR1ZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3JtYWxpemVzIGEgdmVjdG9yIHRvIGhhdmUgYSBtYWduaXR1ZGUgb2YgMS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRpc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIGlmIChkID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54IC8gZCwgdGhpcy55IC8gZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYXZlcmFnZSAobWlkcG9pbnQpIGJldHdlZW4gdGhlIGN1cnJlbnQgcG9pbnQgYW5kIHRoZSBzcGVjaWZpZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmF2ZXJhZ2UgPSBmdW5jdGlvbiAodmVjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCh2ZWMpLnNjYWxlKC41KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNjYWxlcyBhIHZlY3RvcidzIGJ5IGEgZmFjdG9yIG9mIHNpemVcclxuICAgICAgICAgKiBAcGFyYW0gc2l6ZSAgVGhlIGZhY3RvciB0byBzY2FsZSB0aGUgbWFnbml0dWRlIGJ5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAqIHNpemUsIHRoaXMueSAqIHNpemUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBvbmUgdmVjdG9yIHRvIGFub3RoZXJcclxuICAgICAgICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGFkZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54ICsgdi54LCB0aGlzLnkgKyB2LnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gYW5vdGhlciwgaWYgeW91IHN1YnJhY3QgdmVjdG9yIGBCLnN1YihBKWAgdGhlIHJlc3VsdGluZyB2ZWN0b3IgcG9pbnRzIGZyb20gQSAtPiBCXHJcbiAgICAgICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBzdWJ0cmFjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54IC0gdi54LCB0aGlzLnkgLSB2LnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBvbmUgdmVjdG9yIHRvIHRoaXMgb25lIG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGFkZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuYWRkRXF1YWwgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gdi54O1xyXG4gICAgICAgICAgICB0aGlzLnkgKz0gdi55O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN1YnRyYWN0cyBhIHZlY3RvciBmcm9tIHRoaXMgb25lIG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgKiBAcGFyYWxsZWwgdiBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5zdWJFcXVhbCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMueCAtPSB2Lng7XHJcbiAgICAgICAgICAgIHRoaXMueSAtPSB2Lnk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2NhbGVzIHRoaXMgdmVjdG9yIGJ5IGEgZmFjdG9yIG9mIHNpemUgYW5kIG1vZGlmaWVzIHRoZSBvcmlnaW5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuc2NhbGVFcXVhbCA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCAqPSBzaXplO1xyXG4gICAgICAgICAgICB0aGlzLnkgKj0gc2l6ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZXJmb3JtcyBhIGRvdCBwcm9kdWN0IHdpdGggYW5vdGhlciB2ZWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gdiAgVGhlIHZlY3RvciB0byBkb3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih2ICogdGhpcy55LCAtdiAqIHRoaXMueCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBlcnBlbmRpY3VsYXIgdmVjdG9yIHRvIHRoaXMgb25lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5wZXJwZW5kaWN1bGFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnksIC10aGlzLngpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbm9ybWFsIHZlY3RvciB0byB0aGlzIG9uZSwgc2FtZSBhcyB0aGUgcGVycGVuZGljdWxhciBvZiBsZW5ndGggMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUubm9ybWFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJwZW5kaWN1bGFyKCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOZWdhdGUgdGhlIGN1cnJlbnQgdmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlKC0xKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUudG9BbmdsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRlcyB0aGUgY3VycmVudCB2ZWN0b3IgYXJvdW5kIGEgcG9pbnQgYnkgYSBjZXJ0YWluIG51bWJlciBvZlxyXG4gICAgICAgICAqIGRlZ3JlZXMgaW4gcmFkaWFuc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlLCBhbmNob3IpIHtcclxuICAgICAgICAgICAgaWYgKCFhbmNob3IpIHtcclxuICAgICAgICAgICAgICAgIGFuY2hvciA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gY29zQW5nbGUgKiAodGhpcy54IC0gYW5jaG9yLngpIC0gc2luQW5nbGUgKiAodGhpcy55IC0gYW5jaG9yLnkpICsgYW5jaG9yLng7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2luQW5nbGUgKiAodGhpcy54IC0gYW5jaG9yLngpICsgY29zQW5nbGUgKiAodGhpcy55IC0gYW5jaG9yLnkpICsgYW5jaG9yLnk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHgsIHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBuZXcgdmVjdG9yIHRoYXQgaGFzIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgcHJldmlvdXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXBlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiKFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55ICsgXCIpXCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVmVjdG9yO1xyXG4gICAgfSgpKTtcclxuICAgIC8qKlxyXG4gICAgICogQSAoMCwgMCkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5aZXJvID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogQSAoMSwgMSkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5PbmUgPSBuZXcgVmVjdG9yKDEsIDEpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBICgwLjUsIDAuNSkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5IYWxmID0gbmV3IFZlY3RvcigwLjUsIDAuNSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgdXAgKDAsIC0xKVxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuVXAgPSBuZXcgVmVjdG9yKDAsIC0xKTtcclxuICAgIC8qKlxyXG4gICAgICogQSB1bml0IHZlY3RvciBwb2ludGluZyBkb3duICgwLCAxKVxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuRG93biA9IG5ldyBWZWN0b3IoMCwgMSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgbGVmdCAoLTEsIDApXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5MZWZ0ID0gbmV3IFZlY3RvcigtMSwgMCk7XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgcmlnaHQgKDEsIDApXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5SaWdodCA9IG5ldyBWZWN0b3IoMSwgMCk7XHJcbiAgICBleHBvcnRzLlZlY3RvciA9IFZlY3RvcjtcclxuICAgIC8qKlxyXG4gICAgICogQSAyRCByYXkgdGhhdCBjYW4gYmUgY2FzdCBpbnRvIHRoZSBzY2VuZSB0byBkbyBjb2xsaXNpb24gZGV0ZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBSYXkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBwb3MgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgcmF5XHJcbiAgICAgICAgICogQHBhcmFtIGRpciBUaGUgdmVjdG9yIGluZGljYXRpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcmF5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmF5KHBvcywgZGlyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xyXG4gICAgICAgICAgICB0aGlzLmRpciA9IGRpci5ub3JtYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgYSB3aGV0aGVyIHRoaXMgcmF5IGludGVyc2VjdHMgd2l0aCBhIGxpbmUgc2VnbWVudC4gUmV0dXJucyBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIFRoaXMgbnVtYmVyIGluZGljYXRlcyB0aGUgbWF0aGVtYXRpY2FsIGludGVyc2VjdGlvbiB0aW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSBsaW5lICBUaGUgbGluZSB0byB0ZXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmF5LnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gbGluZS5iZWdpbi5zdWIodGhpcy5wb3MpO1xyXG4gICAgICAgICAgICAvLyBUZXN0IGlzIGxpbmUgYW5kIHJheSBhcmUgcGFyYWxsZWwgYW5kIG5vbiBpbnRlcnNlY3RpbmdcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlyLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkgPT09IDAgJiYgbnVtZXJhdG9yLmNyb3NzKHRoaXMuZGlyKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBwYXJhbGxlbFxyXG4gICAgICAgICAgICB2YXIgZGl2aXNvciA9ICh0aGlzLmRpci5jcm9zcyhsaW5lLmdldFNsb3BlKCkpKTtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdCA9IG51bWVyYXRvci5jcm9zcyhsaW5lLmdldFNsb3BlKCkpIC8gZGl2aXNvcjtcclxuICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHUgPSAobnVtZXJhdG9yLmNyb3NzKHRoaXMuZGlyKSAvIGRpdmlzb3IpIC8gbGluZS5nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGlmICh1ID49IDAgJiYgdSA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIGdpdmVuIHRoZSBpbnRlcnNlY3Rpb24gdGltZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJheS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MuYWRkKHRoaXMuZGlyLnNjYWxlKHRpbWUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSYXk7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5SYXkgPSBSYXk7XHJcbiAgICAvKipcclxuICAgICAqIEEgMkQgbGluZSBzZWdtZW50XHJcbiAgICAgKi9cclxuICAgIHZhciBMaW5lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gYmVnaW4gIFRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50XHJcbiAgICAgICAgICogQHBhcmFtIGVuZCAgVGhlIGVuZGluZyBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gTGluZShiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmVnaW4gPSBiZWdpbjtcclxuICAgICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5lLnByb3RvdHlwZSwgXCJzbG9wZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSByYXcgc2xvcGUgKG0pIG9mIHRoZSBsaW5lLiBXaWxsIHJldHVybiAoKy8tKUluZmluaXR5IGZvciB2ZXJ0aWNhbCBsaW5lcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmVuZC55IC0gdGhpcy5iZWdpbi55KSAvICh0aGlzLmVuZC54IC0gdGhpcy5iZWdpbi54KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmUucHJvdG90eXBlLCBcImludGVyY2VwdFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBZLWludGVyY2VwdCAoYikgb2YgdGhlIGxpbmUuIFdpbGwgcmV0dXJuICgrLy0pSW5maW5pdHkgaWYgdGhlcmUgaXMgbm8gaW50ZXJjZXB0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iZWdpbi55IC0gKHRoaXMuc2xvcGUgKiB0aGlzLmJlZ2luLngpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBub3JtYWwgb2YgdGhlIGxpbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBMaW5lLnByb3RvdHlwZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZC5zdWIodGhpcy5iZWdpbikubm9ybWFsKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzbG9wZSBvZiB0aGUgbGluZSBpbiB0aGUgZm9ybSBvZiBhIHZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpbmUucHJvdG90eXBlLmdldFNsb3BlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLmJlZ2luO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbmQuc3ViKGJlZ2luKS5zY2FsZSgxIC8gZGlzdGFuY2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgaW4gcGl4ZWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGluZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLmJlZ2luO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmQgdGhlIHBlcnBlbmRpY3VsYXIgZGlzdGFuY2UgZnJvbSB0aGUgbGluZSB0byBhIHBvaW50XHJcbiAgICAgICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZVxyXG4gICAgICAgICAqIEBwYXJhbSBwb2ludFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpbmUucHJvdG90eXBlLmRpc3RhbmNlVG9Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgeDAgPSBwb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgeTAgPSBwb2ludC55O1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIHZhciBkeSA9IHRoaXMuZW5kLnkgLSB0aGlzLmJlZ2luLnk7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHRoaXMuZW5kLnggLSB0aGlzLmJlZ2luLng7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKGR5ICogeDAgLSBkeCAqIHkwICsgdGhpcy5lbmQueCAqIHRoaXMuYmVnaW4ueSAtIHRoaXMuZW5kLnkgKiB0aGlzLmJlZ2luLngpIC8gbDtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZHMgYSBwb2ludCBvbiB0aGUgbGluZSBnaXZlbiBvbmx5IGFuIFggb3IgYSBZIHZhbHVlLiBHaXZlbiBhbiBYIHZhbHVlLCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xyXG4gICAgICAgICAqIGEgbmV3IHBvaW50IHdpdGggdGhlIGNhbGN1bGF0ZWQgWSB2YWx1ZSBhbmQgdmljZS12ZXJzYS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB4IFRoZSBrbm93biBYIHZhbHVlIG9mIHRoZSB0YXJnZXQgcG9pbnRcclxuICAgICAgICAgKiBAcGFyYW0geSBUaGUga25vd24gWSB2YWx1ZSBvZiB0aGUgdGFyZ2V0IHBvaW50XHJcbiAgICAgICAgICogQHJldHVybnMgQSBuZXcgcG9pbnQgd2l0aCB0aGUgb3RoZXIgY2FsY3VsYXRlZCBheGlzIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGluZS5wcm90b3R5cGUuZmluZFBvaW50ID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgaWYgKHggPT09IHZvaWQgMCkgeyB4ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7IHkgPSBudWxsOyB9XHJcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5zbG9wZTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmludGVyY2VwdDtcclxuICAgICAgICAgICAgaWYgKHggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHgsIChtICogeCkgKyBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigoeSAtIGIpIC8gbSwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYW4gWCBvciBhIFkgdmFsdWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTkwODE1OC8xMDk0NThcclxuICAgICAgICAgKi9cclxuICAgICAgICBMaW5lLnByb3RvdHlwZS5oYXNQb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJQb2ludDtcclxuICAgICAgICAgICAgdmFyIHRocmVzaG9sZCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJQb2ludCA9IG5ldyBWZWN0b3IoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gYXJndW1lbnRzWzJdIHx8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyUG9pbnQgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSBhcmd1bWVudHNbMV0gfHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93ICdDb3VsZCBub3QgZGV0ZXJtaW5lIHRoZSBhcmd1bWVudHMgZm9yIFZlY3Rvci5oYXNQb2ludCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGR4YyA9IGN1cnJQb2ludC54IC0gdGhpcy5iZWdpbi54O1xyXG4gICAgICAgICAgICB2YXIgZHljID0gY3VyclBvaW50LnkgLSB0aGlzLmJlZ2luLnk7XHJcbiAgICAgICAgICAgIHZhciBkeDEgPSB0aGlzLmVuZC54IC0gdGhpcy5iZWdpbi54O1xyXG4gICAgICAgICAgICB2YXIgZHkxID0gdGhpcy5lbmQueSAtIHRoaXMuYmVnaW4ueTtcclxuICAgICAgICAgICAgdmFyIGNyb3NzID0gZHhjICogZHkxIC0gZHljICogZHgxO1xyXG4gICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHBvaW50IGxpbmVzIG9uIHRoZSBsaW5lXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhjcm9zcykgPiB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHBvaW50IGxpZXMgaW4tYmV0d2VlbiBzdGFydCBhbmQgZW5kXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeDEpID49IE1hdGguYWJzKGR5MSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkeDEgPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmJlZ2luLnggPD0gY3VyclBvaW50LnggJiYgY3VyclBvaW50LnggPD0gdGhpcy5lbmQueFxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5lbmQueCA8PSBjdXJyUG9pbnQueCAmJiBjdXJyUG9pbnQueCA8PSB0aGlzLmJlZ2luLng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHkxID4gMFxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5iZWdpbi55IDw9IGN1cnJQb2ludC55ICYmIGN1cnJQb2ludC55IDw9IHRoaXMuZW5kLnlcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZW5kLnkgPD0gY3VyclBvaW50LnkgJiYgY3VyclBvaW50LnkgPD0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTGluZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkxpbmUgPSBMaW5lO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIDEgZGltZW5zaW9uYWwgcHJvamVjdGlvbiBvbiBhbiBheGlzLCB1c2VkIHRvIHRlc3Qgb3ZlcmxhcHNcclxuICAgICAqL1xyXG4gICAgdmFyIFByb2plY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFByb2plY3Rpb24obWluLCBtYXgpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uIChwcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCA+IHByb2plY3Rpb24ubWluICYmIHByb2plY3Rpb24ubWF4ID4gdGhpcy5taW47XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRPdmVybGFwID0gZnVuY3Rpb24gKHByb2plY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxhcHMocHJvamVjdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heCA+IHByb2plY3Rpb24ubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb24ubWF4IC0gdGhpcy5taW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXggLSBwcm9qZWN0aW9uLm1pbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQcm9qZWN0aW9uO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUHJvamVjdGlvbiA9IFByb2plY3Rpb247XHJcbn0pO1xyXG5kZWZpbmUoXCJQaHlzaWNzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWxnZWJyYVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFsZ2VicmFfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFBvc3NpYmxlIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWdpZXNcclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBbW0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5Cb3hdXSB3aGljaCBwZXJmb3JtcyBzaW1wbGUgYXhpcyBhbGlnbmVkIGFyY2FkZSBzdHlsZSBwaHlzaWNzLlxyXG4gICAgICpcclxuICAgICAqIE1vcmUgYWR2YW5jZWQgcmlnaWQgYm9keSBwaHlzaWNzIGFyZSBlbmFibGVkIGJ5IHNldHRpbmcgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuUmlnaWRCb2R5XV0gd2hpY2ggYWxsb3dzIGZvciBjb21wbGljYXRlZFxyXG4gICAgICogc2ltdWxhdGVkIHBoeXNpY2FsIGludGVyYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgdmFyIENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneTtcclxuICAgIChmdW5jdGlvbiAoQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5KSB7XHJcbiAgICAgICAgQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5W0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneVtcIkJveFwiXSA9IDBdID0gXCJCb3hcIjtcclxuICAgICAgICBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3lbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5W1wiUmlnaWRCb2R5XCJdID0gMV0gPSBcIlJpZ2lkQm9keVwiO1xyXG4gICAgfSkoQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5Db2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogUG9zc2libGUgYnJvYWRwaGFzZSBjb2xsaXNpb24gcGFpciBpZGVudGlmaWNhdGlvbiBzdHJhdGVnaWVzXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgaXMgW1tCcm9hZHBoYXNlU3RyYXRlZ3kuRHluYW1pY0FBQkJUcmVlXV0gd2hpY2ggdXNlcyBhIGJpbmFyeSB0cmVlIG9mIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hlcyB0byBpZGVudGlmeVxyXG4gICAgICogcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlycyB3aGljaCBpcyBPKG5sb2cobikpIGZhc3Rlci4gVGhlIG90aGVyIHBvc3NpYmxlIHN0cmF0ZWd5IGlzIHRoZSBbW0Jyb2FkcGhhc2VTdHJhdGVneS5OYWl2ZV1dIHN0cmF0ZWd5XHJcbiAgICAgKiB3aGljaCBsb29wcyBvdmVyIGV2ZXJ5IG9iamVjdCBmb3IgZXZlcnkgb2JqZWN0IGluIHRoZSBzY2VuZSB0byBpZGVudGlmeSBjb2xsaXNpb24gcGFpcnMgd2hpY2ggaXMgTyhuXjIpIHNsb3dlci5cclxuICAgICAqL1xyXG4gICAgdmFyIEJyb2FkcGhhc2VTdHJhdGVneTtcclxuICAgIChmdW5jdGlvbiAoQnJvYWRwaGFzZVN0cmF0ZWd5KSB7XHJcbiAgICAgICAgQnJvYWRwaGFzZVN0cmF0ZWd5W0Jyb2FkcGhhc2VTdHJhdGVneVtcIk5haXZlXCJdID0gMF0gPSBcIk5haXZlXCI7XHJcbiAgICAgICAgQnJvYWRwaGFzZVN0cmF0ZWd5W0Jyb2FkcGhhc2VTdHJhdGVneVtcIkR5bmFtaWNBQUJCVHJlZVwiXSA9IDFdID0gXCJEeW5hbWljQUFCQlRyZWVcIjtcclxuICAgIH0pKEJyb2FkcGhhc2VTdHJhdGVneSA9IGV4cG9ydHMuQnJvYWRwaGFzZVN0cmF0ZWd5IHx8IChleHBvcnRzLkJyb2FkcGhhc2VTdHJhdGVneSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFBvc3NpYmxlIG51bWVyaWNhbCBpbnRlZ3JhdG9ycyBmb3IgcG9zaXRpb24gYW5kIHZlbG9jaXR5XHJcbiAgICAgKi9cclxuICAgIHZhciBJbnRlZ3JhdG9yO1xyXG4gICAgKGZ1bmN0aW9uIChJbnRlZ3JhdG9yKSB7XHJcbiAgICAgICAgSW50ZWdyYXRvcltJbnRlZ3JhdG9yW1wiRXVsZXJcIl0gPSAwXSA9IFwiRXVsZXJcIjtcclxuICAgIH0pKEludGVncmF0b3IgPSBleHBvcnRzLkludGVncmF0b3IgfHwgKGV4cG9ydHMuSW50ZWdyYXRvciA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW1BoeXNpY3NdXSBvYmplY3QgaXMgdGhlIGdsb2JhbCBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYWxsIEV4Y2FsaWJ1ciBwaHlzaWNzLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpQaHlzaWNzLm1kXV1cclxuICAgICAqL1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHZhciBQaHlzaWNzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQaHlzaWNzKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmVzIEV4Y2FsaWJ1ciB0byB1c2UgYm94IHBoeXNpY3MuIEJveCBwaHlzaWNzIHdoaWNoIHBlcmZvcm1zIHNpbXBsZSBheGlzIGFsaWduZWQgYXJjYWRlIHN0eWxlIHBoeXNpY3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGh5c2ljcy51c2VCb3hQaHlzaWNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBQaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5Cb3g7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmVzIEV4Y2FsaWJ1ciB0byB1c2UgcmlnaWQgYm9keSBwaHlzaWNzLiBSaWdpZCBib2R5IHBoeXNpY3MgYWxsb3dzIGZvciBjb21wbGljYXRlZFxyXG4gICAgICAgICAqIHNpbXVsYXRlZCBwaHlzaWNhbCBpbnRlcmFjdGlvbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGh5c2ljcy51c2VSaWdpZEJvZHlQaHlzaWNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBQaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SaWdpZEJvZHk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGh5c2ljcztcclxuICAgIH0oKSk7XHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbCBhY2NlbGVyYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGFsbCB2YW5pbGxhIGFjdG9ycyAoaXQgd29udCBlZmZlY3QgW1tMYWJlbHxsYWJlbHNdXSwgW1tVSUFjdG9yfHVpIGFjdG9yc11dLCBvclxyXG4gICAgICogW1tUcmlnZ2VyfHRyaWdnZXJzXV0gaW4gRXhjYWxpYnVyIHRoYXQgaGF2ZSBhbiBbW0NvbGxpc2lvblR5cGUuQWN0aXZlfGFjdGl2ZV1dIGNvbGxpc2lvbiB0eXBlKS5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyBhIGdyZWF0IHdheSB0byBnbG9iYWxseSBzaW11bGF0ZSBlZmZlY3RzIGxpa2UgZ3Jhdml0eS5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5hY2MgPSBuZXcgQWxnZWJyYV8xLlZlY3RvcigwLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogR2xvYmFsbHkgc3dpdGNoZXMgYWxsIEV4Y2FsaWJ1ciBwaHlzaWNzIGJlaGF2aW9yIG9uIG9yIG9mZi5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBudW1iZXIgb2YgY29sbGlzaW9uIHBhc3NlcyBmb3IgRXhjYWxpYnVyIHRvIHBlcmZvcm0gb24gcGh5c2ljcyBib2RpZXMuXHJcbiAgICAgKlxyXG4gICAgICogUmVkdWNpbmcgY29sbGlzaW9uIHBhc3NlcyBtYXkgY2F1c2UgdGhpbmdzIG5vdCB0byBjb2xsaWRlIGFzIGV4cGVjdGVkIGluIHlvdXIgZ2FtZSwgYnV0IG1heSBpbmNyZWFzZSBwZXJmb3JtYW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBNb3JlIHBhc3NlcyBjYW4gaW1wcm92ZSB0aGUgdmlzdWFsIHF1YWxpdHkgb2YgY29sbGlzaW9ucyB3aGVuIG1hbnkgb2JqZWN0cyBhcmUgb24gdGhlIHNjcmVlbi4gVGhpcyBjYW4gcmVkdWNlIGppdHRlciwgaW1wcm92ZSB0aGVcclxuICAgICAqIGNvbGxpc2lvbiByZXNvbHV0aW9uIG9mIGZhc3QgbW92ZSBvYmplY3RzLCBvciB0aGUgc3RhYmlsaXR5IG9mIGxhcmdlIG51bWJlcnMgb2Ygb2JqZWN0cyBzdGFja2VkIHRvZ2V0aGVyLlxyXG4gICAgICpcclxuICAgICAqIEZld2VyIHBhc3NlcyB3aWxsIGltcHJvdmUgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBnYW1lIGF0IHRoZSBjb3N0IG9mIGNvbGxpc2lvbiBxdWFsaXR5LCBtb3JlIHBhc3NlcyB3aWxsIGltcHJvdmUgcXVhbGl0eSBhdCB0aGVcclxuICAgICAqIGNvc3Qgb2YgcGVyZm9ybWFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgaXMgc2V0IHRvIDUgcGFzc2VzIHdoaWNoIGlzIGEgZ29vZCBzdGFydC5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5jb2xsaXNpb25QYXNzZXMgPSA1O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJyb2FkcGhhc2UgcGFpciBpZGVudGlmaWNhdGlvbiBzdHJhdGVneS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBzdHJhdGVneSBpcyBbW0Jyb2FkcGhhc2VTdHJhdGVneS5EeW5hbWljQUFCQlRyZWVdXSB3aGljaCB1c2VzIGEgYmluYXJ5IHRyZWUgb2YgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveGVzIHRvIGlkZW50aWZ5XHJcbiAgICAgKiBwb3RlbnRpYWwgY29sbGlzaW9uIHBhaXJzIHdoaWNoIGlzIE8obmxvZyhuKSkgZmFzdGVyLiBUaGUgb3RoZXIgcG9zc2libGUgc3RyYXRlZ3kgaXMgdGhlIFtbQnJvYWRwaGFzZVN0cmF0ZWd5Lk5haXZlXV0gc3RyYXRlZ3lcclxuICAgICAqIHdoaWNoIGxvb3BzIG92ZXIgZXZlcnkgb2JqZWN0IGZvciBldmVyeSBvYmplY3QgaW4gdGhlIHNjZW5lIHRvIGlkZW50aWZ5IGNvbGxpc2lvbiBwYWlycyB3aGljaCBpcyBPKG5eMikgc2xvd2VyLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmJyb2FkcGhhc2VTdHJhdGVneSA9IEJyb2FkcGhhc2VTdHJhdGVneS5EeW5hbWljQUFCQlRyZWU7XHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbGx5IHN3aXRjaGVzIHRoZSBkZWJ1ZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGJyb2FkcGhhc2Ugc3RyYXRlZ3lcclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5icm9hZHBoYXNlRGVidWcgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB0aGUgbm9ybWFscyBhcyBhIHJlc3VsdCBvZiBjb2xsaXNpb24gb24gdGhlIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zaG93Q29sbGlzaW9uTm9ybWFscyA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHRoZSBwb3NpdGlvbiwgdmVsb2NpdHksIGFuZCBhY2NlbGVyYXRpb24gYXMgZ3JhcGhpY2FsIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3Muc2hvd01vdGlvblZlY3RvcnMgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB0aGUgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveGVzIG9mIHRoZSBjb2xsaXNpb24gYm9kaWVzIG9uIHRoZSBzY3JlZW4uXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3Muc2hvd0JvdW5kcyA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHRoZSBib3VuZGluZyBjb2xsaXNpb24gYXJlYSBzaGFwZXNcclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zaG93QXJlYSA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHBvaW50cyBvZiBjb2xsaXNpb24gaW50ZXJwcmV0ZWQgYnkgZXhjYWxpYnVyIGFzIGEgcmVzdWx0IG9mIGNvbGxpc2lvbi5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zaG93Q29udGFjdHMgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB0aGUgc3VyZmFjZSBub3JtYWxzIG9mIHRoZSBjb2xsaXNpb24gYXJlYXMuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3Muc2hvd05vcm1hbHMgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBnbG9iYWwgY29sbGlzaW9uIHJlc29sdXRpb24gc3RyYXRlZ3kgKG5hcnJvd3BoYXNlKS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBbW0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5Cb3hdXSB3aGljaCBwZXJmb3JtcyBzaW1wbGUgYXhpcyBhbGlnbmVkIGFyY2FkZSBzdHlsZSBwaHlzaWNzLlxyXG4gICAgICpcclxuICAgICAqIE1vcmUgYWR2YW5jZWQgcmlnaWQgYm9keSBwaHlzaWNzIGFyZSBlbmFibGVkIGJ5IHNldHRpbmcgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuUmlnaWRCb2R5XV0gd2hpY2ggYWxsb3dzIGZvciBjb21wbGljYXRlZFxyXG4gICAgICogc2ltdWxhdGVkIHBoeXNpY2FsIGludGVyYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQm94O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBtYXNzIHRvIHVzZSBpZiBub25lIGlzIHNwZWNpZmllZFxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmRlZmF1bHRNYXNzID0gMTA7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcG9zaXRpb24gYW5kIHZlbG9jaXR5IHBvc2l0aW9uYWwgaW50ZWdyYXRvciwgY3VycmVudGx5IG9ubHkgRXVsZXIgaXMgc3VwcG9ydGVkLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmludGVncmF0b3IgPSBJbnRlZ3JhdG9yLkV1bGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOdW1iZXIgb2Ygc3RlcHMgdG8gdXNlIGluIGludGVncmF0aW9uLiBBIGhpZ2hlciBudW1iZXIgaW1wcm92ZXMgdGhlIHBvc2l0aW9uYWwgYWNjdXJhY3kgb3ZlciB0aW1lLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gaW5jcmVhc2VcclxuICAgICAqIGlmIHlvdSBoYXZlIGZhc3QgbW92aW5nIG9iamVjdHMgaW4geW91ciBzaW11bGF0aW9uIG9yIHlvdSBoYXZlIGEgbGFyZ2UgbnVtYmVyIG9mIG9iamVjdHMgYW5kIG5lZWQgdG8gaW5jcmVhc2Ugc3RhYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmludGVncmF0aW9uU3RlcHMgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciByb3RhdGlvbiBpcyBhbGxvd2VkIGluIGEgUmlnaWRCb2R5IGNvbGxpc2lvbiByZXNvbHV0aW9uXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbiA9IHRydWU7XHJcbiAgICAvKipcclxuICAgICAqIFNtYWxsIHZhbHVlIHRvIGhlbHAgY29sbGlzaW9uIHBhc3NlcyBzZXR0bGUgdGhlbXNlbHZlcyBhZnRlciB0aGUgbmFycm93cGhhc2UuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuY29sbGlzaW9uU2hpZnQgPSAuMDAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGYWN0b3IgdG8gYWRkIHRvIHRoZSBSaWdpZEJvZHkgQm91bmRpbmdCb3gsIGJvdW5kaW5nIGJveCAoZGltZW5zaW9ucyArPSB2ZWwgKiBkeW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbHllcik7XHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGx5ZXIgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYWQgUmlnaWRCb2R5IEJvdW5kaW5nQm94IGJ5IGEgY29uc3RhbnQgYW1vdW50XHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuYm91bmRzUGFkZGluZyA9IDU7XHJcbiAgICAvKipcclxuICAgICAqIFN1cmZhY2UgZXBzaWxvbiBpcyB1c2VkIHRvIGhlbHAgZGVhbCB3aXRoIHN1cmZhY2UgcGVuYXRyYXRpb25cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zdXJmYWNlRXBzaWxvbiA9IC4xO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgZmFzdCBtb3ZpbmcgYm9keSBjaGVja2luZywgdGhpcyBlbmFibGVzIGNoZWNraW5nIGZvciBjb2xsaXNpb24gcGFpcnMgdmlhIHJheWNhc3QgZm9yIGZhc3QgbW92aW5nIG9iamVjdHMgdG8gcHJldmVudFxyXG4gICAgICogYm9kaWVzIGZyb20gdHVubmVsaW5nIHRocm91Z2ggb25lIGFub3RoZXIuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuY2hlY2tGb3JGYXN0Qm9kaWVzID0gdHJ1ZTtcclxuICAgIC8qKlxyXG4gICAgICogRGlzYWJsZSBtaW5pbXVtIGZhc3QgbW92aW5nIGJvZHkgcmF5Y2FzdCwgYnkgZGVmYXVsdCBpZiBleC5QaHlzaWNzLmNoZWNrRm9yRmFzdEJvZGllcyA9IHRydWUgRXhjYWxpYnVyIHdpbGwgb25seSBjaGVjayBpZiB0aGVcclxuICAgICAqIGJvZHkgaXMgbW92aW5nIGF0IGxlYXN0IGhhbGYgb2YgaXRzIG1pbmltdW0gZGltaW5lbnNpb24gaW4gYW4gdXBkYXRlLiBJZiBleC5QaHlzaWNzLmRpc2FibGVNaW5pbXVtU3BlZWRGb3JGYXN0Qm9keSBpcyBzZXQgdG8gdHJ1ZSxcclxuICAgICAqIEV4Y2FsaWJ1ciB3aWxsIGFsd2F5cyBwZXJmb3JtIHRoZSBmYXN0IGJvZHkgcmF5Y2FzdCByZWdhcmRsZXNzIG9mIHNwZWVkLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmRpc2FibGVNaW5pbXVtU3BlZWRGb3JGYXN0Qm9keSA9IGZhbHNlO1xyXG4gICAgZXhwb3J0cy5QaHlzaWNzID0gUGh5c2ljcztcclxufSk7XHJcbmRlZmluZShcIlV0aWwvRWFzaW5nRnVuY3Rpb25zXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFN0YW5kYXJkIGVhc2luZyBmdW5jdGlvbnMgZm9yIG1vdGlvbiBpbiBFeGNhbGlidXIsIGRlZmluZWQgb24gYSBkb21haW4gb2YgWzAsIGR1cmF0aW9uXSBhbmQgYSByYW5nZSBmcm9tIFsrc3RhcnRWYWx1ZSwrZW5kVmFsdWVdXHJcbiAgICAgKiBHaXZlbiBhIHRpbWUsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIHZhbHVlIGZyb20gcG9zaXRpdmUgc3RhcnRWYWx1ZSB0byBwb3NpdGl2ZSBlbmRWYWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogZnVuY3Rpb24gTGluZWFyICh0KSB7XHJcbiAgICAgKiAgICByZXR1cm4gdCAqIHQ7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxyXG4gICAgICogZnVuY3Rpb24gRWFzZUluUXVhZCAodCkge1xyXG4gICAgICogICAgcmV0dXJuIHQgKiB0O1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XHJcbiAgICAgKiBmdW5jdGlvbiBFYXNlT3V0UXVhZCAodCkge1xyXG4gICAgICogICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxyXG4gICAgICogZnVuY3Rpb24gRWFzZUluT3V0UXVhZCAodCkge1xyXG4gICAgICogICAgcmV0dXJuIHQgPCAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcclxuICAgICAqIGZ1bmN0aW9uIEVhc2VJbkN1YmljICh0KSB7XHJcbiAgICAgKiAgICByZXR1cm4gdCAqIHQgKiB0O1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XHJcbiAgICAgKiBmdW5jdGlvbiBFYXNlT3V0Q3ViaWMgKHQpIHtcclxuICAgICAqICAgIHJldHVybiAoLS10KSAqIHQgKiB0ICsgMTtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cclxuICAgICAqIGZ1bmN0aW9uIEVhc2VJbk91dEN1YmljICh0KSB7XHJcbiAgICAgKiAgICByZXR1cm4gdCA8IC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMTtcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB2YXIgRWFzaW5nRnVuY3Rpb25zID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBFYXNpbmdGdW5jdGlvbnMoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFYXNpbmdGdW5jdGlvbnM7XHJcbiAgICB9KCkpO1xyXG4gICAgRWFzaW5nRnVuY3Rpb25zLkxpbmVhciA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAvIGR1cmF0aW9uICsgc3RhcnRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZUluUXVhZCA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcclxuICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZU91dFF1YWQgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XHJcbiAgICAgICAgcmV0dXJuIC1lbmRWYWx1ZSAqIGN1cnJlbnRUaW1lICogKGN1cnJlbnRUaW1lIC0gMikgKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRRdWFkID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcclxuICAgICAgICBpZiAoY3VycmVudFRpbWUgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAvIDIgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFRpbWUtLTtcclxuICAgICAgICByZXR1cm4gLWVuZFZhbHVlIC8gMiAqIChjdXJyZW50VGltZSAqIChjdXJyZW50VGltZSAtIDIpIC0gMSkgKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5DdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcclxuICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlT3V0Q3ViaWMgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XHJcbiAgICAgICAgY3VycmVudFRpbWUtLTtcclxuICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiAoY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgMSkgKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbiAvIDI7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFRpbWUgLT0gMjtcclxuICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIDIpICsgc3RhcnRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBleHBvcnRzLkVhc2luZ0Z1bmN0aW9ucyA9IEVhc2luZ0Z1bmN0aW9ucztcclxufSk7XHJcbi8vIFByb21pc2VzL0ErIFNwZWMgaHR0cDovL3Byb21pc2VzLWFwbHVzLmdpdGh1Yi5pby9wcm9taXNlcy1zcGVjL1xyXG5kZWZpbmUoXCJQcm9taXNlc1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZCBzdGF0ZXMgZm9yIGEgcHJvbWlzZSB0byBiZSBpblxyXG4gICAgICovXHJcbiAgICB2YXIgUHJvbWlzZVN0YXRlO1xyXG4gICAgKGZ1bmN0aW9uIChQcm9taXNlU3RhdGUpIHtcclxuICAgICAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUmVzb2x2ZWRcIl0gPSAwXSA9IFwiUmVzb2x2ZWRcIjtcclxuICAgICAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUmVqZWN0ZWRcIl0gPSAxXSA9IFwiUmVqZWN0ZWRcIjtcclxuICAgICAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUGVuZGluZ1wiXSA9IDJdID0gXCJQZW5kaW5nXCI7XHJcbiAgICB9KShQcm9taXNlU3RhdGUgPSBleHBvcnRzLlByb21pc2VTdGF0ZSB8fCAoZXhwb3J0cy5Qcm9taXNlU3RhdGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9taXNlcyBhcmUgdXNlZCB0byBkbyBhc3luY2hyb25vdXMgd29yayBhbmQgdGhleSBhcmUgdXNlZnVsIGZvclxyXG4gICAgICogY3JlYXRpbmcgYSBjaGFpbiBvZiBhY3Rpb25zLiBJbiBFeGNhbGlidXIgdGhleSBhcmUgdXNlZCBmb3IgbG9hZGluZyxcclxuICAgICAqIHNvdW5kcywgYW5pbWF0aW9uLCBhY3Rpb25zLCBhbmQgbW9yZS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6UHJvbWlzZXMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgUHJvbWlzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUHJvbWlzZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBQcm9taXNlU3RhdGUuUGVuZGluZztcclxuICAgICAgICAgICAgdGhpcy5fc3VjY2Vzc0NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYW5kIHJlc29sdmUgYSBQcm9taXNlIHdpdGggYW4gb3B0aW9uYWwgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHdyYXAgaW4gYSByZXNvbHZlZCBwcm9taXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gKG5ldyBQcm9taXNlKCkpLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhbmQgcmVqZWN0IGEgUHJvbWlzZSB3aXRoIGFuIG9wdGlvbmFsIHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlICBBbiBvcHRpb25hbCB2YWx1ZSB0byB3cmFwIGluIGEgcmVqZWN0ZWQgcHJvbWlzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gKG5ldyBQcm9taXNlKCkpLnJlamVjdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvbWlzZS5qb2luID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmICFBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBqb2luZWRQcm9taXNlID0gbmV3IFByb21pc2UoKTtcclxuICAgICAgICAgICAgaWYgKCFwcm9taXNlcyB8fCAhcHJvbWlzZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gam9pbmVkUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRvdGFsID0gcHJvbWlzZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgc3VjY2Vzc2VzID0gMDtcclxuICAgICAgICAgICAgdmFyIHJlamVjdHMgPSAwO1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICAgICAgICAgIHByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2VzICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyA9PT0gdG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN1Y2Nlc3NlcyArIHJlamVjdHMgKyBlcnJvcnMubGVuZ3RoID09PSB0b3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlamVjdChlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3RzICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIHJlamVjdHMgKyBlcnJvcnMubGVuZ3RoID09PSB0b3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlamVjdChlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlcnJvcnMubGVuZ3RoICsgc3VjY2Vzc2VzICsgcmVqZWN0cykgPT09IHRvdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gam9pbmVkUHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYWluIHN1Y2Nlc3MgYW5kIHJlamVjdCBjYWxsYmFja3MgYWZ0ZXIgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcclxuICAgICAgICAgKiBAcGFyYW0gc3VjY2Vzc0NhbGxiYWNrICBDYWxsIG9uIHJlc29sdXRpb24gb2YgcHJvbWlzZVxyXG4gICAgICAgICAqIEBwYXJhbSByZWplY3RDYWxsYmFjayAgIENhbGwgb24gcmVqZWN0aW9uIG9mIHByb21pc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKHN1Y2Nlc3NDYWxsYmFjaywgcmVqZWN0Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3VjY2Vzc0NhbGxiYWNrcy5wdXNoKHN1Y2Nlc3NDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc292bGVkIGNhbGwgaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKCkgPT09IFByb21pc2VTdGF0ZS5SZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWplY3RDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0Q2FsbGJhY2sgPSByZWplY3RDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcm9taXNlIGlzIGFscmVhZHkgcmVqZWN0ZWQgY2FsbCBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA9PT0gUHJvbWlzZVN0YXRlLlJlamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0Q2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhbiBlcnJvciBjYWxsYmFjayB0byB0aGUgcHJvbWlzZVxyXG4gICAgICAgICAqIEBwYXJhbSBlcnJvckNhbGxiYWNrICBDYWxsIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBpbiBhIGNhbGxiYWNrXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JDYWxsYmFjayA9IGVycm9yQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvbHZlIHRoZSBwcm9taXNlIGFuZCBwYXNzIGFuIG9wdGlvbiB2YWx1ZSB0byB0aGUgc3VjY2VzcyBjYWxsYmFja3NcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgIFZhbHVlIHRvIHBhc3MgdG8gdGhlIHN1Y2Nlc3MgY2FsbGJhY2tzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFByb21pc2VTdGF0ZS5QZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFByb21pc2VTdGF0ZS5SZXNvbHZlZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWNjZXNzQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoX3RoaXMsIF90aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzb2x2ZSBhIHByb21pc2UgdGhhdCBpcyBub3QgaW4gYSBwZW5kaW5nIHN0YXRlIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVqZWN0IHRoZSBwcm9taXNlIGFuZCBwYXNzIGFuIG9wdGlvbiB2YWx1ZSB0byB0aGUgcmVqZWN0IGNhbGxiYWNrc1xyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSAgVmFsdWUgdG8gcGFzcyB0byB0aGUgcmVqZWN0IGNhbGxiYWNrc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFByb21pc2VTdGF0ZS5QZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFByb21pc2VTdGF0ZS5SZWplY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWplY3QgYSBwcm9taXNlIHRoYXQgaXMgbm90IGluIGEgcGVuZGluZyBzdGF0ZSEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc3BlY3QgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYSBwcm9taXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvckNhbGxiYWNrLmNhbGwodGhpcywgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlByb21pc2UgPSBQcm9taXNlO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL1NpZGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZW51bSB0aGF0IGRlc2NyaWJlcyB0aGUgc2lkZXMgb2YgYW4gQWN0b3IgZm9yIGNvbGxpc2lvblxyXG4gICAgICovXHJcbiAgICB2YXIgU2lkZTtcclxuICAgIChmdW5jdGlvbiAoU2lkZSkge1xyXG4gICAgICAgIFNpZGVbU2lkZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgICAgIFNpZGVbU2lkZVtcIlRvcFwiXSA9IDFdID0gXCJUb3BcIjtcclxuICAgICAgICBTaWRlW1NpZGVbXCJCb3R0b21cIl0gPSAyXSA9IFwiQm90dG9tXCI7XHJcbiAgICAgICAgU2lkZVtTaWRlW1wiTGVmdFwiXSA9IDNdID0gXCJMZWZ0XCI7XHJcbiAgICAgICAgU2lkZVtTaWRlW1wiUmlnaHRcIl0gPSA0XSA9IFwiUmlnaHRcIjtcclxuICAgIH0pKFNpZGUgPSBleHBvcnRzLlNpZGUgfHwgKGV4cG9ydHMuU2lkZSA9IHt9KSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL1V0aWxcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBbGdlYnJhXCIsIFwiQ29sbGlzaW9uL1NpZGVcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBbGdlYnJhXzIsIFNpZGVfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFR3byBQSSBjb25zdGFudFxyXG4gICAgICovXHJcbiAgICBleHBvcnRzLlR3b1BJID0gTWF0aC5QSSAqIDI7XHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlcyBvbmUgb3IgbW9yZSBvYmplY3RzIGludG8gYSBzaW5nbGUgdGFyZ2V0IG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIE1lcmdlZCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGZyb20gb3RoZXIgb2JqZWN0c1xyXG4gICAgICogQGNyZWRpdCBodHRwczovL2dvbWFrZXRoaW5ncy5jb20vdmFuaWxsYS1qYXZhc2NyaXB0LXZlcnNpb24tb2YtanF1ZXJ5LWV4dGVuZC9cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZXh0ZW5kKCkge1xyXG4gICAgICAgIHZhciBleHRlbmRlZCA9IHt9O1xyXG4gICAgICAgIHZhciBkZWVwID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGEgZGVlcCBtZXJnZVxyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzWzBdKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nKSB7XHJcbiAgICAgICAgICAgIGRlZXAgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWVyZ2UgdGhlIG9iamVjdCBpbnRvIHRoZSBleHRlbmRlZCBvYmplY3RcclxuICAgICAgICB2YXIgYXNzaWduRXhpc3RzID0gdHlwZW9mIE9iamVjdC5hc3NpZ24gPT09ICdmdW5jdGlvbic7XHJcbiAgICAgICAgdmFyIG1lcmdlID0gbnVsbDtcclxuICAgICAgICBpZiAoIWFzc2lnbkV4aXN0cykge1xyXG4gICAgICAgICAgICBtZXJnZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRlZXAgbWVyZ2UgYW5kIHByb3BlcnR5IGlzIGFuIG9iamVjdCwgbWVyZ2UgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqW3Byb3BdKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkW3Byb3BdID0gZXh0ZW5kKHRydWUsIGV4dGVuZGVkW3Byb3BdLCBvYmpbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRbcHJvcF0gPSBvYmpbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXJnZSA9IE9iamVjdC5hc3NpZ247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIG9iamVjdCBhbmQgY29uZHVjdCBhIG1lcmdlXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWFzc2lnbkV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2Uob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlKGV4dGVuZGVkLCBvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleHRlbmRlZDtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xyXG4gICAgZnVuY3Rpb24gYmFzZTY0RW5jb2RlKGlucHV0U3RyKSB7XHJcbiAgICAgICAgdmFyIGI2NCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XHJcbiAgICAgICAgdmFyIG91dHB1dFN0ciA9ICcnO1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IGlucHV0U3RyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvL2FsbCB0aHJlZSBcIiYgMHhmZlwiIGFkZGVkIGJlbG93IGFyZSB0aGVyZSB0byBmaXggYSBrbm93biBidWdcclxuICAgICAgICAgICAgLy93aXRoIGJ5dGVzIHJldHVybmVkIGJ5IHhoci5yZXNwb25zZVRleHRcclxuICAgICAgICAgICAgdmFyIGJ5dGUxID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcclxuICAgICAgICAgICAgdmFyIGJ5dGUyID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcclxuICAgICAgICAgICAgdmFyIGJ5dGUzID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcclxuICAgICAgICAgICAgdmFyIGVuYzEgPSBieXRlMSA+PiAyO1xyXG4gICAgICAgICAgICB2YXIgZW5jMiA9ICgoYnl0ZTEgJiAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICAgICAgdmFyIGVuYzMsIGVuYzQ7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihieXRlMikpIHtcclxuICAgICAgICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbmMzID0gKChieXRlMiAmIDE1KSA8PCAyKSB8IChieXRlMyA+PiA2KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihieXRlMykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmM0ID0gNjQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmM0ID0gYnl0ZTMgJiA2MztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRwdXRTdHIgKz0gYjY0LmNoYXJBdChlbmMxKSArIGI2NC5jaGFyQXQoZW5jMikgKyBiNjQuY2hhckF0KGVuYzMpICsgYjY0LmNoYXJBdChlbmM0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dFN0cjtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuYmFzZTY0RW5jb2RlID0gYmFzZTY0RW5jb2RlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFtcHMgYSB2YWx1ZSBiZXR3ZWVuIGEgbWluIGFuZCBtYXggaW5jbHVzaXZlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsYW1wKHZhbCwgbWluLCBtYXgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCB2YWwpLCBtYXgpO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xyXG4gICAgZnVuY3Rpb24gcmFuZG9tSW5SYW5nZShtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnJhbmRvbUluUmFuZ2UgPSByYW5kb21JblJhbmdlO1xyXG4gICAgZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHJhbmRvbUluUmFuZ2UobWluLCBtYXgpKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMucmFuZG9tSW50SW5SYW5nZSA9IHJhbmRvbUludEluUmFuZ2U7XHJcbiAgICBmdW5jdGlvbiBjYW5vbmljYWxpemVBbmdsZShhbmdsZSkge1xyXG4gICAgICAgIHZhciB0bXBBbmdsZSA9IGFuZ2xlO1xyXG4gICAgICAgIGlmIChhbmdsZSA+IGV4cG9ydHMuVHdvUEkpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHRtcEFuZ2xlID4gZXhwb3J0cy5Ud29QSSkge1xyXG4gICAgICAgICAgICAgICAgdG1wQW5nbGUgLT0gZXhwb3J0cy5Ud29QSTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0bXBBbmdsZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRtcEFuZ2xlICs9IGV4cG9ydHMuVHdvUEk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRtcEFuZ2xlO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5jYW5vbmljYWxpemVBbmdsZSA9IGNhbm9uaWNhbGl6ZUFuZ2xlO1xyXG4gICAgZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcclxuICAgICAgICByZXR1cm4gMTgwIC8gTWF0aC5QSSAqIHJhZGlhbnM7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnRvRGVncmVlcyA9IHRvRGVncmVlcztcclxuICAgIGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZ3JlZXMgLyAxODAgKiBNYXRoLlBJO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy50b1JhZGlhbnMgPSB0b1JhZGlhbnM7XHJcbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG4gICAgICAgIHZhciBvTGVmdCA9IDAsIG9Ub3AgPSAwO1xyXG4gICAgICAgIHZhciBjYWxjT2Zmc2V0TGVmdCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgb0xlZnQgKz0gcGFyZW50Lm9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQub2Zmc2V0UGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjYWxjT2Zmc2V0TGVmdChwYXJlbnQub2Zmc2V0UGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGNhbGNPZmZzZXRUb3AgPSBmdW5jdGlvbiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIG9Ub3AgKz0gcGFyZW50Lm9mZnNldFRvcDtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5vZmZzZXRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGNPZmZzZXRUb3AocGFyZW50Lm9mZnNldFBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGNhbGNPZmZzZXRMZWZ0KGVsKTtcclxuICAgICAgICBjYWxjT2Zmc2V0VG9wKGVsKTtcclxuICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMi5WZWN0b3Iob0xlZnQsIG9Ub3ApO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5nZXRQb3NpdGlvbiA9IGdldFBvc2l0aW9uO1xyXG4gICAgZnVuY3Rpb24gYWRkSXRlbVRvQXJyYXkoaXRlbSwgYXJyYXkpIHtcclxuICAgICAgICBpZiAoYXJyYXkuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgYXJyYXkucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuYWRkSXRlbVRvQXJyYXkgPSBhZGRJdGVtVG9BcnJheTtcclxuICAgIGZ1bmN0aW9uIHJlbW92ZUl0ZW1Gcm9tQXJyYXkoaXRlbSwgYXJyYXkpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgICAgICBpZiAoKGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKSkgPiAtMSkge1xyXG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5yZW1vdmVJdGVtRnJvbUFycmF5ID0gcmVtb3ZlSXRlbUZyb21BcnJheTtcclxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCBvYmopIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmNvbnRhaW5zID0gY29udGFpbnM7XHJcbiAgICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVNpZGUoc2lkZSkge1xyXG4gICAgICAgIGlmIChzaWRlID09PSBTaWRlXzEuU2lkZS5Ub3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpZGVfMS5TaWRlLkJvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGVfMS5TaWRlLkJvdHRvbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZV8xLlNpZGUuVG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2lkZSA9PT0gU2lkZV8xLlNpZGUuTGVmdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZV8xLlNpZGUuUmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaWRlID09PSBTaWRlXzEuU2lkZS5SaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZV8xLlNpZGUuTGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNpZGVfMS5TaWRlLk5vbmU7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmdldE9wcG9zaXRlU2lkZSA9IGdldE9wcG9zaXRlU2lkZTtcclxuICAgIGZ1bmN0aW9uIGdldFNpZGVGcm9tVmVjdG9yKGRpcmVjdGlvbikge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb25zID0gW0FsZ2VicmFfMi5WZWN0b3IuTGVmdCwgQWxnZWJyYV8yLlZlY3Rvci5SaWdodCwgQWxnZWJyYV8yLlZlY3Rvci5VcCwgQWxnZWJyYV8yLlZlY3Rvci5Eb3duXTtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uRW51bSA9IFtTaWRlXzEuU2lkZS5MZWZ0LCBTaWRlXzEuU2lkZS5SaWdodCwgU2lkZV8xLlNpZGUuVG9wLCBTaWRlXzEuU2lkZS5Cb3R0b21dO1xyXG4gICAgICAgIHZhciBtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB2YXIgbWF4SW5kZXggPSAtMTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbaV0uZG90KGRpcmVjdGlvbikgPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IGRpcmVjdGlvbnNbaV0uZG90KGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbkVudW1bbWF4SW5kZXhdO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5nZXRTaWRlRnJvbVZlY3RvciA9IGdldFNpZGVGcm9tVmVjdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGNhbGlidXIncyBkeW5hbWljYWxseSByZXNpemluZyBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xsZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gaW5pdGlhbFNpemUgIEluaXRpYWwgc2l6ZSBvZiB0aGUgaW50ZXJuYWwgYmFja2luZyBhcnJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbGxlY3Rpb24oaW5pdGlhbFNpemUpIHtcclxuICAgICAgICAgICAgaWYgKGluaXRpYWxTaXplID09PSB2b2lkIDApIHsgaW5pdGlhbFNpemUgPSBDb2xsZWN0aW9uLkRlZmF1bHRTaXplOyB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQXJyYXkgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRQb2ludGVyID0gMDtcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheSA9IG5ldyBBcnJheShpbml0aWFsU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdTaXplID0gdGhpcy5faW50ZXJuYWxBcnJheS5sZW5ndGggKiAyO1xyXG4gICAgICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3U2l6ZSk7XHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdBcnJheVtpXSA9IHRoaXMuX2ludGVybmFsQXJyYXlbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ludGVybmFsQXJyYXk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQXJyYXkgPSBuZXdBcnJheTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFB1c2ggZWxlbWVudHMgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZW5kUG9pbnRlciA9PT0gdGhpcy5faW50ZXJuYWxBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5W3RoaXMuX2VuZFBvaW50ZXIrK10gPSBlbGVtZW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFBvaW50ZXIgPSB0aGlzLl9lbmRQb2ludGVyIC0gMSA8IDAgPyAwIDogdGhpcy5fZW5kUG9pbnRlciAtIDE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5W3RoaXMuX2VuZFBvaW50ZXJdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY291bnQgb2YgdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuZFBvaW50ZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbXB0aWVzIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFBvaW50ZXIgPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgaW50ZXJuYWwgYmFja2luZyBhcnJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmludGVybmFsU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcclxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggIEluZGV4IG9mIGVsZW1lbnQgdG8gcmV0cmlldmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lbGVtZW50QXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuY291bnQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignSW52YWxpZCBwYXJhbWV0ZXI6ICcgKyBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5kZXggJyArIGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxBcnJheVtpbmRleF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnNlcnRzIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgSW5kZXggdG8gaW5zZXJ0IHRoZSBlbGVtZW50XHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlICBFbGVtZW50IHRvIGluc2VydFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuY291bnQoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXlbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgSW5kZXggb2YgZWxlbWVudCB0byByZW1vdmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xyXG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyOiAnICsgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlciAnICsgaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE8obikgU2hpZnRcclxuICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9pbnRlcm5hbEFycmF5W2luZGV4XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheVtpXSA9IHRoaXMuX2ludGVybmFsQXJyYXlbaSArIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFBvaW50ZXItLTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIGVsZW1lbnQgIEVsZW1lbnQgdG8gcmV0cmlldmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW50ZXJuYWxBcnJheS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShpbmRleCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXkuc2xpY2UoMCwgdGhpcy5fZW5kUG9pbnRlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJdGVyYXRlIG92ZXIgZXZlcnkgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBmdW5jICBDYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGVsZW1lbnQgcGFzc2luZyBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4LCByZXR1cm5lZCB2YWx1ZXMgYXJlIGlnbm9yZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBjb3VudCA9IHRoaXMuY291bnQoKTtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZnVuYy5jYWxsKHRoaXMsIHRoaXMuX2ludGVybmFsQXJyYXlbaV0sIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNdXRhdGUgZXZlcnkgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBmdW5jICBDYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGVsZW1lbnQgcGFzc2luZyBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4LCBhbnkgdmFsdWVzIHJldHVybmVkIG11dGF0ZVxyXG4gICAgICAgICAqIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQXJyYXlbaV0gPSBmdW5jLmNhbGwodGhpcywgdGhpcy5faW50ZXJuYWxBcnJheVtpXSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb2xsZWN0aW9uO1xyXG4gICAgfSgpKTtcclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBjb2xsZWN0aW9uIHNpemVcclxuICAgICAqL1xyXG4gICAgQ29sbGVjdGlvbi5EZWZhdWx0U2l6ZSA9IDIwMDtcclxuICAgIGV4cG9ydHMuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XHJcbn0pO1xyXG5kZWZpbmUoXCJDYW1lcmFcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL0Vhc2luZ0Z1bmN0aW9uc1wiLCBcIlByb21pc2VzXCIsIFwiQWxnZWJyYVwiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEVhc2luZ0Z1bmN0aW9uc18xLCBQcm9taXNlc18xLCBBbGdlYnJhXzMsIFV0aWxfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIENvbnRhaW5lciB0byBob3VzZSBjb252ZW5pZW5jZSBzdHJhdGVneSBtZXRob2RzXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdmFyIFN0cmF0ZWd5Q29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBTdHJhdGVneUNvbnRhaW5lcihjYW1lcmEpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgdGhlIFtbTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneV1dIG9uIHRoZSBjdXJyZW50IGNhbWVyYS5cclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIGxvY2sgdGhlIGNhbWVyYSB0b1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmF0ZWd5Q29udGFpbmVyLnByb3RvdHlwZS5sb2NrVG9BY3RvciA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneShhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbmQgYWRkcyB0aGUgW1tMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneV1dIG9uIHRoZSBjdXJyZW50IGNhbWVyYVxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gbG9jayB0aGUgY2FtZXJhIHRvXHJcbiAgICAgICAgICogQHBhcmFtIGF4aXMgVGhlIGF4aXMgdG8gZm9sbG93IHRoZSBhY3RvciBvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmF0ZWd5Q29udGFpbmVyLnByb3RvdHlwZS5sb2NrVG9BY3RvckF4aXMgPSBmdW5jdGlvbiAoYWN0b3IsIGF4aXMpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEuYWRkU3RyYXRlZ3kobmV3IExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5KGFjdG9yLCBheGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW0VsYXN0aWNUb0FjdG9yU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmFcclxuICAgICAgICAgKiBJZiBjYW1lcmFFbGFzdGljaXR5IDwgY2FtZXJhRnJpY3Rpb24gPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGEgZGFtcGVuZWQgc3ByaW5nIHRoYXQgd2lsbCBzbG93bHkgZW5kIGF0IHRoZSB0YXJnZXQgd2l0aG91dCBib3VuY2luZ1xyXG4gICAgICAgICAqIElmIGNhbWVyYUZyaWN0aW9uIDwgY2FtZXJhRWxhc3RpY2l0eSA8IDEuMCwgdGhlIGJlaGF2aW9yIHdpbGwgYmUgYW4gb3NjaWxsYXRpb25nIHNwcmluZyB0aGF0IHdpbGwgb3ZlclxyXG4gICAgICAgICAqIGNvcnJlY3QgYW5kIGJvdW5jZSBhcm91bmQgdGhlIHRhcmdldFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgYWN0b3IgdG8gZWxhc3RpY2FsbHkgZm9sbG93XHJcbiAgICAgICAgICogQHBhcmFtIGNhbWVyYUVsYXN0aWNpdHkgWzAgLSAxLjBdIFRoZSBoaWdoZXIgdGhlIGVsYXN0aWNpdHkgdGhlIG1vcmUgZm9yY2UgdGhhdCB3aWxsIGRyaXZlIHRoZSBjYW1lcmEgdG93YXJkcyB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICogQHBhcmFtIGNhbWVyYUZyaWN0aW9uIFswIC0gMS4wXSBUaGUgaGlnaGVyIHRoZSBmcmljdGlvbiB0aGUgbW9yZSB0aGF0IHRoZSBjYW1lcmEgd2lsbCByZXNpc3QgbW90aW9uIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmF0ZWd5Q29udGFpbmVyLnByb3RvdHlwZS5lbGFzdGljVG9BY3RvciA9IGZ1bmN0aW9uIChhY3RvciwgY2FtZXJhRWxhc3RpY2l0eSwgY2FtZXJhRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEuYWRkU3RyYXRlZ3kobmV3IEVsYXN0aWNUb0FjdG9yU3RyYXRlZ3koYWN0b3IsIGNhbWVyYUVsYXN0aWNpdHksIGNhbWVyYUZyaWN0aW9uKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW1JhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmFcclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCBhY3RvciB0byBmb2xsb3cgd2hlbiBpdCBpcyBcInJhZGl1c1wiIHBpeGVscyBhd2F5XHJcbiAgICAgICAgICogQHBhcmFtIHJhZGl1cyBOdW1iZXIgb2YgcGl4ZWxzIGF3YXkgYmVmb3JlIHRoZSBjYW1lcmEgd2lsbCBmb2xsb3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBTdHJhdGVneUNvbnRhaW5lci5wcm90b3R5cGUucmFkaXVzQXJvdW5kQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IsIHJhZGl1cykge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneShhY3RvciwgcmFkaXVzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3RyYXRlZ3lDb250YWluZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5TdHJhdGVneUNvbnRhaW5lciA9IFN0cmF0ZWd5Q29udGFpbmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYW1lcmEgYXhpcyBlbnVtXHJcbiAgICAgKi9cclxuICAgIHZhciBBeGlzO1xyXG4gICAgKGZ1bmN0aW9uIChBeGlzKSB7XHJcbiAgICAgICAgQXhpc1tBeGlzW1wiWFwiXSA9IDBdID0gXCJYXCI7XHJcbiAgICAgICAgQXhpc1tBeGlzW1wiWVwiXSA9IDFdID0gXCJZXCI7XHJcbiAgICB9KShBeGlzID0gZXhwb3J0cy5BeGlzIHx8IChleHBvcnRzLkF4aXMgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NrIGEgY2FtZXJhIHRvIHRoZSBleGFjdCB4L3kgcG9zdGl0aW9uIG9mIGFuIGFjdG9yLlxyXG4gICAgICovXHJcbiAgICB2YXIgTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneSh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gZnVuY3Rpb24gKHRhcmdldCwgX2NhbSwgX2VuZywgX2RlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gdGFyZ2V0LmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3k7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Mb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5ID0gTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneTtcclxuICAgIC8qKlxyXG4gICAgICogTG9jayBhIGNhbWVyYSB0byBhIHNwZWNpZmljIGF4aXMgYXJvdW5kIGFuIGFjdG9yLlxyXG4gICAgICovXHJcbiAgICB2YXIgTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5KHRhcmdldCwgYXhpcykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5heGlzID0gYXhpcztcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYW0sIF9lbmcsIF9kZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRhcmdldC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Rm9jdXMgPSBjYW0uZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5heGlzID09PSBBeGlzLlgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMy5WZWN0b3IoY2VudGVyLngsIGN1cnJlbnRGb2N1cy55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8zLlZlY3RvcihjdXJyZW50Rm9jdXMueCwgY2VudGVyLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3k7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Mb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneSA9IExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2luZyBbSG9vaydzIGxhd10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9va2Unc19sYXcpLCBlbGFzdGljYWxseSBtb3ZlIHRoZSBjYW1lcmEgdG93YXJkcyB0aGUgdGFyZ2V0IGFjdG9yLlxyXG4gICAgICovXHJcbiAgICB2YXIgRWxhc3RpY1RvQWN0b3JTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgY2FtZXJhRWxhc3RpY2l0eSA8IGNhbWVyYUZyaWN0aW9uIDwgMS4wLCB0aGUgYmVoYXZpb3Igd2lsbCBiZSBhIGRhbXBlbmVkIHNwcmluZyB0aGF0IHdpbGwgc2xvd2x5IGVuZCBhdCB0aGUgdGFyZ2V0IHdpdGhvdXQgYm91bmNpbmdcclxuICAgICAgICAgKiBJZiBjYW1lcmFGcmljdGlvbiA8IGNhbWVyYUVsYXN0aWNpdHkgPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGFuIG9zY2lsbGF0aW9uZyBzcHJpbmcgdGhhdCB3aWxsIG92ZXJcclxuICAgICAgICAgKiBjb3JyZWN0IGFuZCBib3VuY2UgYXJvdW5kIHRoZSB0YXJnZXRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IGFjdG9yIHRvIGVsYXN0aWNhbGx5IGZvbGxvd1xyXG4gICAgICAgICAqIEBwYXJhbSBjYW1lcmFFbGFzdGljaXR5IFswIC0gMS4wXSBUaGUgaGlnaGVyIHRoZSBlbGFzdGljaXR5IHRoZSBtb3JlIGZvcmNlIHRoYXQgd2lsbCBkcml2ZSB0aGUgY2FtZXJhIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgICAgICAqIEBwYXJhbSBjYW1lcmFGcmljdGlvbiBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZnJpY3Rpb24gdGhlIG1vcmUgdGhhdCB0aGUgY2FtZXJhIHdpbGwgcmVzaXN0IG1vdGlvbiB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBFbGFzdGljVG9BY3RvclN0cmF0ZWd5KHRhcmdldCwgY2FtZXJhRWxhc3RpY2l0eSwgY2FtZXJhRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRWxhc3RpY2l0eSA9IGNhbWVyYUVsYXN0aWNpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRnJpY3Rpb24gPSBjYW1lcmFGcmljdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYW0sIF9lbmcsIF9kZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0LmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gY2FtLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FtZXJhVmVsID0gbmV3IEFsZ2VicmFfMy5WZWN0b3IoY2FtLmR4LCBjYW0uZHkpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzdHJlY2ggdmVjdG9yLCB1c2luZyB0aGUgc3ByaW5nIGVxdWF0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBGID0ga1hcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hvb2tlJ3NfbGF3XHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0byB0aGUgY3VycmVudCBjYW1lcmEgdmVsb2NpdHlcclxuICAgICAgICAgICAgICAgIHZhciBzdHJldGNoID0gcG9zaXRpb24uc3ViKGZvY3VzKS5zY2FsZShfdGhpcy5jYW1lcmFFbGFzdGljaXR5KTsgLy8gc3RyZXRjaCBpcyBYXHJcbiAgICAgICAgICAgICAgICBjYW1lcmFWZWwgPSBjYW1lcmFWZWwuYWRkKHN0cmV0Y2gpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBmcmljdGlvbiAoLTEgdG8gYXBwbHkgYSBmb3JjZSBpbiB0aGUgb3Bwb3NpdGlvbiBvZiBtb3Rpb24pXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0byB0aGUgY3VycmVudCBjYW1lcmEgdmVsb2NpdHlcclxuICAgICAgICAgICAgICAgIHZhciBmcmljdGlvbiA9IGNhbWVyYVZlbC5zY2FsZSgtMSkuc2NhbGUoX3RoaXMuY2FtZXJhRnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhVmVsID0gY2FtZXJhVmVsLmFkZChmcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb24gYnkgdmVsb2NpdHkgZGVsdGFzXHJcbiAgICAgICAgICAgICAgICBmb2N1cyA9IGZvY3VzLmFkZChjYW1lcmFWZWwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRWxhc3RpY1RvQWN0b3JTdHJhdGVneTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkVsYXN0aWNUb0FjdG9yU3RyYXRlZ3kgPSBFbGFzdGljVG9BY3RvclN0cmF0ZWd5O1xyXG4gICAgdmFyIFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgYWN0b3IgdG8gZm9sbG93IHdoZW4gaXQgaXMgXCJyYWRpdXNcIiBwaXhlbHMgYXdheVxyXG4gICAgICAgICAqIEBwYXJhbSByYWRpdXMgTnVtYmVyIG9mIHBpeGVscyBhd2F5IGJlZm9yZSB0aGUgY2FtZXJhIHdpbGwgZm9sbG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneSh0YXJnZXQsIHJhZGl1cykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gZnVuY3Rpb24gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRhcmdldC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IGNhbS5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHBvc2l0aW9uLnN1Yihmb2N1cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBkaXJlY3Rpb24ubWFnbml0dWRlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPj0gX3RoaXMucmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGRpc3RhbmNlIC0gX3RoaXMucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb2N1cy5hZGQoZGlyZWN0aW9uLm5vcm1hbGl6ZSgpLnNjYWxlKG9mZnNldCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3kgPSBSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYW1lcmFzXHJcbiAgICAgKlxyXG4gICAgICogW1tCYXNlQ2FtZXJhXV0gaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBFeGNhbGlidXIgY2FtZXJhcy4gQ2FtZXJhcyBhcmUgdXNlZFxyXG4gICAgICogdG8gbW92ZSBhcm91bmQgeW91ciBnYW1lIGFuZCBzZXQgZm9jdXMuIFRoZXkgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lXHJcbiAgICAgKiB3aGF0IGlzIFwib2ZmIHNjcmVlblwiIGFuZCBjYW4gYmUgdXNlZCB0byBzY2FsZSB0aGUgZ2FtZS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6Q2FtZXJhcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBCYXNlQ2FtZXJhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBCYXNlQ2FtZXJhKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBuZXcgU3RyYXRlZ3lDb250YWluZXIodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIGNhbWVyYSBwaHlzaWNhbCBxdWFudGl0aWVzXHJcbiAgICAgICAgICAgIHRoaXMueiA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuZHggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmR5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5keiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYXggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmF5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5heiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnJ4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5feCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gMTAwMDsgLy8gMSBzZWNvbmQgICBcclxuICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vY2FtZXJhIGVmZmVjdHNcclxuICAgICAgICAgICAgdGhpcy5faXNTaGFraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkU2hha2VUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5feFNoYWtlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5feVNoYWtlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX21heFpvb21TY2FsZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb21JbmNyZW1lbnQgPSAwLjAxO1xyXG4gICAgICAgICAgICB0aGlzLl9lYXNpbmcgPSBFYXNpbmdGdW5jdGlvbnNfMS5FYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlQ2FtZXJhLnByb3RvdHlwZSwgXCJ4XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldCB0aGUgY2FtZXJhJ3MgeCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCB0aGUgY2FtZXJhJ3MgeCBwb3NpdGlvbiAoY2Fubm90IGJlIHNldCB3aGVuIGZvbGxvd2luZyBhbiBbW0FjdG9yXV0gb3Igd2hlbiBtb3ZpbmcpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9mb2xsb3cgJiYgIXRoaXMuX2NhbWVyYU1vdmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VDYW1lcmEucHJvdG90eXBlLCBcInlcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBjYW1lcmEncyB5IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0IHRoZSBjYW1lcmEncyB5IHBvc2l0aW9uIChjYW5ub3QgYmUgc2V0IHdoZW4gZm9sbG93aW5nIGFuIFtbQWN0b3JdXSBvciB3aGVuIG1vdmluZylcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZvbGxvdyAmJiAhdGhpcy5fY2FtZXJhTW92aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUNhbWVyYS5wcm90b3R5cGUsIFwicG9zXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldCB0aGUgY2FtZXJhJ3MgcG9zaXRpb24gYXMgYSB2ZWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzMuVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCB0aGUgY2FtZXJhcyBwb3NpdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZS55O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUNhbWVyYS5wcm90b3R5cGUsIFwidmVsXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldCB0aGUgY2FtZXJhJ3MgdmVsb2NpdHkgYXMgYSB2ZWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzMuVmVjdG9yKHRoaXMuZHgsIHRoaXMuZHkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0IHRoZSBjYW1lcmEncyB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHggPSB2YWx1ZS54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5keSA9IHZhbHVlLnk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGZvY2FsIHBvaW50IG9mIHRoZSBjYW1lcmEsIGEgbmV3IHBvaW50IGdpdmluZyB0aGUgeCBhbmQgeSBwb3NpdGlvbiBvZiB0aGUgY2FtZXJhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuZ2V0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8zLlZlY3Rvcih0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1vdmVzIHRoZSBjYW1lcmEgZm9jYWwgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiB1c2luZyBzcGVjaWZpZWQgZWFzaW5nIGZ1bmN0aW9uLiBDYW5ub3QgbW92ZSB3aGVuIGZvbGxvd2luZyBhbiBBY3Rvci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBwb3MgVGhlIHRhcmdldCBwb3NpdGlvbiB0byBtb3ZlIHRvXHJcbiAgICAgICAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdGhlIG1vdmUgc2hvdWxkIGxhc3RcclxuICAgICAgICAgKiBAcGFyYW0gW2Vhc2luZ0ZuXSBBbiBvcHRpb25hbCBlYXNpbmcgZnVuY3Rpb24gKFtbZXguRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljXV0gYnkgZGVmYXVsdClcclxuICAgICAgICAgKiBAcmV0dXJucyBBIFtbUHJvbWlzZV1dIHRoYXQgcmVzb2x2ZXMgd2hlbiBtb3ZlbWVudCBpcyBmaW5pc2hlZCwgaW5jbHVkaW5nIGlmIGl0J3MgaW50ZXJydXB0ZWQuXHJcbiAgICAgICAgICogICAgICAgICAgVGhlIFtbUHJvbWlzZV1dIHZhbHVlIGlzIHRoZSBbW1ZlY3Rvcl1dIG9mIHRoZSB0YXJnZXQgcG9zaXRpb24uIEl0IHdpbGwgYmUgcmVqZWN0ZWQgaWYgYSBtb3ZlIGNhbm5vdCBiZSBtYWRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbiwgZWFzaW5nRm4pIHtcclxuICAgICAgICAgICAgaWYgKGVhc2luZ0ZuID09PSB2b2lkIDApIHsgZWFzaW5nRm4gPSBFYXNpbmdGdW5jdGlvbnNfMS5FYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWM7IH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmdGbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ1BsZWFzZSBzcGVjaWZ5IGFuIEVhc2luZ0Z1bmN0aW9uJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYW5ub3QgbW92ZSB3aGVuIGZvbGxvd2luZyBhbiBhY3RvclxyXG4gICAgICAgICAgICBpZiAodGhpcy5fZm9sbG93KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VzXzEuUHJvbWlzZSgpLnJlamVjdChwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlc29sdmUgZXhpc3RpbmcgcHJvbWlzZSwgaWYgYW55XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwUHJvbWlzZSAmJiB0aGlzLl9sZXJwUHJvbWlzZS5zdGF0ZSgpID09PSBQcm9taXNlc18xLlByb21pc2VTdGF0ZS5QZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXJwUHJvbWlzZS5yZXNvbHZlKHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGVycFByb21pc2UgPSBuZXcgUHJvbWlzZXNfMS5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IHRoaXMuZ2V0Rm9jdXMoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IHBvcztcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZWFzaW5nID0gZWFzaW5nRm47XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXJwUHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNhbWVyYSB0byBzaGFrZSBhdCB0aGUgc3BlY2lmaWVkIG1hZ25pdHVkZXMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb25cclxuICAgICAgICAgKiBAcGFyYW0gbWFnbml0dWRlWCAgVGhlIHggbWFnbml0dWRlIG9mIHRoZSBzaGFrZVxyXG4gICAgICAgICAqIEBwYXJhbSBtYWduaXR1ZGVZICBUaGUgeSBtYWduaXR1ZGUgb2YgdGhlIHNoYWtlXHJcbiAgICAgICAgICogQHBhcmFtIGR1cmF0aW9uICAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgc2hha2UgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuc2hha2UgPSBmdW5jdGlvbiAobWFnbml0dWRlWCwgbWFnbml0dWRlWSwgZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5faXNTaGFraW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVYID0gbWFnbml0dWRlWDtcclxuICAgICAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVZID0gbWFnbml0dWRlWTtcclxuICAgICAgICAgICAgdGhpcy5fc2hha2VEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogWm9vbXMgdGhlIGNhbWVyYSBpbiBvciBvdXQgYnkgdGhlIHNwZWNpZmllZCBzY2FsZSBvdmVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXHJcbiAgICAgICAgICogSWYgbm8gZHVyYXRpb24gaXMgc3BlY2lmaWVkLCBpdCB0YWtlIGVmZmVjdCBpbW1lZGlhdGVseS5cclxuICAgICAgICAgKiBAcGFyYW0gc2NhbGUgICAgVGhlIHNjYWxlIG9mIHRoZSB6b29tXHJcbiAgICAgICAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgem9vbSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24gKHNjYWxlLCBkdXJhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkgeyBkdXJhdGlvbiA9IDA7IH1cclxuICAgICAgICAgICAgdGhpcy5fem9vbVByb21pc2UgPSBuZXcgUHJvbWlzZXNfMS5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21heFpvb21TY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fem9vbUluY3JlbWVudCA9IChzY2FsZSAtIHRoaXMueikgLyBkdXJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy56ID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96b29tUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b29tUHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgem9vbSBzY2FsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLno7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgbmV3IGNhbWVyYSBzdHJhdGVneSB0byB0aGlzIGNhbWVyYVxyXG4gICAgICAgICAqIEBwYXJhbSBjYW1lcmFTdHJhdGVneSBJbnN0YW5jZSBvZiBhbiBbW0lDYW1lcmFTdHJhdGVneV1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuYWRkU3RyYXRlZ3kgPSBmdW5jdGlvbiAoY2FtZXJhU3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcy5wdXNoKGNhbWVyYVN0cmF0ZWd5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBjYW1lcmEgc3RyYXRlZ3kgYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIGNhbWVyYVN0cmF0ZWd5IEluc3RhbmNlIG9mIGFuIFtbSUNhbWVyYVN0cmF0ZWd5XV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5yZW1vdmVTdHJhdGVneSA9IGZ1bmN0aW9uIChjYW1lcmFTdHJhdGVneSkge1xyXG4gICAgICAgICAgICBVdGlsXzEucmVtb3ZlSXRlbUZyb21BcnJheShjYW1lcmFTdHJhdGVneSwgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgYWxsIGNhbWVyYSBzdHJhdGVnaWVzIGZyb20gdGhlIGNhbWVyYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmNsZWFyQWxsU3RyYXRlZ2llcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9lbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwbGFjZW1lbnRzIGJhc2VkIG9uIGxpbmVhciBhbGdlYnJhXHJcbiAgICAgICAgICAgIHRoaXMuX3ggKz0gdGhpcy5keCAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5feSArPSB0aGlzLmR5ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLnogKz0gdGhpcy5keiAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5keCArPSB0aGlzLmF4ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLmR5ICs9IHRoaXMuYXkgKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMuZHogKz0gdGhpcy5heiAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiArPSB0aGlzLnJ4ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNab29taW5nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3Wm9vbSA9IHRoaXMueiArIHRoaXMuX3pvb21JbmNyZW1lbnQgKiBkZWx0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMueiA9IG5ld1pvb207XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fem9vbUluY3JlbWVudCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Wm9vbSA+PSB0aGlzLl9tYXhab29tU2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IHRoaXMuX21heFpvb21TY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9vbVByb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Wm9vbSA8PSB0aGlzLl9tYXhab29tU2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IHRoaXMuX21heFpvb21TY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9vbVByb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbWVyYU1vdmluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMZXJwVGltZSA8IHRoaXMuX2xlcnBEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnggPCB0aGlzLl9sZXJwU3RhcnQueCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0gdGhpcy5fbGVycFN0YXJ0LnggLSAodGhpcy5fZWFzaW5nKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0gdGhpcy5fZWFzaW5nKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueSA8IHRoaXMuX2xlcnBTdGFydC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLl9sZXJwU3RhcnQueSAtICh0aGlzLl9lYXNpbmcodGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC55KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLl9lYXNpbmcodGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0gdGhpcy5fbGVycEVuZC54O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLl9sZXJwRW5kLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycFByb21pc2UucmVzb2x2ZSh0aGlzLl9sZXJwRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRG9uZVNoYWtpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNTaGFraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkU2hha2VUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hha2VEdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl94U2hha2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feVNoYWtlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRTaGFrZVRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl94U2hha2UgPSAoTWF0aC5yYW5kb20oKSAqIHRoaXMuX3NoYWtlTWFnbml0dWRlWCB8IDApICsgMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3lTaGFrZSA9IChNYXRoLnJhbmRvbSgpICogdGhpcy5fc2hha2VNYWduaXR1ZGVZIHwgMCkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHMuYWN0aW9uLmNhbGwocywgcy50YXJnZXQsIHRoaXMsIF9lbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgcmVsZXZhbnQgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBnYW1lIGNhbnZhcyB0byBcIm1vdmVcIiBvciBhcHBseSBlZmZlY3RzIHRvIHRoZSBDYW1lcmFcclxuICAgICAgICAgKiBAcGFyYW0gY3R4ICAgIENhbnZhcyBjb250ZXh0IHRvIGFwcGx5IHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzV2lkdGggPSBjdHguY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY3R4LmNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIHZhciB6b29tID0gdGhpcy5nZXRab29tKCk7XHJcbiAgICAgICAgICAgIHZhciBuZXdDYW52YXNXaWR0aCA9IChjYW52YXNXaWR0aCAvIHpvb20pIC8gcGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgdmFyIG5ld0NhbnZhc0hlaWdodCA9IChjYW52YXNIZWlnaHQgLyB6b29tKSAvIHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIGN0eC5zY2FsZSh6b29tLCB6b29tKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtZm9jdXMueCArIG5ld0NhbnZhc1dpZHRoIC8gMiArIHRoaXMuX3hTaGFrZSwgLWZvY3VzLnkgKyBuZXdDYW52YXNIZWlnaHQgLyAyICsgdGhpcy5feVNoYWtlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAzO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoZm9jdXMueCwgZm9jdXMueSwgMTUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyhmb2N1cy54LCBmb2N1cy55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuX2lzRG9uZVNoYWtpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhKHRoaXMuX2lzU2hha2luZykgfHwgKHRoaXMuX2VsYXBzZWRTaGFrZVRpbWUgPj0gdGhpcy5fc2hha2VEdXJhdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQmFzZUNhbWVyYTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkJhc2VDYW1lcmEgPSBCYXNlQ2FtZXJhO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBleHRlbnNpb24gb2YgW1tCYXNlQ2FtZXJhXV0gdGhhdCBpcyBsb2NrZWQgdmVydGljYWxseTsgaXQgd2lsbCBvbmx5IG1vdmUgc2lkZSB0byBzaWRlLlxyXG4gICAgICpcclxuICAgICAqIENvbW1vbiB1c2FnZXM6IHBsYXRmb3JtZXJzLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgT0JTT0xFVEU6IFdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4xNSwgcGxlYXNlIHVzZSBgQmFzZUNhbWVyYS5zdHJhdGVneS5sb2NrVG9BY3RvckF4aXNgXHJcbiAgICAgKi9cclxuICAgIHZhciBTaWRlQ2FtZXJhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU2lkZUNhbWVyYSwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTaWRlQ2FtZXJhKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIFtbQWN0b3JdXSB0byBmb2xsb3cgd2l0aCB0aGUgY2FtZXJhXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICBUaGUgYWN0b3IgdG8gZm9sbG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2lkZUNhbWVyYS5wcm90b3R5cGUuc2V0QWN0b3JUb0ZvbGxvdyA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9mb2xsb3cgPSBhY3RvcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNpZGVDYW1lcmEucHJvdG90eXBlLmdldEZvY3VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZm9sbG93KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMy5WZWN0b3IodGhpcy5fZm9sbG93LnBvcy54ICsgdGhpcy5fZm9sbG93LmdldFdpZHRoKCkgLyAyLCBfc3VwZXIucHJvdG90eXBlLmdldEZvY3VzLmNhbGwodGhpcykueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXRGb2N1cy5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2lkZUNhbWVyYTtcclxuICAgIH0oQmFzZUNhbWVyYSkpO1xyXG4gICAgZXhwb3J0cy5TaWRlQ2FtZXJhID0gU2lkZUNhbWVyYTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZXh0ZW5zaW9uIG9mIFtbQmFzZUNhbWVyYV1dIHRoYXQgaXMgbG9ja2VkIHRvIGFuIFtbQWN0b3JdXSBvclxyXG4gICAgICogW1tMb2NrZWRDYW1lcmEuZ2V0Rm9jdXN8Zm9jYWwgcG9pbnRdXTsgdGhlIGFjdG9yIHdpbGwgYXBwZWFyIGluIHRoZVxyXG4gICAgICogY2VudGVyIG9mIHRoZSBzY3JlZW4uXHJcbiAgICAgKlxyXG4gICAgICogQ29tbW9uIHVzYWdlczogUlBHcywgYWR2ZW50dXJlIGdhbWVzLCB0b3AtZG93biBnYW1lcy5cclxuICAgICAqIEBkZXByZWNhdGVkIE9CU09MRVRFOiBXaWxsIGJlIHJlbW92ZWQgaW4gdjAuMTUsIHBsZWFzZSB1c2UgYEJhc2VDYW1lcmEuc3RyYXRlZ3kubG9ja1RvQWN0b3JgXHJcbiAgICAgKi9cclxuICAgIHZhciBMb2NrZWRDYW1lcmEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhMb2NrZWRDYW1lcmEsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gTG9ja2VkQ2FtZXJhKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIFtbQWN0b3JdXSB0byBmb2xsb3cgd2l0aCB0aGUgY2FtZXJhXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICBUaGUgYWN0b3IgdG8gZm9sbG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9ja2VkQ2FtZXJhLnByb3RvdHlwZS5zZXRBY3RvclRvRm9sbG93ID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbGxvdyA9IGFjdG9yO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTG9ja2VkQ2FtZXJhLnByb3RvdHlwZS5nZXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvbGxvdykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzMuVmVjdG9yKHRoaXMuX2ZvbGxvdy5wb3MueCArIHRoaXMuX2ZvbGxvdy5nZXRXaWR0aCgpIC8gMiwgdGhpcy5fZm9sbG93LnBvcy55ICsgdGhpcy5fZm9sbG93LmdldEhlaWdodCgpIC8gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXRGb2N1cy5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTG9ja2VkQ2FtZXJhO1xyXG4gICAgfShCYXNlQ2FtZXJhKSk7XHJcbiAgICBleHBvcnRzLkxvY2tlZENhbWVyYSA9IExvY2tlZENhbWVyYTtcclxufSk7XHJcbmRlZmluZShcIkRlYnVnRmxhZ3NcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkRyYXdpbmcvQ29sb3JcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgc3RhbmRhcmQgY29sb3JzIChlLmcuIFtbQ29sb3IuQmxhY2tdXSlcclxuICAgICAqIGJ1dCB5b3UgY2FuIGFsc28gY3JlYXRlIGN1c3RvbSBjb2xvcnMgdXNpbmcgUkdCLCBIU0wsIG9yIEhleC4gQWxzbyBwcm92aWRlc1xyXG4gICAgICogdXNlZnVsIGNvbG9yIG9wZXJhdGlvbnMgbGlrZSBbW0NvbG9yLmxpZ2h0ZW5dXSwgW1tDb2xvci5kYXJrZW5dXSwgYW5kIG1vcmUuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkNvbG9ycy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGFuIHIsIGcsIGIsIGFcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSByICBUaGUgcmVkIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgICAgICogQHBhcmFtIGcgIFRoZSBncmVlbiBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICAgICAqIEBwYXJhbSBiICBUaGUgYmx1ZSBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICAgICAqIEBwYXJhbSBhICBUaGUgYWxwaGEgY29tcG9uZW50IG9mIGNvbG9yICgwLTEuMClcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDb2xvcihyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgICAgIHRoaXMuZyA9IGc7XHJcbiAgICAgICAgICAgIHRoaXMuYiA9IGI7XHJcbiAgICAgICAgICAgIHRoaXMuYSA9IChhICE9IG51bGwgPyBhIDogMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBhbiByLCBnLCBiLCBhXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gciAgVGhlIHJlZCBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICAgICAqIEBwYXJhbSBnICBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAgICAgKiBAcGFyYW0gYiAgVGhlIGJsdWUgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAgICAgKiBAcGFyYW0gYSAgVGhlIGFscGhhIGNvbXBvbmVudCBvZiBjb2xvciAoMC0xLjApXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IuZnJvbVJHQiA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2NhbmNlIG9mIENvbG9yIGZyb20gYSBoZXggc3RyaW5nXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gaGV4ICBDU1MgY29sb3Igc3RyaW5nIG9mIHRoZSBmb3JtICNmZmZmZmYsIHRoZSBhbHBoYSBjb21wb25lbnQgaXMgb3B0aW9uYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5mcm9tSGV4ID0gZnVuY3Rpb24gKGhleCkge1xyXG4gICAgICAgICAgICB2YXIgaGV4UmVnRXggPSAvXiM/KFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KT8kL2k7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCA9IGhleC5tYXRjaChoZXhSZWdFeCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQobWF0Y2hbMV0sIDE2KTtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDE2KTtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQobWF0Y2hbM10sIDE2KTtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gMTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBwYXJzZUludChtYXRjaFs0XSwgMTYpIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nOiAnICsgaGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gaHNsYSB2YWx1ZXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBoICBIdWUgaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAgICAgKiBAcGFyYW0gcyAgU2F0dXJhdGlvbiBpcyByZXByZXNlbnRlZCBbMC0xXVxyXG4gICAgICAgICAqIEBwYXJhbSBsICBMdW1pbmFuY2UgaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAgICAgKiBAcGFyYW0gYSAgQWxwaGEgaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5mcm9tSFNMID0gZnVuY3Rpb24gKGgsIHMsIGwsIGEpIHtcclxuICAgICAgICAgICAgaWYgKGEgPT09IHZvaWQgMCkgeyBhID0gMS4wOyB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gbmV3IEhTTENvbG9yKGgsIHMsIGwsIGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpZ2h0ZW5zIHRoZSBjdXJyZW50IGNvbG9yIGJ5IGEgc3BlY2lmaWVkIGFtb3VudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGFtb3VudCB0byBsaWdodGVuIGJ5IFswLTFdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmxpZ2h0ZW4gPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgICAgICB0ZW1wLmwgKz0gKHRlbXAubCAqIGZhY3Rvcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGFya2VucyB0aGUgY3VycmVudCBjb2xvciBieSBhIHNwZWNpZmllZCBhbW91bnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBhbW91bnQgdG8gZGFya2VuIGJ5IFswLTFdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgICAgIHRlbXAubCAtPSAodGVtcC5sICogZmFjdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYXR1cmF0ZXMgdGhlIGN1cnJlbnQgY29sb3IgYnkgYSBzcGVjaWZpZWQgYW1vdW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgYW1vdW50IHRvIHNhdHVyYXRlIGJ5IFswLTFdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnNhdHVyYXRlID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gSFNMQ29sb3IuZnJvbVJHQkEodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICAgICAgdGVtcC5zICs9ICh0ZW1wLnMgKiBmYWN0b3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlc2F0dXJhdGVzIHRoZSBjdXJyZW50IGNvbG9yIGJ5IGEgc3BlY2lmaWVkIGFtb3VudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGFtb3VudCB0byBkZXNhdHVyYXRlIGJ5IFswLTFdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgICAgICB0ZW1wLnMgLT0gKHRlbXAucyAqIGZhY3Rvcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTXVsdGlwbGllcyBhIGNvbG9yIGJ5IGFub3RoZXIsIHJlc3VsdHMgaW4gYSBkYXJrZXIgY29sb3JcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIG90aGVyIGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLm11bGl0aXBseSA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB2YXIgbmV3UiA9ICgoY29sb3IuciAvIDI1NSAqIHRoaXMuciAvIDI1NSkgKiAyNTUpO1xyXG4gICAgICAgICAgICB2YXIgbmV3RyA9ICgoY29sb3IuZyAvIDI1NSAqIHRoaXMuZyAvIDI1NSkgKiAyNTUpO1xyXG4gICAgICAgICAgICB2YXIgbmV3QiA9ICgoY29sb3IuYiAvIDI1NSAqIHRoaXMuYiAvIDI1NSkgKiAyNTUpO1xyXG4gICAgICAgICAgICB2YXIgbmV3QSA9IChjb2xvci5hICogdGhpcy5hKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXdSLCBuZXdHLCBuZXdCLCBuZXdBKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNjcmVlbnMgYSBjb2xvciBieSBhbm90aGVyLCByZXN1bHRzIGluIGEgbGlnaHRlciBjb2xvclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGNvbG9yICBUaGUgb3RoZXIgY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuc2NyZWVuID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xvcjEgPSBjb2xvci5pbnZlcnQoKTtcclxuICAgICAgICAgICAgdmFyIGNvbG9yMiA9IGNvbG9yLmludmVydCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3IxLm11bGl0aXBseShjb2xvcjIpLmludmVydCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW52ZXJ0cyB0aGUgY3VycmVudCBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoMjU1IC0gdGhpcy5yLCAyNTUgLSB0aGlzLmcsIDI1NSAtIHRoaXMuYiwgMS4wIC0gdGhpcy5hKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEF2ZXJhZ2VzIHRoZSBjdXJyZW50IGNvbG9yIHdpdGggYW5vdGhlclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGNvbG9yICBUaGUgb3RoZXIgY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuYXZlcmFnZSA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB2YXIgbmV3UiA9IChjb2xvci5yICsgdGhpcy5yKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBuZXdHID0gKGNvbG9yLmcgKyB0aGlzLmcpIC8gMjtcclxuICAgICAgICAgICAgdmFyIG5ld0IgPSAoY29sb3IuYiArIHRoaXMuYikgLyAyO1xyXG4gICAgICAgICAgICB2YXIgbmV3QSA9IChjb2xvci5hICsgdGhpcy5hKSAvIDI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3UiwgbmV3RywgbmV3QiwgbmV3QSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgQ1NTIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGZvcm1hdCBDb2xvciByZXByZXNlbnRhdGlvbiwgYWNjZXB0czogcmdiLCBoc2wsIG9yIGhleFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7IGZvcm1hdCA9ICdyZ2InOyB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUkdCQSgpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0hTTEEoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2hleCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENvbG9yIGZvcm1hdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIEhleCBWYWx1ZSBvZiBhIGNvbG9yIGNvbXBvbmVudFxyXG4gICAgICAgICAqIEBwYXJhbSBjIGNvbG9yIGNvbXBvbmVudFxyXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdiXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLl9jb21wb25lbnRUb0hleCA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgIHZhciBoZXggPSBjLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gSGV4IHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyMnICsgdGhpcy5fY29tcG9uZW50VG9IZXgodGhpcy5yKSArIHRoaXMuX2NvbXBvbmVudFRvSGV4KHRoaXMuZykgKyB0aGlzLl9jb21wb25lbnRUb0hleCh0aGlzLmIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIFJHQkEgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUudG9SR0JBID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gU3RyaW5nKHRoaXMuci50b0ZpeGVkKDApKSArICcsICcgKyBTdHJpbmcodGhpcy5nLnRvRml4ZWQoMCkpICsgJywgJyArIFN0cmluZyh0aGlzLmIudG9GaXhlZCgwKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmEgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgcmVzdWx0ICsgJywgJyArIFN0cmluZyh0aGlzLmEpICsgJyknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAncmdiKCcgKyByZXN1bHQgKyAnKSc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gSFNMQSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS50b0hTTEEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgQ1NTIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5maWxsU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ29sb3I7XHJcbiAgICB9KCkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCbGFjayAoIzAwMDAwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuQmxhY2sgPSBDb2xvci5mcm9tSGV4KCcjMDAwMDAwJyk7XHJcbiAgICAvKipcclxuICAgICAqIFdoaXRlICgjRkZGRkZGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5XaGl0ZSA9IENvbG9yLmZyb21IZXgoJyNGRkZGRkYnKTtcclxuICAgIC8qKlxyXG4gICAgICogR3JheSAoIzgwODA4MClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuR3JheSA9IENvbG9yLmZyb21IZXgoJyM4MDgwODAnKTtcclxuICAgIC8qKlxyXG4gICAgICogTGlnaHQgZ3JheSAoI0QzRDNEMylcclxuICAgICAqL1xyXG4gICAgQ29sb3IuTGlnaHRHcmF5ID0gQ29sb3IuZnJvbUhleCgnI0QzRDNEMycpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEYXJrIGdyYXkgKCNBOUE5QTkpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkRhcmtHcmF5ID0gQ29sb3IuZnJvbUhleCgnI0E5QTlBOScpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBZZWxsb3cgKCNGRkZGMDApXHJcbiAgICAgKi9cclxuICAgIENvbG9yLlllbGxvdyA9IENvbG9yLmZyb21IZXgoJyNGRkZGMDAnKTtcclxuICAgIC8qKlxyXG4gICAgICogT3JhbmdlICgjRkZBNTAwKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5PcmFuZ2UgPSBDb2xvci5mcm9tSGV4KCcjRkZBNTAwJyk7XHJcbiAgICAvKipcclxuICAgICAqIFJlZCAoI0ZGMDAwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuUmVkID0gQ29sb3IuZnJvbUhleCgnI0ZGMDAwMCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJtaWxsaW9uICgjRkY1QjMxKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5WZXJtaWxsaW9uID0gQ29sb3IuZnJvbUhleCgnI0ZGNUIzMScpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSb3NlICgjRkYwMDdGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5Sb3NlID0gQ29sb3IuZnJvbUhleCgnI0ZGMDA3RicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWdlbnRhICgjRkYwMEZGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5NYWdlbnRhID0gQ29sb3IuZnJvbUhleCgnI0ZGMDBGRicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWaW9sZXQgKCM3RjAwRkYpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLlZpb2xldCA9IENvbG9yLmZyb21IZXgoJyM3RjAwRkYnKTtcclxuICAgIC8qKlxyXG4gICAgICogQmx1ZSAoIzAwMDBGRilcclxuICAgICAqL1xyXG4gICAgQ29sb3IuQmx1ZSA9IENvbG9yLmZyb21IZXgoJyMwMDAwRkYnKTtcclxuICAgIC8qKlxyXG4gICAgICogQXp1cmUgKCMwMDdGRkYpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkF6dXJlID0gQ29sb3IuZnJvbUhleCgnIzAwN0ZGRicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDeWFuICgjMDBGRkZGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5DeWFuID0gQ29sb3IuZnJvbUhleCgnIzAwRkZGRicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWaXJpZGlhbiAoIzU5OTc4RilcclxuICAgICAqL1xyXG4gICAgQ29sb3IuVmlyaWRpYW4gPSBDb2xvci5mcm9tSGV4KCcjNTk5NzhGJyk7XHJcbiAgICAvKipcclxuICAgICAqIEdyZWVuICgjMDBGRjAwKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5HcmVlbiA9IENvbG9yLmZyb21IZXgoJyMwMEZGMDAnKTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hhcnRyZXVzZSAoIzdGRkYwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuQ2hhcnRyZXVzZSA9IENvbG9yLmZyb21IZXgoJyM3RkZGMDAnKTtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNwYXJlbnQgKCNGRkZGRkYwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuVHJhbnNwYXJlbnQgPSBDb2xvci5mcm9tSGV4KCcjRkZGRkZGMDAnKTtcclxuICAgIGV4cG9ydHMuQ29sb3IgPSBDb2xvcjtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgSFNMIENvbG9yIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKlxyXG4gICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTVlxyXG4gICAgICogaHR0cDovL2F4b25mbHV4LmNvbS9oYW5keS1yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNcclxuICAgICAqL1xyXG4gICAgdmFyIEhTTENvbG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBIU0xDb2xvcihoLCBzLCBsLCBhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaCA9IGg7XHJcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XHJcbiAgICAgICAgICAgIHRoaXMubCA9IGw7XHJcbiAgICAgICAgICAgIHRoaXMuYSA9IGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEhTTENvbG9yLmh1ZTJyZ2IgPSBmdW5jdGlvbiAocCwgcSwgdCkge1xyXG4gICAgICAgICAgICBpZiAodCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHQgLT0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCA8IDEgLyA2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCA8IDEgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCA8IDIgLyAzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBIU0xDb2xvci5mcm9tUkdCQSA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgICAgIHIgLz0gMjU1O1xyXG4gICAgICAgICAgICBnIC89IDI1NTtcclxuICAgICAgICAgICAgYiAvPSAyNTU7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgbWluID0gTWF0aC5taW4ociwgZywgYik7XHJcbiAgICAgICAgICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xyXG4gICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcclxuICAgICAgICAgICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XHJcbiAgICAgICAgICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgYjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoIC89IDY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIU0xDb2xvcihoLCBzLCBsLCBhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEhTTENvbG9yLnByb3RvdHlwZS50b1JHQkEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByLCBnLCBiO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByID0gZyA9IGIgPSB0aGlzLmw7IC8vIGFjaHJvbWF0aWNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBxID0gdGhpcy5sIDwgMC41ID8gdGhpcy5sICogKDEgKyB0aGlzLnMpIDogdGhpcy5sICsgdGhpcy5zIC0gdGhpcy5sICogdGhpcy5zO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSAyICogdGhpcy5sIC0gcTtcclxuICAgICAgICAgICAgICAgIHIgPSBIU0xDb2xvci5odWUycmdiKHAsIHEsIHRoaXMuaCArIDEgLyAzKTtcclxuICAgICAgICAgICAgICAgIGcgPSBIU0xDb2xvci5odWUycmdiKHAsIHEsIHRoaXMuaCk7XHJcbiAgICAgICAgICAgICAgICBiID0gSFNMQ29sb3IuaHVlMnJnYihwLCBxLCB0aGlzLmggLSAxIC8gMyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyICogMjU1LCBnICogMjU1LCBiICogMjU1LCB0aGlzLmEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSFNMQ29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaCA9IHRoaXMuaC50b0ZpeGVkKDApLCBzID0gdGhpcy5zLnRvRml4ZWQoMCksIGwgPSB0aGlzLmwudG9GaXhlZCgwKSwgYSA9IHRoaXMuYS50b0ZpeGVkKDApO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJoc2xhKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiwgXCIgKyBsICsgXCIsIFwiICsgYSArIFwiKVwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEhTTENvbG9yO1xyXG4gICAgfSgpKTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9Db2xsaXNpb25Db250YWN0XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0b3JcIiwgXCJBbGdlYnJhXCIsIFwiUGh5c2ljc1wiLCBcIkV2ZW50c1wiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFjdG9yXzEsIEFsZ2VicmFfNCwgUGh5c2ljc18xLCBFdmVudHNfMSwgVXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIENvbGxpc2lvbiBjb250YWN0cyBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IEV4Y2FsaWJ1ciB0byByZXNvbHZlIGNvbGxpc2lvbiBiZXR3ZWVuIGFjdG9ycy4gVGhpc1xyXG4gICAgICogUGFpciBwcmV2ZW50cyBjb2xsaXNpb25zIGZyb20gYmVpbmcgZXZhbHVhdGVkIG1vcmUgdGhhbiBvbmUgdGltZVxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sbGlzaW9uQ29udGFjdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ29sbGlzaW9uQ29udGFjdChib2R5QSwgYm9keUIsIG10diwgcG9pbnQsIG5vcm1hbCkge1xyXG4gICAgICAgICAgICB0aGlzLmJvZHlBID0gYm9keUE7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuICAgICAgICAgICAgdGhpcy5tdHYgPSBtdHY7XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcclxuICAgICAgICAgICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENvbGxpc2lvbkNvbnRhY3QucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoc3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgaWYgKHN0cmF0ZWd5ID09PSBQaHlzaWNzXzEuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LlJpZ2lkQm9keSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVJpZ2lkQm9keUNvbGxpc2lvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmF0ZWd5ID09PSBQaHlzaWNzXzEuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkJveCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUJveENvbGxpc2lvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWd5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbGxpc2lvbkNvbnRhY3QucHJvdG90eXBlLl9hcHBseUJveEltcHVsc2UgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCLCBtdHYpIHtcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5BY3RpdmUgJiZcclxuICAgICAgICAgICAgICAgIGJvZHlCLmNvbGxpc2lvblR5cGUgIT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5QYXNzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIG92ZXJsYXBzXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkFjdGl2ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCBvdmVybGFwcyBpZiBib3RoIGFyZSBBY3RpdmVcclxuICAgICAgICAgICAgICAgICAgICBtdHYgPSBtdHYuc2NhbGUoLjUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgbXR2XHJcbiAgICAgICAgICAgICAgICBib2R5QS5wb3MueSArPSBtdHYueTtcclxuICAgICAgICAgICAgICAgIGJvZHlBLnBvcy54ICs9IG10di54O1xyXG4gICAgICAgICAgICAgICAgLy8gbm9uLXplcm8gaW50ZXJzZWN0aW9uIG9uIHRoZSB5IGF4aXNcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm10di54ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlbFggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdGggYm9kaWVzIGFyZSB0cmF2ZWxpbmcgaW4gdGhlIHNhbWUgZGlyZWN0aW9uIChuZWdhdGl2ZSBvciBwb3NpdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEudmVsLnggPCAwICYmIGJvZHlCLnZlbC54IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWxYID0gTWF0aC5taW4oYm9keUEudmVsLngsIGJvZHlCLnZlbC54KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9keUEudmVsLnggPiAwICYmIGJvZHlCLnZlbC54ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWxYID0gTWF0aC5tYXgoYm9keUEudmVsLngsIGJvZHlCLnZlbC54KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZGllcyBhcmUgdHJhdmVsaW5nIGluIG9wcG9zaXRlIGRpcmVjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlBLnBvcy5zdWIoYm9keUIucG9zKS5kb3QoYm9keUEudmVsKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlbFggPSBib2R5QS52ZWwueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZHlBIGlzIGhlYWRpbmcgdG93YXJkcyBiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWxYID0gYm9keUIudmVsLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEudmVsLnggPSB2ZWxYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXR2LnkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVsWSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYm90aCBib2RpZXMgYXJlIHRyYXZlbGluZyBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gKG5lZ2F0aXZlIG9yIHBvc2l0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5QS52ZWwueSA8IDAgJiYgYm9keUIudmVsLnkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlbFkgPSBNYXRoLm1pbihib2R5QS52ZWwueSwgYm9keUIudmVsLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChib2R5QS52ZWwueSA+IDAgJiYgYm9keUIudmVsLnkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlbFkgPSBNYXRoLm1heChib2R5QS52ZWwueSwgYm9keUIudmVsLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChib2R5Qi5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9kaWVzIGFyZSB0cmF2ZWxpbmcgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEucG9zLnN1Yihib2R5Qi5wb3MpLmRvdChib2R5QS52ZWwpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVsWSA9IGJvZHlBLnZlbC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9keUEgaXMgaGVhZGluZyB0b3dhcmRzIGJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlbFkgPSBib2R5Qi52ZWwueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBib2R5QS52ZWwueSA9IHZlbFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib2R5QS5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlBvc3RDb2xsaXNpb25FdmVudChib2R5QSwgYm9keUIsIFV0aWwuZ2V0U2lkZUZyb21WZWN0b3IobXR2KSwgbXR2KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbGxpc2lvbkNvbnRhY3QucHJvdG90eXBlLl9yZXNvbHZlQm94Q29sbGlzaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLmJvZHkuYWN0b3I7XHJcbiAgICAgICAgICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUIuYm9keS5hY3RvcjtcclxuICAgICAgICAgICAgdmFyIHNpZGUgPSBVdGlsLmdldFNpZGVGcm9tVmVjdG9yKHRoaXMubXR2KTtcclxuICAgICAgICAgICAgdmFyIG10diA9IHRoaXMubXR2Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIGNvbGxpc2lvbiBldmVudHMgb24gYm90aCBwYXJ0aWNpcGFudHNcclxuICAgICAgICAgICAgYm9keUEuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlByZUNvbGxpc2lvbkV2ZW50KGJvZHlBLCBib2R5Qiwgc2lkZSwgbXR2KSk7XHJcbiAgICAgICAgICAgIGJvZHlCLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBFdmVudHNfMS5QcmVDb2xsaXNpb25FdmVudChib2R5QiwgYm9keUEsIFV0aWwuZ2V0T3Bwb3NpdGVTaWRlKHNpZGUpLCBtdHYubmVnYXRlKCkpKTtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlCb3hJbXB1bHNlKGJvZHlBLCBib2R5QiwgbXR2KTtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlCb3hJbXB1bHNlKGJvZHlCLCBib2R5QSwgbXR2Lm5lZ2F0ZSgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbGxpc2lvbkNvbnRhY3QucHJvdG90eXBlLl9yZXNvbHZlUmlnaWRCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBwZXJmb3JtIGNvbGxpc29uIG9uIGJvdW5kaW5nIGFyZWFzXHJcbiAgICAgICAgICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUEuYm9keTtcclxuICAgICAgICAgICAgdmFyIGJvZHlCID0gdGhpcy5ib2R5Qi5ib2R5O1xyXG4gICAgICAgICAgICB2YXIgbXR2ID0gdGhpcy5tdHY7IC8vIG5vcm1hbCBwb2ludGluZyBhd2F5IGZyb20gYm9keUFcclxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMubm9ybWFsOyAvLyBub3JtYWwgcG9pbnRpbmcgYXdheSBmcm9tIGJvZHlBXHJcbiAgICAgICAgICAgIGlmIChib2R5QS5hY3RvciA9PT0gYm9keUIuYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIGNvbGxpc2lvbiBldmVudHMgb24gYm90aCBwYXJ0aWNpcGFudHNcclxuICAgICAgICAgICAgdmFyIHNpZGUgPSBVdGlsLmdldFNpZGVGcm9tVmVjdG9yKHRoaXMubXR2KTtcclxuICAgICAgICAgICAgYm9keUEuYWN0b3IuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlByZUNvbGxpc2lvbkV2ZW50KHRoaXMuYm9keUEuYm9keS5hY3RvciwgdGhpcy5ib2R5Qi5ib2R5LmFjdG9yLCBzaWRlLCB0aGlzLm10dikpO1xyXG4gICAgICAgICAgICBib2R5Qi5hY3Rvci5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzEuUHJlQ29sbGlzaW9uRXZlbnQodGhpcy5ib2R5Qi5ib2R5LmFjdG9yLCB0aGlzLmJvZHlBLmJvZHkuYWN0b3IsIFV0aWwuZ2V0T3Bwb3NpdGVTaWRlKHNpZGUpLCB0aGlzLm10di5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIHBhcnRpY2lwYW50cyBhcmUgcGFzc2l2ZSB0aGVuIHNob3J0IGNpcmN1aXRcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5QYXNzaXZlIHx8XHJcbiAgICAgICAgICAgICAgICBib2R5Qi5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbnZNYXNzQSA9IGJvZHlBLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCA/IDAgOiAxIC8gYm9keUEubWFzcztcclxuICAgICAgICAgICAgdmFyIGludk1hc3NCID0gYm9keUIuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkID8gMCA6IDEgLyBib2R5Qi5tYXNzO1xyXG4gICAgICAgICAgICB2YXIgaW52TW9pQSA9IGJvZHlBLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCA/IDAgOiAxIC8gYm9keUEubW9pO1xyXG4gICAgICAgICAgICB2YXIgaW52TW9pQiA9IGJvZHlCLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCA/IDAgOiAxIC8gYm9keUIubW9pO1xyXG4gICAgICAgICAgICAvLyBhdmVyYWdlIHJlc3RpdHV0aW9uIG1vcmUgcmVsaXN0aWNcclxuICAgICAgICAgICAgdmFyIGNvZWZSZXN0aXR1dGlvbiA9IE1hdGgubWluKGJvZHlBLnJlc3RpdHV0aW9uLCBib2R5Qi5yZXN0aXR1dGlvbik7XHJcbiAgICAgICAgICAgIHZhciBjb2VmRnJpY3Rpb24gPSBNYXRoLm1pbihib2R5QS5mcmljdGlvbiwgYm9keUIuZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICBub3JtYWwgPSBub3JtYWwubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHZhciB0YW5nZW50ID0gbm9ybWFsLm5vcm1hbCgpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmEgPSB0aGlzLnBvaW50LnN1Yih0aGlzLmJvZHlBLmdldENlbnRlcigpKTsgLy8gcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEgcG9zaXRpb25cclxuICAgICAgICAgICAgdmFyIHJiID0gdGhpcy5wb2ludC5zdWIodGhpcy5ib2R5Qi5nZXRDZW50ZXIoKSk7IC8vLyBwb2ludCByZWxhdGl2ZSB0byBib2R5QlxyXG4gICAgICAgICAgICAvLyBSZWxhdGl2ZSB2ZWxvY2l0eSBpbiBsaW5lYXIgdGVybXNcclxuICAgICAgICAgICAgLy8gQW5ndWxhciB0byBsaW5lYXIgdmVsb2NpdHkgZm9ybXVsYSAtPiBvbWVnYSA9IHYvclxyXG4gICAgICAgICAgICB2YXIgcnYgPSBib2R5Qi52ZWwuYWRkKHJiLmNyb3NzKC1ib2R5Qi5yeCkpLnN1Yihib2R5QS52ZWwuc3ViKHJhLmNyb3NzKGJvZHlBLnJ4KSkpO1xyXG4gICAgICAgICAgICB2YXIgcnZOb3JtYWwgPSBydi5kb3Qobm9ybWFsKTtcclxuICAgICAgICAgICAgdmFyIHJ2VGFuZ2VudCA9IHJ2LmRvdCh0YW5nZW50KTtcclxuICAgICAgICAgICAgdmFyIHJhVGFuZ2VudCA9IHJhLmRvdCh0YW5nZW50KTtcclxuICAgICAgICAgICAgdmFyIHJhTm9ybWFsID0gcmEuZG90KG5vcm1hbCk7XHJcbiAgICAgICAgICAgIHZhciByYlRhbmdlbnQgPSByYi5kb3QodGFuZ2VudCk7XHJcbiAgICAgICAgICAgIHZhciByYk5vcm1hbCA9IHJiLmRvdChub3JtYWwpO1xyXG4gICAgICAgICAgICAvLyBJZiBvYmplY3RzIGFyZSBtb3ZpbmcgYXdheSBpZ25vcmVcclxuICAgICAgICAgICAgaWYgKHJ2Tm9ybWFsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENvbGxpc2lvbiBpbXB1bHNlIGZvcm11bGEgZnJvbSBDaHJpcyBIZWNrZXJcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29sbGlzaW9uX3Jlc3BvbnNlXHJcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLSgoMSArIGNvZWZSZXN0aXR1dGlvbikgKiBydk5vcm1hbCkgL1xyXG4gICAgICAgICAgICAgICAgKChpbnZNYXNzQSArIGludk1hc3NCKSArIGludk1vaUEgKiByYVRhbmdlbnQgKiByYVRhbmdlbnQgKyBpbnZNb2lCICogcmJUYW5nZW50ICogcmJUYW5nZW50KTtcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgYm9keUIudmVsID0gYm9keUIudmVsLmFkZChub3JtYWwuc2NhbGUoaW1wdWxzZSAqIGludk1hc3NCKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc18xLlBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnJ4IC09IGltcHVsc2UgKiBpbnZNb2lCICogLXJiLmNyb3NzKG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib2R5Qi5hZGRNdHYobXR2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChib2R5Qi5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgIGJvZHlBLnZlbCA9IGJvZHlBLnZlbC5zdWIobm9ybWFsLnNjYWxlKGltcHVsc2UgKiBpbnZNYXNzQSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfMS5QaHlzaWNzLmFsbG93UmlnaWRCb2R5Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5yeCArPSBpbXB1bHNlICogaW52TW9pQSAqIC1yYS5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYm9keUEuYWRkTXR2KG10di5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBib2R5Qi52ZWwgPSBib2R5Qi52ZWwuYWRkKG5vcm1hbC5zY2FsZShpbXB1bHNlICogaW52TWFzc0IpKTtcclxuICAgICAgICAgICAgICAgIGJvZHlBLnZlbCA9IGJvZHlBLnZlbC5zdWIobm9ybWFsLnNjYWxlKGltcHVsc2UgKiBpbnZNYXNzQSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfMS5QaHlzaWNzLmFsbG93UmlnaWRCb2R5Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5yeCAtPSBpbXB1bHNlICogaW52TW9pQiAqIC1yYi5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnJ4ICs9IGltcHVsc2UgKiBpbnZNb2lBICogLXJhLmNyb3NzKG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCB0aGUgbXR2IGluIGhhbGYgZm9yIHRoZSB0d28gYm9kaWVzLCBwb3RlbnRpYWxseSB3ZSBjb3VsZCBkbyBzb21ldGhpbmcgc21hcnRlciBoZXJlXHJcbiAgICAgICAgICAgICAgICBib2R5Qi5hZGRNdHYobXR2LnNjYWxlKC41KSk7XHJcbiAgICAgICAgICAgICAgICBib2R5QS5hZGRNdHYobXR2LnNjYWxlKC0uNSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZyaWN0aW9uIHBvcnRpb24gb2YgaW1wdWxzZVxyXG4gICAgICAgICAgICBpZiAoY29lZkZyaWN0aW9uICYmIHJ2VGFuZ2VudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29sdW1iIG1vZGVsIG9mIGZyaWN0aW9uLCBmb3JtdWxhIGZvciBpbXB1bHNlIGR1ZSB0byBmcmljdGlvbiBmcm9tICBcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbGxpc2lvbl9yZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgLy8gdGFuZ2VudCBmb3JjZSBleGVydGVkIGJ5IGJvZHkgb24gYW5vdGhlciBpbiBjb250YWN0XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHJ2LnN1Yihub3JtYWwuc2NhbGUocnYuZG90KG5vcm1hbCkpKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIC8vIGltcHVsc2UgaW4gdGhlIGRpcmVjdGlvbiBvZiB0YW5nZW50IGZvcmNlXHJcbiAgICAgICAgICAgICAgICB2YXIganQgPSBydi5kb3QodCkgLyAoaW52TWFzc0EgKyBpbnZNYXNzQiArIHJhTm9ybWFsICogcmFOb3JtYWwgKiBpbnZNb2lBICsgcmJOb3JtYWwgKiByYk5vcm1hbCAqIGludk1vaUIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyaWN0aW9uSW1wdWxzZSA9IG5ldyBBbGdlYnJhXzQuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGp0KSA8PSBpbXB1bHNlICogY29lZkZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb25JbXB1bHNlID0gdC5zY2FsZShqdCkubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmljdGlvbkltcHVsc2UgPSB0LnNjYWxlKC1pbXB1bHNlICogY29lZkZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChib2R5QS5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBmcmljdGlvbmFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi52ZWwgPSBib2R5Qi52ZWwuYWRkKGZyaWN0aW9uSW1wdWxzZS5zY2FsZShpbnZNYXNzQikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzEuUGh5c2ljcy5hbGxvd1JpZ2lkQm9keVJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLnJ4ICs9IGZyaWN0aW9uSW1wdWxzZS5kb3QodCkgKiBpbnZNb2lCICogcmIuY3Jvc3ModCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9keUIuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgZnJpY3Rpb25hbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEudmVsID0gYm9keUEudmVsLnN1YihmcmljdGlvbkltcHVsc2Uuc2NhbGUoaW52TWFzc0EpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc18xLlBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5yeCAtPSBmcmljdGlvbkltcHVsc2UuZG90KHQpICogaW52TW9pQSAqIHJhLmNyb3NzKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGZyaWN0aW9uYWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnZlbCA9IGJvZHlCLnZlbC5hZGQoZnJpY3Rpb25JbXB1bHNlLnNjYWxlKGludk1hc3NCKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEudmVsID0gYm9keUEudmVsLnN1YihmcmljdGlvbkltcHVsc2Uuc2NhbGUoaW52TWFzc0EpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBmcmljdGlvbmFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc18xLlBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5yeCArPSBmcmljdGlvbkltcHVsc2UuZG90KHQpICogaW52TW9pQiAqIHJiLmNyb3NzKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5yeCAtPSBmcmljdGlvbkltcHVsc2UuZG90KHQpICogaW52TW9pQSAqIHJhLmNyb3NzKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBib2R5QS5hY3Rvci5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlBvc3RDb2xsaXNpb25FdmVudCh0aGlzLmJvZHlBLmJvZHkuYWN0b3IsIHRoaXMuYm9keUIuYm9keS5hY3Rvciwgc2lkZSwgdGhpcy5tdHYpKTtcclxuICAgICAgICAgICAgYm9keUIuYWN0b3IuZW1pdCgncG9zdGNvbGxpc2lvbicsIG5ldyBFdmVudHNfMS5Qb3N0Q29sbGlzaW9uRXZlbnQodGhpcy5ib2R5Qi5ib2R5LmFjdG9yLCB0aGlzLmJvZHlBLmJvZHkuYWN0b3IsIFV0aWwuZ2V0T3Bwb3NpdGVTaWRlKHNpZGUpLCB0aGlzLm10di5uZWdhdGUoKSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkNvbnRhY3Q7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Db2xsaXNpb25Db250YWN0ID0gQ29sbGlzaW9uQ29udGFjdDtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9JQ29sbGlzaW9uQXJlYVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0NpcmNsZUFyZWFcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJDb2xsaXNpb24vUG9seWdvbkFyZWFcIiwgXCJDb2xsaXNpb24vRWRnZUFyZWFcIiwgXCJDb2xsaXNpb24vQ29sbGlzaW9uSnVtcFRhYmxlXCIsIFwiQWxnZWJyYVwiLCBcIlBoeXNpY3NcIiwgXCJEcmF3aW5nL0NvbG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQm91bmRpbmdCb3hfMSwgUG9seWdvbkFyZWFfMSwgRWRnZUFyZWFfMSwgQ29sbGlzaW9uSnVtcFRhYmxlXzEsIEFsZ2VicmFfNSwgUGh5c2ljc18yLCBDb2xvcl8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBhIGNpcmNsZSBjb2xsaXNpb24gYXJlYSBmb3IgdGhlIGV4Y2FsaWJ1ciByaWdpZCBib2R5IHBoeXNpY3Mgc2ltdWxhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgQ2lyY2xlQXJlYSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ2lyY2xlQXJlYShvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSwgcmVsYXRpdmUgdG8gdGhlIGJvZHkgcG9zaXRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gQWxnZWJyYV81LlZlY3Rvci5aZXJvLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gb3B0aW9ucy5wb3MgfHwgQWxnZWJyYV81LlZlY3Rvci5aZXJvLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5ib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBjb2xsaXNpb24gYXJlYSBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYm9keSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zLmFkZCh0aGlzLmJvZHkucG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3M7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGNvbnRhaW5lZCBpbiB0aGlzIGNvbGxpc2lvbiBhcmVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5ib2R5LnBvcy5kaXN0YW5jZShwb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8PSB0aGlzLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FzdHMgYSByYXkgYXQgdGhlIENpcmNsZUFyZWEgYW5kIHJldHVybnMgdGhlIG5lYXJlc3QgcG9pbnQgb2YgY29sbGlzaW9uXHJcbiAgICAgICAgICogQHBhcmFtIHJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAocmF5LCBtYXgpIHtcclxuICAgICAgICAgICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgICAgIC8vaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZSVFMiU4MCU5M3NwaGVyZV9pbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gcmF5LmRpcjtcclxuICAgICAgICAgICAgdmFyIG9yaWcgPSByYXkucG9zO1xyXG4gICAgICAgICAgICB2YXIgZGlzY3JpbWluYW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpci5kb3Qob3JpZy5zdWIoYykpLCAyKSAtXHJcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyhvcmlnLnN1YihjKS5kaXN0YW5jZSgpLCAyKSArXHJcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMikpO1xyXG4gICAgICAgICAgICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2kgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvaSA9IC1kaXIuZG90KG9yaWcuc3ViKGMpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9pID4gMCAmJiB0b2kgPCBtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludCh0b2kpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2kxID0gLWRpci5kb3Qob3JpZy5zdWIoYykpICsgZGlzY3JpbWluYW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2kyID0gLWRpci5kb3Qob3JpZy5zdWIoYykpIC0gZGlzY3JpbWluYW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW50b2kgPSBNYXRoLm1pbih0b2kxLCB0b2kyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWludG9pIDw9IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmF5LmdldFBvaW50KG1pbnRvaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmNvbGxpZGUgPSBmdW5jdGlvbiAoYXJlYSkge1xyXG4gICAgICAgICAgICBpZiAoYXJlYSBpbnN0YW5jZW9mIENpcmNsZUFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMS5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZUNpcmNsZSh0aGlzLCBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmVhIGluc3RhbmNlb2YgUG9seWdvbkFyZWFfMS5Qb2x5Z29uQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8xLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlUG9seWdvbih0aGlzLCBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmVhIGluc3RhbmNlb2YgRWRnZUFyZWFfMS5FZGdlQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8xLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlRWRnZSh0aGlzLCBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNpcmNsZSBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gSUNvbGxpc2lvbkFyZWEgXCIgKyB0eXBlb2YgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBzaGFwZSBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmdldEZ1cnRoZXN0UG9pbnQgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENlbnRlcigpLmFkZChkaXJlY3Rpb24ubm9ybWFsaXplKCkuc2NhbGUodGhpcy5yYWRpdXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIGNpcmNsZSBhcmVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94XzEuQm91bmRpbmdCb3godGhpcy5wb3MueCArIHRoaXMuYm9keS5wb3MueCAtIHRoaXMucmFkaXVzLCB0aGlzLnBvcy55ICsgdGhpcy5ib2R5LnBvcy55IC0gdGhpcy5yYWRpdXMsIHRoaXMucG9zLnggKyB0aGlzLmJvZHkucG9zLnggKyB0aGlzLnJhZGl1cywgdGhpcy5wb3MueSArIHRoaXMuYm9keS5wb3MueSArIHRoaXMucmFkaXVzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBheGlzIG5vdCBpbXBsZW1lbnRlZCBvbiBjaXJjbGVzLCBzaW5jZSB0aGVyZSBhcmUgaW5maW5pdGUgYXhpcyBpbiBhIGNpcmNsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbW9tZW50IG9mIGluZXJ0aWEgb2YgYSBjaXJjbGUgZ2l2ZW4gaXQncyBtYXNzXHJcbiAgICAgICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5nZXRNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXNzID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5Lm1hc3MgOiBQaHlzaWNzXzIuUGh5c2ljcy5kZWZhdWx0TWFzcztcclxuICAgICAgICAgICAgcmV0dXJuIChtYXNzICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cykgLyAyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgdGhlIHNlcGFyYXRpbmcgYXhpcyB0aGVvcmVtIGZvciBjaXJjbGVzIGFnYWluc3QgcG9seWdvbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS50ZXN0U2VwYXJhdGluZ0F4aXNUaGVvcmVtID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcclxuICAgICAgICAgICAgdmFyIGF4ZXMgPSBwb2x5Z29uLmdldEF4ZXMoKTtcclxuICAgICAgICAgICAgdmFyIHBjID0gcG9seWdvbi5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBTQVQgd2l0aCBjaXJjbGVzXHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0UG9pbnRPblBvbHkgPSBwb2x5Z29uLmdldEZ1cnRoZXN0UG9pbnQodGhpcy5wb3Muc3ViKHBjKSk7XHJcbiAgICAgICAgICAgIGF4ZXMucHVzaCh0aGlzLnBvcy5zdWIoY2xvc2VzdFBvaW50T25Qb2x5KS5ub3JtYWxpemUoKSk7XHJcbiAgICAgICAgICAgIHZhciBtaW5PdmVybGFwID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgdmFyIG1pbkF4aXMgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgbWluSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvajEgPSBwb2x5Z29uLnByb2plY3QoYXhlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvajIgPSB0aGlzLnByb2plY3QoYXhlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcCA9IHByb2oxLmdldE92ZXJsYXAocHJvajIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BeGlzID0gYXhlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWluSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWluQXhpcy5ub3JtYWxpemUoKS5zY2FsZShtaW5PdmVybGFwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUucmVjYWxjID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBjaXJjbGVzIGRvbid0IGNhY2hlXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9qZWN0IHRoZSBjaXJjbGUgYWxvbmcgYSBzcGVjaWZpZWQgYXhpc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoYXhpcykge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGFycyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgZG90UHJvZHVjdCA9IHBvaW50LmRvdChheGlzKTtcclxuICAgICAgICAgICAgc2NhbGFycy5wdXNoKGRvdFByb2R1Y3QpO1xyXG4gICAgICAgICAgICBzY2FsYXJzLnB1c2goZG90UHJvZHVjdCArIHRoaXMucmFkaXVzKTtcclxuICAgICAgICAgICAgc2NhbGFycy5wdXNoKGRvdFByb2R1Y3QgLSB0aGlzLnJhZGl1cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV81LlByb2plY3Rpb24oTWF0aC5taW4uYXBwbHkoTWF0aCwgc2NhbGFycyksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjYWxhcnMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCwgY29sb3IpIHtcclxuICAgICAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBDb2xvcl8xLkNvbG9yLkdyZWVuLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5wb3MuYWRkKHRoaXMucG9zKSA6IHRoaXMucG9zO1xyXG4gICAgICAgICAgICB2YXIgcm90YXRpb24gPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkucm90YXRpb24gOiAwO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMocG9zLngsIHBvcy55LCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHBvcy54LCBwb3MueSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oTWF0aC5jb3Mocm90YXRpb24pICogdGhpcy5yYWRpdXMgKyBwb3MueCwgTWF0aC5zaW4ocm90YXRpb24pICogdGhpcy5yYWRpdXMgKyBwb3MueSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENpcmNsZUFyZWE7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5DaXJjbGVBcmVhID0gQ2lyY2xlQXJlYTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9Db2xsaXNpb25KdW1wVGFibGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDb2xsaXNpb24vQ29sbGlzaW9uQ29udGFjdFwiLCBcIkNvbGxpc2lvbi9Qb2x5Z29uQXJlYVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbGxpc2lvbkNvbnRhY3RfMSwgUG9seWdvbkFyZWFfMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkNvbGxpc2lvbkp1bXBUYWJsZSA9IHtcclxuICAgICAgICBDb2xsaWRlQ2lyY2xlQ2lyY2xlOiBmdW5jdGlvbiAoY2lyY2xlQSwgY2lyY2xlQikge1xyXG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gY2lyY2xlQS5yYWRpdXMgKyBjaXJjbGVCLnJhZGl1cztcclxuICAgICAgICAgICAgdmFyIGNpcmNsZUFQb3MgPSBjaXJjbGVBLmJvZHkucG9zLmFkZChjaXJjbGVBLnBvcyk7XHJcbiAgICAgICAgICAgIHZhciBjaXJjbGVCUG9zID0gY2lyY2xlQi5ib2R5LnBvcy5hZGQoY2lyY2xlQi5wb3MpO1xyXG4gICAgICAgICAgICBpZiAoY2lyY2xlQVBvcy5kaXN0YW5jZShjaXJjbGVCUG9zKSA+IHJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGF4aXNPZkNvbGxpc2lvbiA9IGNpcmNsZUJQb3Muc3ViKGNpcmNsZUFQb3MpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB2YXIgbXZ0ID0gYXhpc09mQ29sbGlzaW9uLnNjYWxlKHJhZGl1cyAtIGNpcmNsZUJQb3MuZGlzdGFuY2UoY2lyY2xlQVBvcykpO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRPZkNvbGxpc2lvbiA9IGNpcmNsZUEuZ2V0RnVydGhlc3RQb2ludChheGlzT2ZDb2xsaXNpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KGNpcmNsZUEsIGNpcmNsZUIsIG12dCwgcG9pbnRPZkNvbGxpc2lvbiwgYXhpc09mQ29sbGlzaW9uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIENvbGxpZGVDaXJjbGVQb2x5Z29uOiBmdW5jdGlvbiAoY2lyY2xlLCBwb2x5Z29uKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW5BeGlzID0gY2lyY2xlLnRlc3RTZXBhcmF0aW5nQXhpc1RoZW9yZW0ocG9seWdvbik7XHJcbiAgICAgICAgICAgIGlmICghbWluQXhpcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIG1pbkF4aXMgaXMgcG9pbnRpbmcgYXdheSBmcm9tIGNpcmNsZVxyXG4gICAgICAgICAgICB2YXIgc2FtZWRpciA9IG1pbkF4aXMuZG90KHBvbHlnb24uZ2V0Q2VudGVyKCkuc3ViKGNpcmNsZS5nZXRDZW50ZXIoKSkpO1xyXG4gICAgICAgICAgICBtaW5BeGlzID0gc2FtZWRpciA8IDAgPyBtaW5BeGlzLm5lZ2F0ZSgpIDogbWluQXhpcztcclxuICAgICAgICAgICAgdmFyIHZlcnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb2ludDEgPSBwb2x5Z29uLmdldEZ1cnRoZXN0UG9pbnQobWluQXhpcy5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludDIgPSBjaXJjbGUuZ2V0RnVydGhlc3RQb2ludChtaW5BeGlzKTsgLy8uYWRkKGNjKTtcclxuICAgICAgICAgICAgaWYgKGNpcmNsZS5jb250YWlucyhwb2ludDEpKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvbHlnb24uY29udGFpbnMocG9pbnQyKSkge1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwb2ludDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QoY2lyY2xlLCBwb2x5Z29uLCBtaW5BeGlzLCB2ZXJ0cy5sZW5ndGggPT09IDIgPyB2ZXJ0c1swXS5hdmVyYWdlKHZlcnRzWzFdKSA6IHZlcnRzWzBdLCBtaW5BeGlzLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIENvbGxpZGVDaXJjbGVFZGdlOiBmdW5jdGlvbiAoY2lyY2xlLCBlZGdlKSB7XHJcbiAgICAgICAgICAgIC8vIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcbiAgICAgICAgICAgIHZhciBjYyA9IGNpcmNsZS5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgLy8gdmVjdG9yIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VcclxuICAgICAgICAgICAgdmFyIGUgPSBlZGdlLmVuZC5zdWIoZWRnZS5iZWdpbik7XHJcbiAgICAgICAgICAgIC8vIGFtb3VudCBvZiBvdmVybGFwIHdpdGggdGhlIGNpcmNsZSdzIGNlbnRlciBhbG9uZyB0aGUgZWRnZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgdmFyIHUgPSBlLmRvdChlZGdlLmVuZC5zdWIoY2MpKTtcclxuICAgICAgICAgICAgdmFyIHYgPSBlLmRvdChjYy5zdWIoZWRnZS5iZWdpbikpO1xyXG4gICAgICAgICAgICAvLyBQb3RlbnRpYWwgcmVnaW9uIEEgY29sbGlzaW9uIChjaXJjbGUgaXMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZWRnZSwgYmVmb3JlIHRoZSBiZWdpbm5pbmcpXHJcbiAgICAgICAgICAgIGlmICh2IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYSA9IGVkZ2UuYmVnaW4uc3ViKGNjKTtcclxuICAgICAgICAgICAgICAgIHZhciBkZGEgPSBkYS5kb3QoZGEpOyAvLyBxdWljayBhbmQgZGlydHkgd2F5IG9mIGNhbGMnbiBkaXN0YW5jZSBpbiByXjIgdGVybXMgc2F2ZXMgc29tZSBzcXJ0c1xyXG4gICAgICAgICAgICAgICAgLy8gc2F2ZSBzb21lIHNxcnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoZGRhID4gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbm8gY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KGNpcmNsZSwgZWRnZSwgZGEubm9ybWFsaXplKCkuc2NhbGUoY2lyY2xlLnJhZGl1cyAtIE1hdGguc3FydChkZGEpKSwgZWRnZS5iZWdpbiwgZGEubm9ybWFsaXplKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBvdGVudGlhbCByZWdpb24gQiBjb2xsaXNpb24gKGNpcmNsZSBpcyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgZWRnZSwgYWZ0ZXIgdGhlIGVuZClcclxuICAgICAgICAgICAgaWYgKHUgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRiID0gZWRnZS5lbmQuc3ViKGNjKTtcclxuICAgICAgICAgICAgICAgIHZhciBkZGIgPSBkYi5kb3QoZGIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRkYiA+IGNpcmNsZS5yYWRpdXMgKiBjaXJjbGUucmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KGNpcmNsZSwgZWRnZSwgZGIubm9ybWFsaXplKCkuc2NhbGUoY2lyY2xlLnJhZGl1cyAtIE1hdGguc3FydChkZGIpKSwgZWRnZS5lbmQsIGRiLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcG90ZW50aWFsIHJlZ2lvbiBBQiBjb2xsaXNpb24gKGNpcmNsZSBpcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBlZGdlIGJldHdlZW4gdGhlIGJlZ2lubmluZyBhbmQgZW5kKVxyXG4gICAgICAgICAgICB2YXIgZGVuID0gZS5kb3QoZSk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludE9uRWRnZSA9IChlZGdlLmJlZ2luLnNjYWxlKHUpLmFkZChlZGdlLmVuZC5zY2FsZSh2KSkpLnNjYWxlKDEgLyBkZW4pO1xyXG4gICAgICAgICAgICB2YXIgZCA9IGNjLnN1Yihwb2ludE9uRWRnZSk7XHJcbiAgICAgICAgICAgIHZhciBkZCA9IGQuZG90KGQpO1xyXG4gICAgICAgICAgICBpZiAoZGQgPiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG5vIGNvbGxpc2lvblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuID0gZS5wZXJwZW5kaWN1bGFyKCk7XHJcbiAgICAgICAgICAgIC8vIGZsaXAgY29ycmVjdCBkaXJlY3Rpb25cclxuICAgICAgICAgICAgaWYgKG4uZG90KGNjLnN1YihlZGdlLmJlZ2luKSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBuLnggPSAtbi54O1xyXG4gICAgICAgICAgICAgICAgbi55ID0gLW4ueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdmFyIG12dCA9IG4uc2NhbGUoTWF0aC5hYnMoY2lyY2xlLnJhZGl1cyAtIE1hdGguc3FydChkZCkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChjaXJjbGUsIGVkZ2UsIG12dC5uZWdhdGUoKSwgcG9pbnRPbkVkZ2UsIG4ubmVnYXRlKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQ29sbGlkZUVkZ2VFZGdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEVkZ2UtZWRnZSBjb2xsaXNpb24gZG9lc24ndCBtYWtlIHNlbnNlXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQ29sbGlkZVBvbHlnb25FZGdlOiBmdW5jdGlvbiAocG9seWdvbiwgZWRnZSkge1xyXG4gICAgICAgICAgICAvLyAzIGNhc2VzOlxyXG4gICAgICAgICAgICAvLyAoMSkgUG9seWdvbiBsYW5kcyBvbiB0aGUgZnVsbCBmYWNlXHJcbiAgICAgICAgICAgIC8vICgyKSBQb2x5Z29uIGxhbmRzIG9uIHRoZSByaWdodCBwb2ludFxyXG4gICAgICAgICAgICAvLyAoMykgUG9seWdvbiBsYW5kcyBvbiB0aGUgbGVmdCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgZSA9IGVkZ2UuZW5kLnN1YihlZGdlLmJlZ2luKTtcclxuICAgICAgICAgICAgdmFyIGVkZ2VOb3JtYWwgPSBlLm5vcm1hbCgpO1xyXG4gICAgICAgICAgICBpZiAocG9seWdvbi5jb250YWlucyhlZGdlLmJlZ2luKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gcG9seWdvbi5nZXRDbG9zZXN0RmFjZShlZGdlLmJlZ2luKSwgbXR2ID0gX2EuZGlzdGFuY2UsIGZhY2UgPSBfYS5mYWNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG10dikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QocG9seWdvbiwgZWRnZSwgbXR2Lm5lZ2F0ZSgpLCBlZGdlLmJlZ2luLmFkZChtdHYubmVnYXRlKCkpLCBmYWNlLm5vcm1hbCgpLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9seWdvbi5jb250YWlucyhlZGdlLmVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiA9IHBvbHlnb24uZ2V0Q2xvc2VzdEZhY2UoZWRnZS5lbmQpLCBtdHYgPSBfYi5kaXN0YW5jZSwgZmFjZSA9IF9iLmZhY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAobXR2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChwb2x5Z29uLCBlZGdlLCBtdHYubmVnYXRlKCksIGVkZ2UuZW5kLmFkZChtdHYubmVnYXRlKCkpLCBmYWNlLm5vcm1hbCgpLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGMgPSBwb2x5Z29uLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgZWMgPSBlZGdlLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gZWMuc3ViKHBjKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgLy8gYnVpbGQgYSB0ZW1wb3JhcnkgcG9seWdvbiBmcm9tIHRoZSBlZGdlIHRvIHVzZSBTQVRcclxuICAgICAgICAgICAgdmFyIGxpbmVQb2x5ID0gbmV3IFBvbHlnb25BcmVhXzIuUG9seWdvbkFyZWEoe1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5iZWdpbixcclxuICAgICAgICAgICAgICAgICAgICBlZGdlLmVuZCxcclxuICAgICAgICAgICAgICAgICAgICBlZGdlLmVuZC5hZGQoZGlyLnNjYWxlKDMwKSksXHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5iZWdpbi5hZGQoZGlyLnNjYWxlKDMwKSlcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBtaW5BeGlzID0gcG9seWdvbi50ZXN0U2VwYXJhdGluZ0F4aXNUaGVvcmVtKGxpbmVQb2x5KTtcclxuICAgICAgICAgICAgLy8gbm8gbWluQXhpcywgbm8gb3ZlcmxhcCwgbm8gY29sbGlzaW9uXHJcbiAgICAgICAgICAgIGlmICghbWluQXhpcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmxpcCB0aGUgbm9ybWFsIGFuZCBheGlzIHRvIGFsd2F5cyBoYXZlIHBvc2l0aXZlIGNvbGxpc2lvbnNcclxuICAgICAgICAgICAgZWRnZU5vcm1hbCA9IGVkZ2VOb3JtYWwuZG90KGRpcikgPCAwID8gZWRnZU5vcm1hbC5uZWdhdGUoKSA6IGVkZ2VOb3JtYWw7XHJcbiAgICAgICAgICAgIG1pbkF4aXMgPSBtaW5BeGlzLmRvdChkaXIpIDwgMCA/IG1pbkF4aXMubmVnYXRlKCkgOiBtaW5BeGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KHBvbHlnb24sIGVkZ2UsIG1pbkF4aXMsIHBvbHlnb24uZ2V0RnVydGhlc3RQb2ludChlZGdlTm9ybWFsKSwgZWRnZU5vcm1hbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBDb2xsaWRlUG9seWdvblBvbHlnb246IGZ1bmN0aW9uIChwb2x5QSwgcG9seUIpIHtcclxuICAgICAgICAgICAgLy8gZG8gYSBTQVQgdGVzdCB0byBmaW5kIGEgbWluIGF4aXMgaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgICAgIHZhciBtaW5BeGlzID0gcG9seUEudGVzdFNlcGFyYXRpbmdBeGlzVGhlb3JlbShwb2x5Qik7XHJcbiAgICAgICAgICAgIC8vIG5vIG92ZXJsYXAsIG5vIGNvbGxpc2lvbiByZXR1cm4gbnVsbFxyXG4gICAgICAgICAgICBpZiAoIW1pbkF4aXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IG1pbkF4aXMgaXMgcG9pbnRpbmcgZnJvbSBBIC0+IEJcclxuICAgICAgICAgICAgdmFyIHNhbWVEaXIgPSBtaW5BeGlzLmRvdChwb2x5Qi5nZXRDZW50ZXIoKS5zdWIocG9seUEuZ2V0Q2VudGVyKCkpKTtcclxuICAgICAgICAgICAgbWluQXhpcyA9IHNhbWVEaXIgPCAwID8gbWluQXhpcy5uZWdhdGUoKSA6IG1pbkF4aXM7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgcm91Z2ggcG9pbnQgb2YgY29sbGlzaW9uXHJcbiAgICAgICAgICAgIC8vIHRvZG8gdGhpcyBjb3VsZCBiZSBiZXR0ZXJcclxuICAgICAgICAgICAgdmFyIHZlcnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb2ludEEgPSBwb2x5QS5nZXRGdXJ0aGVzdFBvaW50KG1pbkF4aXMpO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRCID0gcG9seUIuZ2V0RnVydGhlc3RQb2ludChtaW5BeGlzLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgaWYgKHBvbHlCLmNvbnRhaW5zKHBvaW50QSkpIHtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocG9pbnRBKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9seUEuY29udGFpbnMocG9pbnRCKSkge1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwb2ludEIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIGNhbmRpZGF0ZXMsIHBpY2sgc29tZXRoaW5nXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocG9pbnRCKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udGFjdCA9IHZlcnRzLmxlbmd0aCA9PT0gMiA/IHZlcnRzWzBdLmFkZCh2ZXJ0c1sxXSkuc2NhbGUoLjUpIDogdmVydHNbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QocG9seUEsIHBvbHlCLCBtaW5BeGlzLCBjb250YWN0LCBtaW5BeGlzLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL1BvbHlnb25BcmVhXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIlBoeXNpY3NcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJDb2xsaXNpb24vRWRnZUFyZWFcIiwgXCJDb2xsaXNpb24vQ29sbGlzaW9uSnVtcFRhYmxlXCIsIFwiQ29sbGlzaW9uL0NpcmNsZUFyZWFcIiwgXCJBbGdlYnJhXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ29sb3JfMiwgUGh5c2ljc18zLCBCb3VuZGluZ0JveF8yLCBFZGdlQXJlYV8yLCBDb2xsaXNpb25KdW1wVGFibGVfMiwgQ2lyY2xlQXJlYV8xLCBBbGdlYnJhXzYpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb2x5Z29uIGNvbGxpc2lvbiBhcmVhIGZvciBkZXRlY3RpbmcgY29sbGlzaW9ucyBmb3IgYWN0b3JzLCBvciBpbmRlcGVuZGVudGx5XHJcbiAgICAgKi9cclxuICAgIHZhciBQb2x5Z29uQXJlYSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUG9seWdvbkFyZWEob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9heGVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3NpZGVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gb3B0aW9ucy5wb3MgfHwgQWxnZWJyYV82LlZlY3Rvci5aZXJvLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHZhciB3aW5kaW5nID0gISFvcHRpb25zLmNsb2Nrd2lzZVdpbmRpbmc7XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gKHdpbmRpbmcgPyBvcHRpb25zLnBvaW50cy5yZXZlcnNlKCkgOiBvcHRpb25zLnBvaW50cykgfHwgW107XHJcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IG9wdGlvbnMuYm9keSB8fCBudWxsO1xyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgaW5pdGlhbCB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVUcmFuc2Zvcm1hdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgY29sbGlzaW9uIGFyZWEgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnBvcy5hZGQodGhpcy5wb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHVuZGVybHlpbmcgdHJhbnNmb3JtYXRpb24gZnJvbSB0aGUgYm9keSByZWxhdGl2ZSBzcGFjZSB0byB3b3JsZCBzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5fY2FsY3VsYXRlVHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkucG9zLmFkZCh0aGlzLnBvcykgOiB0aGlzLnBvcztcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5LnJvdGF0aW9uIDogMDtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoID0gMDsgLy8gY2xlYXIgb3V0IG9sZCB0cmFuc2Zvcm1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHNbaV0gPSB0aGlzLnBvaW50c1tpXS5yb3RhdGUoYW5nbGUpLmFkZChwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBwb2ludHMgdGhhdCBtYWtlIHVwIHRoZSBwb2x5Z29uIGluIHdvcmxkIHNwYWNlLCBmcm9tIGFjdG9yIHJlbGF0aXZlIHNwYWNlIChpZiBzcGVjaWZpZWQpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlVHJhbnNmb3JtYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1lZFBvaW50cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHNpZGVzIG9mIHRoZSBwb2x5Z29uIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmdldFNpZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc2lkZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lkZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxpbmVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBBbGdlYnJhXzYuTGluZShwb2ludHNbaV0sIHBvaW50c1soaSAtIDEgKyBsZW4pICUgbGVuXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NpZGVzID0gbGluZXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWRlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5yZWNhbGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpZGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2F4ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLmdldEF4ZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRTaWRlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBjb250YWluZWQgaW4gdGhpcyBjb2xsaXNpb24gYXJlYSBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICAvLyBBbHdheXMgY2FzdCB0byB0aGUgcmlnaHQsIGFzIGxvbmcgYXMgd2UgY2FzdCBpbiBhIGNvbnNpdGVudCBmaXhlZCBkaXJlY3Rpb24gd2VcclxuICAgICAgICAgICAgLy8gd2lsbCBiZSBmaW5lXHJcbiAgICAgICAgICAgIHZhciB0ZXN0UmF5ID0gbmV3IEFsZ2VicmFfNi5SYXkocG9pbnQsIG5ldyBBbGdlYnJhXzYuVmVjdG9yKDEsIDApKTtcclxuICAgICAgICAgICAgdmFyIGludGVyc2VjdENvdW50ID0gdGhpcy5nZXRTaWRlcygpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHNpZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXN0UmF5LmludGVyc2VjdChzaWRlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RDb3VudCAlIDIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBjb2xsaXNpb24gY29udGFjdCBpZiB0aGUgMiBjb2xsaXNpb24gYXJlYXMgY29sbGlkZSwgb3RoZXJ3aXNlIGNvbGxpZGUgd2lsbFxyXG4gICAgICAgICAqIHJldHVybiBudWxsLlxyXG4gICAgICAgICAqIEBwYXJhbSBhcmVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmNvbGxpZGUgPSBmdW5jdGlvbiAoYXJlYSkge1xyXG4gICAgICAgICAgICBpZiAoYXJlYSBpbnN0YW5jZW9mIENpcmNsZUFyZWFfMS5DaXJjbGVBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzIuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVQb2x5Z29uKGFyZWEsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZWEgaW5zdGFuY2VvZiBQb2x5Z29uQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8yLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlUG9seWdvblBvbHlnb24odGhpcywgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJlYSBpbnN0YW5jZW9mIEVkZ2VBcmVhXzIuRWRnZUFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMi5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZVBvbHlnb25FZGdlKHRoaXMsIGFyZWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seWdvbiBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gSUNvbGxpc2lvbkFyZWEgXCIgKyB0eXBlb2YgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBzaGFwZSBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5nZXRGdXJ0aGVzdFBvaW50ID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcHRzID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgICAgICB2YXIgZnVydGhlc3RQb2ludCA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBtYXhEaXN0YW5jZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gZGlyZWN0aW9uLmRvdChwdHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbWF4RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1cnRoZXN0UG9pbnQgPSBwdHNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZ1cnRoZXN0UG9pbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kcyB0aGUgY2xvc2VzIGZhY2UgdG8gdGhlIHBvaW50IHVzaW5nIHBlcnBlbmRpY3VsYXIgZGlzdGFuY2VcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnQgcG9pbnQgdG8gdGVzdCBhZ2FpbnN0IHBvbHlnb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0Q2xvc2VzdEZhY2UgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIHNpZGVzID0gdGhpcy5nZXRTaWRlcygpO1xyXG4gICAgICAgICAgICB2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgICAgICB2YXIgZmFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IHNpZGVzW2ldLmRpc3RhbmNlVG9Qb2ludChwb2ludCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZhY2VJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IHNpZGVzW2ZhY2VJbmRleF0ubm9ybWFsKCkuc2NhbGUoZGlzdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2U6IHNpZGVzW2ZhY2VJbmRleF1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBwb2x5Z29uIGFyZWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvIHRoZXJlIGlzIGEgZmFzdGVyIHdheSB0byBkbyB0aGlzXHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIHZhciBtaW5YID0gcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXYsIGN1cnIueCk7XHJcbiAgICAgICAgICAgIH0sIDk5OTk5OTk5OSk7XHJcbiAgICAgICAgICAgIHZhciBtYXhYID0gcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHByZXYsIGN1cnIueCk7XHJcbiAgICAgICAgICAgIH0sIC05OTk5OTk5OSk7XHJcbiAgICAgICAgICAgIHZhciBtaW5ZID0gcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXYsIGN1cnIueSk7XHJcbiAgICAgICAgICAgIH0sIDk5OTk5OTk5OTkpO1xyXG4gICAgICAgICAgICB2YXIgbWF4WSA9IHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChwcmV2LCBjdXJyLnkpO1xyXG4gICAgICAgICAgICB9LCAtOTk5OTk5OTk5OSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3hfMi5Cb3VuZGluZ0JveChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgbW9tZW50IG9mIGluZXJ0aWEgZm9yIGFuIGFyYml0cmFyeSBwb2x5Z29uXHJcbiAgICAgICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0TW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbWFzcyA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5tYXNzIDogUGh5c2ljc18zLlBoeXNpY3MuZGVmYXVsdE1hc3M7XHJcbiAgICAgICAgICAgIHZhciBudW1lcmF0b3IgPSAwO1xyXG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXBsdXNvbmUgPSAoaSArIDEpICUgdGhpcy5wb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNyb3NzVGVybSA9IHRoaXMucG9pbnRzW2lwbHVzb25lXS5jcm9zcyh0aGlzLnBvaW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICBudW1lcmF0b3IgKz0gY3Jvc3NUZXJtICogKHRoaXMucG9pbnRzW2ldLmRvdCh0aGlzLnBvaW50c1tpXSkgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLmRvdCh0aGlzLnBvaW50c1tpcGx1c29uZV0pICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50c1tpcGx1c29uZV0uZG90KHRoaXMucG9pbnRzW2lwbHVzb25lXSkpO1xyXG4gICAgICAgICAgICAgICAgZGVub21pbmF0b3IgKz0gY3Jvc3NUZXJtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAobWFzcyAvIDYpICogKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhc3RzIGEgcmF5IGludG8gdGhlIHBvbHlnb24gYW5kIHJldHVybnMgYSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBwb2ludCBvZiBjb250YWN0IChpbiB3b3JsZCBzcGFjZSkgb3IgbnVsbCBpZiBubyBjb2xsaXNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAocmF5LCBtYXgpIHtcclxuICAgICAgICAgICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG1pbmltdW0gY29udGFjdCB0aW1lIGdyZWF0ZXIgdGhhbiAwXHJcbiAgICAgICAgICAgIC8vIGNvbnRhY3QgdGltZXMgbGVzcyB0aGFuIDAgYXJlIGJlaGluZCB0aGUgcmF5IGFuZCB3ZSBkb24ndCB3YW50IHRob3NlXHJcbiAgICAgICAgICAgIHZhciBzaWRlcyA9IHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHNpZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIG1pbkNvbnRhY3RUaW1lID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgdmFyIGNvbnRhY3RJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdFRpbWUgPSByYXkuaW50ZXJzZWN0KHNpZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250YWN0VGltZSA+PSAwICYmIGNvbnRhY3RUaW1lIDwgbWluQ29udGFjdFRpbWUgJiYgY29udGFjdFRpbWUgPD0gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluQ29udGFjdFRpbWUgPSBjb250YWN0VGltZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbnRhY3Qgd2FzIGZvdW5kXHJcbiAgICAgICAgICAgIGlmIChjb250YWN0SW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludChtaW5Db250YWN0VGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm8gY29udGFjdCBmb3VuZFxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgYXhpcyBhc3NvY2lhdGVkIHdpdGggdGhlIGVkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2F4ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXhlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXhlcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXhlcy5wdXNoKHBvaW50c1tpXS5zdWIocG9pbnRzWyhpICsgMSkgJSBsZW5dKS5ub3JtYWwoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXhlcyA9IGF4ZXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9heGVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybSBTZXBhcmF0aW5nIEF4aXMgdGVzdCBhZ2FpbnN0IGFub3RoZXIgcG9seWdvbiwgcmV0dXJucyBudWxsIGlmIG5vIG92ZXJsYXAgaW4gcG9seXNcclxuICAgICAgICAgKiBSZWZlcmVuY2UgaHR0cDovL3d3dy5keW40ai5vcmcvMjAxMC8wMS9zYXQvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLnRlc3RTZXBhcmF0aW5nQXhpc1RoZW9yZW0gPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgdmFyIHBvbHkxID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHBvbHkyID0gb3RoZXI7XHJcbiAgICAgICAgICAgIHZhciBheGVzID0gcG9seTEuZ2V0QXhlcygpLmNvbmNhdChwb2x5Mi5nZXRBeGVzKCkpO1xyXG4gICAgICAgICAgICB2YXIgbWluT3ZlcmxhcCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIHZhciBtaW5BeGlzID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIG1pbkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2oxID0gcG9seTEucHJvamVjdChheGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9qMiA9IHBvbHkyLnByb2plY3QoYXhlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcCA9IHByb2oxLmdldE92ZXJsYXAocHJvajIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BeGlzID0gYXhlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2tcclxuICAgICAgICAgICAgaWYgKG1pbkluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1pbkF4aXMubm9ybWFsaXplKCkuc2NhbGUobWluT3ZlcmxhcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9qZWN0IHRoZSBlZGdlcyBvZiB0aGUgcG9seWdvbiBhbG9uZyBhIHNwZWNpZmllZCBheGlzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoYXhpcykge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxhciA9IHBvaW50c1tpXS5kb3QoYXhpcyk7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHNjYWxhcik7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHNjYWxhcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzYuUHJvamVjdGlvbihtaW4sIG1heCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBjb2xvcikge1xyXG4gICAgICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IENvbG9yXzIuQ29sb3IuUmVkLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHN1cHBsaWVkIHBvaW50cyBhbmQgY29uc3RydWN0IGEgJ3BvbHlnb24nXHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpWzBdO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBvbHlnb25BcmVhO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUG9seWdvbkFyZWEgPSBQb2x5Z29uQXJlYTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9Cb3VuZGluZ0JveFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkNvbGxpc2lvbi9Qb2x5Z29uQXJlYVwiLCBcIkFsZ2VicmFcIiwgXCJEcmF3aW5nL0NvbG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUG9seWdvbkFyZWFfMywgQWxnZWJyYV83LCBDb2xvcl8zKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQXhpcyBBbGlnbmVkIGNvbGxpc2lvbiBwcmltaXRpdmUgZm9yIEV4Y2FsaWJ1ci5cclxuICAgICAqL1xyXG4gICAgdmFyIEJvdW5kaW5nQm94ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gbGVmdCAgICB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgZWRnZVxyXG4gICAgICAgICAqIEBwYXJhbSB0b3AgICAgIHkgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGVkZ2VcclxuICAgICAgICAgKiBAcGFyYW0gcmlnaHQgICB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGVkZ2VcclxuICAgICAgICAgKiBAcGFyYW0gYm90dG9tICB5IGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBlZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQm91bmRpbmdCb3gobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSB2b2lkIDApIHsgbGVmdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7IHRvcCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSB2b2lkIDApIHsgcmlnaHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChib3R0b20gPT09IHZvaWQgMCkgeyBib3R0b20gPSAwOyB9XHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIHRoaXMudG9wID0gdG9wO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBCb3VuZGluZ0JveC5mcm9tUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50cykge1xyXG4gICAgICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzW2ldLnggPCBtaW5YKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50c1tpXS54ID4gbWF4WCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSBwb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueSA8IG1pblkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gcG9pbnRzW2ldLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzW2ldLnkgPiBtYXhZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHBvaW50c1tpXS55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3gobWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHdpZHRoIG9mIHRoZSBib3VuZGluZyBib3hcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSAtIHRoaXMudG9wO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRlcyBhIGJvdW5kaW5nIGJveCBieSBhbmQgYW5nbGUgYW5kIGFyb3VuZCBhIHBvaW50LCBpZiBubyBwb2ludCBpcyBzcGVjaWZpZWQgKDAsIDApIGlzIHVzZWQgYnkgZGVmYXVsdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUsIHBvaW50KSB7XHJcbiAgICAgICAgICAgIGlmIChwb2ludCA9PT0gdm9pZCAwKSB7IHBvaW50ID0gQWxnZWJyYV83LlZlY3Rvci5aZXJvLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCkubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnJvdGF0ZShhbmdsZSwgcG9pbnQpOyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94LmZyb21Qb2ludHMocG9pbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBlcmltZXRlciBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFBlcmltZXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHd4ID0gdGhpcy5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICB2YXIgd3kgPSB0aGlzLmdldEhlaWdodCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gMiAqICh3eCArIHd5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgQWxnZWJyYV83LlZlY3Rvcih0aGlzLmxlZnQsIHRoaXMudG9wKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgQWxnZWJyYV83LlZlY3Rvcih0aGlzLnJpZ2h0LCB0aGlzLnRvcCkpO1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IEFsZ2VicmFfNy5WZWN0b3IodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pKTtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBBbGdlYnJhXzcuVmVjdG9yKHRoaXMubGVmdCwgdGhpcy5ib3R0b20pKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgUG9seWdvbiBjb2xsaXNpb24gYXJlYSBmcm9tIHRoZSBwb2ludHMgb2YgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS50b1BvbHlnb24gPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQXJlYV8zLlBvbHlnb25BcmVhKHtcclxuICAgICAgICAgICAgICAgIGJvZHk6IGFjdG9yID8gYWN0b3IuYm9keSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IHRoaXMuZ2V0UG9pbnRzKCksXHJcbiAgICAgICAgICAgICAgICBwb3M6IEFsZ2VicmFfNy5WZWN0b3IuWmVyby5jbG9uZSgpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcmF5IGludGVyc2VjdHMgd2l0aCBhIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKHJheSwgZmFyQ2xpcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChmYXJDbGlwRGlzdGFuY2UgPT09IHZvaWQgMCkgeyBmYXJDbGlwRGlzdGFuY2UgPSBJbmZpbml0eTsgfVxyXG4gICAgICAgICAgICAvLyBhbGdvcml0aG0gZnJvbSBodHRwczovL3RhdmlhbmF0b3IuY29tL2Zhc3QtYnJhbmNobGVzcy1yYXlib3VuZGluZy1ib3gtaW50ZXJzZWN0aW9ucy8gXHJcbiAgICAgICAgICAgIHZhciB0bWluID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgdG1heCA9ICtJbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIHhpbnYgPSByYXkuZGlyLnggPT09IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogKDEgLyByYXkuZGlyLngpO1xyXG4gICAgICAgICAgICB2YXIgeWludiA9IHJheS5kaXIueSA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAoMSAvIHJheS5kaXIueSk7XHJcbiAgICAgICAgICAgIHZhciB0eDEgPSAodGhpcy5sZWZ0IC0gcmF5LnBvcy54KSAqIHhpbnY7XHJcbiAgICAgICAgICAgIHZhciB0eDIgPSAodGhpcy5yaWdodCAtIHJheS5wb3MueCkgKiB4aW52O1xyXG4gICAgICAgICAgICB0bWluID0gTWF0aC5taW4odHgxLCB0eDIpO1xyXG4gICAgICAgICAgICB0bWF4ID0gTWF0aC5tYXgodHgxLCB0eDIpO1xyXG4gICAgICAgICAgICB2YXIgdHkxID0gKHRoaXMudG9wIC0gcmF5LnBvcy55KSAqIHlpbnY7XHJcbiAgICAgICAgICAgIHZhciB0eTIgPSAodGhpcy5ib3R0b20gLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICAgICAgdG1pbiA9IE1hdGgubWF4KHRtaW4sIE1hdGgubWluKHR5MSwgdHkyKSk7XHJcbiAgICAgICAgICAgIHRtYXggPSBNYXRoLm1pbih0bWF4LCBNYXRoLm1heCh0eTEsIHR5MikpO1xyXG4gICAgICAgICAgICByZXR1cm4gdG1heCA+PSBNYXRoLm1heCgwLCB0bWluKSAmJiB0bWluIDwgZmFyQ2xpcERpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLnJheUNhc3RUaW1lID0gZnVuY3Rpb24gKHJheSwgZmFyQ2xpcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChmYXJDbGlwRGlzdGFuY2UgPT09IHZvaWQgMCkgeyBmYXJDbGlwRGlzdGFuY2UgPSBJbmZpbml0eTsgfVxyXG4gICAgICAgICAgICAvLyBhbGdvcml0aG0gZnJvbSBodHRwczovL3RhdmlhbmF0b3IuY29tL2Zhc3QtYnJhbmNobGVzcy1yYXlib3VuZGluZy1ib3gtaW50ZXJzZWN0aW9ucy8gXHJcbiAgICAgICAgICAgIHZhciB0bWluID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgdG1heCA9ICtJbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIHhpbnYgPSByYXkuZGlyLnggPT09IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogKDEgLyByYXkuZGlyLngpO1xyXG4gICAgICAgICAgICB2YXIgeWludiA9IHJheS5kaXIueSA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAoMSAvIHJheS5kaXIueSk7XHJcbiAgICAgICAgICAgIHZhciB0eDEgPSAodGhpcy5sZWZ0IC0gcmF5LnBvcy54KSAqIHhpbnY7XHJcbiAgICAgICAgICAgIHZhciB0eDIgPSAodGhpcy5yaWdodCAtIHJheS5wb3MueCkgKiB4aW52O1xyXG4gICAgICAgICAgICB0bWluID0gTWF0aC5taW4odHgxLCB0eDIpO1xyXG4gICAgICAgICAgICB0bWF4ID0gTWF0aC5tYXgodHgxLCB0eDIpO1xyXG4gICAgICAgICAgICB2YXIgdHkxID0gKHRoaXMudG9wIC0gcmF5LnBvcy55KSAqIHlpbnY7XHJcbiAgICAgICAgICAgIHZhciB0eTIgPSAodGhpcy5ib3R0b20gLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICAgICAgdG1pbiA9IE1hdGgubWF4KHRtaW4sIE1hdGgubWluKHR5MSwgdHkyKSk7XHJcbiAgICAgICAgICAgIHRtYXggPSBNYXRoLm1pbih0bWF4LCBNYXRoLm1heCh0eTEsIHR5MikpO1xyXG4gICAgICAgICAgICBpZiAodG1heCA+PSBNYXRoLm1heCgwLCB0bWluKSAmJiB0bWluIDwgZmFyQ2xpcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1pbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBbGdlYnJhXzcuVmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMubGVmdCA8PSB2YWwueCAmJiB0aGlzLnRvcCA8PSB2YWwueSAmJiB0aGlzLmJvdHRvbSA+PSB2YWwueSAmJiB0aGlzLnJpZ2h0ID49IHZhbC54KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCA8IHZhbC5sZWZ0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AgPCB2YWwudG9wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsLmJvdHRvbSA8IHRoaXMuYm90dG9tICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsLnJpZ2h0IDwgdGhpcy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbWJpbmVzIHRoaXMgYm91bmRpbmcgYm94IGFuZCBhbm90aGVyIHRvZ2V0aGVyIHJldHVybmluZyBhIG5ldyBib3VuZGluZyBib3hcclxuICAgICAgICAgKiBAcGFyYW0gb3RoZXIgIFRoZSBib3VuZGluZyBib3ggdG8gY29tYmluZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wb3NpdGVCQiA9IG5ldyBCb3VuZGluZ0JveChNYXRoLm1pbih0aGlzLmxlZnQsIG90aGVyLmxlZnQpLCBNYXRoLm1pbih0aGlzLnRvcCwgb3RoZXIudG9wKSwgTWF0aC5tYXgodGhpcy5yaWdodCwgb3RoZXIucmlnaHQpLCBNYXRoLm1heCh0aGlzLmJvdHRvbSwgb3RoZXIuYm90dG9tKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wb3NpdGVCQjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3Qgd2V0aGVyIHRoaXMgYm91bmRpbmcgYm94IGNvbGxpZGVzIHdpdGggYW5vdGhlciByZXR1cm5pbmcsXHJcbiAgICAgICAgICogdGhlIGludGVyc2VjdGlvbiB2ZWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNvbHZlIHRoZSBjb2xsaXNpb24uIElmIHRoZXJlXHJcbiAgICAgICAgICogaXMgbm8gY29sbGlzaW9uIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbGxpZGFibGUgIE90aGVyIGNvbGxpZGFibGUgdG8gdGVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb2xsaWRlcyA9IGZ1bmN0aW9uIChjb2xsaWRhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xsaWRhYmxlIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNvbGxpZGFibGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxCb3VuZGluZ0JveCA9IHRoaXMuY29tYmluZShvdGhlcik7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgYm91bmRpbmcgYm94IGlzIGxlc3MgdGhhbiB0aGUgc3VtIG9mIHRoZSAyIGJvdW5kcyB0aGVuIHRoZXJlIGlzIGNvbGxpc2lvblxyXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsQm91bmRpbmdCb3guZ2V0V2lkdGgoKSA8IG90aGVyLmdldFdpZHRoKCkgKyB0aGlzLmdldFdpZHRoKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbEJvdW5kaW5nQm94LmdldEhlaWdodCgpIDwgb3RoZXIuZ2V0SGVpZ2h0KCkgKyB0aGlzLmdldEhlaWdodCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBYID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodCA+PSBvdGhlci5sZWZ0ICYmIHRoaXMucmlnaHQgPD0gb3RoZXIucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5sZWZ0IC0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBYID0gb3RoZXIucmlnaHQgLSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdmVybGFwWSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9wIDw9IG90aGVyLmJvdHRvbSAmJiB0aGlzLnRvcCA+PSBvdGhlci50b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci5ib3R0b20gLSB0aGlzLnRvcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBZID0gb3RoZXIudG9wIC0gdGhpcy5ib3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhvdmVybGFwWCkgPCBNYXRoLmFicyhvdmVybGFwWSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzcuVmVjdG9yKG92ZXJsYXBYLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV83LlZlY3RvcigwLCBvdmVybGFwWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBjb2xvcikge1xyXG4gICAgICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IENvbG9yXzMuQ29sb3IuWWVsbG93OyB9XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQm91bmRpbmdCb3g7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Cb3VuZGluZ0JveCA9IEJvdW5kaW5nQm94O1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0VkZ2VBcmVhXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFwiQ29sbGlzaW9uL0NvbGxpc2lvbkp1bXBUYWJsZVwiLCBcIkNvbGxpc2lvbi9DaXJjbGVBcmVhXCIsIFwiQ29sbGlzaW9uL1BvbHlnb25BcmVhXCIsIFwiQWxnZWJyYVwiLCBcIlBoeXNpY3NcIiwgXCJEcmF3aW5nL0NvbG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQm91bmRpbmdCb3hfMywgQ29sbGlzaW9uSnVtcFRhYmxlXzMsIENpcmNsZUFyZWFfMiwgUG9seWdvbkFyZWFfNCwgQWxnZWJyYV84LCBQaHlzaWNzXzQsIENvbG9yXzQpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIEVkZ2VBcmVhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBFZGdlQXJlYShvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmVnaW4gPSBvcHRpb25zLmJlZ2luIHx8IEFsZ2VicmFfOC5WZWN0b3IuWmVyby5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZCA9IG9wdGlvbnMuZW5kIHx8IEFsZ2VicmFfOC5WZWN0b3IuWmVyby5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHkgfHwgbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgY29sbGlzaW9uIGFyZWEgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5iZWdpbi5hdmVyYWdlKHRoaXMuZW5kKS5hZGQodGhpcy5fZ2V0Qm9keVBvcygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5fZ2V0Qm9keVBvcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJvZHlQb3MgPSBBbGdlYnJhXzguVmVjdG9yLlplcm8uY2xvbmUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5wb3MpIHtcclxuICAgICAgICAgICAgICAgIGJvZHlQb3MgPSB0aGlzLmJvZHkucG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5UG9zO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLl9nZXRUcmFuc2Zvcm1lZEJlZ2luID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkucm90YXRpb24gOiAwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZWdpbi5yb3RhdGUoYW5nbGUpLmFkZCh0aGlzLl9nZXRCb2R5UG9zKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLl9nZXRUcmFuc2Zvcm1lZEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5LnJvdGF0aW9uIDogMDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kLnJvdGF0ZShhbmdsZSkuYWRkKHRoaXMuX2dldEJvZHlQb3MoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzbG9wZSBvZiB0aGUgbGluZSBpbiB0aGUgZm9ybSBvZiBhIHZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRTbG9wZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJlZ2luID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVuZC5zdWIoYmVnaW4pLnNjYWxlKDEgLyBkaXN0YW5jZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgc2VnbWVudCBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBiZWdpbi5kaXN0YW5jZShlbmQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGNvbnRhaW5lZCBpbiB0aGlzIGNvbGxpc2lvbiBhcmVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKHJheSwgbWF4KSB7XHJcbiAgICAgICAgICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSBJbmZpbml0eTsgfVxyXG4gICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpLnN1YihyYXkucG9zKTtcclxuICAgICAgICAgICAgLy8gVGVzdCBpcyBsaW5lIGFuZCByYXkgYXJlIHBhcmFsbGVsIGFuZCBub24gaW50ZXJzZWN0aW5nXHJcbiAgICAgICAgICAgIGlmIChyYXkuZGlyLmNyb3NzKHRoaXMuZ2V0U2xvcGUoKSkgPT09IDAgJiYgbnVtZXJhdG9yLmNyb3NzKHJheS5kaXIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBMaW5lcyBhcmUgcGFyYWxsZWxcclxuICAgICAgICAgICAgdmFyIGRpdmlzb3IgPSAocmF5LmRpci5jcm9zcyh0aGlzLmdldFNsb3BlKCkpKTtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ID0gbnVtZXJhdG9yLmNyb3NzKHRoaXMuZ2V0U2xvcGUoKSkgLyBkaXZpc29yO1xyXG4gICAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSA9IChudW1lcmF0b3IuY3Jvc3MocmF5LmRpcikgLyBkaXZpc29yKSAvIHRoaXMuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodSA+PSAwICYmIHUgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYXkuZ2V0UG9pbnQodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5jb2xsaWRlID0gZnVuY3Rpb24gKGFyZWEpIHtcclxuICAgICAgICAgICAgaWYgKGFyZWEgaW5zdGFuY2VvZiBDaXJjbGVBcmVhXzIuQ2lyY2xlQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8zLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlRWRnZShhcmVhLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmVhIGluc3RhbmNlb2YgUG9seWdvbkFyZWFfNC5Qb2x5Z29uQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8zLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlUG9seWdvbkVkZ2UoYXJlYSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJlYSBpbnN0YW5jZW9mIEVkZ2VBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzMuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVFZGdlRWRnZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRnZSBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gSUNvbGxpc2lvbkFyZWEgXCIgKyB0eXBlb2YgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBzaGFwZSBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRGdXJ0aGVzdFBvaW50ID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRCZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbi5kb3QodHJhbnNmb3JtZWRCZWdpbikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRCZWdpbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciB0aGUgY2lyY2xlIGFyZWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRCZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveF8zLkJvdW5kaW5nQm94KE1hdGgubWluKHRyYW5zZm9ybWVkQmVnaW4ueCwgdHJhbnNmb3JtZWRFbmQueCksIE1hdGgubWluKHRyYW5zZm9ybWVkQmVnaW4ueSwgdHJhbnNmb3JtZWRFbmQueSksIE1hdGgubWF4KHRyYW5zZm9ybWVkQmVnaW4ueCwgdHJhbnNmb3JtZWRFbmQueCksIE1hdGgubWF4KHRyYW5zZm9ybWVkQmVnaW4ueSwgdHJhbnNmb3JtZWRFbmQueSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBheGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCkuc3ViKHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKSk7XHJcbiAgICAgICAgICAgIHZhciBlZGdlTm9ybWFsID0gZS5ub3JtYWwoKTtcclxuICAgICAgICAgICAgdmFyIGF4ZXMgPSBbXTtcclxuICAgICAgICAgICAgYXhlcy5wdXNoKGVkZ2VOb3JtYWwpO1xyXG4gICAgICAgICAgICBheGVzLnB1c2goZWRnZU5vcm1hbC5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIGF4ZXMucHVzaChlZGdlTm9ybWFsLm5vcm1hbCgpKTtcclxuICAgICAgICAgICAgYXhlcy5wdXNoKGVkZ2VOb3JtYWwubm9ybWFsKCkubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXhlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgbW9tZW50IG9mIGluZXJ0aWEgZm9yIGFuIGVkZ2VcclxuICAgICAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXNzID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5Lm1hc3MgOiBQaHlzaWNzXzQuUGh5c2ljcy5kZWZhdWx0TWFzcztcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuZW5kLnN1Yih0aGlzLmJlZ2luKS5kaXN0YW5jZSgpIC8gMjtcclxuICAgICAgICAgICAgcmV0dXJuIG1hc3MgKiBsZW5ndGggKiBsZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5yZWNhbGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIGVkZ2VzIGRvbid0IGhhdmUgYW55IGNhY2hlZCBkYXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9qZWN0IHRoZSBlZGdlIGFsb25nIGEgc3BlY2lmaWVkIGF4aXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIChheGlzKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsYXJzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpLCB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpXTtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNjYWxhcnMucHVzaChwb2ludHNbaV0uZG90KGF4aXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfOC5Qcm9qZWN0aW9uKE1hdGgubWluLmFwcGx5KE1hdGgsIHNjYWxhcnMpLCBNYXRoLm1heC5hcHBseShNYXRoLCBzY2FsYXJzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBjb2xvcikge1xyXG4gICAgICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IENvbG9yXzQuQ29sb3IuUmVkLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMuYmVnaW4ueCwgdGhpcy5iZWdpbi55KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmVuZC54LCB0aGlzLmVuZC55KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRWRnZUFyZWE7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5FZGdlQXJlYSA9IEVkZ2VBcmVhO1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9EcmF3VXRpbFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvQ29sb3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xvcl81KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGxpbmUgb24gY2FudmFzIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IFRoZSBjYW52YXMgY29udGV4dFxyXG4gICAgICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIHgxIFRoZSBzdGFydCB4IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB5MSBUaGUgc3RhcnQgeSBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0geDIgVGhlIGVuZGluZyB4IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB5MiBUaGUgZW5kaW5nIHkgY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHRoaWNrbmVzcyBUaGUgbGluZSB0aGlja25lc3NcclxuICAgICAqIEBwYXJhbSBjYXAgVGhlIFtbTGluZUNhcFN0eWxlXV0gKGJ1dHQsIHJvdW5kLCBvciBzcXVhcmUpXHJcbiAgICAgKi9cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBmdW5jdGlvbiBsaW5lKGN0eCwgY29sb3IsIHgxLCB5MSwgeDIsIHkyLCB0aGlja25lc3MsIGNhcCkge1xyXG4gICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gQ29sb3JfNS5Db2xvci5SZWQuY2xvbmUoKTsgfVxyXG4gICAgICAgIGlmICh0aGlja25lc3MgPT09IHZvaWQgMCkgeyB0aGlja25lc3MgPSAxOyB9XHJcbiAgICAgICAgaWYgKGNhcCA9PT0gdm9pZCAwKSB7IGNhcCA9ICdidXR0JzsgfVxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpY2tuZXNzO1xyXG4gICAgICAgIGN0eC5saW5lQ2FwID0gY2FwO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5saW5lID0gbGluZTtcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGUgdmVjdG9yIGFzIGEgcG9pbnQgb250byB0aGUgY2FudmFzLlxyXG4gICAgICovXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZnVuY3Rpb24gcG9pbnQoY3R4LCBjb2xvciwgcG9pbnQpIHtcclxuICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IENvbG9yXzUuQ29sb3IuUmVkLmNsb25lKCk7IH1cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5wb2ludCA9IHBvaW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoZSB2ZWN0b3IgYXMgYSBsaW5lIG9udG8gdGhlIGNhbnZhcyBzdGFydGluZyBhIG9yaWdpbiBwb2ludC5cclxuICAgICAqL1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGZ1bmN0aW9uIHZlY3RvcihjdHgsIGNvbG9yLCBvcmlnaW4sIHZlY3Rvciwgc2NhbGUpIHtcclxuICAgICAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDEuMDsgfVxyXG4gICAgICAgIHZhciBjID0gY29sb3IgPyBjb2xvci50b1N0cmluZygpIDogJ2JsdWUnO1xyXG4gICAgICAgIHZhciB2ID0gdmVjdG9yLnNjYWxlKHNjYWxlKTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYztcclxuICAgICAgICBjdHgubW92ZVRvKG9yaWdpbi54LCBvcmlnaW4ueSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyhvcmlnaW4ueCArIHYueCwgb3JpZ2luLnkgKyB2LnkpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnZlY3RvciA9IHZlY3RvcjtcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIHJvdW5kIHJlY3RhbmdsZSBvbiBhIGNhbnZhcyBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCBUaGUgY2FudmFzIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB4IFRoZSB0b3AtbGVmdCB4IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB5IFRoZSB0b3AtbGVmdCB5IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSByYWRpdXMgVGhlIGJvcmRlciByYWRpdXMgb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIGZpbGwgVGhlIFtbQ29sb3JdXSB0byBmaWxsIHJlY3RhbmdsZSB3aXRoXHJcbiAgICAgKiBAcGFyYW0gc3Ryb2tlIFRoZSBbW0NvbG9yXV0gdG8gc3Ryb2tlIHJlY3RhbmdsZSB3aXRoXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgc3Ryb2tlLCBmaWxsKSB7XHJcbiAgICAgICAgaWYgKHJhZGl1cyA9PT0gdm9pZCAwKSB7IHJhZGl1cyA9IDU7IH1cclxuICAgICAgICBpZiAoc3Ryb2tlID09PSB2b2lkIDApIHsgc3Ryb2tlID0gQ29sb3JfNS5Db2xvci5XaGl0ZTsgfVxyXG4gICAgICAgIGlmIChmaWxsID09PSB2b2lkIDApIHsgZmlsbCA9IG51bGw7IH1cclxuICAgICAgICB2YXIgYnI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYWRpdXMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGJyID0geyB0bDogcmFkaXVzLCB0cjogcmFkaXVzLCBicjogcmFkaXVzLCBibDogcmFkaXVzIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFJhZGl1cyA9IHsgdGw6IDAsIHRyOiAwLCBicjogMCwgYmw6IDAgfTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0UmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFJhZGl1cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWRlID0gcHJvcDtcclxuICAgICAgICAgICAgICAgICAgICBicltzaWRlXSA9IHJhZGl1c1tzaWRlXSB8fCBkZWZhdWx0UmFkaXVzW3NpZGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubW92ZVRvKHggKyBici50bCwgeSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSBici50ciwgeSk7XHJcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyBici50cik7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSBici5icik7XHJcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBici5iciwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgYnIuYmwsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBici5ibCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgYnIudGwpO1xyXG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyBici50bCwgeSk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJva2UpIHtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnJvdW5kUmVjdCA9IHJvdW5kUmVjdDtcclxuICAgIGZ1bmN0aW9uIGNpcmNsZShjdHgsIHgsIHksIHJhZGl1cywgc3Ryb2tlLCBmaWxsKSB7XHJcbiAgICAgICAgaWYgKHN0cm9rZSA9PT0gdm9pZCAwKSB7IHN0cm9rZSA9IENvbG9yXzUuQ29sb3IuV2hpdGU7IH1cclxuICAgICAgICBpZiAoZmlsbCA9PT0gdm9pZCAwKSB7IGZpbGwgPSBudWxsOyB9XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJva2UpIHtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmNpcmNsZSA9IGNpcmNsZTtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvTG9nXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIExvZ2dpbmcgbGV2ZWwgdGhhdCBFeGNhbGlidXIgd2lsbCB0YWdcclxuICAgICAqL1xyXG4gICAgdmFyIExvZ0xldmVsO1xyXG4gICAgKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xyXG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRGVidWdcIl0gPSAwXSA9IFwiRGVidWdcIjtcclxuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAxXSA9IFwiSW5mb1wiO1xyXG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV2FyblwiXSA9IDJdID0gXCJXYXJuXCI7XHJcbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFcnJvclwiXSA9IDNdID0gXCJFcnJvclwiO1xyXG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRmF0YWxcIl0gPSA0XSA9IFwiRmF0YWxcIjtcclxuICAgIH0pKExvZ0xldmVsID0gZXhwb3J0cy5Mb2dMZXZlbCB8fCAoZXhwb3J0cy5Mb2dMZXZlbCA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXRpYyBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzIHRoZSBsb2dnaW5nIGZhY2lsaXR5IGZvciBFeGNhbGlidXIuXHJcbiAgICAgKiBFeGNhbGlidXIgY29tZXMgYnVpbHQtaW4gd2l0aCBhIFtbQ29uc29sZUFwcGVuZGVyXV0gYW5kIFtbU2NyZWVuQXBwZW5kZXJdXS5cclxuICAgICAqIERlcml2ZSBmcm9tIFtbSUFwcGVuZGVyXV0gdG8gY3JlYXRlIHlvdXIgb3duIGxvZ2dpbmcgYXBwZW5kZXJzLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpMb2dnZXIubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgTG9nZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBMb2dnZXIoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGVuZGVycyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBkZWZhdWx0IGxvZ2dpbmcgbGV2ZWwuIEV4Y2FsaWJ1ciB3aWxsIG9ubHkgbG9nXHJcbiAgICAgICAgICAgICAqIG1lc3NhZ2VzIGlmIGVxdWFsIHRvIG9yIGFib3ZlIHRoaXMgbGV2ZWwuIERlZmF1bHQ6IFtbTG9nTGV2ZWwuSW5mb11dXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCA9IExvZ0xldmVsLkluZm87XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvZ2dlciBpcyBhIHNpbmdsZXRvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIExvZ2dlci5faW5zdGFuY2UgPSB0aGlzO1xyXG4gICAgICAgICAgICAvLyBEZWZhdWx0IGNvbnNvbGUgYXBwZW5kZXJcclxuICAgICAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZS5hZGRBcHBlbmRlcihuZXcgQ29uc29sZUFwcGVuZGVyKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gTG9nZ2VyLl9pbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0aWMgaW5zdGFuY2Ugb2YgTG9nZ2VyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoTG9nZ2VyLl9pbnN0YW5jZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuX2luc3RhbmNlID0gbmV3IExvZ2dlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBMb2dnZXIuX2luc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIG5ldyBbW0lBcHBlbmRlcl1dIHRvIHRoZSBsaXN0IG9mIGFwcGVuZGVycyB0byB3cml0ZSB0b1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuYWRkQXBwZW5kZXIgPSBmdW5jdGlvbiAoYXBwZW5kZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXBwZW5kZXJzLnB1c2goYXBwZW5kZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIGFsbCBhcHBlbmRlcnMgZnJvbSB0aGUgbG9nZ2VyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5jbGVhckFwcGVuZGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXBwZW5kZXJzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCBhIGdpdmVuIExvZ0xldmVsXHJcbiAgICAgICAgICogQHBhcmFtIGxldmVsICBUaGUgTG9nTGV2ZWxgdG8gbG9nIHRoZSBtZXNzYWdlIGF0XHJcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgICBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gd3JpdGUgdG8gYW4gYXBwZW5kZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2dnZXIucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxldmVsID0gdGhpcy5kZWZhdWx0TGV2ZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9hcHBlbmRlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID49IHRoaXMuZGVmYXVsdExldmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kZXJzW2ldLmxvZyhsZXZlbCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkRlYnVnXV0gbGV2ZWxcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkRlYnVnLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkluZm9dXSBsZXZlbFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5JbmZvLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLldhcm5dXSBsZXZlbFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5XYXJuLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkVycm9yXV0gbGV2ZWxcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkVycm9yLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkZhdGFsXV0gbGV2ZWxcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZmF0YWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkZhdGFsLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBMb2dnZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgTG9nZ2VyLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICBleHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc29sZSBhcHBlbmRlciBmb3IgYnJvd3NlcnMgKGkuZS4gYGNvbnNvbGUubG9nYClcclxuICAgICAqL1xyXG4gICAgdmFyIENvbnNvbGVBcHBlbmRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ29uc29sZUFwcGVuZGVyKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUgZ2l2ZW4gW1tMb2dMZXZlbF1dXHJcbiAgICAgICAgICogQHBhcmFtIGxldmVsICBMZXZlbCB0byBsb2cgYXRcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgIEFyZ3VtZW50cyB0byBsb2dcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb25zb2xlQXBwZW5kZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgYXJncykge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY29uc29sZSBzdXBwb3J0XHJcbiAgICAgICAgICAgIGlmICghY29uc29sZSAmJiAhY29uc29sZS5sb2cgJiYgY29uc29sZS53YXJuICYmIGNvbnNvbGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRvZG8gbWF5YmUgZG8gc29tZXRoaW5nIGJldHRlciB0aGFuIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29uc29sZSBhcmdzIGFycmF5XHJcbiAgICAgICAgICAgIHZhciBjb25zb2xlQXJncyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zb2xlQXJncy51bnNoaWZ0LmFwcGx5KGNvbnNvbGVBcmdzLCBhcmdzKTtcclxuICAgICAgICAgICAgY29uc29sZUFyZ3MudW5zaGlmdCgnWycgKyBMb2dMZXZlbFtsZXZlbF0gKyAnXSA6ICcpO1xyXG4gICAgICAgICAgICBpZiAobGV2ZWwgPCBMb2dMZXZlbC5XYXJuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIC5sb2cgZm9yIERlYnVnL0luZm9cclxuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgcmVxdWlyZWQgb24gc29tZSBvbGRlciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgYXBwbHkgb24gY29uc29sZS5sb2cgOihcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb25zb2xlQXJncy5qb2luKCcgJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxldmVsIDwgTG9nTGV2ZWwuRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIENhbGwgLndhcm4gZm9yIFdhcm5cclxuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLndhcm4uYXBwbHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgY29uc29sZUFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIC5lcnJvciBmb3IgRXJyb3IvRmF0YWxcclxuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yLmFwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb25zb2xlQXBwZW5kZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Db25zb2xlQXBwZW5kZXIgPSBDb25zb2xlQXBwZW5kZXI7XHJcbiAgICAvKipcclxuICAgICAqIE9uLXNjcmVlbiAoY2FudmFzKSBhcHBlbmRlclxyXG4gICAgICovXHJcbiAgICB2YXIgU2NyZWVuQXBwZW5kZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCAgIFdpZHRoIG9mIHRoZSBzY3JlZW4gYXBwZW5kZXIgaW4gcGl4ZWxzXHJcbiAgICAgICAgICogQHBhcmFtIGhlaWdodCAgSGVpZ2h0IG9mIHRoZSBzY3JlZW4gYXBwZW5kZXIgaW4gcGl4ZWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gU2NyZWVuQXBwZW5kZXIod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICAvLyBAdG9kbyBDbGVhbiB0aGlzIHVwXHJcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSB3aWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IGhlaWdodCB8fCB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvZ3MgYSBtZXNzYWdlIGF0IHRoZSBnaXZlbiBbW0xvZ0xldmVsXV1cclxuICAgICAgICAgKiBAcGFyYW0gbGV2ZWwgIExldmVsIHRvIGxvZyBhdFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICAgQXJndW1lbnRzIHRvIGxvZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjcmVlbkFwcGVuZGVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmdzLmpvaW4oJywnKTtcclxuICAgICAgICAgICAgdGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlcy51bnNoaWZ0KCdbJyArIExvZ0xldmVsW2xldmVsXSArICddIDogJyArIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gMTA7XHJcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gMS4wO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsJyArIG9wYWNpdHkudG9GaXhlZCgyKSArICcpJztcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5maWxsVGV4dCh0aGlzLl9tZXNzYWdlc1tpXSwgMjAwLCBwb3MpO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IDEwO1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IG9wYWNpdHkgPiAwID8gb3BhY2l0eSAtIC4wNSA6IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTY3JlZW5BcHBlbmRlcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNjcmVlbkFwcGVuZGVyID0gU2NyZWVuQXBwZW5kZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0RlY29yYXRvcnNcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL0xvZ1wiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIExvZ18xLCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogT2Jzb2xldGUgZGVjb3JhdG9yIGZvciBtYXJraW5nIEV4Y2FsaWJ1ciBtZXRob2RzIG9ic29sZXRlLCB5b3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSBhIGN1c3RvbSBtZXNzYWdlIGFuZC9vciBhbHRlcm5hdGUgcmVwbGFjZW1lbnRcclxuICAgICAqIG1ldGhvZCBkbyB0aGUgZGVwcmVjYXRlZCBvbmUuIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9qYXlwaGVscHMvY29yZS1kZWNvcmF0b3JzLmpzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9ic29sZXRlKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIHsgbWVzc2FnZTogJ1RoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgRXhjYWxpYnVyLicsIGFsdGVybmF0ZU1ldGhvZDogbnVsbCB9LCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbicgfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBkZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyB8fFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ID09PSAnZnVuY3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdPbmx5IGZ1bmN0aW9ucy9nZXR0ZXJzL3NldHRlcnMgY2FuIGJlIG1hcmtlZCBhcyBvYnNvbGV0ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RTaWduYXR1cmUgPSBcIlwiICsgKHRhcmdldC5uYW1lIHx8ICcnKSArICh0YXJnZXQubmFtZSA/ICcuJyA6ICcnKSArIHByb3BlcnR5O1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1ldGhvZFNpZ25hdHVyZSArIFwiIGlzIG1hcmtlZCBvYnNvbGV0ZTogXCIgKyBvcHRpb25zLm1lc3NhZ2UgK1xyXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMuYWx0ZXJuYXRlTWV0aG9kID8gXCIgVXNlIFwiICsgb3B0aW9ucy5hbHRlcm5hdGVNZXRob2QgKyBcIiBpbnN0ZWFkXCIgOiAnJyk7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBVdGlsLmV4dGVuZCh7fSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QudmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzEuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ18xLkxvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfMS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLm9ic29sZXRlID0gb2Jzb2xldGU7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vQm9keVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlBoeXNpY3NcIiwgXCJDb2xsaXNpb24vRWRnZUFyZWFcIiwgXCJDb2xsaXNpb24vQ2lyY2xlQXJlYVwiLCBcIkNvbGxpc2lvbi9Qb2x5Z29uQXJlYVwiLCBcIkNvbGxpc2lvbi9QYWlyXCIsIFwiQWxnZWJyYVwiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJVdGlsL0RyYXdVdGlsXCIsIFwiVXRpbC9EZWNvcmF0b3JzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUGh5c2ljc181LCBFZGdlQXJlYV8zLCBDaXJjbGVBcmVhXzMsIFBvbHlnb25BcmVhXzUsIFBhaXJfMSwgQWxnZWJyYV85LCBDb2xvcl82LCBEcmF3VXRpbCwgRGVjb3JhdG9yc18xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBCb2R5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHBoeXNpY3MgYm9keSBhc3NvY2lhdGVkIHdpdGggYW4gYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBCb2R5KGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFtJQ29sbGlzaW9uQXJlYXxDb2xsaXNpb24gYXJlYV0gb2YgdGhpcyBwaHlzaWNzIGJvZHksIGRlZmluZXMgdGhlIHNoYXBlIGZvciByaWdpZCBib2R5IGNvbGxpc2lvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25BcmVhID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSAoeCwgeSkgcG9zaXRpb24gb2YgdGhlIGFjdG9yIHRoaXMgd2lsbCBiZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBhY3RvciBpZiB0aGVcclxuICAgICAgICAgICAgICogW1tBY3Rvci5hbmNob3JdXSBpcyBzZXQgdG8gKDAuNSwgMC41KSB3aGljaCBpcyBkZWZhdWx0LlxyXG4gICAgICAgICAgICAgKiBJZiB5b3Ugd2FudCB0aGUgKHgsIHkpIHBvc2l0aW9uIHRvIGJlIHRoZSB0b3AgbGVmdCBvZiB0aGUgYWN0b3Igc3BlY2lmeSBhbiBhbmNob3Igb2YgKDAsIDApLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXcgQWxnZWJyYV85LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgYWN0b3IgbGFzdCBmcmFtZSAoeCwgeSkgaW4gcGl4ZWxzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9sZFBvcyA9IG5ldyBBbGdlYnJhXzkuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgdmVsb2NpdHkgdmVjdG9yICh2eCwgdnkpIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnZlbCA9IG5ldyBBbGdlYnJhXzkuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBsYXN0IGZyYW1lICh2eCwgdnkpIGluIHBpeGVscy9zZWNvbmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub2xkVmVsID0gbmV3IEFsZ2VicmFfOS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmV0IGFjY2VsZXJhdGlvbiB2ZWN0b3IgKGF4LCBheSkgb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmQvc2Vjb25kLiBBbiBhY2NlbGVyYXRpb24gcG9pbnRpbmcgZG93biBzdWNoIGFzICgwLCAxMDApIG1heVxyXG4gICAgICAgICAgICAgKiBiZSB1c2VmdWwgdG8gc2ltdWxhdGUgYSBncmF2aXRhdGlvbmFsIGVmZmVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuYWNjID0gbmV3IEFsZ2VicmFfOS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCB0b3JxdWUgYXBwbGllZCB0byB0aGUgYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudG9ycXVlID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IG1hc3Mgb2YgdGhlIGFjdG9yLCBtYXNzIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByZXNpc3RhbmNlIHRvIGFjY2VsZXJhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubWFzcyA9IDEuMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IG1vbWVudCBvZiBpbmVydGlhLCBtb2kgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJlc2lzdGFuY2UgdG8gcm90YXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm1vaSA9IDEwMDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBcIm1vdGlvblwiIG9mIHRoZSBhY3RvciwgdXNlZCB0byBjYWxjdWxhdGVkIHNsZWVwIGluIHRoZSBwaHlzaWNzIHNpbXVsYXRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubW90aW9uID0gMTA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29lZmZpY2llbnQgb2YgZnJpY3Rpb24gb24gdGhpcyBhY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbiA9IC45OTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbiBvZiB0aGlzIGFjdG9yLCByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgZW5lcmd5IHByZXNlcnZlZCBhZnRlciBjb2xsaXNpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVzdGl0dXRpb24gPSAuMjtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSByb3RhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcmFkaWFuc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7IC8vIHJhZGlhbnNcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiByYWRpYW5zL3NlY29uZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yeCA9IDA7IC8vcmFkaWFucy9zZWNcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxNdHYgPSBBbGdlYnJhXzkuVmVjdG9yLlplcm8uY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIG1pbmltdW0gdHJhbnNsYXRpb24gdmVjdG9ycyBhY2N1bXVsYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgZnJhbWUgdG8gcmVzb2x2ZSBjb2xsaXNpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmFkZE10diA9IGZ1bmN0aW9uIChtdHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxNdHYuYWRkRXF1YWwobXR2KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIGFjY3VtdWxhdGVkIHRyYW5zbGF0aW9uIHZlY3RvcnMgdG8gdGhlIGFjdG9ycyBwb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmFwcGx5TXR2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcy5hZGRFcXVhbCh0aGlzLl90b3RhbE10dik7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTXR2LnNldFRvKDAsIDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYm9keSdzIFtbQm91bmRpbmdCb3hdXSBjYWxjdWxhdGVkIGZvciB0aGlzIGluc3RhbnQgaW4gd29ybGQgc3BhY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc181LlBoeXNpY3MuY29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID09PSBQaHlzaWNzXzUuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkJveCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3IuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25BcmVhLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhY3RvcidzIFtbQm91bmRpbmdCb3hdXSByZWxhdGl2ZSB0byB0aGUgYWN0b3JzIHBvc2l0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldFJlbGF0aXZlQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc181LlBoeXNpY3MuY29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID09PSBQaHlzaWNzXzUuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkJveCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3IuZ2V0UmVsYXRpdmVCb3VuZHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdG9yLmdldFJlbGF0aXZlQm91bmRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGNvbGxpc2lvbiBhcmVhIGdlb21ldHJ5IGFuZCBpbnRlcm5hbCBjYWNoZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbGxpc2lvbkFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQXJlYS5yZWNhbGMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB1cCBhIGJveCBjb2xsaXNpb24gYXJlYSBiYXNlZCBvbiB0aGUgY3VycmVudCBib3VuZHMgb2YgdGhlIGFzc29jaWF0ZWQgYWN0b3Igb2YgdGhpcyBwaHlzaWNzIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYm94IGlzIGNlbnRlciBpcyBhdCAoMCwgMCkgd2hpY2ggbWVhbnMgaXQgaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhY3RvcnMgYW5jaG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnVzZUJveENvbGxpc2lvbiA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNlbnRlciA9PT0gdm9pZCAwKSB7IGNlbnRlciA9IEFsZ2VicmFfOS5WZWN0b3IuWmVyby5jbG9uZSgpOyB9XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQXJlYSA9IG5ldyBQb2x5Z29uQXJlYV81LlBvbHlnb25BcmVhKHtcclxuICAgICAgICAgICAgICAgIGJvZHk6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IHRoaXMuYWN0b3IuZ2V0UmVsYXRpdmVCb3VuZHMoKS5nZXRQb2ludHMoKSxcclxuICAgICAgICAgICAgICAgIHBvczogY2VudGVyIC8vIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGFjdG9yXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGEgbmFuIG1vaSwgY29hbGVzY2UgdG8gYSBzYWZlIGRlZmF1bHRcclxuICAgICAgICAgICAgdGhpcy5tb2kgPSB0aGlzLmNvbGxpc2lvbkFyZWEuZ2V0TW9tZW50T2ZJbmVydGlhKCkgfHwgdGhpcy5tb2k7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHVwIGEgcG9seWdvbiBjb2xsaXNpb24gYXJlYSBiYXNlZCBvbiBhIGxpc3Qgb2Ygb2YgcG9pbnRzIHJlbGF0aXZlIHRvIHRoZSBhbmNob3Igb2YgdGhlIGFzc29jaWF0ZWQgYWN0b3Igb2YgdGhpcyBwaHlzaWNzIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBPbmx5IFtjb252ZXggcG9seWdvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udmV4X3BvbHlnb24pIGRlZmluaXRpb25zIGFyZSBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYm94IGlzIGNlbnRlciBpcyBhdCAoMCwgMCkgd2hpY2ggbWVhbnMgaXQgaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhY3RvcnMgYW5jaG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnVzZVBvbHlnb25Db2xsaXNpb24gPSBmdW5jdGlvbiAocG9pbnRzLCBjZW50ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNlbnRlciA9PT0gdm9pZCAwKSB7IGNlbnRlciA9IEFsZ2VicmFfOS5WZWN0b3IuWmVyby5jbG9uZSgpOyB9XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQXJlYSA9IG5ldyBQb2x5Z29uQXJlYV81LlBvbHlnb25BcmVhKHtcclxuICAgICAgICAgICAgICAgIGJvZHk6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgICAgIHBvczogY2VudGVyIC8vIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGFjdG9yXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGEgbmFuIG1vaSwgY29sbGVzY2UgdG8gYSBzYWZlIGRlZmF1bHRcclxuICAgICAgICAgICAgdGhpcy5tb2kgPSB0aGlzLmNvbGxpc2lvbkFyZWEuZ2V0TW9tZW50T2ZJbmVydGlhKCkgfHwgdGhpcy5tb2k7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHVwIGEgW1tDaXJjbGVBcmVhfGNpcmNsZSBjb2xsaXNpb24gYXJlYV1dIHdpdGggYSBzcGVjaWZpZWQgcmFkaXVzIGluIHBpeGVscy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUudXNlQ2lyY2xlQ29sbGlzaW9uID0gZnVuY3Rpb24gKHJhZGl1cywgY2VudGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChjZW50ZXIgPT09IHZvaWQgMCkgeyBjZW50ZXIgPSBBbGdlYnJhXzkuVmVjdG9yLlplcm8uY2xvbmUoKTsgfVxyXG4gICAgICAgICAgICBpZiAoIXJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gdGhpcy5hY3Rvci5nZXRXaWR0aCgpIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkFyZWEgPSBuZXcgQ2lyY2xlQXJlYV8zLkNpcmNsZUFyZWEoe1xyXG4gICAgICAgICAgICAgICAgYm9keTogdGhpcyxcclxuICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBjZW50ZXJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubW9pID0gdGhpcy5jb2xsaXNpb25BcmVhLmdldE1vbWVudE9mSW5lcnRpYSgpIHx8IHRoaXMubW9pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB1cCBhbiBbW0VkZ2VBcmVhfGVkZ2UgY29sbGlzaW9uXV0gd2l0aCBhIHN0YXJ0IHBvaW50IGFuZCBhbiBlbmQgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGFuY2hvciBvZiB0aGUgYXNzb2NpYXRlZCBhY3RvclxyXG4gICAgICAgICAqIG9mIHRoaXMgcGh5c2ljcyBib2R5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGJveCBpcyBjZW50ZXIgaXMgYXQgKDAsIDApIHdoaWNoIG1lYW5zIGl0IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYWN0b3JzIGFuY2hvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS51c2VFZGdlQ29sbGlzaW9uID0gZnVuY3Rpb24gKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25BcmVhID0gbmV3IEVkZ2VBcmVhXzMuRWRnZUFyZWEoe1xyXG4gICAgICAgICAgICAgICAgYmVnaW46IGJlZ2luLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBlbmQsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm1vaSA9IHRoaXMuY29sbGlzaW9uQXJlYS5nZXRNb21lbnRPZkluZXJ0aWEoKSB8fCB0aGlzLm1vaTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAvLyBEcmF3IG1vdGlvbiB2ZWN0b3JzXHJcbiAgICAgICAgICAgIGlmIChQaHlzaWNzXzUuUGh5c2ljcy5zaG93TW90aW9uVmVjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgRHJhd1V0aWwudmVjdG9yKGN0eCwgQ29sb3JfNi5Db2xvci5ZZWxsb3csIHRoaXMucG9zLCAodGhpcy5hY2MuYWRkKFBoeXNpY3NfNS5QaHlzaWNzLmFjYykpKTtcclxuICAgICAgICAgICAgICAgIERyYXdVdGlsLnZlY3RvcihjdHgsIENvbG9yXzYuQ29sb3IuUmVkLCB0aGlzLnBvcywgKHRoaXMudmVsKSk7XHJcbiAgICAgICAgICAgICAgICBEcmF3VXRpbC5wb2ludChjdHgsIENvbG9yXzYuQ29sb3IuUmVkLCB0aGlzLnBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfNS5QaHlzaWNzLnNob3dCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Qm91bmRzKCkuZGVidWdEcmF3KGN0eCwgQ29sb3JfNi5Db2xvci5ZZWxsb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChQaHlzaWNzXzUuUGh5c2ljcy5zaG93QXJlYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25BcmVhLmRlYnVnRHJhdyhjdHgsIENvbG9yXzYuQ29sb3IuR3JlZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBib2R5IGNvbGxpZGVkIHdpdGhcclxuICAgICAgICAgKiBvciB3YXMgaW4gc3RhdGlvbmFyeSBjb250YWN0IHdpdGhcclxuICAgICAgICAgKiB0aGUgYm9keSBvZiB0aGUgb3RoZXIgW1tBY3Rvcl1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUudG91Y2hpbmcgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgdmFyIHBhaXIgPSBuZXcgUGFpcl8xLlBhaXIodGhpcywgb3RoZXIuYm9keSk7XHJcbiAgICAgICAgICAgIHBhaXIuY29sbGlkZSgpO1xyXG4gICAgICAgICAgICBpZiAocGFpci5jb2xsaXNpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgdHJ1ZSBpZiB0aGlzIGJvZHkgQ09MTElERUQgd2l0aFxyXG4gICAgICAgICAqIHRoZSBib2R5IG9mIHRoZSBvdGhlciBBY3RvciBpbiB0aGUgbGFzdCBmcmFtZSwgYW5kIHRoZXkgYXJlIG5vIGxvbmdlciB0b3VjaGluZ1xyXG4gICAgICAgICAqIGluIHRoaXMgZnJhbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS53YXNUb3VjaGluZyA9IGZ1bmN0aW9uIChvdGhlciwgZ2FtZSkge1xyXG4gICAgICAgICAgICB2YXIgcGFpciA9IG5ldyBQYWlyXzEuUGFpcih0aGlzLCBvdGhlci5ib2R5KTtcclxuICAgICAgICAgICAgdmFyIHdhc1RvdWNoaW5nTGFzdEZyYW1lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChnYW1lICYmIGdhbWUuc3RhdHMucHJldkZyYW1lICYmIGdhbWUuc3RhdHMucHJldkZyYW1lLnBoeXNpY3MuY29sbGlkZXJzSGFzaFtwYWlyLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgd2FzVG91Y2hpbmdMYXN0RnJhbWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50bHlUb3VjaGluZyA9IHRoaXMudG91Y2hpbmcob3RoZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gd2FzVG91Y2hpbmdMYXN0RnJhbWUgJiYgIWN1cnJlbnRseVRvdWNoaW5nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEJvZHk7XHJcbiAgICB9KCkpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGVjb3JhdG9yc18xLm9ic29sZXRlKHsgbWVzc2FnZTogJ3dpbGwgYmUgcmVtb3ZlZCBpbiB2MC4xNSwgdXNlIHRoZSBjb2xsaXNpb25lbmQgZXZlbnQgaW5zdGVhZCcgfSlcclxuICAgIF0sIEJvZHkucHJvdG90eXBlLCBcIndhc1RvdWNoaW5nXCIsIG51bGwpO1xyXG4gICAgZXhwb3J0cy5Cb2R5ID0gQm9keTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9QYWlyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJBY3RvclwiLCBcIlV0aWwvRHJhd1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzYsIENvbG9yXzcsIEFjdG9yXzIsIERyYXdVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogTW9kZWxzIGEgcG90ZW50aWFsIGNvbGxpc2lvbiBiZXR3ZWVuIDIgYm9kaWVzXHJcbiAgICAgKi9cclxuICAgIHZhciBQYWlyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQYWlyKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgICAgICB0aGlzLmJvZHlBID0gYm9keUE7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IFBhaXIuY2FsY3VsYXRlUGFpckhhc2goYm9keUEsIGJvZHlCKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhaXIucHJvdG90eXBlLCBcImNhbkNvbGxpZGVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhaXJzIHRvIGNvbGxpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdG9yQSA9IHRoaXMuYm9keUEuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0b3JCID0gdGhpcy5ib2R5Qi5hY3RvcjtcclxuICAgICAgICAgICAgICAgIC8vIGlmIGJvdGggYXJlIGZpeGVkIHNob3J0IGNpcmN1aXRcclxuICAgICAgICAgICAgICAgIGlmIChhY3RvckEuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMi5Db2xsaXNpb25UeXBlLkZpeGVkICYmIGFjdG9yQi5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8yLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgb3RoZXIgaXMgcHJldmVudCBjb2xsaXNpb24gb3IgaXMgZGVhZCBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3JCLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzIuQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uIHx8IGFjdG9yQi5pc0tpbGxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJ1bnMgdGhlIGNvbGxpc29uIGludGVyc2VjdGlvbiBsb2dpYyBvbiB0aGUgbWVtYmVycyBvZiB0aGlzIHBhaXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYWlyLnByb3RvdHlwZS5jb2xsaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbiA9IHRoaXMuYm9keUEuY29sbGlzaW9uQXJlYS5jb2xsaWRlKHRoaXMuYm9keUIuY29sbGlzaW9uQXJlYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvdmxlcyB0aGUgY29sbGlzaW9uIGJvZHkgcG9zaXRpb24gYW5kIHZlbG9jaXR5IGlmIGEgY29sbGlzaW9uIG9jY3VyZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYWlyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbGxpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb24ucmVzb2x2ZShzdHJhdGVneSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHVuaXF1ZSBwYWlyIGhhc2ggaWQgZm9yIHRoaXMgY29sbGlzaW9uIHBhaXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYWlyLmNhbGN1bGF0ZVBhaXJIYXNoID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgICAgICBpZiAoYm9keUEuYWN0b3IuaWQgPCBib2R5Qi5hY3Rvci5pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgYm9keUEuYWN0b3IuaWQgKyBcIitcIiArIGJvZHlCLmFjdG9yLmlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgYm9keUIuYWN0b3IuaWQgKyBcIitcIiArIGJvZHlBLmFjdG9yLmlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIFBhaXIucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc182LlBoeXNpY3Muc2hvd0NvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRHJhd1V0aWwucG9pbnQoY3R4LCBDb2xvcl83LkNvbG9yLlJlZCwgdGhpcy5jb2xsaXNpb24ucG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfNi5QaHlzaWNzLnNob3dDb2xsaXNpb25Ob3JtYWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRHJhd1V0aWwudmVjdG9yKGN0eCwgQ29sb3JfNy5Db2xvci5DeWFuLCB0aGlzLmNvbGxpc2lvbi5wb2ludCwgdGhpcy5jb2xsaXNpb24ubm9ybWFsLCAzMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQYWlyO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUGFpciA9IFBhaXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJEZWJ1Z1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWJ1ZyBzdGF0aXN0aWNzIGFuZCBmbGFncyBmb3IgRXhjYWxpYnVyLiBJZiBwb2xsaW5nIHRoZXNlIHZhbHVlcywgaXQgd291bGQgYmVcclxuICAgICAqIGJlc3QgdG8gZG8gc28gb24gdGhlIGBwb3N0dXBkYXRlYCBldmVudCBmb3IgW1tFbmdpbmVdXSwgYWZ0ZXIgYWxsIHZhbHVlcyBoYXZlIGJlZW5cclxuICAgICAqIHVwZGF0ZWQgZHVyaW5nIGEgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIHZhciBEZWJ1ZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRGVidWcoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQZXJmb3JtYW5jZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRzID0ge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDdXJyZW50IGZyYW1lIHN0YXRpc3RpY3MuIEVuZ2luZSByZXVzZXMgdGhpcyBpbnN0YW5jZSwgdXNlIFtbRnJhbWVTdGF0cy5jbG9uZV1dIHRvIGNvcHkgZnJhbWUgc3RhdHMuXHJcbiAgICAgICAgICAgICAgICAgKiBCZXN0IGFjY2Vzc2VkIG9uIFtbcG9zdGZyYW1lXV0gZXZlbnQuIFNlZSBbW0lGcmFtZVN0YXRzXV1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY3VyckZyYW1lOiBuZXcgRnJhbWVTdGF0cygpLFxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBQcmV2aW91cyBmcmFtZSBzdGF0aXN0aWNzLiBFbmdpbmUgcmV1c2VzIHRoaXMgaW5zdGFuY2UsIHVzZSBbW0ZyYW1lU3RhdHMuY2xvbmVdXSB0byBjb3B5IGZyYW1lIHN0YXRzLlxyXG4gICAgICAgICAgICAgICAgICogQmVzdCBhY2Nlc3NlZCBvbiBbW3ByZWZyYW1lXV0gZXZlbnQuIEJlc3QgaW5zcGVjdGVkIG9uIGVuZ2luZSBldmVudCBgcHJlZnJhbWVgLiBTZWUgW1tJRnJhbWVTdGF0c11dXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHByZXZGcmFtZTogbmV3IEZyYW1lU3RhdHMoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRGVidWc7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5EZWJ1ZyA9IERlYnVnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBhIGZyYW1lJ3Mgc3RhdHMuIE1lYW50IHRvIGhhdmUgdmFsdWVzIGNvcGllZCB2aWEgW1tGcmFtZVN0YXRzLnJlc2V0XV0sIGF2b2lkXHJcbiAgICAgKiBjcmVhdGluZyBpbnN0YW5jZXMgb2YgdGhpcyBldmVyeSBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgdmFyIEZyYW1lU3RhdHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEZyYW1lU3RhdHMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lkID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fZGVsdGEgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9mcHMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvclN0YXRzID0ge1xyXG4gICAgICAgICAgICAgICAgYWxpdmU6IDAsXHJcbiAgICAgICAgICAgICAgICBraWxsZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICB1aTogMCxcclxuICAgICAgICAgICAgICAgIGdldCByZW1haW5pbmcoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpdmUgLSB0aGlzLmtpbGxlZDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnZXQgdG90YWwoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nICsgdGhpcy51aTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25TdGF0cyA9IHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZTogMCxcclxuICAgICAgICAgICAgICAgIGRyYXc6IDAsXHJcbiAgICAgICAgICAgICAgICBnZXQgdG90YWwoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlICsgdGhpcy5kcmF3O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9waHlzaWNzU3RhdHMgPSBuZXcgUGh5c2ljc1N0YXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFplcm8gb3V0IHZhbHVlcyBvciBjbG9uZSBvdGhlciBJRnJhbWVTdGF0IHN0YXRzLiBBbGxvd3MgaW5zdGFuY2UgcmV1c2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gW290aGVyU3RhdHNdIE9wdGlvbmFsIHN0YXRzIHRvIGNsb25lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRnJhbWVTdGF0cy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAob3RoZXJTdGF0cykge1xyXG4gICAgICAgICAgICBpZiAob3RoZXJTdGF0cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IG90aGVyU3RhdHMuaWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbHRhID0gb3RoZXJTdGF0cy5kZWx0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnBzID0gb3RoZXJTdGF0cy5mcHM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9ycy5hbGl2ZSA9IG90aGVyU3RhdHMuYWN0b3JzLmFsaXZlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RvcnMua2lsbGVkID0gb3RoZXJTdGF0cy5hY3RvcnMua2lsbGVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RvcnMudWkgPSBvdGhlclN0YXRzLmFjdG9ycy51aTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24udXBkYXRlID0gb3RoZXJTdGF0cy5kdXJhdGlvbi51cGRhdGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uLmRyYXcgPSBvdGhlclN0YXRzLmR1cmF0aW9uLmRyYXc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9waHlzaWNzU3RhdHMucmVzZXQob3RoZXJTdGF0cy5waHlzaWNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLmRlbHRhID0gdGhpcy5mcHMgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RvcnMuYWxpdmUgPSB0aGlzLmFjdG9ycy5raWxsZWQgPSB0aGlzLmFjdG9ycy51aSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uLnVwZGF0ZSA9IHRoaXMuZHVyYXRpb24uZHJhdyA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9waHlzaWNzU3RhdHMucmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvdmlkZXMgYSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZyYW1lU3RhdHMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZnMgPSBuZXcgRnJhbWVTdGF0cygpO1xyXG4gICAgICAgICAgICBmcy5yZXNldCh0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYW1lU3RhdHMucHJvdG90eXBlLCBcImlkXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgaWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgZnJhbWUncyBpZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFtZVN0YXRzLnByb3RvdHlwZSwgXCJkZWx0YVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGRlbHRhICh0aW1lIHNpbmNlIGxhc3QgZnJhbWUpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWx0YTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGZyYW1lJ3MgZGVsdGEgKHRpbWUgc2luY2UgbGFzdCBmcmFtZSkuIEludGVybmFsIHVzZSBvbmx5LlxyXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWx0YSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhbWVTdGF0cy5wcm90b3R5cGUsIFwiZnBzXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgZnJhbWVzLXBlci1zZWNvbmQgKEZQUylcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZwcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGZyYW1lJ3MgZnJhbWVzLXBlci1zZWNvbmQgKEZQUykuIEludGVybmFsIHVzZSBvbmx5LlxyXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcHMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYW1lU3RhdHMucHJvdG90eXBlLCBcImFjdG9yc1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGFjdG9yIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdG9yU3RhdHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFtZVN0YXRzLnByb3RvdHlwZSwgXCJkdXJhdGlvblwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGR1cmF0aW9uIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uU3RhdHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFtZVN0YXRzLnByb3RvdHlwZSwgXCJwaHlzaWNzXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgcGh5c2ljcyBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9waHlzaWNzU3RhdHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBGcmFtZVN0YXRzO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRnJhbWVTdGF0cyA9IEZyYW1lU3RhdHM7XHJcbiAgICB2YXIgUGh5c2ljc1N0YXRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQaHlzaWNzU3RhdHMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhaXJzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9ucyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyc0hhc2ggPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5fZmFzdEJvZGllcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCb2R5Q29sbGlzaW9ucyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2Jyb2FkcGhhc2UgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9uYXJyb3dwaGFzZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFplcm8gb3V0IHZhbHVlcyBvciBjbG9uZSBvdGhlciBJUGh5c2ljc1N0YXRzIHN0YXRzLiBBbGxvd3MgaW5zdGFuY2UgcmV1c2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gW290aGVyU3RhdHNdIE9wdGlvbmFsIHN0YXRzIHRvIGNsb25lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGh5c2ljc1N0YXRzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhaXJzID0gb3RoZXJTdGF0cy5wYWlycztcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9ucyA9IG90aGVyU3RhdHMuY29sbGlzaW9ucztcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlkZXJzSGFzaCA9IG90aGVyU3RhdHMuY29sbGlkZXJzSGFzaDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFzdEJvZGllcyA9IG90aGVyU3RhdHMuZmFzdEJvZGllcztcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFzdEJvZHlDb2xsaXNpb25zID0gb3RoZXJTdGF0cy5mYXN0Qm9keUNvbGxpc2lvbnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkcGhhc2UgPSBvdGhlclN0YXRzLmJyb2FkcGhhc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hcnJvd3BoYXNlID0gb3RoZXJTdGF0cy5uYXJyb3dwaGFzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFpcnMgPSB0aGlzLmNvbGxpc2lvbnMgPSB0aGlzLmZhc3RCb2RpZXMgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYXN0Qm9keUNvbGxpc2lvbnMgPSB0aGlzLmJyb2FkcGhhc2UgPSB0aGlzLm5hcnJvd3BoYXNlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlkZXJzSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm92aWRlcyBhIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGh5c2ljc1N0YXRzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBzID0gbmV3IFBoeXNpY3NTdGF0cygpO1xyXG4gICAgICAgICAgICBwcy5yZXNldCh0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBoeXNpY3NTdGF0cy5wcm90b3R5cGUsIFwicGFpcnNcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYWlycztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaXJzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaHlzaWNzU3RhdHMucHJvdG90eXBlLCBcImNvbGxpc2lvbnNcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsaXNpb25zO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9ucyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGh5c2ljc1N0YXRzLnByb3RvdHlwZSwgXCJjb2xsaWRlcnNIYXNoXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlkZXJzSGFzaDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaWRlcnNIYXNoID0gY29sbGlkZXJzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGh5c2ljc1N0YXRzLnByb3RvdHlwZSwgXCJmYXN0Qm9kaWVzXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJvZGllcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCb2RpZXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBoeXNpY3NTdGF0cy5wcm90b3R5cGUsIFwiZmFzdEJvZHlDb2xsaXNpb25zXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJvZHlDb2xsaXNpb25zO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJvZHlDb2xsaXNpb25zID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaHlzaWNzU3RhdHMucHJvdG90eXBlLCBcImJyb2FkcGhhc2VcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9icm9hZHBoYXNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGh5c2ljc1N0YXRzLnByb3RvdHlwZSwgXCJuYXJyb3dwaGFzZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hcnJvd3BoYXNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmFycm93cGhhc2UgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBoeXNpY3NTdGF0cztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlBoeXNpY3NTdGF0cyA9IFBoeXNpY3NTdGF0cztcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSUV2ZW50ZWRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkV2ZW50RGlzcGF0Y2hlclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEV2ZW50c18yKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRXhjYWxpYnVyJ3MgaW50ZXJuYWwgZXZlbnQgZGlzcGF0Y2hlciBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIENhbGxiYWNrcyBhcmUgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW4gZXZlbnQgaXMgcHVibGlzaGVkLlxyXG4gICAgICogVHlwaWNhbGx5IHlvdSB3aWxsIHVzZSBbW0NsYXNzLmV2ZW50RGlzcGF0Y2hlcl1dIHNpbmNlIG1vc3QgY2xhc3NlcyBpblxyXG4gICAgICogRXhjYWxpYnVyIGluaGVyaXQgZnJvbSBbW0NsYXNzXV0uIFlvdSB3aWxsIHJhcmVseSBjcmVhdGUgYW4gYEV2ZW50RGlzcGF0Y2hlcmBcclxuICAgICAqIHlvdXJzZWxmLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpFdmVudHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgRXZlbnREaXNwYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0ICBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGUgcmVjaXBpZW50IG9mIGV2ZW50cyBmcm9tIHRoaXMgZXZlbnQgZGlzcGF0Y2hlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcih0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5fd2lyZWRFdmVudERpc3BhdGNoZXJzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW1pdHMgYW4gZXZlbnQgZm9yIHRhcmdldFxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBwdWJsaXNoXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50ICAgICAgT3B0aW9uYWxseSBwYXNzIGFuIGV2ZW50IGRhdGEgb2JqZWN0IHRvIHRoZSBoYW5kbGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGtleSBub3QgbWFwcGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQ7XHJcbiAgICAgICAgICAgIGlmICghZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50c18yLkdhbWVFdmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgdmFyIGksIGxlbjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1baV0uY2FsbCh0YXJnZXQsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgbGVuID0gdGhpcy5fd2lyZWRFdmVudERpc3BhdGNoZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dpcmVkRXZlbnREaXNwYXRjaGVyc1tpXS5lbWl0KGV2ZW50TmFtZSwgZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlciB0byBhIHBhcnRpY3VsYXIgZXZlbnQgbmFtZSwgbXVsdGlwbGUgaGFuZGxlcnMgcGVyIGV2ZW50IG5hbWUgYXJlIGFsbG93ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyICAgIFRoZSBoYW5kbGVyIGNhbGxiYWNrIHRvIGZpcmUgb24gdGhpcyBldmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgICAgIC8vIG1ldGEgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gJ3Vuc3Vic2NyaWJlJyAmJiBldmVudE5hbWUgIT09ICdzdWJzY3JpYmUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N1YnNjcmliZScsIG5ldyBFdmVudHNfMi5TdWJzY3JpYmVFdmVudChldmVudE5hbWUsIGhhbmRsZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5zdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlcihzKSBmcm9tIGFuIGV2ZW50LiBJZiBhIHNwZWNpZmljIGhhbmRsZXJcclxuICAgICAgICAgKiBpcyBzcGVjaWZpZWQgZm9yIGFuIGV2ZW50LCBvbmx5IHRoYXQgaGFuZGxlciB3aWxsIGJlIHVuc3Vic2NyaWJlZC5cclxuICAgICAgICAgKiBPdGhlcndpc2UgYWxsIGhhbmRsZXJzIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGZvciB0aGF0IGV2ZW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHVuc3Vic2NyaWJlXHJcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgICAgT3B0aW9uYWxseSB0aGUgc3BlY2lmaWMgaGFuZGxlciB0byB1bnN1YnNjcmliZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV07XHJcbiAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBleHBsaWNpdCBoYW5kbGVyIGlzIGdpdmUgd2l0aCB0aGUgZXZlbnQgbmFtZSBjbGVhciBhbGwgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGV2ZW50SGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbWV0YSBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lICE9PSAndW5zdWJzY3JpYmUnICYmIGV2ZW50TmFtZSAhPT0gJ3N1YnNjcmliZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndW5zdWJzY3JpYmUnLCBuZXcgRXZlbnRzXzIuVW5zdWJzY3JpYmVFdmVudChldmVudE5hbWUsIGhhbmRsZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT25jZSBsaXN0ZW5zIHRvIGFuIGV2ZW50IG9uZSB0aW1lLCB0aGVuIHVuc3Vic2NyaWJlcyBmcm9tIHRoYXQgZXZlbnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0byBvbmNlXHJcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgICBUaGUgaGFuZGxlciBvZiB0aGUgZXZlbnQgdGhhdCB3aWxsIGJlIGF1dG8gdW5zdWJzY3JpYmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgbWV0YUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldiA9IGV2ZW50IHx8IG5ldyBFdmVudHNfMi5HYW1lRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIGV2LnRhcmdldCA9IGV2LnRhcmdldCB8fCBfdGhpcy5fdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwoZXYudGFyZ2V0LCBldik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMub24oZXZlbnROYW1lLCBtZXRhSGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaXJlcyB0aGlzIGV2ZW50IGRpc3BhdGNoZXIgdG8gYWxzbyByZWNpZXZlIGV2ZW50cyBmcm9tIGFub3RoZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLndpcmUgPSBmdW5jdGlvbiAoZXZlbnREaXNwYXRjaGVyKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5fd2lyZWRFdmVudERpc3BhdGNoZXJzLnB1c2godGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbndpcmVzIHRoaXMgZXZlbnQgZGlzcGF0Y2hlciBmcm9tIGFub3RoZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnVud2lyZSA9IGZ1bmN0aW9uIChldmVudERpc3BhdGNoZXIpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZXZlbnREaXNwYXRjaGVyLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnMuaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5fd2lyZWRFdmVudERpc3BhdGNoZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFdmVudERpc3BhdGNoZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJBY3Rpb25zL0FjdGlvbkNvbnRleHRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBY3Rpb25zL0FjdGlvblwiLCBcIlByb21pc2VzXCIsIFwiVXRpbC9FYXNpbmdGdW5jdGlvbnNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBY3Rpb25zLCBQcm9taXNlc18yLCBFYXNpbmdGdW5jdGlvbnNfMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbHVlbnQgQWN0aW9uIEFQSSBhbGxvd3MgeW91IHRvIHBlcmZvcm0gXCJhY3Rpb25zXCIgb25cclxuICAgICAqIFtbQWN0b3J8QWN0b3JzXV0gc3VjaCBhcyBmb2xsb3dpbmcsIG1vdmluZywgcm90YXRpbmcsIGFuZFxyXG4gICAgICogbW9yZS4gWW91IGNhbiBpbXBsZW1lbnQgeW91ciBvd24gYWN0aW9ucyBieSBpbXBsZW1lbnRpbmdcclxuICAgICAqIHRoZSBbW0lBY3Rpb25dXSBpbnRlcmZhY2UuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkFjdGlvbnMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgQWN0aW9uQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQWN0aW9uQ29udGV4dCgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RvcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzID0gdGhpcy5fYWN0b3JzLm1hcChmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmFjdGlvblF1ZXVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIGFsbCBxdWV1ZWQgYWN0aW9ucyBmcm9tIHRoZSBBY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmNsZWFyQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmNsZWFyQWN0aW9ucygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5hZGRBY3RvclRvQ29udGV4dCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvcnMucHVzaChhY3Rvcik7XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIHJ1biBpbnRvIHByb2JsZW1zIHJlcGxhY2UgdGhlIGxpbmUgYmVsb3cgd2l0aDpcclxuICAgICAgICAgICAgdGhpcy5fcXVldWVzLnB1c2goYWN0b3IuYWN0aW9uUXVldWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlQWN0b3JGcm9tQ29udGV4dCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9hY3RvcnMuaW5kZXhPZihhY3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1vdmUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBgeGAgYW5kIGB5YCBwb3NpdGlvbiBvdmVyIHRoZVxyXG4gICAgICAgICAqIHNwZWNpZmllZCBkdXJhdGlvbiB1c2luZyBhIGdpdmVuIFtbRWFzaW5nRnVuY3Rpb25zXV0gYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xyXG4gICAgICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICAgIFRoZSB4IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgICBUaGUgeSBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xyXG4gICAgICAgICAqIEBwYXJhbSBkdXJhdGlvbiAgVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdGhlIGFjdG9yIHRvIG1vdmUgdG8gdGhlIG5ldyBsb2NhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKiBAcGFyYW0gZWFzaW5nRmNuIFVzZSBbW0Vhc2luZ0Z1bmN0aW9uc11dIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIHRvIHVzZSB0byBjYWxjdWxhdGUgcG9zaXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5lYXNlVG8gPSBmdW5jdGlvbiAoeCwgeSwgZHVyYXRpb24sIGVhc2luZ0Zjbikge1xyXG4gICAgICAgICAgICBpZiAoZWFzaW5nRmNuID09PSB2b2lkIDApIHsgZWFzaW5nRmNuID0gRWFzaW5nRnVuY3Rpb25zXzIuRWFzaW5nRnVuY3Rpb25zLkxpbmVhcjsgfVxyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLkVhc2VUbyh0aGlzLl9hY3RvcnNbaV0sIHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbW92ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHggYW5kIHkgcG9zaXRpb24gYXQgdGhlXHJcbiAgICAgICAgICogc3BlZWQgc3BlY2lmaWVkIChpbiBwaXhlbHMgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xyXG4gICAgICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgIFRoZSB4IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICBUaGUgeSBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCAgVGhlIHNwZWVkIGluIHBpeGVscyBwZXIgc2Vjb25kIHRvIG1vdmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5Nb3ZlVG8odGhpcy5fYWN0b3JzW2ldLCB4LCB5LCBzcGVlZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBtb3ZlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBieSBhXHJcbiAgICAgICAgICogY2VydGFpbiB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICBUaGUgeCBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICBUaGUgeSBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lICBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0aGUgYWN0b3IgdG8gbW92ZSB0byB0aGUgbmV3IGxvY2F0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLm1vdmVCeSA9IGZ1bmN0aW9uICh4LCB5LCB0aW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuTW92ZUJ5KHRoaXMuX2FjdG9yc1tpXSwgeCwgeSwgdGltZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCByb3RhdGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBhbmdsZSBhdCB0aGUgc3BlZWRcclxuICAgICAgICAgKiBzcGVjaWZpZWQgKGluIHJhZGlhbnMgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xyXG4gICAgICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zICBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnNcclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQgICAgICAgICBUaGUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgcm90YXRpb24gc3BlY2lmaWVkIGluIHJhZGlhbnMgcGVyIHNlY29uZFxyXG4gICAgICAgICAqIEBwYXJhbSByb3RhdGlvblR5cGUgIFRoZSBbW1JvdGF0aW9uVHlwZV1dIHRvIHVzZSBmb3IgdGhpcyByb3RhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLnJvdGF0ZVRvID0gZnVuY3Rpb24gKGFuZ2xlUmFkaWFucywgc3BlZWQsIHJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLlJvdGF0ZVRvKHRoaXMuX2FjdG9yc1tpXSwgYW5nbGVSYWRpYW5zLCBzcGVlZCwgcm90YXRpb25UeXBlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGJ5IGEgY2VydGFpblxyXG4gICAgICAgICAqIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpcyBtZXRob2QgaXMgcGFydFxyXG4gICAgICAgICAqIG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zICBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnNcclxuICAgICAgICAgKiBAcGFyYW0gdGltZSAgICAgICAgICBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0aGUgYWN0b3IgdG8gY29tcGxldGUgdGhlIHJvdGF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqIEBwYXJhbSByb3RhdGlvblR5cGUgIFRoZSBbW1JvdGF0aW9uVHlwZV1dIHRvIHVzZSBmb3IgdGhpcyByb3RhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLnJvdGF0ZUJ5ID0gZnVuY3Rpb24gKGFuZ2xlUmFkaWFucywgdGltZSwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuUm90YXRlQnkodGhpcy5fYWN0b3JzW2ldLCBhbmdsZVJhZGlhbnMsIHRpbWUsIHJvdGF0aW9uVHlwZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBzY2FsZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHNpemUgYXQgdGhlIHNwZWVkXHJcbiAgICAgICAgICogc3BlY2lmaWVkIChpbiBtYWduaXR1ZGUgaW5jcmVhc2UgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZVxyXG4gICAgICAgICAqIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nXHJcbiAgICAgICAgICogYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBzaXplWCAgIFRoZSBzY2FsaW5nIGZhY3RvciB0byBhcHBseSBvbiBYIGF4aXNcclxuICAgICAgICAgKiBAcGFyYW0gc2l6ZVkgICBUaGUgc2NhbGluZyBmYWN0b3IgdG8gYXBwbHkgb24gWSBheGlzXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkWCAgVGhlIHNwZWVkIG9mIHNjYWxpbmcgc3BlY2lmaWVkIGluIG1hZ25pdHVkZSBpbmNyZWFzZSBwZXIgc2Vjb25kIG9uIFggYXhpc1xyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZFkgIFRoZSBzcGVlZCBvZiBzY2FsaW5nIHNwZWNpZmllZCBpbiBtYWduaXR1ZGUgaW5jcmVhc2UgcGVyIHNlY29uZCBvbiBZIGF4aXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5zY2FsZVRvID0gZnVuY3Rpb24gKHNpemVYLCBzaXplWSwgc3BlZWRYLCBzcGVlZFkpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5TY2FsZVRvKHRoaXMuX2FjdG9yc1tpXSwgc2l6ZVgsIHNpemVZLCBzcGVlZFgsIHNwZWVkWSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBzY2FsZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHNpemUgYnkgYSBjZXJ0YWluIHRpbWVcclxuICAgICAgICAgKiAoaW4gbWlsbGlzZWNvbmRzKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZVxyXG4gICAgICAgICAqIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBzaXplWCAgIFRoZSBzY2FsaW5nIGZhY3RvciB0byBhcHBseSBvbiBYIGF4aXNcclxuICAgICAgICAgKiBAcGFyYW0gc2l6ZVkgICBUaGUgc2NhbGluZyBmYWN0b3IgdG8gYXBwbHkgb24gWSBheGlzXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWUgICAgVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gY29tcGxldGUgdGhlIHNjYWxpbmcgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuc2NhbGVCeSA9IGZ1bmN0aW9uIChzaXplWCwgc2l6ZVksIHRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5TY2FsZUJ5KHRoaXMuX2FjdG9yc1tpXSwgc2l6ZVgsIHNpemVZLCB0aW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yIHRvIGJsaW5rIChiZWNvbWUgdmlzaWJsZSBhbmQgbm90XHJcbiAgICAgICAgICogdmlzaWJsZSkuIE9wdGlvbmFsbHksIHlvdSBtYXkgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIGJsaW5rcy4gU3BlY2lmeSB0aGUgYW1vdW50IG9mIHRpbWVcclxuICAgICAgICAgKiB0aGUgYWN0b3Igc2hvdWxkIGJlIHZpc2libGUgcGVyIGJsaW5rLCBhbmQgdGhlIGFtb3VudCBvZiB0aW1lIG5vdCB2aXNpYmxlLlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lVmlzaWJsZSAgICAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIHN0YXkgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVOb3RWaXNpYmxlICBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc3RheSBub3QgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICogQHBhcmFtIG51bUJsaW5rcyAgICAgICBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGJsaW5rXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuYmxpbmsgPSBmdW5jdGlvbiAodGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpIHtcclxuICAgICAgICAgICAgaWYgKG51bUJsaW5rcyA9PT0gdm9pZCAwKSB7IG51bUJsaW5rcyA9IDE7IH1cclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5CbGluayh0aGlzLl9hY3RvcnNbaV0sIHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yJ3Mgb3BhY2l0eSB0byBjaGFuZ2UgZnJvbSBpdHMgY3VycmVudCB2YWx1ZVxyXG4gICAgICAgICAqIHRvIHRoZSBwcm92aWRlZCB2YWx1ZSBieSBhIHNwZWNpZmllZCB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpc1xyXG4gICAgICAgICAqIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBvcGFjaXR5ICBUaGUgZW5kaW5nIG9wYWNpdHlcclxuICAgICAgICAgKiBAcGFyYW0gdGltZSAgICAgVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gZmFkZSB0aGUgYWN0b3IgKGluIG1pbGxpc2Vjb25kcylcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5mYWRlID0gZnVuY3Rpb24gKG9wYWNpdHksIHRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5GYWRlKHRoaXMuX2FjdG9yc1tpXSwgb3BhY2l0eSwgdGltZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBkZWxheSB0aGUgbmV4dCBhY3Rpb24gZnJvbSBleGVjdXRpbmcgZm9yIGEgY2VydGFpblxyXG4gICAgICAgICAqIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lICBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIG5leHQgYWN0aW9uIGluIHRoZSBxdWV1ZSBmcm9tIGV4ZWN1dGluZyBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuRGVsYXkodGhpcy5fYWN0b3JzW2ldLCB0aW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBhbiBhY3Rpb24gdG8gdGhlIHF1ZXVlIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFjdG9yIGZyb20gdGhlXHJcbiAgICAgICAgICogc2NlbmUgb25jZSBpdCBoYXMgY29tcGxldGVkIGl0cyBwcmV2aW91cyBhY3Rpb25zLiBBbnkgYWN0aW9ucyBvbiB0aGVcclxuICAgICAgICAgKiBhY3Rpb24gcXVldWUgYWZ0ZXIgdGhpcyBhY3Rpb24gd2lsbCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuZGllID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLkRpZSh0aGlzLl9hY3RvcnNbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gY2FsbCBhbiBhcmJpdHJhcnkgbWV0aG9kIGFzIHRoZSBuZXh0IGFjdGlvbiBpbiB0aGVcclxuICAgICAgICAgKiBhY3Rpb24gcXVldWUuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGV4ZWN1dGUgY29kZSBpbiBhZnRlciBhIHNwZWNpZmljXHJcbiAgICAgICAgICogYWN0aW9uLCBpLmUgQW4gYWN0b3IgYXJyaXZlcyBhdCBhIGRlc3RpbmF0aW9uIGFmdGVyIHRyYXZlcnNpbmcgYSBwYXRoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuY2FsbE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5DYWxsTWV0aG9kKHRoaXMuX2FjdG9yc1tpXSwgbWV0aG9kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byByZXBlYXQgYWxsIG9mIHRoZSBwcmV2aW91c2x5XHJcbiAgICAgICAgICogY2FsbGVkIGFjdGlvbnMgYSBjZXJ0YWluIG51bWJlciBvZiB0aW1lcy4gSWYgdGhlIG51bWJlciBvZiByZXBlYXRzXHJcbiAgICAgICAgICogaXMgbm90IHNwZWNpZmllZCBpdCB3aWxsIHJlcGVhdCBmb3JldmVyLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mXHJcbiAgICAgICAgICogdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVzICBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCBhbGwgdGhlIHByZXZpb3VzIGFjdGlvbnMgaW4gdGhlIGFjdGlvbiBxdWV1ZS4gSWYgbm90aGluZyBpcyBzcGVjaWZpZWQgdGhlIGFjdGlvbnNcclxuICAgICAgICAgKiB3aWxsIHJlcGVhdCBmb3JldmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24gKHRpbWVzKSB7XHJcbiAgICAgICAgICAgIGlmICghdGltZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0Rm9yZXZlcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5SZXBlYXQodGhpcy5fYWN0b3JzW2ldLCB0aW1lcywgdGhpcy5fYWN0b3JzW2ldLmFjdGlvblF1ZXVlLmdldEFjdGlvbnMoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gcmVwZWF0IGFsbCBvZiB0aGUgcHJldmlvdXNseVxyXG4gICAgICAgICAqIGNhbGxlZCBhY3Rpb25zIGZvcmV2ZXIuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nXHJcbiAgICAgICAgICogZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUucmVwZWF0Rm9yZXZlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5SZXBlYXRGb3JldmVyKHRoaXMuX2FjdG9yc1tpXSwgdGhpcy5fYWN0b3JzW2ldLmFjdGlvblF1ZXVlLmdldEFjdGlvbnMoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gZm9sbG93IGFub3RoZXIgYXQgYSBzcGVjaWZpZWQgZGlzdGFuY2VcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgICAgICAgICAgIFRoZSBhY3RvciB0byBmb2xsb3dcclxuICAgICAgICAgKiBAcGFyYW0gZm9sbG93RGlzdGFuY2UgIFRoZSBkaXN0YW5jZSB0byBtYWludGFpbiB3aGVuIGZvbGxvd2luZywgaWYgbm90IHNwZWNpZmllZCB0aGUgYWN0b3Igd2lsbCBmb2xsb3cgYXQgdGhlIGN1cnJlbnQgZGlzdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuZm9sbG93ID0gZnVuY3Rpb24gKGFjdG9yLCBmb2xsb3dEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9sbG93RGlzdGFuY2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuRm9sbG93KHRoaXMuX2FjdG9yc1tpXSwgYWN0b3IpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuRm9sbG93KHRoaXMuX2FjdG9yc1tpXSwgYWN0b3IsIGZvbGxvd0Rpc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byBtb3ZlIHRvd2FyZHMgYW5vdGhlciB1bnRpbCB0aGV5XHJcbiAgICAgICAgICogY29sbGlkZSBcIm1lZXRcIiBhdCBhIHNwZWNpZmllZCBzcGVlZC5cclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgIFRoZSBhY3RvciB0byBtZWV0XHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkICBUaGUgc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmQgdG8gbW92ZSwgaWYgbm90IHNwZWNpZmllZCBpdCB3aWxsIG1hdGNoIHRoZSBzcGVlZCBvZiB0aGUgb3RoZXIgYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5tZWV0ID0gZnVuY3Rpb24gKGFjdG9yLCBzcGVlZCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuTWVldCh0aGlzLl9hY3RvcnNbaV0sIGFjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLk1lZXQodGhpcy5fYWN0b3JzW2ldLCBhY3Rvciwgc3BlZWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY3VycmVudCBhY3Rpb24gcXVldWUgdXAgdG8gbm93XHJcbiAgICAgICAgICogaXMgZmluaXNoZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuYXNQcm9taXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSB0aGlzLl9xdWV1ZXMubWFwKGZ1bmN0aW9uIChxLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IG5ldyBQcm9taXNlc18yLlByb21pc2UoKTtcclxuICAgICAgICAgICAgICAgIHEuYWRkKG5ldyBBY3Rpb25zLkNhbGxNZXRob2QoX3RoaXMuX2FjdG9yc1tpXSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZXNfMi5Qcm9taXNlLmpvaW4uYXBwbHkodGhpcywgcHJvbWlzZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEFjdGlvbkNvbnRleHQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5BY3Rpb25Db250ZXh0ID0gQWN0aW9uQ29udGV4dDtcclxufSk7XHJcbmRlZmluZShcIkFjdGlvbnMvSUFjdGlvbmFibGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkdyb3VwXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWxnZWJyYVwiLCBcIkFjdGlvbnMvQWN0aW9uQ29udGV4dFwiLCBcIkFjdG9yXCIsIFwiVXRpbC9Mb2dcIiwgXCJDbGFzc1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFsZ2VicmFfMTAsIEFjdGlvbkNvbnRleHRfMSwgQWN0b3JfMywgTG9nXzIsIENsYXNzXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHcm91cHMgYXJlIHVzZWQgZm9yIGxvZ2ljYWxseSBncm91cGluZyBBY3RvcnMgc28gdGhleSBjYW4gYmUgYWN0ZWQgdXBvblxyXG4gICAgICogaW4gYnVsay5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6R3JvdXBzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIEdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR3JvdXAsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gR3JvdXAobmFtZSwgc2NlbmUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgIF90aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIgPSBMb2dfMi5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgX3RoaXMuX21lbWJlcnMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuYWN0aW9ucyA9IG5ldyBBY3Rpb25Db250ZXh0XzEuQWN0aW9uQ29udGV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoc2NlbmUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcignSW52YWxpZCBjb25zdHJ1Y3RvciBhcmd1bWVudHMgcGFzc2VkIHRvIEdyb3VwOiAnLCBuYW1lLCAnLCBzY2VuZSBtdXN0IG5vdCBiZSBudWxsIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nR3JvdXAgPSBzY2VuZS5ncm91cHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIud2FybignR3JvdXAgd2l0aCBuYW1lJywgbmFtZSwgJ2FscmVhZHkgZXhpc3RzLiBUaGlzIG5ldyBncm91cCB3aWxsIHJlcGxhY2UgaXQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzY2VuZS5ncm91cHNbbmFtZV0gPSBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYWN0b3JPckFjdG9ycykge1xyXG4gICAgICAgICAgICBpZiAoYWN0b3JPckFjdG9ycyBpbnN0YW5jZW9mIEFjdG9yXzMuQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yT3JBY3RvcnMgPSBbXS5jb25jYXQoYWN0b3JPckFjdG9ycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSBhY3Rvck9yQWN0b3JzLmxlbmd0aCwgZ3JvdXBJZHg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cElkeCA9IHRoaXMuZ2V0TWVtYmVycygpLmluZGV4T2YoYWN0b3JPckFjdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBJZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVtYmVycy5wdXNoKGFjdG9yT3JBY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuYWRkKGFjdG9yT3JBY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5hZGRBY3RvclRvQ29udGV4dChhY3Rvck9yQWN0b3JzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci53aXJlKGFjdG9yT3JBY3RvcnNbaV0uZXZlbnREaXNwYXRjaGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9tZW1iZXJzLmluZGV4T2YoYWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVtYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnJlbW92ZUFjdG9yRnJvbUNvbnRleHQoYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIudW53aXJlKGFjdG9yLmV2ZW50RGlzcGF0Y2hlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBtZW1iZXJzID0gdGhpcy5nZXRNZW1iZXJzKCksIGxlbiA9IG1lbWJlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmdzIGluc3RhbmNlb2YgQWxnZWJyYV8xMC5WZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyc1tpXS5wb3MueCArPSBhcmdzLng7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyc1tpXS5wb3MueSArPSBhcmdzLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlcnNbaV0ucG9zLnggKz0geDtcclxuICAgICAgICAgICAgICAgICAgICBtZW1iZXJzW2ldLnBvcy55ICs9IHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBncm91cCBtb3ZlJywgdGhpcy5uYW1lLCAnYXJnczonLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5nbGUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBncm91cCByb3RhdGUnLCB0aGlzLm5hbWUsICdhcmdzOicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZ2V0TWVtYmVycygpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lbWJlciA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIG1lbWJlci5yb3RhdGlvbiArPSBhbmdsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh0b3BpYywgZXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCh0b3BpYywgZXZlbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1lbWJlcnMoKS5pbmRleE9mKGFjdG9yKSA+IC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLmdldE1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZW1iZXJzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLmdldFJhbmRvbU1lbWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lbWJlcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5fbWVtYmVycy5sZW5ndGgpXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1lbWJlcnMoKS5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuZ2V0Qm91bmRzKCk7IH0pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYuY29tYmluZShjdXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gR3JvdXA7XHJcbiAgICB9KENsYXNzXzEuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuR3JvdXAgPSBHcm91cDtcclxufSk7XHJcbi8qKlxyXG4gKiBUaGVzZSBlZmZlY3RzIGNhbiBiZSBhcHBsaWVkIHRvIGFueSBiaXRtYXAgaW1hZ2UgYnV0IGFyZSBtYWlubHkgdXNlZFxyXG4gKiBmb3IgW1tTcHJpdGVdXSBlZmZlY3RzIG9yIFtbQW5pbWF0aW9uXV0gZWZmZWN0cy5cclxuICpcclxuICogW1tpbmNsdWRlOlNwcml0ZUVmZmVjdHMubWRdXVxyXG4gKi9cclxuZGVmaW5lKFwiRHJhd2luZy9TcHJpdGVFZmZlY3RzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9Db2xvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbG9yXzgpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIkdyYXlzY2FsZVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgcmVtb3ZpbmcgY29sb3IgaW5mb3JtYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHZhciBHcmF5c2NhbGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEdyYXlzY2FsZSgpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgR3JheXNjYWxlLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBhdmcgPSAocGl4ZWxbZmlyc3RQaXhlbCArIDBdICsgcGl4ZWxbZmlyc3RQaXhlbCArIDFdICsgcGl4ZWxbZmlyc3RQaXhlbCArIDJdKSAvIDM7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGF2ZztcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gYXZnO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBhdmc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gR3JheXNjYWxlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuR3JheXNjYWxlID0gR3JheXNjYWxlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIkludmVydFwiIGVmZmVjdCB0byBhIHNwcml0ZSwgaW52ZXJ0aW5nIHRoZSBwaXhlbCBjb2xvcnMuXHJcbiAgICAgKi9cclxuICAgIHZhciBJbnZlcnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEludmVydCgpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgSW52ZXJ0LnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IDI1NSAtIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXTtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gMjU1IC0gcGl4ZWxbZmlyc3RQaXhlbCArIDFdO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSAyNTUgLSBwaXhlbFtmaXJzdFBpeGVsICsgMl07XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gSW52ZXJ0O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuSW52ZXJ0ID0gSW52ZXJ0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIk9wYWNpdHlcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIHNldHRpbmcgdGhlIGFscGhhIG9mIGFsbCBwaXhlbHMgdG8gYSBnaXZlbiB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgdmFyIE9wYWNpdHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBvcGFjaXR5ICBUaGUgbmV3IG9wYWNpdHkgb2YgdGhlIHNwcml0ZSBmcm9tIDAtMS4wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gT3BhY2l0eShvcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9wYWNpdHkucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDNdID0gTWF0aC5yb3VuZCh0aGlzLm9wYWNpdHkgKiBwaXhlbFtmaXJzdFBpeGVsICsgM10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT3BhY2l0eTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLk9wYWNpdHkgPSBPcGFjaXR5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIkNvbG9yaXplXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIHRoZSBwaXhlbHMgdG8gYW5cclxuICAgICAqIGF2ZXJhZ2Ugb2YgdGhlIG9yaWdpbmFsIGNvbG9yIGFuZCB0aGUgcHJvdmlkZWQgY29sb3JcclxuICAgICAqL1xyXG4gICAgdmFyIENvbG9yaXplID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBjb2xvciB0byBhcHBseSB0byB0aGUgc3ByaXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQ29sb3JpemUoY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDb2xvcml6ZS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDBdICsgdGhpcy5jb2xvci5yKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDFdICsgdGhpcy5jb2xvci5nKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDJdICsgdGhpcy5jb2xvci5iKSAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb2xvcml6ZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkNvbG9yaXplID0gQ29sb3JpemU7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiTGlnaHRlblwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgbGlnaHRuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgKi9cclxuICAgIHZhciBMaWdodGVuID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgZmFjdG9yIG9mIHRoZSBlZmZlY3QgYmV0d2VlbiAwLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBMaWdodGVuKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yID0gZmFjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBMaWdodGVuLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IENvbG9yXzguQ29sb3IuZnJvbVJHQihwaXhlbFtmaXJzdFBpeGVsICsgMF0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDJdLCBwaXhlbFtmaXJzdFBpeGVsICsgM10pLmxpZ2h0ZW4odGhpcy5mYWN0b3IpO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBjb2xvci5yO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSBjb2xvci5nO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBjb2xvci5hO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIExpZ2h0ZW47XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5MaWdodGVuID0gTGlnaHRlbjtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJEYXJrZW5cIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGRhcmtuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgKi9cclxuICAgIHZhciBEYXJrZW4gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBmYWN0b3Igb2YgdGhlIGVmZmVjdCBiZXR3ZWVuIDAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIERhcmtlbihmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgRGFya2VuLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IENvbG9yXzguQ29sb3IuZnJvbVJHQihwaXhlbFtmaXJzdFBpeGVsICsgMF0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDJdLCBwaXhlbFtmaXJzdFBpeGVsICsgM10pLmRhcmtlbih0aGlzLmZhY3Rvcik7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGNvbG9yLnI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IGNvbG9yLmI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IGNvbG9yLmE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRGFya2VuO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRGFya2VuID0gRGFya2VuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIlNhdHVyYXRlXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAqL1xyXG4gICAgdmFyIFNhdHVyYXRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgZmFjdG9yIG9mIHRoZSBlZmZlY3QgYmV0d2VlbiAwLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBTYXR1cmF0ZShmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2F0dXJhdGUucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gQ29sb3JfOC5Db2xvci5mcm9tUkdCKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDFdLCBwaXhlbFtmaXJzdFBpeGVsICsgMl0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSkuc2F0dXJhdGUodGhpcy5mYWN0b3IpO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBjb2xvci5yO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSBjb2xvci5nO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBjb2xvci5hO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNhdHVyYXRlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU2F0dXJhdGUgPSBTYXR1cmF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJEZXNhdHVyYXRlXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBkZXNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICovXHJcbiAgICB2YXIgRGVzYXR1cmF0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGZhY3RvciBvZiB0aGUgZWZmZWN0IGJldHdlZW4gMC0xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRGVzYXR1cmF0ZShmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgRGVzYXR1cmF0ZS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBDb2xvcl84LkNvbG9yLmZyb21SR0IocGl4ZWxbZmlyc3RQaXhlbCArIDBdLCBwaXhlbFtmaXJzdFBpeGVsICsgMV0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDNdKS5kZXNhdHVyYXRlKHRoaXMuZmFjdG9yKTtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gY29sb3IucjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gY29sb3IuZztcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gY29sb3IuYjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDNdID0gY29sb3IuYTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEZXNhdHVyYXRlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRGVzYXR1cmF0ZSA9IERlc2F0dXJhdGU7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiRmlsbFwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBub24tdHJhbnNwYXJlbnQgcGl4ZWxzIHRvIG1hdGNoXHJcbiAgICAgKiBhIGdpdmVuIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBGaWxsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBjb2xvciB0byBhcHBseSB0byB0aGUgc3ByaXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRmlsbChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZpbGwucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gdGhpcy5jb2xvci5yO1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gdGhpcy5jb2xvci5nO1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gdGhpcy5jb2xvci5iO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRmlsbDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkZpbGwgPSBGaWxsO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JRHJhd2FibGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSUxvYWRhYmxlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJSZXNvdXJjZXMvUmVzb3VyY2VcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDbGFzc1wiLCBcIlByb21pc2VzXCIsIFwiVXRpbC9Mb2dcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDbGFzc18yLCBQcm9taXNlc18zLCBMb2dfMykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW1Jlc291cmNlXV0gdHlwZSBhbGxvd3MgZ2FtZXMgYnVpbHQgaW4gRXhjYWxpYnVyIHRvIGxvYWQgZ2VuZXJpYyByZXNvdXJjZXMuXHJcbiAgICAgKiBGb3IgYW55IHR5cGUgb2YgcmVtb3RlIHJlc291cmNlIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBbW1Jlc291cmNlXV0gZm9yIHByZWxvYWRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlJlc291cmNlcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBSZXNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFJlc291cmNlLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBwYXRoICAgICAgICAgIFBhdGggdG8gdGhlIHJlbW90ZSByZXNvdXJjZVxyXG4gICAgICAgICAqIEBwYXJhbSByZXNwb25zZVR5cGUgIFRoZSB0eXBlIHRvIGV4cGVjdCBhcyBhIHJlc3BvbnNlOiBcIlwiIHwgXCJhcnJheWJ1ZmZlclwiIHwgXCJibG9iXCIgfCBcImRvY3VtZW50XCIgfCBcImpzb25cIiB8IFwidGV4dFwiO1xyXG4gICAgICAgICAqIEBwYXJhbSBidXN0Q2FjaGUgICAgIFdoZXRoZXIgb3Igbm90IHRvIGNhY2hlLWJ1c3QgcmVxdWVzdHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSZXNvdXJjZShwYXRoLCByZXNwb25zZVR5cGUsIGJ1c3RDYWNoZSkge1xyXG4gICAgICAgICAgICBpZiAoYnVzdENhY2hlID09PSB2b2lkIDApIHsgYnVzdENhY2hlID0gdHJ1ZTsgfVxyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xyXG4gICAgICAgICAgICBfdGhpcy5idXN0Q2FjaGUgPSBidXN0Q2FjaGU7XHJcbiAgICAgICAgICAgIF90aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIgPSBMb2dfMy5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgX3RoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIF90aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIFJlc291cmNlIGlzIGNvbXBsZXRlbHkgbG9hZGVkIGFuZCBpcyByZWFkeVxyXG4gICAgICAgICAqIHRvIGJlIGRyYXduLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSAhPT0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS53aXJlRW5naW5lID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuX2NhY2hlQnVzdCA9IGZ1bmN0aW9uICh1cmkpIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gL1xcP1xcdyo9XFx3Ki87XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS50ZXN0KHVyaSkpIHtcclxuICAgICAgICAgICAgICAgIHVyaSArPSAoJyZfXz0nICsgRGF0ZS5ub3coKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1cmkgKz0gKCc/X189JyArIERhdGUubm93KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1cmk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnU3RhcnRlZCBsb2FkaW5nIHJlc291cmNlICcgKyB0aGlzLnBhdGgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVnaW4gbG9hZGluZyB0aGUgcmVzb3VyY2UgYW5kIHJldHVybnMgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIG9uIGNvbXBsZXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IFByb21pc2VzXzMuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGFscmVhZHkgaGF2ZSBkYXRhXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdBbHJlYWR5IGhhdmUgZGF0YSBmb3IgcmVzb3VyY2UnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZSh0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB0aGlzLmJ1c3RDYWNoZSA/IHRoaXMuX2NhY2hlQnVzdCh0aGlzLnBhdGgpIDogdGhpcy5wYXRoLCB0cnVlKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWRzdGFydCA9IGZ1bmN0aW9uICgpIHsgX3RoaXMuX3N0YXJ0KCk7IH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gdGhpcy5vbmVycm9yO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIFhIUiBvbiBmaWxlOi8vIHN1Y2Nlc3Mgc3RhdHVzIGlzIDAsIHN1Y2ggYXMgd2l0aCBQaGFudG9tSlNcclxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gbG9hZCByZXNvdXJjZSAnLCBfdGhpcy5wYXRoLCAnIHNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBjb2RlJywgcmVxdWVzdC5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IocmVxdWVzdC5yZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRhID0gX3RoaXMucHJvY2Vzc0RhdGEocmVxdWVzdC5yZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoJ0NvbXBsZXRlZCBsb2FkaW5nIHJlc291cmNlJywgX3RoaXMucGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbG9hZGVkIGRhdGEgb25jZSB0aGUgcmVzb3VyY2UgaXMgbG9hZGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBkYXRhIGZvciB0aGlzIHJlc291cmNlIGRpcmVjdGx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnByb2Nlc3NEYXRhKGRhdGEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuIHRvIGhhbmRsZSBhbnkgYWRkaXRpb25hbFxyXG4gICAgICAgICAqIHByb2Nlc3NpbmcuIFN1Y2ggYXMgZGVjb2RpbmcgZG93bmxvYWRlZCBhdWRpbyBiaXRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5wcm9jZXNzRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9yZXNwb25zZVR5cGVcclxuICAgICAgICAgICAgLy8gQmxvYiByZXF1aXJlcyBhbiBvYmplY3QgdXJsXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2Jsb2InKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSZXNvdXJjZTtcclxuICAgIH0oQ2xhc3NfMi5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5SZXNvdXJjZSA9IFJlc291cmNlO1xyXG59KTtcclxuZGVmaW5lKFwiUmVzb3VyY2VzL1RleHR1cmVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJSZXNvdXJjZXMvUmVzb3VyY2VcIiwgXCJQcm9taXNlc1wiLCBcIkRyYXdpbmcvU3ByaXRlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUmVzb3VyY2VfMSwgUHJvbWlzZXNfNCwgU3ByaXRlXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgW1tUZXh0dXJlXV0gb2JqZWN0IGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBpbWFnZSByZXNvdXJjZXMuXHJcbiAgICAgKiBbW1RleHR1cmVdXSBpcyBhbiBbW0lMb2FkYWJsZV1dIHdoaWNoIG1lYW5zIGl0IGNhbiBiZSBwYXNzZWQgdG8gYSBbW0xvYWRlcl1dXHJcbiAgICAgKiB0byBwcmUtbG9hZCBiZWZvcmUgc3RhcnRpbmcgYSBsZXZlbCBvciBnYW1lLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpUZXh0dXJlcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBUZXh0dXJlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGV4dHVyZSwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gcGF0aCAgICAgICBQYXRoIHRvIHRoZSBpbWFnZSByZXNvdXJjZVxyXG4gICAgICAgICAqIEBwYXJhbSBidXN0Q2FjaGUgIE9wdGlvbmFsbHkgbG9hZCB0ZXh0dXJlIHdpdGggY2FjaGUgYnVzdGluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFRleHR1cmUocGF0aCwgYnVzdENhY2hlKSB7XHJcbiAgICAgICAgICAgIGlmIChidXN0Q2FjaGUgPT09IHZvaWQgMCkgeyBidXN0Q2FjaGUgPSB0cnVlOyB9XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhdGgsICdibG9iJywgYnVzdENhY2hlKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICAgICAgX3RoaXMuYnVzdENhY2hlID0gYnVzdENhY2hlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBbW1Byb21pc2VdXSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIFRleHR1cmUgaXMgbG9hZGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubG9hZGVkID0gbmV3IFByb21pc2VzXzQuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX3Nwcml0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLl9zcHJpdGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKF90aGlzLCAwLCAwLCAwLCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIFRleHR1cmUgaXMgY29tcGxldGVseSBsb2FkZWQgYW5kIGlzIHJlYWR5XHJcbiAgICAgICAgICogdG8gYmUgZHJhd24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0xvYWRlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJlZ2lucyBsb2FkaW5nIHRoZSB0ZXh0dXJlIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IFByb21pc2VzXzQuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gX3N1cGVyLnByb3RvdHlwZS5sb2FkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIGxvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud2lkdGggPSBfdGhpcy5fc3ByaXRlLnN3aWR0aCA9IF90aGlzLl9zcHJpdGUubmF0dXJhbFdpZHRoID0gX3RoaXMuX3Nwcml0ZS53aWR0aCA9IF90aGlzLmltYWdlLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oZWlnaHQgPSBfdGhpcy5fc3ByaXRlLnNoZWlnaHQgPSBfdGhpcy5fc3ByaXRlLm5hdHVyYWxIZWlnaHQgPSBfdGhpcy5fc3ByaXRlLmhlaWdodCA9IF90aGlzLmltYWdlLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9hZGVkLnJlc29sdmUoX3RoaXMuaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoX3RoaXMuaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbWFnZS5zcmMgPSBfc3VwZXIucHJvdG90eXBlLmdldERhdGEuY2FsbChfdGhpcyk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlamVjdCgnRXJyb3IgbG9hZGluZyB0ZXh0dXJlLicpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUuYXNTcHJpdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcHJpdGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVGV4dHVyZTtcclxuICAgIH0oUmVzb3VyY2VfMS5SZXNvdXJjZSkpO1xyXG4gICAgZXhwb3J0cy5UZXh0dXJlID0gVGV4dHVyZTtcclxufSk7XHJcbmRlZmluZShcIkRyYXdpbmcvU3ByaXRlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9TcHJpdGVFZmZlY3RzXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIkFsZ2VicmFcIiwgXCJVdGlsL0xvZ1wiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEVmZmVjdHMsIENvbG9yXzksIEFsZ2VicmFfMTEsIExvZ180LCBVdGlsXzIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIFtbU3ByaXRlXV0gaXMgb25lIG9mIHRoZSBtYWluIGRyYXdpbmcgcHJpbWl0aXZlcy4gSXQgaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmdcclxuICAgICAqIGltYWdlcyBvciBwYXJ0cyBvZiBpbWFnZXMgZnJvbSBhIFtbVGV4dHVyZV1dIHJlc291cmNlIHRvIHRoZSBzY3JlZW4uXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlNwcml0ZXMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgU3ByaXRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgICBUaGUgYmFja2luZyBpbWFnZSB0ZXh0dXJlIHRvIGJ1aWxkIHRoZSBTcHJpdGVcclxuICAgICAgICAgKiBAcGFyYW0gc3ggICAgICBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgc3ByaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHN5ICAgICAgVGhlIHkgcG9zaXRpb24gb2YgdGhlIHNwcml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSBzd2lkdGggIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlIGluIHBpeGVsc1xyXG4gICAgICAgICAqIEBwYXJhbSBzaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBTcHJpdGUoaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuc3ggPSBzeDtcclxuICAgICAgICAgICAgdGhpcy5zeSA9IHN5O1xyXG4gICAgICAgICAgICB0aGlzLnN3aWR0aCA9IHN3aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5zaGVpZ2h0ID0gc2hlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy5hbmNob3IgPSBuZXcgQWxnZWJyYV8xMS5WZWN0b3IoMC4wLCAwLjApO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gbmV3IEFsZ2VicmFfMTEuVmVjdG9yKDEsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IExvZ180LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRHJhd3MgdGhlIHNwcml0ZSBmbGlwcGVkIHZlcnRpY2FsbHlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmxpcFZlcnRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEcmF3cyB0aGUgc3ByaXRlIGZsaXBwZWQgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZsaXBIb3Jpem9udGFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUNhbnZhcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsRGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsc0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUVmZmVjdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoc3ggPCAwIHx8IHN5IDwgMCB8fCBzd2lkdGggPCAwIHx8IHNoZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignU3ByaXRlIGNhbm5vdCBoYXZlIGFueSBuZWdhdGl2ZSBkaW1lbnNpb25zIHg6Jywgc3gsICd5OicsIHN5LCAnd2lkdGg6Jywgc3dpZHRoLCAnaGVpZ2h0OicsIHNoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUgPSBpbWFnZTtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUNhbnZhcy53aWR0aCA9IHN3aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzLmhlaWdodCA9IHNoZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eCA9IHRoaXMuX3Nwcml0ZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlLmxvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zcHJpdGVDYW52YXMud2lkdGggPSBfdGhpcy5fc3ByaXRlQ2FudmFzLndpZHRoIHx8IF90aGlzLl90ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zcHJpdGVDYW52YXMuaGVpZ2h0ID0gX3RoaXMuX3Nwcml0ZUNhbnZhcy5oZWlnaHQgfHwgX3RoaXMuX3RleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2FkUGl4ZWxzKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGlydHlFZmZlY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9KS5lcnJvcihmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKCdFcnJvciBsb2FkaW5nIHRleHR1cmUgJywgX3RoaXMuX3RleHR1cmUucGF0aCwgZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gc3dpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHNoZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbFdpZHRoID0gc3dpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxIZWlnaHQgPSBzaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBTcHJpdGUucHJvdG90eXBlLl9sb2FkUGl4ZWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5pc0xvYWRlZCgpICYmICF0aGlzLl9waXhlbHNMb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYXR1cmFsV2lkdGggPSB0aGlzLl90ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSB0aGlzLl90ZXh0dXJlLmltYWdlLm5hdHVyYWxIZWlnaHQgfHwgMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN3aWR0aCA+IG5hdHVyYWxXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1RoZSBzcHJpdGUgd2lkdGgnLCB0aGlzLnN3aWR0aCwgJ2V4Y2VlZHMgdGhlIHdpZHRoJywgbmF0dXJhbFdpZHRoLCAnb2YgdGhlIGJhY2tpbmcgdGV4dHVyZScsIHRoaXMuX3RleHR1cmUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaGVpZ2h0ID4gbmF0dXJhbEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1RoZSBzcHJpdGUgaGVpZ2h0JywgdGhpcy5zaGVpZ2h0LCAnZXhjZWVkcyB0aGUgaGVpZ2h0JywgbmF0dXJhbEhlaWdodCwgJ29mIHRoZSBiYWNraW5nIHRleHR1cmUnLCB0aGlzLl90ZXh0dXJlLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ3R4LmRyYXdJbWFnZSh0aGlzLl90ZXh0dXJlLmltYWdlLCBVdGlsXzIuY2xhbXAodGhpcy5zeCwgMCwgbmF0dXJhbFdpZHRoKSwgVXRpbF8yLmNsYW1wKHRoaXMuc3ksIDAsIG5hdHVyYWxIZWlnaHQpLCBVdGlsXzIuY2xhbXAodGhpcy5zd2lkdGgsIDAsIG5hdHVyYWxXaWR0aCksIFV0aWxfMi5jbGFtcCh0aGlzLnNoZWlnaHQsIDAsIG5hdHVyYWxIZWlnaHQpLCAwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BpeGVsc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbT3BhY2l0eV1dIGVmZmVjdCB0byBhIHNwcml0ZSwgc2V0dGluZyB0aGUgYWxwaGEgb2YgYWxsIHBpeGVscyB0byBhIGdpdmVuIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5vcGFjaXR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLk9wYWNpdHkodmFsdWUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbR3JheXNjYWxlXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCByZW1vdmluZyBjb2xvciBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmdyYXlzY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuR3JheXNjYWxlKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tJbnZlcnRdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGludmVydGluZyB0aGUgcGl4ZWwgY29sb3JzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5JbnZlcnQoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW0ZpbGxdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgbm9uLXRyYW5zcGFyZW50IHBpeGVscyB0byBtYXRjaCBhIGdpdmVuIGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkZpbGwoY29sb3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbQ29sb3JpemVdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgcGl4ZWxzIHRvIGJlIHRoZSBhdmVyYWdlIG9mIHRoZSBvcmlnaW5hbCBjb2xvclxyXG4gICAgICAgICAqIGFuZCB0aGUgcHJvdmlkZWQgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5jb2xvcml6ZSA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5Db2xvcml6ZShjb2xvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tMaWdodGVuXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBsaWdodG5lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmxpZ2h0ZW4gPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuTGlnaHRlbihmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbRGFya2VuXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBkYXJrbmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuZGFya2VuID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkRhcmtlbihmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbU2F0dXJhdGVdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIHNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuU2F0dXJhdGUoZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW0Rlc2F0dXJhdGVdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGRlc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkRlc2F0dXJhdGUoZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgbmV3IFtbSVNwcml0ZUVmZmVjdF1dIHRvIHRoaXMgZHJhd2luZy5cclxuICAgICAgICAgKiBAcGFyYW0gZWZmZWN0ICBFZmZlY3QgdG8gYWRkIHRvIHRoZSB0aGlzIGRyYXdpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcclxuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLnB1c2goZWZmZWN0KTtcclxuICAgICAgICAgICAgLy8gV2UgbXVzdCBjaGVjayBpZiB0aGUgdGV4dHVyZSBhbmQgdGhlIGJhY2tpbmcgc3ByaXRlIHBpeGVscyBhcmUgbG9hZGVkIGFzIHdlbGwgYmVmb3JlIFxyXG4gICAgICAgICAgICAvLyBhbiBlZmZlY3QgY2FuIGJlIGFwcGxpZWRcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlLmlzTG9hZGVkKCkgfHwgIXRoaXMuX3BpeGVsc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHlFZmZlY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUucmVtb3ZlRWZmZWN0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleFRvUmVtb3ZlID0gLTE7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gcGFyYW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gdGhpcy5lZmZlY3RzLmluZGV4T2YocGFyYW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGJvdW5kcyBjaGVja1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhUb1JlbW92ZSA8IDAgfHwgaW5kZXhUb1JlbW92ZSA+PSB0aGlzLmVmZmVjdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLnNwbGljZShpbmRleFRvUmVtb3ZlLCAxKTtcclxuICAgICAgICAgICAgLy8gV2UgbXVzdCBjaGVjayBpZiB0aGUgdGV4dHVyZSBhbmQgdGhlIGJhY2tpbmcgc3ByaXRlIHBpeGVscyBhcmUgbG9hZGVkIGFzIHdlbGwgYmVmb3JlIFxyXG4gICAgICAgICAgICAvLyBhbiBlZmZlY3QgY2FuIGJlIGFwcGxpZWRcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlLmlzTG9hZGVkKCkgfHwgIXRoaXMuX3BpeGVsc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHlFZmZlY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuX2FwcGx5RWZmZWN0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5hdHVyYWxXaWR0aCA9IHRoaXMuX3RleHR1cmUuaW1hZ2UubmF0dXJhbFdpZHRoIHx8IDA7XHJcbiAgICAgICAgICAgIHZhciBuYXR1cmFsSGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5pbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5kcmF3SW1hZ2UodGhpcy5fdGV4dHVyZS5pbWFnZSwgVXRpbF8yLmNsYW1wKHRoaXMuc3gsIDAsIG5hdHVyYWxXaWR0aCksIFV0aWxfMi5jbGFtcCh0aGlzLnN5LCAwLCBuYXR1cmFsSGVpZ2h0KSwgVXRpbF8yLmNsYW1wKHRoaXMuc3dpZHRoLCAwLCBuYXR1cmFsV2lkdGgpLCBVdGlsXzIuY2xhbXAodGhpcy5zaGVpZ2h0LCAwLCBuYXR1cmFsSGVpZ2h0KSwgMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsRGF0YSA9IHRoaXMuX3Nwcml0ZUN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgeCA9IDAsIHkgPSAwLCBsZW4gPSB0aGlzLmVmZmVjdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHk7IHkgPCB0aGlzLnNoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoeDsgeCA8IHRoaXMuc3dpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnVwZGF0ZVBpeGVsKHgsIHksIHRoaXMuX3BpeGVsRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5wdXRJbWFnZURhdGEodGhpcy5fcGl4ZWxEYXRhLCAwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlFZmZlY3QgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyBhbGwgZWZmZWN0cyBmcm9tIHRoZSBkcmF3aW5nIGFuZCByZXR1cm4gaXQgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuY2xlYXJFZmZlY3RzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlFZmZlY3RzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBkcmF3aW5nIChpZiBhbnkpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5KSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZWRTV2lkdGggPSB0aGlzLndpZHRoICogdGhpcy5zY2FsZS54O1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVkU0hlaWdodCA9IHRoaXMuaGVpZ2h0ICogdGhpcy5zY2FsZS55O1xyXG4gICAgICAgICAgICB2YXIgeHBvaW50ID0gKHNjYWxlZFNXaWR0aCkgKiB0aGlzLmFuY2hvci54O1xyXG4gICAgICAgICAgICB2YXIgeXBvaW50ID0gKHNjYWxlZFNIZWlnaHQpICogdGhpcy5hbmNob3IueTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3JfOS5Db2xvci5CbGFjay50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCgteHBvaW50LCAteXBvaW50LCBzY2FsZWRTV2lkdGgsIHNjYWxlZFNIZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgdGhlIHNwcml0ZSBhcHByb3ByaWF0ZWx5IHRvIHRoZSAyRCByZW5kZXJpbmcgY29udGV4dCwgYXQgYW4geCBhbmQgeSBjb29yZGluYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggIFRoZSAyRCByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgIFRoZSB4IGNvb3JkaW5hdGUgb2Ygd2hlcmUgdG8gZHJhd1xyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgIFRoZSB5IGNvb3JkaW5hdGUgb2Ygd2hlcmUgdG8gZHJhd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIHgsIHkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RpcnR5RWZmZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUVmZmVjdHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGluZyBjdXJyZW50IGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMubmF0dXJhbFdpZHRoICogdGhpcy5zY2FsZS54O1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubmF0dXJhbEhlaWdodCAqIHRoaXMuc2NhbGUueTtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgdmFyIHhwb2ludCA9IHRoaXMud2lkdGggKiB0aGlzLmFuY2hvci54O1xyXG4gICAgICAgICAgICB2YXIgeXBvaW50ID0gdGhpcy5oZWlnaHQgKiB0aGlzLmFuY2hvci55O1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVkU1dpZHRoID0gdGhpcy5zd2lkdGggKiB0aGlzLnNjYWxlLng7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZWRTSGVpZ2h0ID0gdGhpcy5zaGVpZ2h0ICogdGhpcy5zY2FsZS55O1xyXG4gICAgICAgICAgICAvLyB0b2RvIGNhY2hlIGZsaXBwZWQgc3ByaXRlc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzY2FsZWRTV2lkdGgsIDApO1xyXG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5mbGlwVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgc2NhbGVkU0hlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fc3ByaXRlQ2FudmFzLCAwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0LCAteHBvaW50LCAteXBvaW50LCBzY2FsZWRTV2lkdGgsIHNjYWxlZFNIZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvZHVjZXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHNwcml0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3ByaXRlKHRoaXMuX3RleHR1cmUsIHRoaXMuc3gsIHRoaXMuc3ksIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xyXG4gICAgICAgICAgICByZXN1bHQuc2NhbGUgPSB0aGlzLnNjYWxlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgICAgICAgIHJlc3VsdC5mbGlwSG9yaXpvbnRhbCA9IHRoaXMuZmxpcEhvcml6b250YWw7XHJcbiAgICAgICAgICAgIHJlc3VsdC5mbGlwVmVydGljYWwgPSB0aGlzLmZsaXBWZXJ0aWNhbDtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLmVmZmVjdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZEVmZmVjdCh0aGlzLmVmZmVjdHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3ByaXRlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xyXG59KTtcclxuZGVmaW5lKFwiRHJhd2luZy9BbmltYXRpb25cIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL1Nwcml0ZUVmZmVjdHNcIiwgXCJBbGdlYnJhXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgRWZmZWN0cywgQWxnZWJyYV8xMiwgVXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbnMgYWxsb3cgeW91IHRvIGRpc3BsYXkgYSBzZXJpZXMgb2YgaW1hZ2VzIG9uZSBhZnRlciBhbm90aGVyLFxyXG4gICAgICogY3JlYXRpbmcgdGhlIGlsbHVzaW9uIG9mIGNoYW5nZS4gR2VuZXJhbGx5IHRoZXNlIGltYWdlcyB3aWxsIGNvbWUgZnJvbSBhIFtbU3ByaXRlU2hlZXRdXSBzb3VyY2UuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkFuaW1hdGlvbnMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgQW5pbWF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUeXBpY2FsbHkgeW91IHdpbGwgdXNlIGEgW1tTcHJpdGVTaGVldF1dIHRvIGdlbmVyYXRlIGFuIFtbQW5pbWF0aW9uXV0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBlbmdpbmVcclxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VzICBBbiBhcnJheSBvZiBzcHJpdGVzIHRvIGNyZWF0ZSB0aGUgZnJhbWVzIGZvciB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkICAgVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIGluIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKiBAcGFyYW0gbG9vcCAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYW5pbWF0aW9uIHNob3VsZCBsb29wIGFmdGVyIGl0IGlzIGNvbXBsZXRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQsIGxvb3ApIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEN1cnJlbnQgZnJhbWUgaW5kZXggYmVpbmcgc2hvd25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fb2xkVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yID0gbmV3IEFsZ2VicmFfMTIuVmVjdG9yKDAuMCwgMC4wKTtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IG5ldyBBbGdlYnJhXzEyLlZlY3RvcigxLCAxKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGxvb3AgYWZ0ZXIgaXQgaXMgY29tcGxldGVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmxvb3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHRoZSBmcmFtZSBpbmRleCB0aGUgYW5pbWF0aW9uIHNob3VsZCBmcmVlemUgb24gZm9yIGEgbm9uLWxvb3BpbmdcclxuICAgICAgICAgICAgICogYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0IGlzIHRoZSBsYXN0IGZyYW1lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mcmVlemVGcmFtZSA9IC0xO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmxpcCBlYWNoIGZyYW1lIHZlcnRpY2FsbHkuIFNldHMgW1tTcHJpdGUuZmxpcFZlcnRpY2FsXV0uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZsaXBWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmxpcCBlYWNoIGZyYW1lIGhvcml6b250YWxseS4gU2V0cyBbW1Nwcml0ZS5mbGlwSG9yaXpvbnRhbF1dLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IGltYWdlcztcclxuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIGlmIChsb29wICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGltYWdlcyAmJiBpbWFnZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaW1hZ2VzWzBdID8gaW1hZ2VzWzBdLmhlaWdodCA6IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gaW1hZ2VzWzBdID8gaW1hZ2VzWzBdLndpZHRoIDogMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubmF0dXJhbFdpZHRoID0gaW1hZ2VzWzBdID8gaW1hZ2VzWzBdLm5hdHVyYWxXaWR0aCA6IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdHVyYWxIZWlnaHQgPSBpbWFnZXNbMF0gPyBpbWFnZXNbMF0ubmF0dXJhbEhlaWdodCA6IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lID0gaW1hZ2VzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgb3BhY2l0eSBlZmZlY3QgdG8gYSBzcHJpdGUsIHNldHRpbmcgdGhlIGFscGhhIG9mIGFsbCBwaXhlbHMgdG8gYSBnaXZlbiB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUub3BhY2l0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5PcGFjaXR5KHZhbHVlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBncmF5c2NhbGUgZWZmZWN0IHRvIGEgc3ByaXRlLCByZW1vdmluZyBjb2xvciBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmdyYXlzY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuR3JheXNjYWxlKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgaW52ZXJ0IGVmZmVjdCB0byBhIHNwcml0ZSwgaW52ZXJ0aW5nIHRoZSBwaXhlbCBjb2xvcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkludmVydCgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIGZpbGwgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIG5vbi10cmFuc3BhcmVudCBwaXhlbHMgdG8gbWF0Y2ggYSBnaXZlbiBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5GaWxsKGNvbG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBjb2xvcml6ZSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgcGl4ZWxzIHRvIGJlIHRoZSBhdmVyYWdlIG9mIHRoZSBvcmlnaW5hbCBjb2xvciBhbmQgdGhlXHJcbiAgICAgICAgICogcHJvdmlkZWQgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5jb2xvcml6ZSA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5Db2xvcml6ZShjb2xvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgbGlnaHRlbiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGxpZ2h0bmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIGhzbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUubGlnaHRlbiA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5MaWdodGVuKGZhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgZGFya2VuIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgZGFya25lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBoc2xcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5EYXJrZW4oZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBzYXR1cmF0ZSBlZmZlY3QgdG8gYSBzcHJpdGUsIHNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIGhzbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuU2F0dXJhdGUoZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBkZXNhdHVyYXRlIGVmZmVjdCB0byBhIHNwcml0ZSwgZGVzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBoc2xcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuRGVzYXR1cmF0ZShmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhIFtbSVNwcml0ZUVmZmVjdF1dIG1hbnVhbGx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5hZGRFZmZlY3QgPSBmdW5jdGlvbiAoZWZmZWN0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uYWRkRWZmZWN0KGVmZmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUucmVtb3ZlRWZmZWN0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0ucmVtb3ZlRWZmZWN0KHBhcmFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXIgYWxsIHNwcml0ZSBlZmZlY3RzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5jbGVhckVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uY2xlYXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuX3NldEFuY2hvciA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICAvL2lmICghdGhpcy5hbmNob3IuZXF1YWxzKHBvaW50KSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLmFuY2hvci5zZXRUbyhwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuX3NldFJvdGF0aW9uID0gZnVuY3Rpb24gKHJhZGlhbnMpIHtcclxuICAgICAgICAgICAgLy9pZiAodGhpcy5yb3RhdGlvbiAhPT0gcmFkaWFucykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnJvdGF0aW9uID0gcmFkaWFucztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuX3NldFNjYWxlID0gZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgICAgICAgICAgIC8vaWYgKCF0aGlzLnNjYWxlLmVxdWFscyhzY2FsZSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoZSBhbmltYXRpb24gdG8gZmlyc3QgZnJhbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgYW5pbWF0aW9ucyB0aGF0IGxvb3AgYXJlIG5ldmVyIGNvbXBsZXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKCF0aGlzLmxvb3AgJiYgdGhpcy5jdXJyZW50RnJhbWUgPj0gdGhpcy5zcHJpdGVzLmxlbmd0aCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3QgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IGdhbWUgZGV2ZWxvcGVycy4gVGlja3MgdGhlIGFuaW1hdGlvbiBmb3J3YXJkIGludGVybmFsbHkgYW5kXHJcbiAgICAgICAgICogY2FsY3VsYXRlcyB3aGV0aGVyIHRvIGNoYW5nZSB0byB0aGUgZnJhbWUuXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGlmICgodGltZSAtIHRoaXMuX29sZFRpbWUpID4gdGhpcy5zcGVlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAodGhpcy5sb29wID8gKHRoaXMuY3VycmVudEZyYW1lICsgMSkgJSB0aGlzLnNwcml0ZXMubGVuZ3RoIDogdGhpcy5jdXJyZW50RnJhbWUgKyAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29sZFRpbWUgPSB0aW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLl91cGRhdGVWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEFuY2hvcih0aGlzLmFuY2hvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFJvdGF0aW9uKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRTY2FsZSh0aGlzLnNjYWxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNraXBzIGFoZWFkIGEgc3BlY2lmaWVkIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBmcmFtZXMgIEZyYW1lcyB0byBza2lwIGFoZWFkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKGZyYW1lcykge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9ICh0aGlzLmN1cnJlbnRGcmFtZSArIGZyYW1lcykgJSB0aGlzLnNwcml0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWVzKCk7XHJcbiAgICAgICAgICAgIHZhciBjdXJyU3ByaXRlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RnJhbWUgPCB0aGlzLnNwcml0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyU3ByaXRlID0gdGhpcy5zcHJpdGVzW3RoaXMuY3VycmVudEZyYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsaXBWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZmxpcFZlcnRpY2FsID0gdGhpcy5mbGlwVmVydGljYWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZmxpcEhvcml6b250YWwgPSB0aGlzLmZsaXBIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VyclNwcml0ZS5kcmF3KGN0eCwgeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZnJlZXplRnJhbWUgIT09IC0xICYmIHRoaXMuY3VycmVudEZyYW1lID49IHRoaXMuc3ByaXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUgPSB0aGlzLnNwcml0ZXNbVXRpbC5jbGFtcCh0aGlzLmZyZWV6ZUZyYW1lLCAwLCB0aGlzLnNwcml0ZXMubGVuZ3RoIC0gMSldO1xyXG4gICAgICAgICAgICAgICAgY3VyclNwcml0ZS5kcmF3KGN0eCwgeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWRkIHRoZSBjYWxjdWxhdGVkIHdpZHRoXHJcbiAgICAgICAgICAgIGlmIChjdXJyU3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gY3VyclNwcml0ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gY3VyclNwcml0ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBsYXlzIGFuIGFuaW1hdGlvbiBhdCBhbiBhcmJpdHJhcnkgbG9jYXRpb24gaW4gdGhlIGdhbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHggIFRoZSB4IHBvc2l0aW9uIGluIHRoZSBnYW1lIHRvIHBsYXlcclxuICAgICAgICAgKiBAcGFyYW0geSAgVGhlIHkgcG9zaXRpb24gaW4gdGhlIGdhbWUgdG8gcGxheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnBsYXlBbmltYXRpb24odGhpcywgeCwgeSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xyXG59KTtcclxuZGVmaW5lKFwiRHJhd2luZy9TcHJpdGVTaGVldFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvU3ByaXRlXCIsIFwiRHJhd2luZy9BbmltYXRpb25cIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiRHJhd2luZy9TcHJpdGVFZmZlY3RzXCIsIFwiVXRpbC9Mb2dcIiwgXCJMYWJlbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFNwcml0ZV8yLCBBbmltYXRpb25fMSwgQ29sb3JfMTAsIEVmZmVjdHMsIExvZ181LCBMYWJlbF8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogU3ByaXRlIHNoZWV0cyBhcmUgYSB1c2VmdWwgbWVjaGFuaXNtIGZvciBzbGljaW5nIHVwIGltYWdlIHJlc291cmNlcyBpbnRvXHJcbiAgICAgKiBzZXBhcmF0ZSBzcHJpdGVzIG9yIGZvciBnZW5lcmF0aW5nIGluIGdhbWUgYW5pbWF0aW9ucy4gW1tTcHJpdGV8U3ByaXRlc11dIGFyZSBvcmdhbml6ZWRcclxuICAgICAqIGluIHJvdyBtYWpvciBvcmRlciBpbiB0aGUgW1tTcHJpdGVTaGVldF1dLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpTcHJpdGVTaGVldHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgU3ByaXRlU2hlZXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSAgICAgVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlU2hlZXRcclxuICAgICAgICAgKiBAcGFyYW0gY29sdW1ucyAgIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgaW1hZ2UgdGV4dHVyZVxyXG4gICAgICAgICAqIEBwYXJhbSByb3dzICAgICAgVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBpbWFnZSB0ZXh0dXJlXHJcbiAgICAgICAgICogQHBhcmFtIHNwV2lkdGggICBUaGUgd2lkdGggb2YgZWFjaCBpbmRpdmlkdWFsIHNwcml0ZSBpbiBwaXhlbHNcclxuICAgICAgICAgKiBAcGFyYW0gc3BIZWlnaHQgIFRoZSBoZWlnaHQgb2YgZWFjaCBpbmRpdmlkdWFsIHNwcml0ZSBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBTcHJpdGVTaGVldChpbWFnZSwgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xyXG4gICAgICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxJbWFnZSA9IGltYWdlLmltYWdlO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBuZXcgQXJyYXkoY29sdW1ucyAqIHJvd3MpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBJbnNwZWN0IGFjdHVhbCBpbWFnZSBkaW1lbnNpb25zIHdpdGggcHJlbG9hZGluZ1xyXG4gICAgICAgICAgICAvKmlmKHNwV2lkdGggKiBjb2x1bW5zID4gdGhpcy5pbnRlcm5hbEltYWdlLm5hdHVyYWxXaWR0aCl7XHJcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwcml0ZVNoZWV0IHNwZWNpZmllZCBpcyB3aWRlciB0aGFuIGltYWdlIHdpZHRoXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAgICAgICBpZihzcEhlaWdodCAqIHJvd3MgPiB0aGlzLmludGVybmFsSW1hZ2UubmF0dXJhbEhlaWdodCl7XHJcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwcml0ZVNoZWV0IHNwZWNpZmllZCBpcyBoaWdoZXIgdGhhbiBpbWFnZSBoZWlnaHRcIik7XHJcbiAgICAgICAgICAgIH0qL1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIHZhciBqID0gMDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tqICsgaSAqIGNvbHVtbnNdID0gbmV3IFNwcml0ZV8yLlNwcml0ZSh0aGlzLmltYWdlLCBqICogc3BXaWR0aCwgaSAqIHNwSGVpZ2h0LCBzcFdpZHRoLCBzcEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlIGFuIGFuaW1hdGlvbiBmcm9tIHRoZSB0aGlzIFNwcml0ZVNoZWV0IGJ5IGxpc3Rpbmcgb3V0IHRoZVxyXG4gICAgICAgICAqIHNwcml0ZSBpbmRpY2VzLiBTcHJpdGVzIGFyZSBvcmdhbml6ZWQgaW4gcm93IG1ham9yIG9yZGVyIGluIHRoZSBTcHJpdGVTaGVldC5cclxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lICAgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgW1tFbmdpbmVdXVxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRpY2VzICBBbiBhcnJheSBvZiBzcHJpdGUgaW5kaWNlcyB0byB1c2UgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCAgICBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZVNoZWV0LnByb3RvdHlwZS5nZXRBbmltYXRpb25CeUluZGljZXMgPSBmdW5jdGlvbiAoZW5naW5lLCBpbmRpY2VzLCBzcGVlZCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3ByaXRlc1tpbmRleF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpbWFnZXMgPSBpbWFnZXMubWFwKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25fMS5BbmltYXRpb24oZW5naW5lLCBpbWFnZXMsIHNwZWVkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhbiBhbmltYXRpb24gZnJvbSB0aGUgdGhpcyBTcHJpdGVTaGVldCBieSBzcGVjaWZpbmcgdGhlIHJhbmdlIG9mXHJcbiAgICAgICAgICogaW1hZ2VzIHdpdGggdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSAgICAgIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIEVuZ2luZVxyXG4gICAgICAgICAqIEBwYXJhbSBiZWdpbkluZGV4ICBUaGUgaW5kZXggdG8gc3RhcnQgdGFraW5nIGZyYW1lc1xyXG4gICAgICAgICAqIEBwYXJhbSBlbmRJbmRleCAgICBUaGUgaW5kZXggdG8gc3RvcCB0YWtpbmcgZnJhbWVzXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkICAgICAgIFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlU2hlZXQucHJvdG90eXBlLmdldEFuaW1hdGlvbkJldHdlZW4gPSBmdW5jdGlvbiAoZW5naW5lLCBiZWdpbkluZGV4LCBlbmRJbmRleCwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdmFyIGltYWdlcyA9IHRoaXMuc3ByaXRlcy5zbGljZShiZWdpbkluZGV4LCBlbmRJbmRleCk7XHJcbiAgICAgICAgICAgIGltYWdlcyA9IGltYWdlcy5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbl8xLkFuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJlYXQgdGhlIGVudGlyZSBTcHJpdGVTaGVldCBhcyBvbmUgYW5pbWF0aW9uLCBvcmdhbml6aW5nIHRoZSBmcmFtZXMgaW5cclxuICAgICAgICAgKiByb3cgbWFqb3Igb3JkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSAgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgW1tFbmdpbmVdXVxyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCAgIFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlU2hlZXQucHJvdG90eXBlLmdldEFuaW1hdGlvbkZvckFsbCA9IGZ1bmN0aW9uIChlbmdpbmUsIHNwZWVkKSB7XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGVzID0gdGhpcy5zcHJpdGVzLm1hcChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuY2xvbmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uXzEuQW5pbWF0aW9uKGVuZ2luZSwgc3ByaXRlcywgc3BlZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0cmVpdmUgYSBzcGVjaWZpYyBzcHJpdGUgZnJvbSB0aGUgU3ByaXRlU2hlZXQgYnkgaXRzIGluZGV4LiBTcHJpdGVzIGFyZSBvcmdhbml6ZWRcclxuICAgICAgICAgKiBpbiByb3cgbWFqb3Igb3JkZXIgaW4gdGhlIFNwcml0ZVNoZWV0LlxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgVGhlIGluZGV4IG9mIHRoZSBzcHJpdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVTaGVldC5wcm90b3R5cGUuZ2V0U3ByaXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlc1tpbmRleF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5kZXg6ICcgKyBpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTcHJpdGVTaGVldDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQ7XHJcbiAgICAvKipcclxuICAgICAqIFNwcml0ZSBmb250cyBhcmUgYSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSBbW0xhYmVsXV0gdG8gc3BlY2lmeVxyXG4gICAgICogYSBwYXJ0aWN1bGFyIGJpdG1hcCBhcyBhIGZvbnQuIE5vdGUgdGhhdCBzb21lIGZvbnQgZmVhdHVyZXMgYXJlIG5vdFxyXG4gICAgICogc3VwcG9ydGVkIGJ5IFNwcml0ZSBmb250cy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6U3ByaXRlRm9udHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgU3ByaXRlRm9udCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNwcml0ZUZvbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGltYWdlICAgICAgICAgICBUaGUgYmFja2luZyBpbWFnZSB0ZXh0dXJlIHRvIGJ1aWxkIHRoZSBTcHJpdGVGb250XHJcbiAgICAgICAgICogQHBhcmFtIGFscGhhYmV0ICAgICAgICBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBpbWFnZSwgaW4gcm93IG1ham9yIG9yZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSBjYXNlSW5zZW5zaXRpdmUgIEluZGljYXRlIHdoZXRoZXIgdGhpcyBmb250IHRha2VzIGNhc2UgaW50byBhY2NvdW50XHJcbiAgICAgICAgICogQHBhcmFtIGNvbHVtbnMgICAgICAgICBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgb2YgY2hhcmFjdGVycyBpbiB0aGUgaW1hZ2VcclxuICAgICAgICAgKiBAcGFyYW0gcm93cyAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygcm93cyBvZiBjaGFyYWN0ZXJzIGluIHRoZSBpbWFnZVxyXG4gICAgICAgICAqIEBwYXJhbSBzcFdpZHRoICAgICAgICAgVGhlIHdpZHRoIG9mIGVhY2ggY2hhcmFjdGVyIGluIHBpeGVsc1xyXG4gICAgICAgICAqIEBwYXJhbSBzcEhlaWdodCAgICAgICAgVGhlIGhlaWdodCBvZiBlYWNoIGNoYXJhY3RlciBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBTcHJpdGVGb250KGltYWdlLCBhbHBoYWJldCwgY2FzZUluc2Vuc2l0aXZlLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbWFnZSwgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgICAgIF90aGlzLmFscGhhYmV0ID0gYWxwaGFiZXQ7XHJcbiAgICAgICAgICAgIF90aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IGNhc2VJbnNlbnNpdGl2ZTtcclxuICAgICAgICAgICAgX3RoaXMuc3BXaWR0aCA9IHNwV2lkdGg7XHJcbiAgICAgICAgICAgIF90aGlzLnNwSGVpZ2h0ID0gc3BIZWlnaHQ7XHJcbiAgICAgICAgICAgIF90aGlzLl9jdXJyZW50Q29sb3IgPSBDb2xvcl8xMC5Db2xvci5CbGFjay5jbG9uZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5fY3VycmVudE9wYWNpdHkgPSAxLjA7XHJcbiAgICAgICAgICAgIF90aGlzLl9zcHJpdGVzID0ge307XHJcbiAgICAgICAgICAgIC8vIHRleHQgc2hhZG93XHJcbiAgICAgICAgICAgIF90aGlzLl90ZXh0U2hhZG93T24gPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX3RleHRTaGFkb3dEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIF90aGlzLl90ZXh0U2hhZG93Q29sb3IgPSBDb2xvcl8xMC5Db2xvci5CbGFjay5jbG9uZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXMgPSB7fTtcclxuICAgICAgICAgICAgX3RoaXMuX3NoYWRvd09mZnNldFggPSA1O1xyXG4gICAgICAgICAgICBfdGhpcy5fc2hhZG93T2Zmc2V0WSA9IDU7XHJcbiAgICAgICAgICAgIF90aGlzLl9zcHJpdGVzID0gX3RoaXMuZ2V0VGV4dFNwcml0ZXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgZGljdGlvbmFyeSB0aGF0IG1hcHMgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGFscGhhYmV0IHRvIHRoZSBhcHByb3ByaWF0ZSBbW1Nwcml0ZV1dLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUZvbnQucHJvdG90eXBlLmdldFRleHRTcHJpdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbG9va3VwID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbHBoYWJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmFscGhhYmV0W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FzZUluc2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9IGNoYXIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxvb2t1cFtjaGFyXSA9IHRoaXMuc3ByaXRlc1tpXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsb29rdXA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB0ZXh0IHNoYWRvdyBmb3Igc3ByaXRlIGZvbnRzXHJcbiAgICAgICAgICogQHBhcmFtIG9mZnNldFggICAgICBUaGUgeCBvZmZzZXQgaW4gcGl4ZWxzIHRvIHBsYWNlIHRoZSBzaGFkb3dcclxuICAgICAgICAgKiBAcGFyYW0gb2Zmc2V0WSAgICAgIFRoZSB5IG9mZnNldCBpbiBwaXhlbHMgdG8gcGxhY2UgdGhlIHNoYWRvd1xyXG4gICAgICAgICAqIEBwYXJhbSBzaGFkb3dDb2xvciAgVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IHNoYWRvd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUZvbnQucHJvdG90eXBlLnNldFRleHRTaGFkb3cgPSBmdW5jdGlvbiAob2Zmc2V0WCwgb2Zmc2V0WSwgc2hhZG93Q29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WCA9IG9mZnNldFg7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFkgPSBvZmZzZXRZO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93RGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjaGFyYWN0ZXIgaW4gdGhpcy5fc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXSA9IHRoaXMuX3Nwcml0ZXNbY2hhcmFjdGVyXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUb2dnbGVzIHRleHQgc2hhZG93cyBvbiBvciBvZmZcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVGb250LnByb3RvdHlwZS51c2VUZXh0U2hhZG93ID0gZnVuY3Rpb24gKG9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dPbiA9IG9uO1xyXG4gICAgICAgICAgICBpZiAob24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGV4dFNoYWRvdyg1LCA1LCB0aGlzLl90ZXh0U2hhZG93Q29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3cyB0aGUgY3VycmVudCBzcHJpdGUgZm9udFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUZvbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB0ZXh0LCB4LCB5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50Q29sb3IudG9TdHJpbmcoKSAhPT0gb3B0aW9ucy5jb2xvci50b1N0cmluZygpIHx8IHRoaXMuX2N1cnJlbnRPcGFjaXR5ICE9PSBvcHRpb25zLm9wYWNpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gb3B0aW9ucy5jb2xvcjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYXIgaW4gdGhpcy5fc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZXNbY2hhcl0uY2xlYXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlc1tjaGFyXS5maWxsKG9wdGlvbnMuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZXNbY2hhcl0ub3BhY2l0eShvcHRpb25zLm9wYWNpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0U2hhZG93T24gJiYgdGhpcy5fdGV4dFNoYWRvd0RpcnR5ICYmIHRoaXMuX3RleHRTaGFkb3dDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2hhcmFjdGVyU2hhZG93IGluIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyU2hhZG93XS5jbGVhckVmZmVjdHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJTaGFkb3ddLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5GaWxsKHRoaXMuX3RleHRTaGFkb3dDb2xvci5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93RGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0ZXh0IGluIHBpeGVsc1xyXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5zcHJpdGVzWzBdO1xyXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBjdXJyZW50IGhlaWdodCBmbyB0aGUgdGV4dCBpbiBwaXhlbHNcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNwcml0ZS5zaGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgYXBwcm9wcmlhdGUgc2NhbGUgZm9yIGZvbnQgc2l6ZVxyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBvcHRpb25zLmZvbnRTaXplIC8gaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gKHRleHQubGVuZ3RoICogc3ByaXRlLnN3aWR0aCAqIHNjYWxlKSArICh0ZXh0Lmxlbmd0aCAqIG9wdGlvbnMubGV0dGVyU3BhY2luZyk7XHJcbiAgICAgICAgICAgIHZhciBjdXJyWCA9IHg7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHRBbGlnbiA9PT0gTGFiZWxfMS5UZXh0QWxpZ24uTGVmdCB8fCBvcHRpb25zLnRleHRBbGlnbiA9PT0gTGFiZWxfMS5UZXh0QWxpZ24uU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJYID0geDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLnRleHRBbGlnbiA9PT0gTGFiZWxfMS5UZXh0QWxpZ24uUmlnaHQgfHwgb3B0aW9ucy50ZXh0QWxpZ24gPT09IExhYmVsXzEuVGV4dEFsaWduLkVuZCkge1xyXG4gICAgICAgICAgICAgICAgY3VyclggPSB4IC0gbGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudGV4dEFsaWduID09PSBMYWJlbF8xLlRleHRBbGlnbi5DZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJYID0geCAtIGxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGN1cnJZID0geSAtIGhlaWdodCAqIHNjYWxlO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5iYXNlQWxpZ24gPT09IExhYmVsXzEuQmFzZUFsaWduLlRvcCB8fCBvcHRpb25zLmJhc2VBbGlnbiA9PT0gTGFiZWxfMS5CYXNlQWxpZ24uSGFuZ2luZykge1xyXG4gICAgICAgICAgICAgICAgY3VyclkgPSB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYmFzZUFsaWduID09PSBMYWJlbF8xLkJhc2VBbGlnbi5JZGVvZ3JhcGhpYyB8fFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5iYXNlQWxpZ24gPT09IExhYmVsXzEuQmFzZUFsaWduLkJvdHRvbSB8fFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5iYXNlQWxpZ24gPT09IExhYmVsXzEuQmFzZUFsaWduLkFscGhhYmV0aWMpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJZID0geSAtIGhlaWdodCAqIHNjYWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYmFzZUFsaWduID09PSBMYWJlbF8xLkJhc2VBbGlnbi5NaWRkbGUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJZID0geSAtIChoZWlnaHQgKiBzY2FsZSkgLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRleHRbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYXNlSW5zZW5zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGV4dCBzaGFkb3dcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGV4dFNoYWRvd09uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzW2NoYXJhY3Rlcl0uc2NhbGUueCA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdLnNjYWxlLnkgPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXS5kcmF3KGN0eCwgY3VyclggKyB0aGlzLl9zaGFkb3dPZmZzZXRYLCBjdXJyWSArIHRoaXMuX3NoYWRvd09mZnNldFkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhclNwcml0ZSA9IHRoaXMuX3Nwcml0ZXNbY2hhcmFjdGVyXTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLnNjYWxlLnggPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLnNjYWxlLnkgPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLmRyYXcoY3R4LCBjdXJyWCwgY3VyclkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJYICs9IChjaGFyU3ByaXRlLndpZHRoICsgb3B0aW9ucy5sZXR0ZXJTcGFjaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzUuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoXCJTcHJpdGVGb250IEVycm9yIGRyYXdpbmcgY2hhciBcIiArIGNoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwcml0ZUZvbnQucHJvdG90eXBlLl9wYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IG9wdGlvbnMuZm9udFNpemUgfHwgMTAsXHJcbiAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiBvcHRpb25zLmxldHRlclNwYWNpbmcgfHwgMCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBvcHRpb25zLmNvbG9yIHx8IENvbG9yXzEwLkNvbG9yLkJsYWNrLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHR5cGVvZiBvcHRpb25zLnRleHRBbGlnbiA9PT0gdW5kZWZpbmVkID8gTGFiZWxfMS5UZXh0QWxpZ24uTGVmdCA6IG9wdGlvbnMudGV4dEFsaWduLFxyXG4gICAgICAgICAgICAgICAgYmFzZUFsaWduOiB0eXBlb2Ygb3B0aW9ucy5iYXNlQWxpZ24gPT09IHVuZGVmaW5lZCA/IExhYmVsXzEuQmFzZUFsaWduLkJvdHRvbSA6IG9wdGlvbnMuYmFzZUFsaWduLFxyXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IG9wdGlvbnMubWF4V2lkdGggfHwgLTEsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcHRpb25zLm9wYWNpdHkgfHwgMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNwcml0ZUZvbnQ7XHJcbiAgICB9KFNwcml0ZVNoZWV0KSk7XHJcbiAgICBleHBvcnRzLlNwcml0ZUZvbnQgPSBTcHJpdGVGb250O1xyXG59KTtcclxuZGVmaW5lKFwiTGFiZWxcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiQWN0b3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xvcl8xMSwgQWN0b3JfNCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgZm9udCBzaXplIHVuaXRzXHJcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC1zaXplXHJcbiAgICAgKi9cclxuICAgIHZhciBGb250VW5pdDtcclxuICAgIChmdW5jdGlvbiAoRm9udFVuaXQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbSBpcyBhIHNjYWxhYmxlIHVuaXQsIDEgZW0gaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgZm9udCBzaXplIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQsIHBhcmVudCBlbGVtZW50cyBjYW4gZWZmZWN0IGVtIHZhbHVlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZvbnRVbml0W0ZvbnRVbml0W1wiRW1cIl0gPSAwXSA9IFwiRW1cIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW0gaXMgc2ltaWxhciB0byB0aGUgRW0sIGl0IGlzIGEgc2NhbGFibGUgdW5pdC4gMSByZW0gaXMgZXFhdWwgdG8gdGhlIGZvbnQgc2l6ZSBvZiB0aGUgcm9vdCBlbGVtZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRm9udFVuaXRbRm9udFVuaXRbXCJSZW1cIl0gPSAxXSA9IFwiUmVtXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGl4ZWwgaXMgYSB1bml0IG9mIGxlbmd0aCBpbiBzY3JlZW4gcGl4ZWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRm9udFVuaXRbRm9udFVuaXRbXCJQeFwiXSA9IDJdID0gXCJQeFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBvaW50IGlzIGEgcGh5c2ljYWwgdW5pdCBsZW5ndGggKDEvNzIgb2YgYW4gaW5jaClcclxuICAgICAgICAgKi9cclxuICAgICAgICBGb250VW5pdFtGb250VW5pdFtcIlB0XCJdID0gM10gPSBcIlB0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyY2VudCBpcyBhIHNjYWxhYmxlIHVuaXQgc2ltaWxhciB0byBFbSwgdGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGUgRW0gdW5pdHMgc2NhbGUgZmFzdGVyIHdoZW4gVGV4dC1TaXplIHN0dWZmXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRm9udFVuaXRbRm9udFVuaXRbXCJQZXJjZW50XCJdID0gNF0gPSBcIlBlcmNlbnRcIjtcclxuICAgIH0pKEZvbnRVbml0ID0gZXhwb3J0cy5Gb250VW5pdCB8fCAoZXhwb3J0cy5Gb250VW5pdCA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgaG9yaXpvbnRhbCB0ZXh0IGFsaWdubWVudHNcclxuICAgICAqL1xyXG4gICAgdmFyIFRleHRBbGlnbjtcclxuICAgIChmdW5jdGlvbiAoVGV4dEFsaWduKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgaXMgbGVmdC1hbGlnbmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBpcyByaWdodC1hbGlnbmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJSaWdodFwiXSA9IDFdID0gXCJSaWdodFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIGNlbnRlcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJDZW50ZXJcIl0gPSAyXSA9IFwiQ2VudGVyXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgaXMgYWxpZ25lZCBhdCB0aGUgbm9ybWFsIHN0YXJ0IG9mIHRoZSBsaW5lIChsZWZ0LWFsaWduZWQgZm9yIGxlZnQtdG8tcmlnaHQgbG9jYWxlcyxcclxuICAgICAgICAgKiByaWdodC1hbGlnbmVkIGZvciByaWdodC10by1sZWZ0IGxvY2FsZXMpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJTdGFydFwiXSA9IDNdID0gXCJTdGFydFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIGFsaWduZWQgYXQgdGhlIG5vcm1hbCBlbmQgb2YgdGhlIGxpbmUgKHJpZ2h0LWFsaWduZWQgZm9yIGxlZnQtdG8tcmlnaHQgbG9jYWxlcyxcclxuICAgICAgICAgKiBsZWZ0LWFsaWduZWQgZm9yIHJpZ2h0LXRvLWxlZnQgbG9jYWxlcykuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIkVuZFwiXSA9IDRdID0gXCJFbmRcIjtcclxuICAgIH0pKFRleHRBbGlnbiA9IGV4cG9ydHMuVGV4dEFsaWduIHx8IChleHBvcnRzLlRleHRBbGlnbiA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgYmFzZWxpbmUgdGV4dCBhbGlnbm1lbnRzXHJcbiAgICAgKi9cclxuICAgIHZhciBCYXNlQWxpZ247XHJcbiAgICAoZnVuY3Rpb24gKEJhc2VBbGlnbikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSB0b3Agb2YgdGhlIGVtIHNxdWFyZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiVG9wXCJdID0gMF0gPSBcIlRvcFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBoYW5naW5nIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGwgYWN0IGxpa2VcclxuICAgICAgICAgKiBhbHBoYWJldGljLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJIYW5naW5nXCJdID0gMV0gPSBcIkhhbmdpbmdcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgbWlkZGxlIG9mIHRoZSBlbSBzcXVhcmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIk1pZGRsZVwiXSA9IDJdID0gXCJNaWRkbGVcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgbm9ybWFsIGFscGhhYmV0aWMgYmFzZWxpbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIkFscGhhYmV0aWNcIl0gPSAzXSA9IFwiQWxwaGFiZXRpY1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBpZGVvZ3JhcGhpYyBiYXNlbGluZTsgdGhpcyBpcyB0aGUgYm90dG9tIG9mXHJcbiAgICAgICAgICogdGhlIGJvZHkgb2YgdGhlIGNoYXJhY3RlcnMsIGlmIHRoZSBtYWluIGJvZHkgb2YgY2hhcmFjdGVycyBwcm90cnVkZXNcclxuICAgICAgICAgKiBiZW5lYXRoIHRoZSBhbHBoYWJldGljIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGxcclxuICAgICAgICAgKiBhY3QgbGlrZSBhbHBoYWJldGljLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJJZGVvZ3JhcGhpY1wiXSA9IDRdID0gXCJJZGVvZ3JhcGhpY1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBib3R0b20gb2YgdGhlIGJvdW5kaW5nIGJveC4gIFRoaXMgZGlmZmVyc1xyXG4gICAgICAgICAqIGZyb20gdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lIGluIHRoYXQgdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lXHJcbiAgICAgICAgICogZG9lc24ndCBjb25zaWRlciBkZXNjZW5kZXJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJCb3R0b21cIl0gPSA1XSA9IFwiQm90dG9tXCI7XHJcbiAgICB9KShCYXNlQWxpZ24gPSBleHBvcnRzLkJhc2VBbGlnbiB8fCAoZXhwb3J0cy5CYXNlQWxpZ24gPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IHBvc3NpYmxlIGZvbnQgc3R5bGVzXHJcbiAgICAgKi9cclxuICAgIHZhciBGb250U3R5bGU7XHJcbiAgICAoZnVuY3Rpb24gKEZvbnRTdHlsZSkge1xyXG4gICAgICAgIEZvbnRTdHlsZVtGb250U3R5bGVbXCJOb3JtYWxcIl0gPSAwXSA9IFwiTm9ybWFsXCI7XHJcbiAgICAgICAgRm9udFN0eWxlW0ZvbnRTdHlsZVtcIkl0YWxpY1wiXSA9IDFdID0gXCJJdGFsaWNcIjtcclxuICAgICAgICBGb250U3R5bGVbRm9udFN0eWxlW1wiT2JsaXF1ZVwiXSA9IDJdID0gXCJPYmxpcXVlXCI7XHJcbiAgICB9KShGb250U3R5bGUgPSBleHBvcnRzLkZvbnRTdHlsZSB8fCAoZXhwb3J0cy5Gb250U3R5bGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMYWJlbHMgYXJlIHRoZSB3YXkgdG8gZHJhdyBzbWFsbCBhbW91bnRzIG9mIHRleHQgdG8gdGhlIHNjcmVlbi4gVGhleSBhcmVcclxuICAgICAqIGFjdG9ycyBhbmQgaW5oZXJpdCBhbGwgb2YgdGhlIGJlbmVmaXRzIGFuZCBjYXBhYmlsaXRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkxhYmVscy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBMYWJlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKExhYmVsLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB0ZXh0ICAgICAgICBUaGUgdGV4dCBvZiB0aGUgbGFiZWxcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICAgICAgVGhlIHggcG9zaXRpb24gb2YgdGhlIGxhYmVsXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgICAgIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBsYWJlbFxyXG4gICAgICAgICAqIEBwYXJhbSBmb250RmFtaWx5ICBVc2UgYW55IHZhbGlkIENTUyBmb250IHN0cmluZyBmb3IgdGhlIGxhYmVsJ3MgZm9udC4gV2ViIGZvbnRzIGFyZSBzdXBwb3J0ZWQuIERlZmF1bHQgaXMgYDEwcHggc2Fucy1zZXJpZmAuXHJcbiAgICAgICAgICogQHBhcmFtIHNwcml0ZUZvbnQgIFVzZSBhbiBFeGNhbGlidXIgc3ByaXRlIGZvbnQgZm9yIHRoZSBsYWJlbCdzIGZvbnQsIGlmIGEgU3ByaXRlRm9udCBpcyBwcm92aWRlZCBpdCB3aWxsIHRha2UgcHJlY2VkZW5jZVxyXG4gICAgICAgICAqIG92ZXIgYSBjc3MgZm9udC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBMYWJlbCh0ZXh0LCB4LCB5LCBmb250RmFtaWx5LCBzcHJpdGVGb250KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHgsIHkpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGJvbGQgcHJvcGVydHkgb2YgdGhlIGxhYmVsJ3MgdGV4dCwgYnkgZGVmYXVsdCBpdCdzIGZhbHNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5ib2xkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZm9udCBzaXplIGluIHRoZSBzZWxlY3RlZCB1bml0cywgZGVmYXVsdCBpcyAxMCAoZGVmYXVsdCB1bml0cyBpcyBwaXhlbClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZvbnRTaXplID0gMTA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZm9udCBzdHlsZSBmb3IgdGhpcyBsYWJlbCwgdGhlIGRlZmF1bHQgaXMgW1tGb250U3R5bGUuTm9ybWFsXV1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZvbnRTdHlsZSA9IEZvbnRTdHlsZS5Ob3JtYWw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3NzIHVuaXRzIGZvciBhIGZvbnQgc2l6ZSBzdWNoIGFzIHB4LCBwdCwgZW0gKFNwcml0ZUZvbnQgb25seSBzdXBwb3J0IHB4KSwgYnkgZGVmYXVsdCBpcyAncHgnO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZm9udFVuaXQgPSBGb250VW5pdC5QeDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgaG9yaXpvbnRhbCB0ZXh0IGFsaWdubWVudCBwcm9wZXJ0eSBmb3IgdGhlIGxhYmVsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMudGV4dEFsaWduID0gVGV4dEFsaWduLkxlZnQ7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhc2VsaW5lIGFsaWdubWVudCBwcm9wZXJ0eSBmb3IgdGhlIGxhYmVsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuYmFzZUFsaWduID0gQmFzZUFsaWduLkJvdHRvbTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGV0dGVyIHNwYWNpbmcgb24gYSBMYWJlbC4gT25seSBzdXBwb3J0ZWQgd2l0aCBTcHJpdGUgRm9udHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5sZXR0ZXJTcGFjaW5nID0gMDsgLy9weFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIFtbU3ByaXRlRm9udF1dIHdpbGwgYmUgY2FzZS1zZW5zaXRpdmUgd2hlbiBtYXRjaGluZyBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgX3RoaXMuX3RleHRTaGFkb3dPbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fc2hhZG93T2Zmc2V0WCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl9zaGFkb3dPZmZzZXRZID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX3NoYWRvd0NvbG9yID0gQ29sb3JfMTEuQ29sb3IuQmxhY2suY2xvbmUoKTtcclxuICAgICAgICAgICAgX3RoaXMudGV4dCA9IHRleHQgfHwgJyc7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbG9yID0gQ29sb3JfMTEuQ29sb3IuQmxhY2suY2xvbmUoKTtcclxuICAgICAgICAgICAgX3RoaXMuc3ByaXRlRm9udCA9IHNwcml0ZUZvbnQ7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbGxpc2lvblR5cGUgPSBBY3Rvcl80LkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgX3RoaXMuZm9udEZhbWlseSA9IGZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnOyAvLyBjb2FsZXNjZSB0byBkZWZhdWx0IGNhbnZhcyBmb250XHJcbiAgICAgICAgICAgIGlmIChzcHJpdGVGb250KSB7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuX3RleHRTcHJpdGVzID0gc3ByaXRlRm9udC5nZXRUZXh0U3ByaXRlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHRleHQgaW4gdGhlIGxhYmVsIChpbiBwaXhlbHMpO1xyXG4gICAgICAgICAqIEBwYXJhbSBjdHggIFJlbmRlcmluZyBjb250ZXh0IHRvIG1lYXN1cmUgdGhlIHN0cmluZyB3aXRoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLmdldFRleHRXaWR0aCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdmFyIG9sZEZvbnQgPSBjdHguZm9udDtcclxuICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLl9mb250U3RyaW5nO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcclxuICAgICAgICAgICAgY3R4LmZvbnQgPSBvbGRGb250O1xyXG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3Qgc3VwcG9ydCBzdHJpbmcgZW51bXMgOihcclxuICAgICAgICBMYWJlbC5wcm90b3R5cGUuX2xvb2t1cEZvbnRVbml0ID0gZnVuY3Rpb24gKGZvbnRVbml0KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZm9udFVuaXQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFVuaXQuRW06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlbSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRVbml0LlJlbTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JlbSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRVbml0LlB0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncHQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBGb250VW5pdC5QeDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3B4JztcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFVuaXQuUGVyY2VudDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyUnO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3B4JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLl9sb29rdXBUZXh0QWxpZ24gPSBmdW5jdGlvbiAodGV4dEFsaWduKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHRBbGlnbi5MZWZ0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHRBbGlnbi5SaWdodDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JpZ2h0JztcclxuICAgICAgICAgICAgICAgIGNhc2UgVGV4dEFsaWduLkNlbnRlcjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHRBbGlnbi5FbmQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlbmQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0QWxpZ24uU3RhcnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdzdGFydCc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnc3RhcnQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMYWJlbC5wcm90b3R5cGUuX2xvb2t1cEJhc2VBbGlnbiA9IGZ1bmN0aW9uIChiYXNlQWxpZ24pIHtcclxuICAgICAgICAgICAgc3dpdGNoIChiYXNlQWxpZ24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUFsaWduLkFscGhhYmV0aWM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhbHBoYWJldGljJztcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUFsaWduLkJvdHRvbTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VBbGlnbi5IYW5naW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGFuZ2luJztcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUFsaWduLklkZW9ncmFwaGljOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaWRlb2dyYXBoaWMnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlQWxpZ24uTWlkZGxlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbWlkZGxlJztcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUFsaWduLlRvcDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvcCc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYWxwaGFiZXRpYyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5fbG9va3VwRm9udFN0eWxlID0gZnVuY3Rpb24gKGZvbnRTdHlsZSkge1xyXG4gICAgICAgICAgICB2YXIgYm9sZHN0cmluZyA9IHRoaXMuYm9sZCA/ICcgYm9sZCcgOiAnJztcclxuICAgICAgICAgICAgc3dpdGNoIChmb250U3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFN0eWxlLkl0YWxpYzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2l0YWxpYycgKyBib2xkc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBGb250U3R5bGUuTm9ybWFsOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9ybWFsJyArIGJvbGRzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRTdHlsZS5PYmxpcXVlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnb2JsaXF1ZScgKyBib2xkc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25vcm1hbCcgKyBib2xkc3RyaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB0ZXh0IHNoYWRvdyBmb3Igc3ByaXRlIGZvbnRzXHJcbiAgICAgICAgICogQHBhcmFtIG9mZnNldFggICAgICBUaGUgeCBvZmZzZXQgaW4gcGl4ZWxzIHRvIHBsYWNlIHRoZSBzaGFkb3dcclxuICAgICAgICAgKiBAcGFyYW0gb2Zmc2V0WSAgICAgIFRoZSB5IG9mZnNldCBpbiBwaXhlbHMgdG8gcGxhY2UgdGhlIHNoYWRvd1xyXG4gICAgICAgICAqIEBwYXJhbSBzaGFkb3dDb2xvciAgVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IHNoYWRvd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5zZXRUZXh0U2hhZG93ID0gZnVuY3Rpb24gKG9mZnNldFgsIG9mZnNldFksIHNoYWRvd0NvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlRm9udC5zZXRUZXh0U2hhZG93KG9mZnNldFgsIG9mZnNldFksIHNoYWRvd0NvbG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRvZ2dsZXMgdGV4dCBzaGFkb3dzIG9uIG9yIG9mZiwgb25seSBhcHBsaWVzIHdoZW4gdXNpbmcgc3ByaXRlIGZvbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLnVzZVRleHRTaGFkb3cgPSBmdW5jdGlvbiAob24pIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVGb250LnVzZVRleHRTaGFkb3cob24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSBjdXJyZW50IHRleHQgc2hhZG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLmNsZWFyVGV4dFNoYWRvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRZID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3IgPSBDb2xvcl8xMS5Db2xvci5CbGFjay5jbG9uZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgaWYgKHRoaXMuc3ByaXRlRm9udCAmJiAodGhpcy5fY29sb3IgIT09IHRoaXMuY29sb3IgfHwgdGhpcy5wcmV2aW91c09wYWNpdHkgIT09IHRoaXMub3BhY2l0eSkpIHtcclxuICAgICAgICAgICAgICBmb3IgKHZhciBjaGFyYWN0ZXIgaW4gdGhpcy5fdGV4dFNwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U3ByaXRlc1tjaGFyYWN0ZXJdLmNsZWFyRWZmZWN0cygpO1xyXG4gICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTcHJpdGVzW2NoYXJhY3Rlcl0uZmlsbCh0aGlzLmNvbG9yLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTcHJpdGVzW2NoYXJhY3Rlcl0ub3BhY2l0eSh0aGlzLm9wYWNpdHkpO1xyXG4gICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB0aGlzLl9jb2xvciA9IHRoaXMuY29sb3I7XHJcbiAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c09wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICBcclxuICAgICAgICAgICBpZiAodGhpcy5zcHJpdGVGb250ICYmIHRoaXMuX3RleHRTaGFkb3dPbiAmJiB0aGlzLl9zaGFkb3dDb2xvckRpcnR5ICYmIHRoaXMuX3NoYWRvd0NvbG9yKSB7XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgY2hhcmFjdGVyU2hhZG93IGluIHRoaXMuX3NoYWRvd1Nwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgICB0aGlzLl9zaGFkb3dTcHJpdGVzW2NoYXJhY3RlclNoYWRvd10uY2xlYXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJTaGFkb3ddLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5GaWxsKHRoaXMuX3NoYWRvd0NvbG9yLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3JEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgIH0qL1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMucG9zLngsIHRoaXMucG9zLnkpO1xyXG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dFNoYWRvd09uKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLl9zaGFkb3dPZmZzZXRYLCB0aGlzLl9zaGFkb3dPZmZzZXRZKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnREcmF3KGN0eCk7XHJcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbnREcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMsIGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLl9mb250RHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3ByaXRlRm9udCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVGb250LmRyYXcoY3R4LCB0aGlzLnRleHQsIDAsIDAsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvci5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VBbGlnbjogdGhpcy5iYXNlQWxpZ24sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0aGlzLnRleHRBbGlnbixcclxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5vcGFjaXR5XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRBbGlnbiA9IGN0eC50ZXh0QWxpZ247XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkVGV4dEJhc2VsaW5lID0gY3R4LnRleHRCYXNlbGluZTtcclxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLl9sb29rdXBUZXh0QWxpZ24odGhpcy50ZXh0QWxpZ24pO1xyXG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMuX2xvb2t1cEJhc2VBbGlnbih0aGlzLmJhc2VBbGlnbik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3IuYSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuX2ZvbnRTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnRleHQsIDAsIDAsIHRoaXMubWF4V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gb2xkQWxpZ247XHJcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gb2xkVGV4dEJhc2VsaW5lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGFiZWwucHJvdG90eXBlLCBcIl9mb250U3RyaW5nXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9va3VwRm9udFN0eWxlKHRoaXMuZm9udFN0eWxlKSArIFwiIFwiICsgdGhpcy5mb250U2l6ZSArIHRoaXMuX2xvb2t1cEZvbnRVbml0KHRoaXMuZm9udFVuaXQpICsgXCIgXCIgKyB0aGlzLmZvbnRGYW1pbHk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVidWdEcmF3LmNhbGwodGhpcywgY3R4KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBMYWJlbDtcclxuICAgIH0oQWN0b3JfNC5BY3RvcikpO1xyXG4gICAgZXhwb3J0cy5MYWJlbCA9IExhYmVsO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JQXVkaW9cIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSUF1ZGlvSW1wbGVtZW50YXRpb25cIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIlJlc291cmNlcy9Tb3VuZFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlV0aWwvTG9nXCIsIFwiVXRpbC9VdGlsXCIsIFwiUHJvbWlzZXNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBMb2dfNiwgVXRpbCwgUHJvbWlzZXNfNSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvLyBzZXQgdXAgYXVkaW8gY29udGV4dCByZWZlcmVuY2VcclxuICAgIC8vIHdoZW4gd2UgaW50cm9kdWNlIG11bHRpLXRyYWNraW5nLCB3ZSBtYXkgbmVlZCB0byBtb3ZlIHRoaXMgdG8gYSBmYWN0b3J5IG1ldGhvZFxyXG4gICAgaWYgKHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcclxuICAgICAgICB2YXIgYXVkaW9Db250ZXh0ID0gbmV3IHdpbmRvdy5BdWRpb0NvbnRleHQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXVkaW8gaW1wbGVtZW50YXRpb24gZm9yIEhUTUw1IGF1ZGlvLlxyXG4gICAgICovXHJcbiAgICB2YXIgQXVkaW9UYWcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEF1ZGlvVGFnKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhbnNmb3JtcyByYXcgQmxvYiBkYXRhIGludG8gYSBvYmplY3QgVVJMIGZvciB1c2UgaW4gYXVkaW8gdGFnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLnByb2Nlc3NEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlc181LlByb21pc2UucmVzb2x2ZSh1cmwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBhdWRpbyB0YWcgcmVmZXJlbmNpbmcgdGhlIHByb3ZpZGVkIGF1ZGlvIFVSTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5jcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdWRpb1RhZ0luc3RhbmNlKHVybCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQXVkaW9UYWc7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5BdWRpb1RhZyA9IEF1ZGlvVGFnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhdWRpbyBpbXBsZW1lbnRhdGlvbiBmb3IgV2ViIEF1ZGlvIEFQSS5cclxuICAgICAqL1xyXG4gICAgdmFyIFdlYkF1ZGlvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBXZWJBdWRpbygpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nXzYuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvY2Vzc2VzIHJhdyBhcnJheWJ1ZmZlciBkYXRhIGFuZCBkZWNvZGVzIGludG8gV2ViQXVkaW8gYnVmZmVyIChhc3luYykuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLnByb2Nlc3NEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IFByb21pc2VzXzUuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICBhdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGRhdGEsIGZ1bmN0aW9uIChidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoYnVmZmVyKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcignVW5hYmxlIHRvIGRlY29kZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnIHRoaXMgYnJvd3NlciBtYXkgbm90IGZ1bGx5IHN1cHBvcnQgdGhpcyBmb3JtYXQsIG9yIHRoZSBmaWxlIG1heSBiZSBjb3JydXB0LCAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaWYgdGhpcyBpcyBhbiBtcDMgdHJ5IHJlbW92aW5nIGlkMyB0YWdzIGFuZCBhbGJ1bSBhcnQgZnJvbSB0aGUgZmlsZS4nKTtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgV2ViQXVkaW8gQXVkaW9CdWZmZXJTb3VyY2VOb2RlIHRvIHBsYXkgYSBzb3VuZCBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5jcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdWRpb0luc3RhbmNlKGJ1ZmZlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbGF5IGFuIGVtcHR5IHNvdW5kIHRvIHVubG9jayBTYWZhcmkgV2ViQXVkaW8gY29udGV4dC4gQ2FsbCB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgICAgICogcmlnaHQgYWZ0ZXIgYSB1c2VyIGludGVyYWN0aW9uIGV2ZW50LiBUeXBpY2FsbHkgdXNlZCBieSBbW1BhdXNlQWZ0ZXJMb2FkZXJdXVxyXG4gICAgICAgICAqIEBzb3VyY2UgaHR0cHM6Ly9wYXVsYmFrYXVzLmNvbS90dXRvcmlhbHMvaHRtbDUvd2ViLWF1ZGlvLW9uLWlvcy9cclxuICAgICAgICAgKi9cclxuICAgICAgICBXZWJBdWRpby51bmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChXZWJBdWRpby5fdW5sb2NrZWQgfHwgIWF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBlbXB0eSBidWZmZXIgYW5kIHBsYXkgaXRcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMSwgMjIwNTApO1xyXG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgICAgICAgICB2YXIgZW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgc291cmNlLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICAgICAgc291cmNlLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmRlZCA9IHRydWU7IH07XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2Uubm90ZU9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkXHJcbiAgICAgICAgICAgICAgICBzb3VyY2Uubm90ZU9uKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc291cmNlLnN0YXJ0KDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGJ5IGNoZWNraW5nIHRoZSBwbGF5IHN0YXRlIGFmdGVyIHNvbWUgdGltZSwgd2Uga25vdyBpZiB3ZSdyZSByZWFsbHkgdW5sb2NrZWRcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnBsYXliYWNrU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVnYWN5U291cmNlID0gc291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWdhY3lTb3VyY2UucGxheWJhY2tTdGF0ZSA9PT0gbGVnYWN5U291cmNlLlBMQVlJTkdfU1RBVEUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVnYWN5U291cmNlLnBsYXliYWNrU3RhdGUgPT09IGxlZ2FjeVNvdXJjZS5GSU5JU0hFRF9TVEFURSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBXZWJBdWRpby5fdW5sb2NrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb0NvbnRleHQuY3VycmVudFRpbWUgPiAwIHx8IGVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFdlYkF1ZGlvLl91bmxvY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvLmlzVW5sb2NrZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmxvY2tlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBXZWJBdWRpbztcclxuICAgIH0oKSk7XHJcbiAgICBXZWJBdWRpby5fdW5sb2NrZWQgPSBmYWxzZTtcclxuICAgIGV4cG9ydHMuV2ViQXVkaW8gPSBXZWJBdWRpbztcclxuICAgIC8qKlxyXG4gICAgICogRmFjdG9yeSBtZXRob2QgdGhhdCBnZXRzIHRoZSBhdWRpbyBpbXBsZW1lbnRhdGlvbiB0byB1c2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0QXVkaW9JbXBsZW1lbnRhdGlvbigpIHtcclxuICAgICAgICBpZiAod2luZG93LkF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1ZGlvKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1ZGlvVGFnKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5nZXRBdWRpb0ltcGxlbWVudGF0aW9uID0gZ2V0QXVkaW9JbXBsZW1lbnRhdGlvbjtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFtbU291bmRdXSBvYmplY3QgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGF1ZGlvXHJcbiAgICAgKiBjb21wb25lbnRzLCBmcm9tIHNvdW5kdHJhY2tzIHRvIHNvdW5kIGVmZmVjdHMuIFtbU291bmRdXSBpcyBhbiBbW0lMb2FkYWJsZV1dXHJcbiAgICAgKiB3aGljaCBtZWFucyBpdCBjYW4gYmUgcGFzc2VkIHRvIGEgW1tMb2FkZXJdXSB0byBwcmUtbG9hZCBiZWZvcmUgYSBnYW1lIG9yIGxldmVsLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpTb3VuZHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgU291bmQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBwYXRocyBBIGxpc3Qgb2YgYXVkaW8gc291cmNlcyAoY2xpcC53YXYsIGNsaXAubXAzLCBjbGlwLm9nZykgZm9yIHRoaXMgYXVkaW8gY2xpcC4gVGhpcyBpcyBkb25lIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gU291bmQoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRocyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgcGF0aHNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dfNi5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZSA9IDEuMDtcclxuICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qIENocm9tZSA6IE1QMywgV0FWLCBPZ2dcclxuICAgICAgICAgICAgICAgKiBGaXJlZm94IDogV0FWLCBPZ2csXHJcbiAgICAgICAgICAgICAgICogSUUgOiBNUDMsIFdBViBjb21pbmcgc29vblxyXG4gICAgICAgICAgICAgICAqIFNhZmFyaSBNUDMsIFdBViwgT2dnXHJcbiAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9ICcnO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHBhdGhzXzEgPSBwYXRoczsgX2EgPCBwYXRoc18xLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBwYXRoc18xW19hXTtcclxuICAgICAgICAgICAgICAgIGlmIChTb3VuZC5jYW5QbGF5RmlsZShwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhbnkgb2YgdGhlIGF1ZGlvIGZpbGVzIHNwZWNpZmllZDonLCBwYXRocy5qb2luKCcsICcpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdBdHRlbXB0aW5nIHRvIHVzZScsIHBhdGhzWzBdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhdGhzWzBdOyAvLyBzZWxlY3QgdGhlIGZpcnN0IHNwZWNpZmllZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc291bmQgPSBnZXRBdWRpb0ltcGxlbWVudGF0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGNhbiBwbGF5IHRoaXMgZmlsZSBhcyBIVE1MNSBBdWRpb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLmNhblBsYXlGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gbmV3IEF1ZGlvKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXR5cGUgPSAvLipcXC4oW0EtWmEtejAtOV0rKSQvO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWxlLm1hdGNoKGZpbGV0eXBlKVsxXTtcclxuICAgICAgICAgICAgICAgIGlmIChhLmNhblBsYXlUeXBlKCdhdWRpby8nICsgdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzYuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQ2Fubm90IGRldGVybWluZSBhdWRpbyBzdXBwb3J0LCBhc3N1bWluZyBubyBzdXBwb3J0IGZvciB0aGUgQXVkaW8gVGFnJywgZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS53aXJlRW5naW5lID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ2hpZGRlbicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5naW5lLnBhdXNlQXVkaW9XaGVuSGlkZGVuICYmIF90aGlzLmlzUGxheWluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLm9uKCd2aXNpYmxlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmdpbmUucGF1c2VBdWRpb1doZW5IaWRkZW4gJiYgX3RoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBob3cgbWFueSBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5pbnN0YW5jZUNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tzLmxlbmd0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHZvbHVtZSBvZiB0aGUgc291bmQgY2xpcFxyXG4gICAgICAgICAqIEBwYXJhbSB2b2x1bWUgIEEgdm9sdW1lIHZhbHVlIGJldHdlZW4gMC0xLjBcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZvbHVtZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92b2x1bWUgPSB2b2x1bWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl90cmFja3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0cmFjay5zZXRWb2x1bWUodm9sdW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1NldCB2b2x1bWUgZm9yIGFsbCBpbnN0YW5jZXMgb2Ygc291bmQnLCB0aGlzLnBhdGgsICd0bycsIHZvbHVtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY2xpcCBzaG91bGQgbG9vcCB3aGVuIGNvbXBsZXRlXHJcbiAgICAgICAgICogQHBhcmFtIGxvb3AgIFNldCB0aGUgbG9vcGluZyBmbGFnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAobG9vcCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gbG9vcDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3RyYWNrczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHRyYWNrLnNldExvb3AobG9vcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTZXQgbG9vcCBmb3IgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCwgJ3RvJywgbG9vcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc291bmQgaXMgcGxheWluZyByaWdodCBub3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tzLnNvbWUoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuaXNQbGF5aW5nKCk7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGxheSB0aGUgc291bmQsIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc291bmQgaXMgZG9uZSBwbGF5aW5nXHJcbiAgICAgICAgICogQW4gb3B0aW9uYWwgdm9sdW1lIGFyZ3VtZW50IGNhbiBiZSBwYXNzZWQgaW4gdG8gcGxheSB0aGUgc291bmQuIE1heCB2b2x1bWUgaXMgMS4wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAodm9sdW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VtZWQgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB3ZSByZXN1bWUgKmN1cnJlbnQqIHRyYWNrcyAoaWYgcGF1c2VkKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3RyYWNrczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1lZC5wdXNoKHRyYWNrLnBsYXkoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHBhdXNlZCwgZG9uJ3Qgc3RhcnQgcGxheWluZyBuZXcgdHJhY2tcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdSZXN1bWluZyBwYXVzZWQgaW5zdGFuY2VzIGZvciBzb3VuZCcsIHRoaXMucGF0aCwgdGhpcy5fdHJhY2tzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHdoZW4gcmVzdW1lZCB0cmFja3MgYXJlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZXNfNS5Qcm9taXNlLmpvaW4ocmVzdW1lZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwdXNoIGEgbmV3IHRyYWNrXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VHJhY2sgPSB0aGlzLnNvdW5kLmNyZWF0ZUluc3RhbmNlKHRoaXMuX2RhdGEpO1xyXG4gICAgICAgICAgICAgICAgbmV3VHJhY2suc2V0TG9vcCh0aGlzLl9sb29wKTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2x1bWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdUcmFjay5zZXRWb2x1bWUoVXRpbC5jbGFtcCh2b2x1bWUsIDAuMCwgMS4wKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdUcmFjay5zZXRWb2x1bWUodGhpcy5fdm9sdW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrcy5wdXNoKG5ld1RyYWNrKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnUGxheWluZyBuZXcgaW5zdGFuY2UgZm9yIHNvdW5kJywgdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdUcmFjay5wbGF5KCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBkb25lLCByZW1vdmUgdHJhY2tcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdHJhY2tzLnNwbGljZShfdGhpcy5fdHJhY2tzLmluZGV4T2YobmV3VHJhY2spLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VzXzUuUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9wIHRoZSBzb3VuZCwgYW5kIGRvIG5vdCByZXdpbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl90cmFja3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0cmFjay5wYXVzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdQYXVzZWQgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9wIHRoZSBzb3VuZCBhbmQgcmV3aW5kXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSB0aGlzLl90cmFja3MuY29uY2F0KFtdKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0cmFja3NfMSA9IHRyYWNrczsgX2kgPCB0cmFja3NfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc18xW19pXTtcclxuICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1N0b3BwZWQgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNvdW5kIGlzIGxvYWRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVnaW5zIGxvYWRpbmcgdGhlIHNvdW5kIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBQcm9taXNlc181LlByb21pc2UoKTtcclxuICAgICAgICAgICAgaWYgKCEhdGhpcy5nZXREYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnQWxyZWFkeSBoYXZlIGRhdGEgZm9yIGF1ZGlvIHJlc291cmNlJywgdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUodGhpcy5zb3VuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1N0YXJ0ZWQgbG9hZGluZyBzb3VuZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mZXRjaFJlc291cmNlKGZ1bmN0aW9uIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcignRmFpbGVkIHRvIGxvYWQgYXVkaW8gcmVzb3VyY2UgJywgX3RoaXMucGF0aCwgJyBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3IgY29kZScsIHJlcXVlc3Quc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25lcnJvcihyZXF1ZXN0LnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBsb2FkIHNvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0RGF0YShyZXF1ZXN0LnJlc3BvbnNlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdDb21wbGV0ZWQgbG9hZGluZyBzb3VuZCcsIF90aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLnNvdW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gY29tcGxldGUucmVzb2x2ZShlKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdFcnJvciBsb2FkaW5nIHNvdW5kISBJZiB0aGlzIGlzIGEgY3Jvc3Mgb3JpZ2luIGVycm9yLCBcXFxyXG4gICAgICAgICAgICB5b3UgbXVzdCBob3N0IHlvdXIgc291bmQgd2l0aCB5b3VyIGh0bWwgYW5kIGphdmFzY3JpcHQuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLl9mZXRjaFJlc291cmNlID0gZnVuY3Rpb24gKG9ubG9hZCkge1xyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHRoaXMucGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5zb3VuZC5yZXNwb25zZVR5cGU7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gdGhpcy5vbmVycm9yO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ubG9hZChyZXF1ZXN0KTsgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSByYXcgc291bmQgZGF0YSAoZS5nLiBibG9iIFVSTCBvciBBdWRpb0J1ZmZlcilcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHJhdyBzb3VuZCBkYXRhIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gc291bmQgZGF0YSBpcyBwcm9jZXNzZWRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIFRoZSBYSFIgZGF0YSBmb3IgdGhlIHNvdW5kIGltcGxlbWVudGF0aW9uIHRvIHByb2Nlc3MgKEJsb2Igb3IgQXJyYXlCdWZmZXIpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VuZC5wcm9jZXNzRGF0YShkYXRhKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2RhdGEgPSBfdGhpcy5wcm9jZXNzRGF0YShkYXRhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgcmF3IHNvdW5kIGRhdGEgKGUuZy4gYmxvYiBVUkwgb3IgQXVkaW9CdWZmZXIpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnByb2Nlc3NEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU291bmQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Tb3VuZCA9IFNvdW5kO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBjbGFzcyByZXByZXNlbnRpbmcgYSBIVE1MNSBhdWRpbyBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgdmFyIEF1ZGlvVGFnSW5zdGFuY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEF1ZGlvVGFnSW5zdGFuY2Uoc3JjKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZSA9IDEuMDtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50ID0gbmV3IEF1ZGlvKHNyYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGxheWluZztcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZSwgXCJsb29wXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9vcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5sb29wID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpcmVVcE9uRW5kZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92b2x1bWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LnZvbHVtZSA9IFV0aWwuY2xhbXAodmFsdWUsIDAsIDEuMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlpbmdQcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQubG9hZCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQubG9vcCA9IHRoaXMuX2xvb3A7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5wbGF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdQcm9taXNlID0gbmV3IFByb21pc2VzXzUuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LnBsYXkoKTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fd2lyZVVwT25FbmRlZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5wYXVzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQuY3VycmVudFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVPbkVuZGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5fd2lyZVVwT25FbmRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9sb29wKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQub25lbmRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9oYW5kbGVPbkVuZGVkKCk7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLl9oYW5kbGVPbkVuZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheWluZ1Byb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBdWRpb1RhZ0luc3RhbmNlO1xyXG4gICAgfSgpKTtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgY2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViIEF1ZGlvIEF1ZGlvQnVmZmVyU291cmNlTm9kZSBpbnN0YW5jZVxyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0F1ZGlvX0FQSVxyXG4gICAgICovXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgdmFyIFdlYkF1ZGlvSW5zdGFuY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFdlYkF1ZGlvSW5zdGFuY2UoX2J1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBfYnVmZmVyO1xyXG4gICAgICAgICAgICB0aGlzLl92b2x1bWVOb2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fdm9sdW1lID0gMS4wO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3VycmVudCBwbGF5YmFjayBvZmZzZXQgKGluIHNlY29uZHMpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNQbGF5aW5nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl92b2x1bWVOb2RlLmdhaW4udmFsdWUgPSBVdGlsLmNsYW1wKHZhbHVlLCAwLCAxLjApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9idWZmZXJTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5sb29wID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWluZ1Byb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZU5vZGUuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLnN0YXJ0KDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdQcm9taXNlID0gbmV3IFByb21pc2VzXzUuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYSBidWZmZXIgc291cmNlIGNhbiBvbmx5IGJlIHN0YXJ0ZWQgb25jZVxyXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGRpc3Bvc2Ugb2YgdGhlIHByZXZpb3VzIGluc3RhbmNlIGJlZm9yZVxyXG4gICAgICAgICAgICAvLyBcInJlc3VtaW5nXCIgdGhlIG5leHQgb25lXHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5vbmVuZGVkID0gbnVsbDsgLy8gZGlzcG9zZSBvZiBhbnkgcHJldmlvdXMgZXZlbnQgaGFuZGxlclxyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gKDEgLyB0aGlzLl9idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlKSAqIHRoaXMuX2J1ZmZlci5kdXJhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLnN0YXJ0KDAsIHRoaXMuX2N1cnJlbnRPZmZzZXQgJSBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpcmVVcE9uRW5kZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLl9jcmVhdGVCdWZmZXJTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLmJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLmxvb3AgPSB0aGlzLl9sb29wO1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gMS4wO1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2UuY29ubmVjdCh0aGlzLl92b2x1bWVOb2RlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5zdG9wKDApO1xyXG4gICAgICAgICAgICAvLyBQbGF5YmFjayByYXRlIHdpbGwgYmUgYSBzY2FsZSBmYWN0b3Igb2YgaG93IGZhc3Qvc2xvdyB0aGUgYXVkaW8gaXMgYmVpbmcgcGxheWVkXHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgMS4wXHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaW52ZXJ0IGl0IHRvIGdldCB0aGUgdGltZSBzY2FsZVxyXG4gICAgICAgICAgICB2YXIgcGJSYXRlID0gMSAvICh0aGlzLl9idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlIHx8IDEuMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSAqIHBiUmF0ZSkgLyAxMDAwOyAvLyBpbiBzZWNvbmRzXHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5zdG9wKDApO1xyXG4gICAgICAgICAgICAvLyBoYW5kbGVyIHdpbGwgbm90IGJlIHdpcmVkIHVwIGlmIHdlIHdlcmUgbG9vcGluZ1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2J1ZmZlclNvdXJjZS5vbmVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVPbkVuZGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuX3dpcmVVcE9uRW5kZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9vcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faGFuZGxlT25FbmRlZCgpOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5faGFuZGxlT25FbmRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gcGF1c2luZyBjYWxscyBzdG9wKDApIHdoaWNoIHRyaWdnZXJzIG9uZW5kZWQgZXZlbnRcclxuICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgXCJyZXNvbHZlXCIgeWV0ICh3aGVuIHdlIHJlc3VtZSB3ZSdsbCB0cnkgYWdhaW4pXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheWluZ1Byb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFdlYkF1ZGlvSW5zdGFuY2U7XHJcbiAgICB9KCkpO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JTG9hZGVyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJMb2FkZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiUmVzb3VyY2VzL1NvdW5kXCIsIFwiVXRpbC9Mb2dcIiwgXCJQcm9taXNlc1wiLCBcIkNsYXNzXCIsIFwiVXRpbC9EcmF3VXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbG9yXzEyLCBTb3VuZF8xLCBMb2dfNywgUHJvbWlzZXNfNiwgQ2xhc3NfMywgRHJhd1V0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmUtbG9hZGluZyBhc3NldHNcclxuICAgICAqXHJcbiAgICAgKiBUaGUgbG9hZGVyIHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIHByZWxvYWQgbXVsdGlwbGUgcmVzb3VyY2VzIGF0XHJcbiAgICAgKiBvbmUgdGltZS4gVGhlIGxvYWRlciBtdXN0IGJlIHBhc3NlZCB0byB0aGUgZW5naW5lIGluIG9yZGVyIHRvXHJcbiAgICAgKiB0cmlnZ2VyIHRoZSBsb2FkaW5nIHByb2dyZXNzIGJhci5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgW1tMb2FkZXJdXSBpdHNlbGYgaW1wbGVtZW50cyBbW0lMb2FkYWJsZV1dIHNvIHlvdSBjYW4gbG9hZCBsb2FkZXJzLlxyXG4gICAgICpcclxuICAgICAqICMjIEV4YW1wbGU6IFByZS1sb2FkaW5nIHJlc291cmNlcyBmb3IgYSBnYW1lXHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIC8vIGNyZWF0ZSBhIGxvYWRlclxyXG4gICAgICogdmFyIGxvYWRlciA9IG5ldyBleC5Mb2FkZXIoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBjcmVhdGUgYSByZXNvdXJjZSBkaWN0aW9uYXJ5IChiZXN0IHByYWN0aWNlIGlzIHRvIGtlZXAgYSBzZXBhcmF0ZSBmaWxlKVxyXG4gICAgICogdmFyIHJlc291cmNlcyA9IHtcclxuICAgICAqICAgVGV4dHVyZUdyb3VuZDogbmV3IGV4LlRleHR1cmUoXCIvaW1hZ2VzL3RleHR1cmVzL2dyb3VuZC5wbmdcIiksXHJcbiAgICAgKiAgIFNvdW5kRGVhdGg6IG5ldyBleC5Tb3VuZChcIi9zb3VuZC9kZWF0aC53YXZcIiwgXCIvc291bmQvZGVhdGgubXAzXCIpXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIC8vIGxvb3AgdGhyb3VnaCBkaWN0aW9uYXJ5IGFuZCBhZGQgdG8gbG9hZGVyXHJcbiAgICAgKiBmb3IgKHZhciBsb2FkYWJsZSBpbiByZXNvdXJjZXMpIHtcclxuICAgICAqICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShsb2FkYWJsZSkpIHtcclxuICAgICAqICAgICBsb2FkZXIuYWRkUmVzb3VyY2UocmVzb3VyY2VzW2xvYWRhYmxlXSk7XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBzdGFydCBnYW1lXHJcbiAgICAgKiBnYW1lLnN0YXJ0KGxvYWRlcikudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgKiAgIGNvbnNvbGUubG9nKFwiR2FtZSBzdGFydGVkIVwiKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHZhciBMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhMb2FkZXIsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGxvYWRhYmxlcyAgT3B0aW9uYWxseSBwcm92aWRlIHRoZSBsaXN0IG9mIHJlc291cmNlcyB5b3Ugd2FudCB0byBsb2FkIGF0IGNvbnN0cnVjdG9yIHRpbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBMb2FkZXIobG9hZGFibGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZXNvdXJjZUxpc3QgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2luZGV4ID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX3Jlc291cmNlQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5fbnVtTG9hZGVkID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX3Byb2dyZXNzQ291bnRzID0ge307XHJcbiAgICAgICAgICAgIF90aGlzLl90b3RhbENvdW50cyA9IHt9O1xyXG4gICAgICAgICAgICAvLyBsb2dvIGRyYXdpbmcgc3R1ZmZcclxuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXHJcbiAgICAgICAgICAgIC8vIGJhc2U2NCBzdHJpbmcgZW5jb2Rpbmcgb2YgdGhlIGV4Y2FsaWJ1ciBsb2dvIChsb2dvLXdoaXRlLnBuZylcclxuICAgICAgICAgICAgX3RoaXMubG9nbyA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWRRQUFBQjJDQVlBQUFCeGhHSTlBQUFBQ1hCSVdYTUFBQXNTQUFBTEVnSFMzWDc4QUFBS25VbEVRVlI0MnUzZFAyd2pTeDBIOE44aEpJb25JUm1KanNxMFNCUitCUTFkY3FLaGUwbEQ3N1N2U3dwS2tKS0dQdWxwa3RmUklNVWRFcUtJcVY1N3JwQW9rTTRkYlNpeXE3T05QVFA3eDM5aWZ6N1NGYm5FbnAzeGVyNDdPN3V6SDE1Zlh3TUE2T1lIbWdBQUJDb0FDRlFBRUtnQWdFQUZBSUVLQUFJVkFBUXFBQ0JRQVVDZ0FvQkFCUUNCQ2dBSVZBQVFxQUFnVUFGQW9BSUFBaFVBQkNvQUNGUUFFS2dBZ0VDRkxibU9pTmVGZjJQYkF5ejY4UHI2cWhVZ2JSd1I5MnYrL3p3aUpyWUhNRUtGTW1jTi8vL1V0Z2NRcUZCazFQRC85N1U5UXg4VkNGU2d1NEVtQUlFS0FBSVZBQVFxQUNCUTRaMjVqb2pQOGVYKzBXdE5BZ0lWYU9ZK0ltNWorZUtoMjRoNDFqUWdVSUV5WjdGNU5hUFU3d0NCQ2l3WWQvdzljT0IrcUFsZ0ozS0xMb3cwRVYxOTg4MDNSV3ZKZnZmZGR4KzBsaEVxSEt1NUpnQWpWQ0J2bGhtRnpqUVJYVWVrSHo5K1RQNzl5OHVMUmpOQ2hYZnZvZVB2QVlFS3hOdGoxZTQyL081Sm9JSkFCY3JkUk1SVkxNK1gza1RFcGFhQjk4OGNLdXpXZzlFb2JUV2RNeDBPbHk4dU40ZHFoQW9BUnFnbmFOM2FySGZxdTdPeUg4SXRLTFZCL1ArQ0VmTVRIeUdQWTNucHgxbTh6V0dERWVvQmZVay94ZHRpNTdkci9yMVd2Mis2RVBvdzN0WjVyUmRTNzJzMW5ldUY5N3h2V2QrWFRIMC9WK1VNdHREV3FiSS9yMm5yeGZwK2p2MnVTalNPN1MrT1h5L0EvM2xOKzl4WDVUNUh4RVVQWlowdGZCNzErdzU3ZUovSEZ1K3oramt2MXU5MllYOWZiSS9IaFgzSkE5cnA1TVByNjZ0V2FHOVVmVUdickhJemk3Y0xVeVlGZi90cFRhZHkwM0VFZUw4bVVKNmk3TUtZTnZXTnFyNFBlMmpyYWRYTzYwTHJ2UEF6MlBRNVJQWDY4NGFoOGR4RCsyemFudG5DZ1ZpcFNWVittL3RnQjlXMkREcTJTeC92TTk1d2NIaFpoV1ZKbTh5cnY1OGNTZ2ZUZGM3MCsrKy9YL3I1MjIrL3RVS1NFZXBCcW8rb200WkxQZXJNalV3dU5uUUN0eDFHV0p0ZWUxRndkRDV1V2Q4NnhMczhVYVZ0MmFORU8xL3NhWi9aNXJZTVc0enE2djM0ckdWOUJnM3EyZVo5U2tlTm05cXd5VWgzME9QSUhZRkt4NUZHMDNDN3puU09xWUJxK3FXL3pwUTNhbkgwMzdUTkhsdUc2ZjBXUHNQaEh2YWI0UUZ0eTdvZ09ldXhEWWNOeTIvenUyMjE0V05ZV3htQnVyTk84YkduOTdwTkJPTzh4eS85dUNvclpaNEkycjRDN2FKZ083WlY5aUU0OURtNk52T1d4K3BXRTlDVXEzemJkVHA5ZG96MzhUYlh0enFIOVJUNUN5V2U0MjJPYVpvWkdlWkNhYnJoUFFZOUhqd3NqcFR2Q2c0WXRsRTIrVGEvajJiem44ZnFyRHFnbSs2eVVIT21BdldVakF0R2hiTll2c0JrbkRucUgxUWhjN1ZteEhnZWIvTmJ1ZEE1ai9VWGxZd2lmMnA2bHVoQWM5dGV1MW5waUhLbkRzOGlmNnRDbTdKTFgzTktwZ3R0WGU5cnVjOW1ITWQ3YTgzaXdkeEY1dnQ4dHV0QVJhQ2VrbFJuTks5QzhXbk5GN2dlSlE0VDRYRzNKaFNuVmRpbFFyRyt5T25ybFZIZnNFR1l6aE5CbjdMdTZ0UzcrSEphZkpRNEVNaU5sTnFXWFo5V1B2VmduVllIRzVNMUJ5RFhrVDZsZVgyRWdUcUp0eXQ0NXl2N1MycU8zc0VaalpoRExYZVIrWUtkSjBaZGs4UW9jdkg5TjczMktyTnRxK0ZaL3p6SUhBQmNKcllwZCtYdjE0bE9kNWFwNzZTZ3JkdVcvVlRRMXFjUXBxbmJndTRpZlp2VU1OcGQ5WHVvWm12Q3RQYVEyWS9CQ0hWTGdickpUZVJQRGRWZjZwZk1LRFUyZk9rSG1WRkZmWHIzTXNvdUxzbk52VjVrUm9lNStzNDMxUGV1b0tQcVduYXVyWS9aUEJFZXF3Y2VONGw5Nml3TzZIN01qcTR5N1ZHUFZOZTEwVmFaTXpWQ1BWV3BJL1o2RlpiY3Y1Zk1xR0NVK2RMZkZHemo1OGpQOCtiQ2RKQ283eXpLVHdkT0YwYnU5VWc3VjRjK3l6N0ZKZlllR295c1VzczBIc3NJZFZad1lMRHVqTXFsRVNvQ2RUdEdzWnRiSG5KQmVOZERTSlNzMGpUS2RNSk4xSE5YNTRXdjdidnNVOU5rVkpWYTEzZFgrL3d1QXJWMFgvbDVSSHlvL2xuZkY0RzZwNkRyUzBrSGR0WGh5MzVUR0VyRFBZWlVuMldmV3FET28vbFZxZE1EMk8vaEtKaEQ3Uy9vZHVreW1xOXMwMlFONEVFUFIvemJhT3VtWmMrcjE1eksxWnF6bmw5anNmaWVtVE0xUW1WM0hVdVRrZWRsZzlISVF6UmJVRDkzZGZDKzJ0cGoyZklIRUgyK1JxQ0NRSDEzZ1pxN2hXWFROcFZ1MTlPQjFmYzluUTBBS09LVWI1bFUwUDFrRHlPbmVvV2swbE9aOWNJUDB4N3F1OCsyQmhDb1Iyd1l1MStlN0RtYVh6QlNzdTV2YVgxbmUyenJwbVVQVG14ZjdQTTFEbTR5L3ZDN255N05pZjcrei85Wm10TTBaM3BhblBMdFBtcmE5ZjE2YmNLMERwYm53azQzVmQvUkh0dTZ6Zk5RVHkxUUJ5M2FxRzJnOW5WbXhtbCtCT29KeVQzTnBXbW45eGhmRm51NGJ2RGErNDRCWGhxcWZkZjN1VUY5K3l6NzdBVDMxWXVlMm1qZWNZUTYyTkxmZ2tBOWdoSHFMTkVoTmVtNEgxYzZ2ZHlEeGhmL2JwejVtNGNvVy9jMzl3aTZWSDJiUHRIbGNhVjljdlh0cyt6eENlNnJUZXFjMm5kTDd1R2Q5M1F3TTliRmNBek1vWlo3U2dUQmJXeCthc3VpNjFoL2lxMStSbWpxZGJuUVhRM1QxRE5RNjNWL1U5dWNxbS9wTXpQYjFyZVBzay8xaVRPamd2YXRSNFczTGM4VUxCNzhwRUx5cm5BZmVUY2oxTlU1MDkvODZtZkozMy84K01mMDBhMDVVeVBVRXc3VVZDZVdHL1dORWlFeHlIUk10NWx0VzMwaXpVUGsxOHl0dDdsTmZjOGkvL0R2dHZYdG8reVNBNUJqbGpzTFVGOGxQa3FNUEV0VzFKb21Ec2lHQlo5QnliNE5BdlVJVFNOOUd1d3NJajZ0NlVUT3FrN2pKUkVrbXpxbGk4eElzOTZ1ZFNPMjBzWDBIMXZXOTJJTDllMWE5cmdxVnlmOTFnYlBzVHk5VUQ5bjlsT2tUOGsrUmZrRlI1UE1OcXhPY2RTZjMyUEJ2ZzN2aWxPK3pkeEUrb2t4OVdtMHBoMzZYWXNSWkNwTUY5OTNHT2s1cXZxQjNEY3Q2anZzc2I2N0t2dVVOSjNmcnc5MmJocjgvU1RTRjBKZFJQTUxwVUNnbnNnbzlTNzZQWjI0NlpGazF3V3ZLNW0zdlZvWXZXMVN6N25OOTFqZlhiUTFaUWM3VFc2SGVhb09hbHlwRy84L3AvclAxYU5BYzZaSHpTbmZkcVBVUGhkeTJQUXc2Tno5Z1NWaHVoaXF1ZVVIUjN1dTd5N0szcmREWDR1NDZaclBiVWEwSUZCWjBzZUtRM1hRVFJ0MnZtM1cvYTJEYk5LeXMrK3J2bTNlcDYreTF4MlVkUDNiV1U5bHpyYTQ3VTFHbWxjdFgvc1EyM3QrYU9sQnlMVGgvNE5BUGFDUnh0Y2RPNUhMU0ovNnZOdEN3R3g2N1ZQbVBidldkMXE5ZnJLSHRwNGtBcVJKMkhSOWo3NjJKZlgzYlovL2VsUHRqMTNQUER4MStENXRxay9YaTZOTzhTSHo3TW1IMTlkWHJkQk5mVkZQNlQyUFQxVUhOaXQ4Ny90NG01K2FSSCtuUUJkdnF5aFpES0pMZlpzOGg3WFBzcWRWMlpPVit0YW5LQjhhbG4wZHl4ZEFYYlY0ajRndnQ0b01PcmJQNnZiVTczTlc3VE1sYmRUblByV3BmcVhmaDlIS1o5dmtlN0t1VGVaUk50WFJTZTYrMUZWLy9jZS9sbjVlWGZzWGdjcVh6cjYrOTI2MU0zbW9Pb2E3RTZudlRaVGZ5N2lOc21mYjdramZnWEdzdnhlMHZpaHNFdHM5SFRxdVBwdDFxMXZ0YWh1MlRxQWlVQUVFS2owemh3b0FScWdBdS9PblgvNDQyV0grOXhjL1d2cjU4cmUvVHI3ZjQxLytac1JxaEFvQUNGUUFFS2dBY0hqTW9RSnNrSnN6L2VxcnI1Wit2dnI3djVmbVFGZXZBbDVsenRRSUZRQVFxQUFnVUFIZ0lKbERCZGhnZFE0MU4yZUtFU29BSUZBQlFLQUN3RkV3aHdvQVJxZ0FJRkFCUUtBQ0FBSVZBQVFxQUFoVUFCQ29BSUJBQlFDQkNnQUNGUUFFS2dBZ1VBRkFvQUtBUUFVQWdRb0FDRlFBRUtnQUlGQUJRS0FDQUFJVkFBUXFBQWhVQUJDb0FJQkFCUUNCQ2dBQ0ZRQVFxQUFnVUFGQW9BS0FRQVVBbHZ3UGNGRG5zMURzSDRzQUFBQUFTVVZPUks1Q1lJST0nO1xyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xyXG4gICAgICAgICAgICBfdGhpcy5sb2dvV2lkdGggPSA0Njg7XHJcbiAgICAgICAgICAgIF90aGlzLmxvZ29IZWlnaHQgPSAxMTg7XHJcbiAgICAgICAgICAgIF90aGlzLmJhY2tncm91bmRDb2xvciA9ICcjMTc2QkFBJztcclxuICAgICAgICAgICAgX3RoaXMuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICBfdGhpcy5zZXREYXRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIF90aGlzLnByb2Nlc3NEYXRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIF90aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzcuTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1tleC5Mb2FkZXJdIExvYWRpbmcgJyArICgxMDAgKiBlLmxvYWRlZCAvIGUudG90YWwpLnRvRml4ZWQoMCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIF90aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgaWYgKGxvYWRhYmxlcykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkUmVzb3VyY2VzKGxvYWRhYmxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9hZGVyLnByb3RvdHlwZSwgXCJfaW1hZ2VcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faW1hZ2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LnNyYyA9IHRoaXMubG9nbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbWFnZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIDtcclxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLndpcmVFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhIHJlc291cmNlIHRvIHRoZSBsb2FkZXIgdG8gbG9hZFxyXG4gICAgICAgICAqIEBwYXJhbSBsb2FkYWJsZSAgUmVzb3VyY2UgdG8gYWRkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5hZGRSZXNvdXJjZSA9IGZ1bmN0aW9uIChsb2FkYWJsZSkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5faW5kZXgrKztcclxuICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2VMaXN0LnB1c2gobG9hZGFibGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc0NvdW50c1trZXldID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxDb3VudHNba2V5XSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc291cmNlQ291bnQrKztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIHRoZSBsb2FkZXIgdG8gbG9hZFxyXG4gICAgICAgICAqIEBwYXJhbSBsb2FkYWJsZXMgIFRoZSBsaXN0IG9mIHJlc291cmNlcyB0byBsb2FkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5hZGRSZXNvdXJjZXMgPSBmdW5jdGlvbiAobG9hZGFibGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gbG9hZGFibGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUmVzb3VyY2UobG9hZGFibGVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBsb2FkZXIgaGFzIGNvbXBsZXRlbHkgbG9hZGVkIGFsbCByZXNvdXJjZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbnVtTG9hZGVkID09PSB0aGlzLl9yZXNvdXJjZUNvdW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVnaW4gbG9hZGluZyBhbGwgb2YgdGhlIHN1cHBsaWVkIHJlc291cmNlcywgcmV0dXJuaW5nIGEgcHJvbWlzZVxyXG4gICAgICAgICAqIHRoYXQgcmVzb2x2ZXMgd2hlbiBsb2FkaW5nIG9mIGFsbCBpcyBjb21wbGV0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IFByb21pc2VzXzYuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVzb3VyY2VMaXN0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbWUub25jb21wbGV0ZS5jYWxsKG1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHByb2dyZXNzQXJyYXkgPSBuZXcgQXJyYXkodGhpcy5fcmVzb3VyY2VMaXN0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc0NodW5rcyA9IHRoaXMuX3Jlc291cmNlTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc291cmNlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2VuZ2luZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHIud2lyZUVuZ2luZShfdGhpcy5fZW5naW5lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gZS50b3RhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZGVkID0gZS5sb2FkZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NBcnJheVtpXSA9IHsgbG9hZGVkOiAoKGxvYWRlZCAvIHRvdGFsKSAqICgxMDAgLyBwcm9ncmVzc0NodW5rcykpLCB0b3RhbDogMTAwIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzUmVzdWx0ID0gcHJvZ3Jlc3NBcnJheS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxvYWRlZDogKGFjY3VtLmxvYWRlZCArIG5leHQubG9hZGVkKSwgdG90YWw6IDEwMCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHsgbG9hZGVkOiAwLCB0b3RhbDogMTAwIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lLm9ucHJvZ3Jlc3MuY2FsbChtZSwgcHJvZ3Jlc3NSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHIub25jb21wbGV0ZSA9IHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZS5fbnVtTG9hZGVkKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLl9udW1Mb2FkZWQgPT09IG1lLl9yZXNvdXJjZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm9uY29tcGxldGUuY2FsbChtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gbG9hZE5leHQobGlzdCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbGlzdFtpbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaXN0W2luZGV4XS5sb2FkKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZE5leHQobGlzdCwgaW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvYWROZXh0KHRoaXMuX3Jlc291cmNlTGlzdCwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRlciBkcmF3IGZ1bmN0aW9uLiBEcmF3cyB0aGUgZGVmYXVsdCBFeGNhbGlidXIgbG9hZGluZyBzY3JlZW4uXHJcbiAgICAgICAgICogT3ZlcnJpZGUgYGxvZ29gLCBgbG9nb1dpZHRoYCwgYGxvZ29IZWlnaHRgIGFuZCBgYmFja2dyb3VuZENvbG9yYCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICogdG8gY3VzdG9taXplIHRoZSBkcmF3aW5nLCBvciBqdXN0IG92ZXJyaWRlIGVudGlyZSBtZXRob2QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gdGhpcy5fZW5naW5lLmNhbnZhc0hlaWdodCAvIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLl9lbmdpbmUuY2FudmFzV2lkdGggLyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gY2FudmFzSGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5taW4odGhpcy5sb2dvV2lkdGgsIGNhbnZhc1dpZHRoICogMC43NSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gKGNhbnZhc1dpZHRoIC8gMikgLSAod2lkdGggLyAyKTtcclxuICAgICAgICAgICAgdmFyIGltYWdlSGVpZ2h0ID0gTWF0aC5mbG9vcih3aWR0aCAqICh0aGlzLmxvZ29IZWlnaHQgLyB0aGlzLmxvZ29XaWR0aCkpOyAvLyBPRyBoZWlnaHQvd2lkdGggZmFjdG9yXHJcbiAgICAgICAgICAgIHZhciBvbGRBbnRpYWxpYXMgPSB0aGlzLl9lbmdpbmUuZ2V0QW50aWFsaWFzaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5zZXRBbnRpYWxpYXNpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDAsIHRoaXMubG9nb1dpZHRoLCB0aGlzLmxvZ29IZWlnaHQsIHgsIHkgLSBpbWFnZUhlaWdodCAtIDIwLCB3aWR0aCwgaW1hZ2VIZWlnaHQpO1xyXG4gICAgICAgICAgICAvLyBsb2FkaW5nIGJveFxyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcclxuICAgICAgICAgICAgRHJhd1V0aWwucm91bmRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIDIwLCAxMCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHdpZHRoICogKHRoaXMuX251bUxvYWRlZCAvIHRoaXMuX3Jlc291cmNlQ291bnQpO1xyXG4gICAgICAgICAgICB2YXIgbWFyZ2luID0gNTtcclxuICAgICAgICAgICAgdmFyIHByb2dyZXNzV2lkdGggPSBwcm9ncmVzcyAtIG1hcmdpbiAqIDI7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAyMCAtIG1hcmdpbiAqIDI7XHJcbiAgICAgICAgICAgIERyYXdVdGlsLnJvdW5kUmVjdChjdHgsIHggKyBtYXJnaW4sIHkgKyBtYXJnaW4sIHByb2dyZXNzV2lkdGggPiAwID8gcHJvZ3Jlc3NXaWR0aCA6IDAsIGhlaWdodCwgNSwgbnVsbCwgQ29sb3JfMTIuQ29sb3IuV2hpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUuc2V0QW50aWFsaWFzaW5nKG9sZEFudGlhbGlhcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZXJmb3JtIGFueSBjYWxjdWxhdGlvbnMgb3IgbG9naWMgaW4gdGhlIGB1cGRhdGVgIG1ldGhvZC4gVGhlIGRlZmF1bHQgYExvYWRlcmAgZG9lcyBub3RcclxuICAgICAgICAgKiBkbyBhbnl0aGluZyBpbiB0aGlzIG1ldGhvZCBzbyBpdCBpcyBzYWZlIHRvIG92ZXJyaWRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgICAgICAvLyBvdmVycmlkYWJsZSB1cGRhdGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBMb2FkZXI7XHJcbiAgICB9KENsYXNzXzMuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuTG9hZGVyID0gTG9hZGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIFtbTG9hZGVyXV0gdGhhdCBwYXVzZXMgYWZ0ZXIgbG9hZGluZyB0byBhbGxvdyB1c2VyXHJcbiAgICAgKiB0byBwcm9jZWVkIHRvIHBsYXkgdGhlIGdhbWUuIFR5cGljYWxseSB5b3Ugd2lsbFxyXG4gICAgICogd2FudCB0byB1c2UgdGhpcyBsb2FkZXIgZm9yIGlPUyB0byBhbGxvdyBzb3VuZHNcclxuICAgICAqIHRvIHBsYXkgYWZ0ZXIgbG9hZGluZyAoQXBwbGUgU2FmYXJpIHJlcXVpcmVzIHVzZXJcclxuICAgICAqIGludGVyYWN0aW9uIHRvIGFsbG93IHNvdW5kcywgZXZlbiBmb3IgZ2FtZXMpXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIEJlY2F1c2UgTG9hZGVyIGlzIG5vdCBwYXJ0IG9mIGEgU2NlbmUsIHlvdSBtdXN0XHJcbiAgICAgKiBjYWxsIGB1cGRhdGVgIGFuZCBgZHJhd2AgbWFudWFsbHkgb24gXCJjaGlsZFwiIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogIyMgSW1wbGVtZW50aW5nIGEgVHJpZ2dlclxyXG4gICAgICpcclxuICAgICAqIFRoZSBgUGF1c2VBZnRlckxvYWRlcmAgcmVxdWlyZXMgYW4gZWxlbWVudCB0byBhY3QgYXMgdGhlIHRyaWdnZXIgYnV0dG9uXHJcbiAgICAgKiB0byBzdGFydCB0aGUgZ2FtZS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgbGV0J3MgY3JlYXRlIGFuIGA8YT5gIHRhZyB0byBiZSBvdXIgdHJpZ2dlciBhbmQgY2FsbCBpdCBgdGFwLXRvLXBsYXlgLlxyXG4gICAgICpcclxuICAgICAqIGBgYGh0bWxcclxuICAgICAqIDxkaXYgaWQ9XCJ3cmFwcGVyXCI+XHJcbiAgICAgKiAgICA8Y2FudmFzIGlkPVwiZ2FtZVwiPjwvY2FudmFzPlxyXG4gICAgICogICAgPGEgaWQ9XCJ0YXAtdG8tcGxheVwiIGhyZWY9J2phdmFzY3JpcHQ6dm9pZCgwKTsnPlRhcCB0byBQbGF5PC9hPlxyXG4gICAgICogPC9kaXY+XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBXZSd2ZSBwdXQgaXQgaW5zaWRlIGEgd3JhcHBlciB0byBwb3NpdGlvbiBpdCBwcm9wZXJseSBvdmVyIHRoZSBnYW1lIGNhbnZhcy5cclxuICAgICAqXHJcbiAgICAgKiBOb3cgbGV0J3MgYWRkIHNvbWUgQ1NTIHRvIHN0eWxlIGl0IChpbnNlcnQgaW50byBgPGhlYWQ+YCk6XHJcbiAgICAgKlxyXG4gICAgICogYGBgaHRtbFxyXG4gICAgICogPHN0eWxlPlxyXG4gICAgICogICAgICN3cmFwcGVyIHtcclxuICAgICAqICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICogICAgICAgICB3aWR0aDogNTAwcHg7XHJcbiAgICAgKiAgICAgICAgIGhlaWdodDogNTAwcHg7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICAgICN0YXAtdG8tcGxheSB7XHJcbiAgICAgKiAgICAgICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgICAgKiAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcclxuICAgICAqICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcbiAgICAgKiAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgICAqICAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAqICAgICAgICAgY29sb3I6IHdoaXRlO1xyXG4gICAgICogICAgICAgICB3aWR0aDogMjAwcHg7XHJcbiAgICAgKiAgICAgICAgIGhlaWdodDogNTBweDtcclxuICAgICAqICAgICAgICAgbGluZS1oZWlnaHQ6IDUwcHg7XHJcbiAgICAgKiAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcclxuICAgICAqICAgICAgICAgbGVmdDogMTQ3cHg7XHJcbiAgICAgKiAgICAgICAgIHRvcDogODAlO1xyXG4gICAgICogICAgIH1cclxuICAgICAqIDwvc3R5bGU+XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBOb3cgd2UgY2FuIGNyZWF0ZSBhIGBQYXVzZUFmdGVyTG9hZGVyYCB3aXRoIGEgcmVmZXJlbmNlIHRvIG91ciB0cmlnZ2VyIGJ1dHRvbjpcclxuICAgICAqXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICogdmFyIGxvYWRlciA9IG5ldyBleC5QYXVzZUFmdGVyTG9hZGVyKCd0YXAtdG8tcGxheScsIFsuLi5dKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqICMjIFVzZSBQYXVzZUFmdGVyTG9hZGVyIGZvciBpT1NcclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJpbWFyeSB1c2UgY2FzZSBmb3IgcGF1c2luZyBiZWZvcmUgc3RhcnRpbmcgdGhlIGdhbWUgaXMgdG9cclxuICAgICAqIHBhc3MgQXBwbGUncyByZXF1aXJlbWVudCBvZiB1c2VyIGludGVyYWN0aW9uLiBUaGUgV2ViIEF1ZGlvIGNvbnRleHRcclxuICAgICAqIGluIFNhZmFyaSBpcyBkaXNhYmxlZCBieSBkZWZhdWx0IHVudGlsIHVzZXIgaW50ZXJhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhlcmVmb3JlLCB5b3UgY2FuIHVzZSB0aGlzIHNuaXBwZXQgdG8gb25seSB1c2UgUGF1c2VBZnRlckxvYWRlciB3aGVuXHJcbiAgICAgKiBpT1MgaXMgZGV0ZWN0ZWQgKHNlZSBbdGhpcyB0aHJlYWRdKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTAzODYyNS9kZXRlY3QtaWYtZGV2aWNlLWlzLWlvcylcclxuICAgICAqIGZvciBtb3JlIHRlY2huaXF1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIGBgYHRzXHJcbiAgICAgKiB2YXIgaU9TID0gL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgISg8YW55PndpbmRvdykuTVNTdHJlYW07XHJcbiAgICAgKiB2YXIgbG9hZGVyOiBleC5Mb2FkZXIgPSBpT1MgPyBuZXcgZXguUGF1c2VBZnRlckxvYWRlcigndGFwLXRvLXBsYXknKSA6IG5ldyBleC5Mb2FkZXIoKTtcclxuICAgICAqXHJcbiAgICAgKiBsb2FkZXIuYWRkUmVzb3VyY2UoLi4uKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB2YXIgUGF1c2VBZnRlckxvYWRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBhdXNlQWZ0ZXJMb2FkZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUGF1c2VBZnRlckxvYWRlcih0cmlnZ2VyRWxlbWVudElkLCBsb2FkYWJsZXMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbG9hZGFibGVzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlT25UcmlnZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl93YWl0UHJvbWlzZS5zdGF0ZSgpICE9PSBQcm9taXNlc182LlByb21pc2VTdGF0ZS5QZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdW5sb2NrIFNhZmFyaSBXZWJBdWRpbyBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBTb3VuZF8xLldlYkF1ZGlvLnVubG9jaygpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29udGludWUgdG8gcGxheSBnYW1lXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fd2FpdFByb21pc2UucmVzb2x2ZShfdGhpcy5fbG9hZGVkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgLy8gaGlkZSBET00gZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3BsYXlUcmlnZ2VyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLl9wbGF5VHJpZ2dlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRyaWdnZXJFbGVtZW50SWQpO1xyXG4gICAgICAgICAgICBfdGhpcy5fcGxheVRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5faGFuZGxlT25UcmlnZ2VyKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQYXVzZUFmdGVyTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl93YWl0UHJvbWlzZSA9IG5ldyBQcm9taXNlc182LlByb21pc2UoKTtcclxuICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCB1c2VyIGluZGljYXRlcyB0byBwcm9jZWVkIGJlZm9yZSBmaW5pc2hpbmcgbG9hZFxyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmxvYWQuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9hZGVkVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIC8vIHNob3cgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3BsYXlUcmlnZ2VyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl93YWl0UHJvbWlzZS5yZWplY3QodmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dhaXRQcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBhdXNlQWZ0ZXJMb2FkZXI7XHJcbiAgICB9KExvYWRlcikpO1xyXG4gICAgZXhwb3J0cy5QYXVzZUFmdGVyTG9hZGVyID0gUGF1c2VBZnRlckxvYWRlcjtcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSUFjdG9yVHJhaXRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIlRyYWl0cy9DYXB0dXJlUG9pbnRlclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wb2dhdGVzIHBvaW50ZXIgZXZlbnRzIHRvIHRoZSBhY3RvclxyXG4gICAgICovXHJcbiAgICB2YXIgQ2FwdHVyZVBvaW50ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIENhcHR1cmVQb2ludGVyKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBDYXB0dXJlUG9pbnRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUpIHtcclxuICAgICAgICAgICAgaWYgKCFhY3Rvci5lbmFibGVDYXB0dXJlUG9pbnRlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhY3Rvci5pc0tpbGxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW5naW5lLmlucHV0LnBvaW50ZXJzLnByb3BvZ2F0ZShhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ2FwdHVyZVBvaW50ZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5DYXB0dXJlUG9pbnRlciA9IENhcHR1cmVQb2ludGVyO1xyXG59KTtcclxuZGVmaW5lKFwiVHJhaXRzL0V1bGVyTW92ZW1lbnRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJQaHlzaWNzXCIsIFwiQWN0b3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzcsIEFjdG9yXzUpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIEV1bGVyTW92ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEV1bGVyTW92ZW1lbnQoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV1bGVyTW92ZW1lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhY3RvciwgX2VuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHBsYWNlbWVudHMgYmFzZWQgb24gbGluZWFyIGFsZ2VicmFcclxuICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbEFjYyA9IGFjdG9yLmFjYy5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvLyBPbmx5IGFjdGl2ZSB2YW5pbGxhIGFjdG9ycyBhcmUgYWZmZWN0ZWQgYnkgZ2xvYmFsIGFjY2VsZXJhdGlvblxyXG4gICAgICAgICAgICBpZiAoYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfNS5Db2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdG90YWxBY2MuYWRkRXF1YWwoUGh5c2ljc183LlBoeXNpY3MuYWNjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3Rvci5vbGRWZWwgPSBhY3Rvci52ZWw7XHJcbiAgICAgICAgICAgIGFjdG9yLnZlbC5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZShzZWNvbmRzKSk7XHJcbiAgICAgICAgICAgIGFjdG9yLnBvcy5hZGRFcXVhbChhY3Rvci52ZWwuc2NhbGUoc2Vjb25kcykpLmFkZEVxdWFsKHRvdGFsQWNjLnNjYWxlKDAuNSAqIHNlY29uZHMgKiBzZWNvbmRzKSk7XHJcbiAgICAgICAgICAgIGFjdG9yLnJ4ICs9IGFjdG9yLnRvcnF1ZSAqICgxLjAgLyBhY3Rvci5tb2kpICogc2Vjb25kcztcclxuICAgICAgICAgICAgYWN0b3Iucm90YXRpb24gKz0gYWN0b3IucnggKiBzZWNvbmRzO1xyXG4gICAgICAgICAgICBhY3Rvci5zY2FsZS54ICs9IGFjdG9yLnN4ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICBhY3Rvci5zY2FsZS55ICs9IGFjdG9yLnN5ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEV1bGVyTW92ZW1lbnQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5FdWxlck1vdmVtZW50ID0gRXVsZXJNb3ZlbWVudDtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvQ3VsbGluZ0JveFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFsZ2VicmFcIiwgXCJEcmF3aW5nL0NvbG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWxnZWJyYV8xMywgQ29sb3JfMTMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIEN1bGxpbmdCb3ggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEN1bGxpbmdCb3goKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcExlZnQgPSBuZXcgQWxnZWJyYV8xMy5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcFJpZ2h0ID0gbmV3IEFsZ2VicmFfMTMuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3R0b21MZWZ0ID0gbmV3IEFsZ2VicmFfMTMuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3R0b21SaWdodCA9IG5ldyBBbGdlYnJhXzEzLlZlY3RvcigwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ3VsbGluZ0JveC5wcm90b3R5cGUuaXNTcHJpdGVPZmZTY3JlZW4gPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgZHJhd2luZ1dpZHRoID0gYWN0b3IuY3VycmVudERyYXdpbmcud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBkcmF3aW5nSGVpZ2h0ID0gYWN0b3IuY3VycmVudERyYXdpbmcuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgcm90YXRpb24gPSBhY3Rvci5yb3RhdGlvbjtcclxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IGFjdG9yLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgd29ybGRQb3MgPSBhY3Rvci5nZXRXb3JsZFBvcygpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BMZWZ0LnggPSB3b3JsZFBvcy54IC0gKGRyYXdpbmdXaWR0aCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BMZWZ0LnkgPSB3b3JsZFBvcy55IC0gKGRyYXdpbmdIZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9wTGVmdCA9IHRoaXMuX3RvcExlZnQucm90YXRlKHJvdGF0aW9uLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BSaWdodC54ID0gd29ybGRQb3MueCArIChkcmF3aW5nV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9wUmlnaHQueSA9IHdvcmxkUG9zLnkgLSAoZHJhd2luZ0hlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BSaWdodCA9IHRoaXMuX3RvcFJpZ2h0LnJvdGF0ZShyb3RhdGlvbiwgYW5jaG9yKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tTGVmdC54ID0gd29ybGRQb3MueCAtIChkcmF3aW5nV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tTGVmdC55ID0gd29ybGRQb3MueSArIChkcmF3aW5nSGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbUxlZnQgPSB0aGlzLl9ib3R0b21MZWZ0LnJvdGF0ZShyb3RhdGlvbiwgYW5jaG9yKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tUmlnaHQueCA9IHdvcmxkUG9zLnggKyAoZHJhd2luZ1dpZHRoIC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbVJpZ2h0LnkgPSB3b3JsZFBvcy55ICsgKGRyYXdpbmdIZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tUmlnaHQgPSB0aGlzLl9ib3R0b21SaWdodC5yb3RhdGUocm90YXRpb24sIGFuY2hvcik7XHJcbiAgICAgICAgICAgIC8vL1xyXG4gICAgICAgICAgICB2YXIgdG9wTGVmdFNjcmVlbiA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXModGhpcy5fdG9wTGVmdCk7XHJcbiAgICAgICAgICAgIHZhciB0b3BSaWdodFNjcmVlbiA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXModGhpcy5fdG9wUmlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgYm90dG9tTGVmdFNjcmVlbiA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXModGhpcy5fYm90dG9tTGVmdCk7XHJcbiAgICAgICAgICAgIHZhciBib3R0b21SaWdodFNjcmVlbiA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXModGhpcy5fYm90dG9tUmlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl94Q29vcmRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3lDb29yZHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5feENvb3Jkcy5wdXNoKHRvcExlZnRTY3JlZW4ueCwgdG9wUmlnaHRTY3JlZW4ueCwgYm90dG9tTGVmdFNjcmVlbi54LCBib3R0b21SaWdodFNjcmVlbi54KTtcclxuICAgICAgICAgICAgdGhpcy5feUNvb3Jkcy5wdXNoKHRvcExlZnRTY3JlZW4ueSwgdG9wUmlnaHRTY3JlZW4ueSwgYm90dG9tTGVmdFNjcmVlbi55LCBib3R0b21SaWdodFNjcmVlbi55KTtcclxuICAgICAgICAgICAgdGhpcy5feE1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHRoaXMuX3hDb29yZHMpO1xyXG4gICAgICAgICAgICB0aGlzLl95TWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgdGhpcy5feUNvb3Jkcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3hNYXggPSBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLl94Q29vcmRzKTtcclxuICAgICAgICAgICAgdGhpcy5feU1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuX3lDb29yZHMpO1xyXG4gICAgICAgICAgICB2YXIgbWluV29ybGQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzEzLlZlY3Rvcih0aGlzLl94TWluLCB0aGlzLl95TWluKSk7XHJcbiAgICAgICAgICAgIHZhciBtYXhXb3JsZCA9IGVuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNYXgsIHRoaXMuX3lNYXgpKTtcclxuICAgICAgICAgICAgdGhpcy5feE1pbldvcmxkID0gbWluV29ybGQueDtcclxuICAgICAgICAgICAgdGhpcy5feU1pbldvcmxkID0gbWluV29ybGQueTtcclxuICAgICAgICAgICAgdGhpcy5feE1heFdvcmxkID0gbWF4V29ybGQueDtcclxuICAgICAgICAgICAgdGhpcy5feU1heFdvcmxkID0gbWF4V29ybGQueTtcclxuICAgICAgICAgICAgdmFyIGJvdW5kaW5nUG9pbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgbmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNaW4sIHRoaXMuX3lNaW4pLFxyXG4gICAgICAgICAgICAgICAgbmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNYXgsIHRoaXMuX3lNaW4pLFxyXG4gICAgICAgICAgICAgICAgbmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNaW4sIHRoaXMuX3lNYXgpLFxyXG4gICAgICAgICAgICAgICAgbmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNYXgsIHRoaXMuX3lNYXgpXHJcbiAgICAgICAgICAgIF07IC8vIGJvdHRvbXJpZ2h0XHJcbiAgICAgICAgICAgIC8vIHNwcml0ZSBjYW4gYmUgd2lkZXIgdGhhbiBjYW52YXMgc2NyZWVuIChhbmQgc3RpbGwgdmlzaWJsZSB3aXRoaW4gY2FudmFzKVxyXG4gICAgICAgICAgICAvLyB0b3Agb3IgYm90dG9tIG9mIHNwcml0ZSBtdXN0IGJlIHdpdGhpbiBjYW52YXNcclxuICAgICAgICAgICAgaWYgKGJvdW5kaW5nUG9pbnRzWzBdLnggPCAwICYmIGJvdW5kaW5nUG9pbnRzWzFdLnggPiBlbmdpbmUuY2FudmFzLmNsaWVudFdpZHRoICYmXHJcbiAgICAgICAgICAgICAgICAoYm91bmRpbmdQb2ludHNbMF0ueSA+IDAgfHwgYm91bmRpbmdQb2ludHNbMl0ueSA8IGVuZ2luZS5jYW52YXMuY2xpZW50SGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNwcml0ZSBjYW4gYmUgdGFsbGVyIHRoYW4gY2FudmFzIHNjcmVlbiAoYW5kIHN0aWxsIHZpc2libGUgd2l0aGluIGNhbnZhcylcclxuICAgICAgICAgICAgLy8gbGVmdCBvciByaWdodCBvZiBzcHJpdGUgbXVzdCBiZSB3aXRoaW4gY2FudmFzXHJcbiAgICAgICAgICAgIGlmIChib3VuZGluZ1BvaW50c1swXS55IDwgMCAmJiBib3VuZGluZ1BvaW50c1syXS55ID4gZW5naW5lLmNhbnZhcy5jbGllbnRIZWlnaHQgJiZcclxuICAgICAgICAgICAgICAgIChib3VuZGluZ1BvaW50c1sxXS54ID4gMCB8fCBib3VuZGluZ1BvaW50c1swXS54IDwgZW5naW5lLmNhbnZhcy5jbGllbnRXaWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaWYgYW55IGNvcm5lciBpcyB2aXNpYmxlLCB3ZSdyZSBub3Qgb2Zmc2NyZWVuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRpbmdQb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZGluZ1BvaW50c1tpXS54ID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUG9pbnRzW2ldLnkgPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdQb2ludHNbaV0ueCA8IGVuZ2luZS5jYW52YXMuY2xpZW50V2lkdGggJiZcclxuICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1BvaW50c1tpXS55IDwgZW5naW5lLmNhbnZhcy5jbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDdWxsaW5nQm94LnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIC8vIGJvdW5kaW5nIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yXzEzLkNvbG9yLldoaXRlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZWN0KHRoaXMuX3hNaW5Xb3JsZCwgdGhpcy5feU1pbldvcmxkLCB0aGlzLl94TWF4V29ybGQgLSB0aGlzLl94TWluV29ybGQsIHRoaXMuX3lNYXhXb3JsZCAtIHRoaXMuX3lNaW5Xb3JsZCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzEzLkNvbG9yLlJlZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5fdG9wTGVmdC54LCB0aGlzLl90b3BMZWZ0LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMTMuQ29sb3IuR3JlZW4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMuX3RvcFJpZ2h0LngsIHRoaXMuX3RvcFJpZ2h0LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMTMuQ29sb3IuQmx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5fYm90dG9tTGVmdC54LCB0aGlzLl9ib3R0b21MZWZ0LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMTMuQ29sb3IuTWFnZW50YS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5fYm90dG9tUmlnaHQueCwgdGhpcy5fYm90dG9tUmlnaHQueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ3VsbGluZ0JveDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkN1bGxpbmdCb3ggPSBDdWxsaW5nQm94O1xyXG59KTtcclxuZGVmaW5lKFwiVHJhaXRzL09mZnNjcmVlbkN1bGxpbmdcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL0N1bGxpbmdCb3hcIiwgXCJBbGdlYnJhXCIsIFwiRXZlbnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ3VsbGluZ0JveF8xLCBBbGdlYnJhXzE0LCBFdmVudHNfMykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgT2Zmc2NyZWVuQ3VsbGluZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gT2Zmc2NyZWVuQ3VsbGluZygpIHtcclxuICAgICAgICAgICAgdGhpcy5jdWxsaW5nQm94ID0gbmV3IEN1bGxpbmdCb3hfMS5DdWxsaW5nQm94KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9mZnNjcmVlbkN1bGxpbmcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhY3RvciwgZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudERpc3BhdGNoZXIgPSBhY3Rvci5ldmVudERpc3BhdGNoZXI7XHJcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBhY3Rvci5hbmNob3I7XHJcbiAgICAgICAgICAgIHZhciBnbG9iYWxTY2FsZSA9IGFjdG9yLmdldEdsb2JhbFNjYWxlKCk7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGdsb2JhbFNjYWxlLnggKiBhY3Rvci5nZXRXaWR0aCgpIC8gYWN0b3Iuc2NhbGUueDtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGdsb2JhbFNjYWxlLnkgKiBhY3Rvci5nZXRIZWlnaHQoKSAvIGFjdG9yLnNjYWxlLnk7XHJcbiAgICAgICAgICAgIHZhciB3b3JsZFBvcyA9IGFjdG9yLmdldFdvcmxkUG9zKCk7XHJcbiAgICAgICAgICAgIHZhciBhY3RvclNjcmVlbkNvb3JkcyA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMTQuVmVjdG9yKHdvcmxkUG9zLnggLSBhbmNob3IueCAqIHdpZHRoLCB3b3JsZFBvcy55IC0gYW5jaG9yLnkgKiBoZWlnaHQpKTtcclxuICAgICAgICAgICAgdmFyIHpvb20gPSAxLjA7XHJcbiAgICAgICAgICAgIGlmIChhY3Rvci5zY2VuZSAmJiBhY3Rvci5zY2VuZS5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgIHpvb20gPSBNYXRoLmFicyhhY3Rvci5zY2VuZS5jYW1lcmEuZ2V0Wm9vbSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNTcHJpdGVPZmZTY3JlZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3IuY3VycmVudERyYXdpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaXNTcHJpdGVPZmZTY3JlZW4gPSB0aGlzLmN1bGxpbmdCb3guaXNTcHJpdGVPZmZTY3JlZW4oYWN0b3IsIGVuZ2luZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhY3Rvci5pc09mZlNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKChhY3RvclNjcmVlbkNvb3Jkcy54ICsgd2lkdGggKiB6b29tIDwgMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yU2NyZWVuQ29vcmRzLnkgKyBoZWlnaHQgKiB6b29tIDwgMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yU2NyZWVuQ29vcmRzLnggPiBlbmdpbmUuY2FudmFzV2lkdGggfHxcclxuICAgICAgICAgICAgICAgICAgICBhY3RvclNjcmVlbkNvb3Jkcy55ID4gZW5naW5lLmNhbnZhc0hlaWdodCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1Nwcml0ZU9mZlNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5lbWl0KCdleGl0dmlld3BvcnQnLCBuZXcgRXZlbnRzXzMuRXhpdFZpZXdQb3J0RXZlbnQoYWN0b3IpKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rvci5pc09mZlNjcmVlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGFjdG9yU2NyZWVuQ29vcmRzLnggKyB3aWR0aCAqIHpvb20gPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3JTY3JlZW5Db29yZHMueSArIGhlaWdodCAqIHpvb20gPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3JTY3JlZW5Db29yZHMueCA8IGVuZ2luZS5jYW52YXNXaWR0aCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yU2NyZWVuQ29vcmRzLnkgPCBlbmdpbmUuY2FudmFzSGVpZ2h0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFpc1Nwcml0ZU9mZlNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5lbWl0KCdlbnRlcnZpZXdwb3J0JywgbmV3IEV2ZW50c18zLkVudGVyVmlld1BvcnRFdmVudChhY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmlzT2ZmU2NyZWVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPZmZzY3JlZW5DdWxsaW5nO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuT2Zmc2NyZWVuQ3VsbGluZyA9IE9mZnNjcmVlbkN1bGxpbmc7XHJcbn0pO1xyXG5kZWZpbmUoXCJUcmFpdHMvVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvblwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFjdG9yXCIsIFwiQ29sbGlzaW9uL1NpZGVcIiwgXCJFdmVudHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBY3Rvcl82LCBTaWRlXzIsIEV2ZW50c180KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnREaXNwYXRjaGVyID0gYWN0b3IuZXZlbnREaXNwYXRjaGVyO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3IuY29sbGlzaW9uVHlwZSAhPT0gQWN0b3JfNi5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb24gJiYgZW5naW5lLmN1cnJlbnRTY2VuZSAmJiBlbmdpbmUuY3VycmVudFNjZW5lLnRpbGVNYXBzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVuZ2luZS5jdXJyZW50U2NlbmUudGlsZU1hcHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gZW5naW5lLmN1cnJlbnRTY2VuZS50aWxlTWFwc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0TWFwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWRlID0gU2lkZV8yLlNpZGUuTm9uZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gMjtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW50ZXJzZWN0TWFwID0gbWFwLmNvbGxpZGVzKGFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4LS0gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gYWN0b3IuZ2V0U2lkZUZyb21JbnRlcnNlY3QoaW50ZXJzZWN0TWFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBFdmVudHNfNC5QcmVDb2xsaXNpb25FdmVudChhY3RvciwgbnVsbCwgc2lkZSwgaW50ZXJzZWN0TWFwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl82LkNvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5wb3MueSArPSBpbnRlcnNlY3RNYXAueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLnBvcy54ICs9IGludGVyc2VjdE1hcC54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3Bvc3Rjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzQuUG9zdENvbGxpc2lvbkV2ZW50KGFjdG9yLCBudWxsLCBzaWRlLCBpbnRlcnNlY3RNYXApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb247XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5UaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uID0gVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvbjtcclxufSk7XHJcbmRlZmluZShcIlRyYWl0cy9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlRyYWl0cy9DYXB0dXJlUG9pbnRlclwiLCBcIlRyYWl0cy9FdWxlck1vdmVtZW50XCIsIFwiVHJhaXRzL09mZnNjcmVlbkN1bGxpbmdcIiwgXCJUcmFpdHMvVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvblwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENhcHR1cmVQb2ludGVyXzEsIEV1bGVyTW92ZW1lbnRfMSwgT2Zmc2NyZWVuQ3VsbGluZ18xLCBUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KENhcHR1cmVQb2ludGVyXzEpO1xyXG4gICAgX19leHBvcnQoRXVsZXJNb3ZlbWVudF8xKTtcclxuICAgIF9fZXhwb3J0KE9mZnNjcmVlbkN1bGxpbmdfMSk7XHJcbiAgICBfX2V4cG9ydChUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uXzEpO1xyXG59KTtcclxuZGVmaW5lKFwiUGFydGljbGVzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0b3JcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiQWxnZWJyYVwiLCBcIlV0aWwvVXRpbFwiLCBcIlV0aWwvRHJhd1V0aWxcIiwgXCJUcmFpdHMvSW5kZXhcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBY3Rvcl83LCBDb2xvcl8xNCwgQWxnZWJyYV8xNSwgVXRpbCwgRHJhd1V0aWwsIFRyYWl0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGVudW0gdGhhdCByZXByZXNlbnRzIHRoZSB0eXBlcyBvZiBlbWl0dGVyIG5venpsZXNcclxuICAgICAqL1xyXG4gICAgdmFyIEVtaXR0ZXJUeXBlO1xyXG4gICAgKGZ1bmN0aW9uIChFbWl0dGVyVHlwZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0YW50IGZvciB0aGUgY2lyY3VsYXIgZW1pdHRlciB0eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW1pdHRlclR5cGVbRW1pdHRlclR5cGVbXCJDaXJjbGVcIl0gPSAwXSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RhbnQgZm9yIHRoZSByZWN0YW5ndWxhciBlbWl0dGVyIHR5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbWl0dGVyVHlwZVtFbWl0dGVyVHlwZVtcIlJlY3RhbmdsZVwiXSA9IDFdID0gXCJSZWN0YW5nbGVcIjtcclxuICAgIH0pKEVtaXR0ZXJUeXBlID0gZXhwb3J0cy5FbWl0dGVyVHlwZSB8fCAoZXhwb3J0cy5FbWl0dGVyVHlwZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFBhcnRpY2xlIGlzIHVzZWQgaW4gYSBbW1BhcnRpY2xlRW1pdHRlcl1dXHJcbiAgICAgKi9cclxuICAgIHZhciBQYXJ0aWNsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUGFydGljbGUoZW1pdHRlciwgbGlmZSwgb3BhY2l0eSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYWNjZWxlcmF0aW9uLCBzdGFydFNpemUsIGVuZFNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBBbGdlYnJhXzE1LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBBbGdlYnJhXzE1LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgQWxnZWJyYV8xNS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZm9jdXMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZvY3VzQWNjZWwgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBDb2xvcl8xNC5Db2xvci5XaGl0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZENvbG9yID0gQ29sb3JfMTQuQ29sb3IuV2hpdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy8gTGlmZSBpcyBjb3VudGVkIGluIG1zXHJcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IDMwMDtcclxuICAgICAgICAgICAgdGhpcy5mYWRlRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBDb2xvciB0cmFuc2l0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLl9yUmF0ZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2dSYXRlID0gMTtcclxuICAgICAgICAgICAgdGhpcy5fYlJhdGUgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9hUmF0ZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvciA9IENvbG9yXzE0LkNvbG9yLldoaXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVTaXplID0gNTtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZVJhdGUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRNdWx0aXBsaWVyID0gMDtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcclxuICAgICAgICAgICAgdGhpcy5saWZlID0gbGlmZSB8fCB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHkgfHwgdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICB0aGlzLmVuZENvbG9yID0gZW5kQ29sb3IgfHwgdGhpcy5lbmRDb2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBiZWdpbkNvbG9yIHx8IHRoaXMuYmVnaW5Db2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSB0aGlzLmJlZ2luQ29sb3IuY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uIHx8IHRoaXMucG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eSB8fCB0aGlzLnZlbG9jaXR5O1xyXG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IGFjY2VsZXJhdGlvbiB8fCB0aGlzLmFjY2VsZXJhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fclJhdGUgPSAodGhpcy5lbmRDb2xvci5yIC0gdGhpcy5iZWdpbkNvbG9yLnIpIC8gdGhpcy5saWZlO1xyXG4gICAgICAgICAgICB0aGlzLl9nUmF0ZSA9ICh0aGlzLmVuZENvbG9yLmcgLSB0aGlzLmJlZ2luQ29sb3IuZykgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgIHRoaXMuX2JSYXRlID0gKHRoaXMuZW5kQ29sb3IuYiAtIHRoaXMuYmVnaW5Db2xvci5iKSAvIHRoaXMubGlmZTtcclxuICAgICAgICAgICAgdGhpcy5fYVJhdGUgPSB0aGlzLm9wYWNpdHkgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaXplID0gc3RhcnRTaXplIHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kU2l6ZSA9IGVuZFNpemUgfHwgMDtcclxuICAgICAgICAgICAgaWYgKCh0aGlzLmVuZFNpemUgPiAwKSAmJiAodGhpcy5zdGFydFNpemUgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplUmF0ZSA9ICh0aGlzLmVuZFNpemUgLSB0aGlzLnN0YXJ0U2l6ZSkgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IHRoaXMuc3RhcnRTaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBhcnRpY2xlLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlUGFydGljbGUodGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IHRoaXMubGlmZSAtIGRlbHRhO1xyXG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRNdWx0aXBsaWVyID0gdGhpcy5lbGFwc2VkTXVsdGlwbGllciArIGRlbHRhO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saWZlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5raWxsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZmFkZUZsYWcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IFV0aWwuY2xhbXAodGhpcy5fYVJhdGUgKiB0aGlzLmxpZmUsIDAuMDAwMSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCh0aGlzLnN0YXJ0U2l6ZSA+IDApICYmICh0aGlzLmVuZFNpemUgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSBVdGlsLmNsYW1wKHRoaXMuc2l6ZVJhdGUgKiBkZWx0YSArIHRoaXMucGFydGljbGVTaXplLCBNYXRoLm1pbih0aGlzLnN0YXJ0U2l6ZSwgdGhpcy5lbmRTaXplKSwgTWF0aC5tYXgodGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5yID0gVXRpbC5jbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuciArIHRoaXMuX3JSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5nID0gVXRpbC5jbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuZyArIHRoaXMuX2dSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5iID0gVXRpbC5jbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuYiArIHRoaXMuX2JSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5hID0gVXRpbC5jbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWNjZWwgPSB0aGlzLmZvY3VzLnN1Yih0aGlzLnBvc2l0aW9uKS5ub3JtYWxpemUoKS5zY2FsZSh0aGlzLmZvY3VzQWNjZWwpLnNjYWxlKGRlbHRhIC8gMTAwMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eS5hZGQoYWNjZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkuYWRkKHRoaXMuYWNjZWxlcmF0aW9uLnNjYWxlKGRlbHRhIC8gMTAwMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmFkZCh0aGlzLnZlbG9jaXR5LnNjYWxlKGRlbHRhIC8gMTAwMCkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Um90YXRpb24gPSAodGhpcy5jdXJyZW50Um90YXRpb24gKyB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ICogZGVsdGEgLyAxMDAwKSAlICgyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFBhcnRpY2xlLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5yb3RhdGlvbiA9IHRoaXMuY3VycmVudFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5zY2FsZS5zZXRUbyh0aGlzLnBhcnRpY2xlU2l6ZSwgdGhpcy5wYXJ0aWNsZVNpemUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5kcmF3KGN0eCwgdGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5hID0gVXRpbC5jbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9jdXJyZW50Q29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55LCB0aGlzLnBhcnRpY2xlU2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGFydGljbGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5QYXJ0aWNsZSA9IFBhcnRpY2xlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2luZyBhIHBhcnRpY2xlIGVtaXR0ZXIgaXMgYSBncmVhdCB3YXkgdG8gY3JlYXRlIGludGVyZXN0aW5nIGVmZmVjdHNcclxuICAgICAqIGluIHlvdXIgZ2FtZSwgbGlrZSBzbW9rZSwgZmlyZSwgd2F0ZXIsIGV4cGxvc2lvbnMsIGV0Yy4gYFBhcnRpY2xlRW1pdHRlcmBcclxuICAgICAqIGV4dGVuZCBbW0FjdG9yXV0gYWxsb3dpbmcgeW91IHRvIHVzZSBhbGwgb2YgdGhlIGZlYXR1cmVzIHRoYXQgY29tZSB3aXRoLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpQYXJ0aWNsZXMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgUGFydGljbGVFbWl0dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUGFydGljbGVFbWl0dGVyLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBlbWl0dGVyXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgVGhlIHkgcG9zaXRpb24gb2YgdGhlIGVtaXR0ZXJcclxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggICBUaGUgd2lkdGggb2YgdGhlIGVtaXR0ZXJcclxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0ICBUaGUgaGVpZ2h0IG9mIHRoZSBlbWl0dGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUGFydGljbGVFbWl0dGVyKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgeCwgeSwgd2lkdGgsIGhlaWdodCwgQ29sb3JfMTQuQ29sb3IuV2hpdGUpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5udW1QYXJ0aWNsZXMgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBpc0VtaXR0aW5nIGZsYWdcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmlzRW1pdHRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiYWNraW5nIHBhcnRpY2xlIGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnBhcnRpY2xlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhY2tpbmcgZGVhZFBhcnRpY2xlIGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmRlYWRQYXJ0aWNsZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHBhcnRpY2xlIHZlbG9jaXR5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5taW5WZWwgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHBhcnRpY2xlIHZlbG9jaXR5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5tYXhWZWwgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBhY2NlbGVyYXRpb24gdmVjdG9yIGZvciBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgQWxnZWJyYV8xNS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubWluQW5nbGUgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIGFuZ2xlIGluIHJhZGlhbnNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm1heEFuZ2xlID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pc3Npb24gcmF0ZSBmb3IgcGFydGljbGVzIChwYXJ0aWNsZXMvc2VjKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZW1pdFJhdGUgPSAxOyAvL3BhcnRpY2xlcy9zZWNcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGlmZSBvZiBlYWNoIHBhcnRpY2xlIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucGFydGljbGVMaWZlID0gMjAwMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3BhY2l0eSBvZiBlYWNoIHBhcnRpY2xlIGZyb20gMCB0byAxLjBcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBmYWRlIGZsYWcgd2hpY2ggY2F1c2VzIHBhcnRpY2xlcyB0byBncmFkdWFsbHkgZmFkZSBvdXQgb3ZlciB0aGUgY291cnNlIG9mIHRoZWlyIGxpZmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5mYWRlRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBmb2N1cyB3aGVyZSBhbGwgcGFydGljbGVzIHNob3VsZCBhY2NlbGVyYXRlIHRvd2FyZHNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZvY3VzID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYWNjZWxlcmF0aW9uIGZvciBmb2N1c2luZyBwYXJ0aWNsZXMgaWYgYSBmb2N1cyBoYXMgYmVlbiBzcGVjaWZpZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZvY3VzQWNjZWwgPSAxO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIHN0YXJ0aW5nIHNpemUgZm9yIHRoZSBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0U2l6ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3B0aW9uYWwgZW5kaW5nIHNpemUgZm9yIHRoZSBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmVuZFNpemUgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHNpemUgb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubWluU2l6ZSA9IDU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gc2l6ZSBvZiBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5tYXhTaXplID0gNTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmVnaW5uaW5nIGNvbG9yIG9mIGFsbCBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmJlZ2luQ29sb3IgPSBDb2xvcl8xNC5Db2xvci5XaGl0ZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW5kaW5nIGNvbG9yIG9mIGFsbCBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmVuZENvbG9yID0gQ29sb3JfMTQuQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHNwcml0ZSB0aGF0IGEgcGFydGljbGUgc2hvdWxkIHVzZVxyXG4gICAgICAgICAgICAgKiBAd2FybmluZyBQZXJmb3JtYW5jZSBpbnRlbnNpdmVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnBhcnRpY2xlU3ByaXRlID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pdHRlciB0eXBlIGZvciB0aGUgcGFydGljbGUgZW1pdHRlclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZW1pdHRlclR5cGUgPSBFbWl0dGVyVHlwZS5SZWN0YW5nbGU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXR0ZXIgcmFkaXVzLCBvbmx5IHRha2VzIGVmZmVjdCB3aGVuIHRoZSBbW2VtaXR0ZXJUeXBlXV0gaXMgW1tFbWl0dGVyVHlwZS5DaXJjbGVdXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucmFkaXVzID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcGFydGljbGUgcm90YXRpb25hbCBzcGVlZCB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgcGFydGljbGVzIHNob3VsZCBzdGFydCB3aXRoIGEgcmFuZG9tIHJvdGF0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5yYW5kb21Sb3RhdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5jb2xsaXNpb25UeXBlID0gQWN0b3JfNy5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgICAgIF90aGlzLnBhcnRpY2xlcyA9IG5ldyBVdGlsLkNvbGxlY3Rpb24oKTtcclxuICAgICAgICAgICAgX3RoaXMuZGVhZFBhcnRpY2xlcyA9IG5ldyBVdGlsLkNvbGxlY3Rpb24oKTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9mZnNjcmVlbiBjdWxsaW5nIGZyb20gcGFydGljbGUgZW1pdHRlcnNcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy50cmFpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50cmFpdHNbaV0gaW5zdGFuY2VvZiBUcmFpdHMuT2Zmc2NyZWVuQ3VsbGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyYWl0cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZVBhcnRpY2xlID0gZnVuY3Rpb24gKHBhcnRpY2xlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcy5wdXNoKHBhcnRpY2xlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhdXNlcyB0aGUgZW1pdHRlciB0byBlbWl0IHBhcnRpY2xlc1xyXG4gICAgICAgICAqIEBwYXJhbSBwYXJ0aWNsZUNvdW50ICBOdW1iZXIgb2YgcGFydGljbGVzIHRvIGVtaXQgcmlnaHQgbm93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS5lbWl0UGFydGljbGVzID0gZnVuY3Rpb24gKHBhcnRpY2xlQ291bnQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWNsZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVzLnB1c2godGhpcy5fY3JlYXRlUGFydGljbGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUuY2xlYXJQYXJ0aWNsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLmNsZWFyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDcmVhdGVzIGEgbmV3IHBhcnRpY2xlIGdpdmVuIHRoZSBjb25zdHJhaW50cyBvZiB0aGUgZW1pdHRlclxyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUuX2NyZWF0ZVBhcnRpY2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvIGltcGxlbWVudCBlbWl0dGVyIGNvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICB2YXIgcmFuWCA9IDA7XHJcbiAgICAgICAgICAgIHZhciByYW5ZID0gMDtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gVXRpbC5yYW5kb21JblJhbmdlKHRoaXMubWluQW5nbGUsIHRoaXMubWF4QW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgdmVsID0gVXRpbC5yYW5kb21JblJhbmdlKHRoaXMubWluVmVsLCB0aGlzLm1heFZlbCk7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5zdGFydFNpemUgfHwgVXRpbC5yYW5kb21JblJhbmdlKHRoaXMubWluU2l6ZSwgdGhpcy5tYXhTaXplKTtcclxuICAgICAgICAgICAgdmFyIGR4ID0gdmVsICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgZHkgPSB2ZWwgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVtaXR0ZXJUeXBlID09PSBFbWl0dGVyVHlwZS5SZWN0YW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIHJhblggPSBVdGlsLnJhbmRvbUluUmFuZ2UodGhpcy5wb3MueCwgdGhpcy5wb3MueCArIHRoaXMuZ2V0V2lkdGgoKSk7XHJcbiAgICAgICAgICAgICAgICByYW5ZID0gVXRpbC5yYW5kb21JblJhbmdlKHRoaXMucG9zLnksIHRoaXMucG9zLnkgKyB0aGlzLmdldEhlaWdodCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmVtaXR0ZXJUeXBlID09PSBFbWl0dGVyVHlwZS5DaXJjbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBVdGlsLnJhbmRvbUluUmFuZ2UoMCwgdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgcmFuWCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSArIHRoaXMucG9zLng7XHJcbiAgICAgICAgICAgICAgICByYW5ZID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpICsgdGhpcy5wb3MueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQYXJ0aWNsZSh0aGlzLCB0aGlzLnBhcnRpY2xlTGlmZSwgdGhpcy5vcGFjaXR5LCB0aGlzLmJlZ2luQ29sb3IsIHRoaXMuZW5kQ29sb3IsIG5ldyBBbGdlYnJhXzE1LlZlY3RvcihyYW5YLCByYW5ZKSwgbmV3IEFsZ2VicmFfMTUuVmVjdG9yKGR4LCBkeSksIHRoaXMuYWNjZWxlcmF0aW9uLCB0aGlzLnN0YXJ0U2l6ZSwgdGhpcy5lbmRTaXplKTtcclxuICAgICAgICAgICAgcC5mYWRlRmxhZyA9IHRoaXMuZmFkZUZsYWc7XHJcbiAgICAgICAgICAgIHAucGFydGljbGVTaXplID0gc2l6ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFydGljbGVTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgIHAucGFydGljbGVTcHJpdGUgPSB0aGlzLnBhcnRpY2xlU3ByaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yYW5kb21Sb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50Um90YXRpb24gPSBVdGlsLnJhbmRvbUluUmFuZ2UoMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICBwLmZvY3VzID0gdGhpcy5mb2N1cy5hZGQobmV3IEFsZ2VicmFfMTUuVmVjdG9yKHRoaXMucG9zLngsIHRoaXMucG9zLnkpKTtcclxuICAgICAgICAgICAgICAgIHAuZm9jdXNBY2NlbCA9IHRoaXMuZm9jdXNBY2NlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbWl0dGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ICs9IHRoaXMuZW1pdFJhdGUgKiAoZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgICAgIC8vdmFyIG51bVBhcnRpY2xlcyA9IE1hdGguY2VpbCh0aGlzLmVtaXRSYXRlICogZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPiAxLjApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRQYXJ0aWNsZXMoTWF0aC5mbG9vcih0aGlzLl9wYXJ0aWNsZXNUb0VtaXQpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPSB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgLSBNYXRoLmZsb29yKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC51cGRhdGUoZGVsdGEpOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIF90aGlzLnBhcnRpY2xlcy5yZW1vdmVFbGVtZW50KHApOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLmNsZWFyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gaXMgdGhlcmUgYSBtb3JlIGVmZmljaWVudCB0byBkcmF3IFxyXG4gICAgICAgICAgICAvLyBwb3NzaWJseSB1c2UgYSB3ZWJnbCBvZmZzY3JlZW4gY2FudmFzIGFuZCBzaGFkZXJzIHRvIGRvIHBhcnRpY2xlcz9cclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5kcmF3KGN0eCk7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVidWdEcmF3LmNhbGwodGhpcywgY3R4KTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzE0LkNvbG9yLkJsYWNrLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCgnUGFydGljbGVzOiAnICsgdGhpcy5wYXJ0aWNsZXMuY291bnQoKSwgdGhpcy5wb3MueCwgdGhpcy5wb3MueSArIDIwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLmZvY3VzLnggKyB0aGlzLnBvcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnBvcy55LCAzLCAzKTtcclxuICAgICAgICAgICAgICAgIERyYXdVdGlsLmxpbmUoY3R4LCBDb2xvcl8xNC5Db2xvci5ZZWxsb3csIHRoaXMuZm9jdXMueCArIHRoaXMucG9zLngsIHRoaXMuZm9jdXMueSArIHRoaXMucG9zLnksIF9zdXBlci5wcm90b3R5cGUuZ2V0Q2VudGVyLmNhbGwodGhpcykueCwgX3N1cGVyLnByb3RvdHlwZS5nZXRDZW50ZXIuY2FsbCh0aGlzKS55KTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCgnRm9jdXMnLCB0aGlzLmZvY3VzLnggKyB0aGlzLnBvcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnBvcy55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlRW1pdHRlcjtcclxuICAgIH0oQWN0b3JfNy5BY3RvcikpO1xyXG4gICAgZXhwb3J0cy5QYXJ0aWNsZUVtaXR0ZXIgPSBQYXJ0aWNsZUVtaXR0ZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJUaWxlTWFwXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIkNsYXNzXCIsIFwiQWxnZWJyYVwiLCBcIlV0aWwvTG9nXCIsIFwiRXZlbnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQm91bmRpbmdCb3hfNCwgQ29sb3JfMTUsIENsYXNzXzQsIEFsZ2VicmFfMTYsIExvZ184LCBFdmVudHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgW1tUaWxlTWFwXV0gY2xhc3MgcHJvdmlkZXMgYSBsaWdodHdlaWdodCB3YXkgdG8gZG8gbGFyZ2UgY29tcGxleCBzY2VuZXMgd2l0aCBjb2xsaXNpb25cclxuICAgICAqIHdpdGhvdXQgdGhlIG92ZXJoZWFkIG9mIGFjdG9ycy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6VGlsZU1hcHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgVGlsZU1hcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFRpbGVNYXAsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgICAgICAgVGhlIHggY29vcmRpbmF0ZSB0byBhbmNob3IgdGhlIFRpbGVNYXAncyB1cHBlciBsZWZ0IGNvcm5lciAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgICAgICAgIFRoZSB5IGNvb3JkaW5hdGUgdG8gYW5jaG9yIHRoZSBUaWxlTWFwJ3MgdXBwZXIgbGVmdCBjb3JuZXIgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAgICAgKiBAcGFyYW0gY2VsbFdpZHRoICAgICBUaGUgaW5kaXZpZHVhbCB3aWR0aCBvZiBlYWNoIGNlbGwgKGluIHBpeGVscykgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAgICAgKiBAcGFyYW0gY2VsbEhlaWdodCAgICBUaGUgaW5kaXZpZHVhbCBoZWlnaHQgb2YgZWFjaCBjZWxsIChpbiBwaXhlbHMpIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgICAgICogQHBhcmFtIHJvd3MgICAgICAgICAgVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBUaWxlTWFwIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgICAgICogQHBhcmFtIGNvbHMgICAgICAgICAgVGhlIG51bWJlciBvZiBjb2xzIGluIHRoZSBUaWxlTWFwIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVGlsZU1hcCh4LCB5LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHJvd3MsIGNvbHMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIF90aGlzLnkgPSB5O1xyXG4gICAgICAgICAgICBfdGhpcy5jZWxsV2lkdGggPSBjZWxsV2lkdGg7XHJcbiAgICAgICAgICAgIF90aGlzLmNlbGxIZWlnaHQgPSBjZWxsSGVpZ2h0O1xyXG4gICAgICAgICAgICBfdGhpcy5yb3dzID0gcm93cztcclxuICAgICAgICAgICAgX3RoaXMuY29scyA9IGNvbHM7XHJcbiAgICAgICAgICAgIF90aGlzLl9jb2xsaWRpbmdYID0gLTE7XHJcbiAgICAgICAgICAgIF90aGlzLl9jb2xsaWRpbmdZID0gLTE7XHJcbiAgICAgICAgICAgIF90aGlzLl9vblNjcmVlblhTdGFydCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl9vblNjcmVlblhFbmQgPSA5OTk5O1xyXG4gICAgICAgICAgICBfdGhpcy5fb25TY3JlZW5ZU3RhcnQgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5fb25TY3JlZW5ZRW5kID0gOTk5OTtcclxuICAgICAgICAgICAgX3RoaXMuX3Nwcml0ZVNoZWV0cyA9IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIgPSBMb2dfOC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgX3RoaXMuZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5kYXRhID0gbmV3IEFycmF5KHJvd3MgKiBjb2xzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93czsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0gbmV3IENlbGwoaSAqIGNlbGxXaWR0aCArIHgsIGogKiBjZWxsSGVpZ2h0ICsgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBpICsgaiAqIGNvbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kYXRhW2kgKyBqICogY29sc10gPSBjZDtcclxuICAgICAgICAgICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUucmVnaXN0ZXJTcHJpdGVTaGVldCA9IGZ1bmN0aW9uIChrZXksIHNwcml0ZVNoZWV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVNoZWV0c1trZXldID0gc3ByaXRlU2hlZXQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gdmVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSBjb2xsaXNpb25zIHdpdGggYWN0b3JzLiBJZiB0aGVyZVxyXG4gICAgICAgICAqIGlzIG5vIGNvbGxpc2lvbiBudWxsIGlzIHJldHVybmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGFjdG9yLnBvcy54ICsgYWN0b3IuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFjdG9yLnBvcy55ICsgYWN0b3IuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHZhciBhY3RvckJvdW5kcyA9IGFjdG9yLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gdHJhY2UgcG9pbnRzIGZvciBvdmVybGFwXHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSBhY3RvckJvdW5kcy5sZWZ0OyB4IDw9IHdpZHRoOyB4ICs9IE1hdGgubWluKGFjdG9yLmdldFdpZHRoKCkgLyAyLCB0aGlzLmNlbGxXaWR0aCAvIDIpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gYWN0b3JCb3VuZHMudG9wOyB5IDw9IGhlaWdodDsgeSArPSBNYXRoLm1pbihhY3Rvci5nZXRIZWlnaHQoKSAvIDIsIHRoaXMuY2VsbEhlaWdodCAvIDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldENlbGxCeVBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsICYmIGNlbGwuc29saWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSBhY3RvckJvdW5kcy5jb2xsaWRlcyhjZWxsLmdldEJvdW5kcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpciA9IGFjdG9yLmdldENlbnRlcigpLnN1YihjZWxsLmdldENlbnRlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgJiYgb3ZlcmxhcC5kb3QoZGlyKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLnB1c2gob3ZlcmxhcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG92ZXJsYXBzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBzbWFsbGVzdCBjaGFuZ2Ugb3RoZXIgdGhhbiB6ZXJvXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvdmVybGFwcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGFjY3VtLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGFjY3VtLnk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYWNjdW0ueCkgPCBNYXRoLmFicyhuZXh0LngpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IG5leHQueDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhhY2N1bS55KSA8IE1hdGguYWJzKG5leHQueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gbmV4dC55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzE2LlZlY3Rvcih4LCB5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBbW0NlbGxdXSBieSBpbmRleCAocm93IG1ham9yIG9yZGVyKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmdldENlbGxCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgW1tDZWxsXV0gYnkgaXRzIHggYW5kIHkgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS5nZXRDZWxsID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5jb2xzIHx8IHkgPj0gdGhpcy5yb3dzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3ggKyB5ICogdGhpcy5jb2xzXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIFtbQ2VsbF1dIGJ5IHRlc3RpbmcgYSBwb2ludCBpbiBnbG9iYWwgY29vcmRpbmF0ZXMsXHJcbiAgICAgICAgICogcmV0dXJucyBgbnVsbGAgaWYgbm8gY2VsbCB3YXMgZm91bmQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUuZ2V0Q2VsbEJ5UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoeCAtIHRoaXMueCkgLyB0aGlzLmNlbGxXaWR0aCk7XHJcbiAgICAgICAgICAgIHkgPSBNYXRoLmZsb29yKCh5IC0gdGhpcy55KSAvIHRoaXMuY2VsbEhlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRDZWxsKHgsIHkpO1xyXG4gICAgICAgICAgICBpZiAoeCA+PSAwICYmIHkgPj0gMCAmJiB4IDwgdGhpcy5jb2xzICYmIHkgPCB0aGlzLnJvd3MgJiYgY2VsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBFdmVudHMuUHJlVXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICB2YXIgd29ybGRDb29yZHNVcHBlckxlZnQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzE2LlZlY3RvcigwLCAwKSk7XHJcbiAgICAgICAgICAgIHZhciB3b3JsZENvb3Jkc0xvd2VyUmlnaHQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzE2LlZlY3RvcihlbmdpbmUuY2FudmFzLmNsaWVudFdpZHRoLCBlbmdpbmUuY2FudmFzLmNsaWVudEhlaWdodCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlblhTdGFydCA9IE1hdGgubWF4KE1hdGguZmxvb3Iod29ybGRDb29yZHNVcHBlckxlZnQueCAvIHRoaXMuY2VsbFdpZHRoKSAtIDIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlbllTdGFydCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzVXBwZXJMZWZ0LnkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KSAtIDIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlblhFbmQgPSBNYXRoLm1heChNYXRoLmZsb29yKHdvcmxkQ29vcmRzTG93ZXJSaWdodC54IC8gdGhpcy5jZWxsV2lkdGgpICsgMiwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWUVuZCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzTG93ZXJSaWdodC55IC0gdGhpcy55KSAvIHRoaXMuY2VsbEhlaWdodCkgKyAyLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0dXBkYXRlJywgbmV3IEV2ZW50cy5Qb3N0VXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgdGhlIHRpbGUgbWFwIHRvIHRoZSBzY3JlZW4uIENhbGxlZCBieSB0aGUgW1tTY2VuZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggICAgVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGRyYXdcclxuICAgICAgICAgKi9cclxuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmVkcmF3JywgbmV3IEV2ZW50cy5QcmVEcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLl9vblNjcmVlblhTdGFydCwgeEVuZCA9IE1hdGgubWluKHRoaXMuX29uU2NyZWVuWEVuZCwgdGhpcy5jb2xzKTtcclxuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLl9vblNjcmVlbllTdGFydCwgeUVuZCA9IE1hdGgubWluKHRoaXMuX29uU2NyZWVuWUVuZCwgdGhpcy5yb3dzKTtcclxuICAgICAgICAgICAgdmFyIGNzLCBjc2ksIGNzbGVuO1xyXG4gICAgICAgICAgICBmb3IgKHg7IHggPCB4RW5kOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAoeTsgeSA8IHlFbmQ7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBub24tbmVnYXRpdmUgdGlsZSBzcHJpdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgY3MgPSB0aGlzLmdldENlbGwoeCwgeSkuc3ByaXRlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuc3ByaXRlSWQgPiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNzaSA9IDAsIGNzbGVuID0gY3MubGVuZ3RoOyBjc2kgPCBjc2xlbjsgY3NpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNzID0gdGhpcy5fc3ByaXRlU2hlZXRzW2NzW2NzaV0uc3ByaXRlU2hlZXRLZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHNwcml0ZSwgd2FybmluZyBpZiBzcHJpdGUgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzcy5nZXRTcHJpdGUoY3NbY3NpXS5zcHJpdGVJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmRyYXcoY3R4LCB4ICogdGhpcy5jZWxsV2lkdGgsIHkgKiB0aGlzLmNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignU3ByaXRlIGRvZXMgbm90IGV4aXN0IGZvciBpZCcsIGNzW2NzaV0uc3ByaXRlSWQsICdpbiBzcHJpdGUgc2hlZXQnLCBjc1tjc2ldLnNwcml0ZVNoZWV0S2V5LCBzcHJpdGUsIHNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1Nwcml0ZSBzaGVldCcsIGNzW2NzaV0uc3ByaXRlU2hlZXRLZXksICdkb2VzIG5vdCBleGlzdCcsIHNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLl9vblNjcmVlbllTdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkcmF3JywgbmV3IEV2ZW50cy5Qb3N0RHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYXdzIGFsbCB0aGUgdGlsZSBtYXAncyBkZWJ1ZyBpbmZvLiBDYWxsZWQgYnkgdGhlIFtbU2NlbmVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gY3R4ICBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jb2xzICogdGhpcy5jZWxsV2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnJvd3MgKiB0aGlzLmNlbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yXzE1LkNvbG9yLlJlZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuY29scyArIDE7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnggKyB4ICogdGhpcy5jZWxsV2lkdGgsIHRoaXMueSk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMueCArIHggKiB0aGlzLmNlbGxXaWR0aCwgdGhpcy55ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHRoaXMucm93cyArIDE7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLngsIHRoaXMueSArIHkgKiB0aGlzLmNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnggKyB3aWR0aCwgdGhpcy55ICsgeSAqIHRoaXMuY2VsbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNvbGlkID0gQ29sb3JfMTUuQ29sb3IuUmVkLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHNvbGlkLmEgPSAuMztcclxuICAgICAgICAgICAgdGhpcy5kYXRhLmZpbHRlcihmdW5jdGlvbiAoY2VsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwuc29saWQ7XHJcbiAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzb2xpZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGNlbGwueCwgY2VsbC55LCBjZWxsLndpZHRoLCBjZWxsLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29sbGlkaW5nWSA+IC0xICYmIHRoaXMuX2NvbGxpZGluZ1ggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzE1LkNvbG9yLkN5YW4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB0aGlzLl9jb2xsaWRpbmdYICogdGhpcy5jZWxsV2lkdGgsIHRoaXMueSArIHRoaXMuX2NvbGxpZGluZ1kgKiB0aGlzLmNlbGxIZWlnaHQsIHRoaXMuY2VsbFdpZHRoLCB0aGlzLmNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVGlsZU1hcDtcclxuICAgIH0oQ2xhc3NfNC5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5UaWxlTWFwID0gVGlsZU1hcDtcclxuICAgIC8qKlxyXG4gICAgICogVGlsZSBzcHJpdGVzIGFyZSB1c2VkIHRvIHJlbmRlciBhIHNwZWNpZmljIHNwcml0ZSBmcm9tIGEgW1tUaWxlTWFwXV0ncyBzcHJpdGVzaGVldChzKVxyXG4gICAgICovXHJcbiAgICB2YXIgVGlsZVNwcml0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHNwcml0ZVNoZWV0S2V5ICBUaGUga2V5IG9mIHRoZSBzcHJpdGVzaGVldCB0byB1c2VcclxuICAgICAgICAgKiBAcGFyYW0gc3ByaXRlSWQgICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc3ByaXRlIGluIHRoZSBbW1Nwcml0ZVNoZWV0XV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBUaWxlU3ByaXRlKHNwcml0ZVNoZWV0S2V5LCBzcHJpdGVJZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZVNoZWV0S2V5ID0gc3ByaXRlU2hlZXRLZXk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlSWQgPSBzcHJpdGVJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFRpbGVTcHJpdGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5UaWxlU3ByaXRlID0gVGlsZVNwcml0ZTtcclxuICAgIC8qKlxyXG4gICAgICogVGlsZU1hcCBDZWxsXHJcbiAgICAgKlxyXG4gICAgICogQSBsaWdodC13ZWlnaHQgb2JqZWN0IHRoYXQgb2NjdXBpZXMgYSBzcGFjZSBpbiBhIGNvbGxpc2lvbiBtYXAuIEdlbmVyYWxseVxyXG4gICAgICogY3JlYXRlZCBieSBhIFtbVGlsZU1hcF1dLlxyXG4gICAgICpcclxuICAgICAqIENlbGxzIGNhbiBkcmF3IG11bHRpcGxlIHNwcml0ZXMuIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgZHJhd2luZyBpcyB0aGUgb3JkZXJcclxuICAgICAqIG9mIHRoZSBzcHJpdGVzIGluIHRoZSBhcnJheSBzbyB0aGUgbGFzdCBvbmUgd2lsbCBiZSBkcmF3biBvbiB0b3AuIFlvdSBjYW5cclxuICAgICAqIHVzZSB0cmFuc3BhcmVuY3kgdG8gY3JlYXRlIGxheWVycyB0aGlzIHdheS5cclxuICAgICAqL1xyXG4gICAgdmFyIENlbGwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgIEdldHMgb3Igc2V0cyB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICBHZXRzIG9yIHNldHMgeSBjb29yZGluYXRlIG9mIHRoZSBjZWxsIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICogQHBhcmFtIHdpZHRoICAgR2V0cyBvciBzZXRzIHRoZSB3aWR0aCBvZiB0aGUgY2VsbFxyXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgIEdldHMgb3Igc2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBjZWxsXHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICAgVGhlIGluZGV4IG9mIHRoZSBjZWxsIGluIHJvdyBtYWpvciBvcmRlclxyXG4gICAgICAgICAqIEBwYXJhbSBzb2xpZCAgIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRoaXMgY2VsbCBpcyBzb2xpZFxyXG4gICAgICAgICAqIEBwYXJhbSBzcHJpdGVzIFRoZSBsaXN0IG9mIHRpbGUgc3ByaXRlcyB0byB1c2UgdG8gZHJhdyBpbiB0aGlzIGNlbGwgKGluIG9yZGVyKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIENlbGwoeCwgeSwgd2lkdGgsIGhlaWdodCwgaW5kZXgsIHNvbGlkLCBzcHJpdGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChzb2xpZCA9PT0gdm9pZCAwKSB7IHNvbGlkID0gZmFsc2U7IH1cclxuICAgICAgICAgICAgaWYgKHNwcml0ZXMgPT09IHZvaWQgMCkgeyBzcHJpdGVzID0gW107IH1cclxuICAgICAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLnNvbGlkID0gc29saWQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IHNwcml0ZXM7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZGluZ0JveF80LkJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55LCB0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkgKyB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBmb3IgdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY2VudGVyIGNvb3JkaW5hdGUgb2YgdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMTYuVmVjdG9yKHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGFub3RoZXIgW1tUaWxlU3ByaXRlXV0gdG8gdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUucHVzaFNwcml0ZSA9IGZ1bmN0aW9uICh0aWxlU3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcy5wdXNoKHRpbGVTcHJpdGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlIGFuIGluc3RhbmNlIG9mIFtbVGlsZVNwcml0ZV1dIGZyb20gdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUucmVtb3ZlU3ByaXRlID0gZnVuY3Rpb24gKHRpbGVTcHJpdGUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGlmICgoaW5kZXggPSB0aGlzLnNwcml0ZXMuaW5kZXhPZih0aWxlU3ByaXRlKSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFyIGFsbCBzcHJpdGVzIGZyb20gdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuY2xlYXJTcHJpdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDZWxsO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ2VsbCA9IENlbGw7XHJcbn0pO1xyXG5kZWZpbmUoXCJUaW1lclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgRXhjYWxpYnVyIHRpbWVyIGhvb2tzIGludG8gdGhlIGludGVybmFsIHRpbWVyIGFuZCBmaXJlcyBjYWxsYmFja3MsXHJcbiAgICAgKiBhZnRlciBhIGNlcnRhaW4gaW50ZXJ2YWwsIG9wdGlvbmFsbHkgcmVwZWF0aW5nLlxyXG4gICAgICovXHJcbiAgICB2YXIgVGltZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBmY24gICAgICAgIFRoZSBjYWxsYmFjayB0byBiZSBmaXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgaXMgY29tcGxldGUuXHJcbiAgICAgICAgICogQHBhcmFtIGludGVydmFsICAgSW50ZXJ2YWwgbGVuZ3RoXHJcbiAgICAgICAgICogQHBhcmFtIHJlcGVhdHMgICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYWxsIGJhY2sgc2hvdWxkIGJlIGZpcmVkIG9ubHkgb25jZSwgb3IgcmVwZWF0IGFmdGVyIGV2ZXJ5IGludGVydmFsIGFzIGNvbXBsZXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBUaW1lcihmY24sIGludGVydmFsLCByZXBlYXRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gMTA7XHJcbiAgICAgICAgICAgIHRoaXMuZmNuID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZUFsaXZlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBUaW1lci5pZCsrO1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWwgfHwgdGhpcy5pbnRlcnZhbDtcclxuICAgICAgICAgICAgdGhpcy5mY24gPSBmY24gfHwgdGhpcy5mY247XHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IHJlcGVhdHMgfHwgdGhpcy5yZXBlYXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB0aW1lciBhZnRlciBhIGNlcnRhaW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBlbmdpbmUuXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICBOdW1iZXIgb2YgZWxhcHNlZCBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZUFsaXZlICs9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29tcGxldGUgJiYgdGhpcy5fZWxhcHNlZFRpbWUgPj0gdGhpcy5pbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmNuLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGUgdGltZXIgc28gdGhhdCBpdCBjYW4gYmUgcmV1c2VkLCBhbmQgb3B0aW9uYWxseSByZWNvbmZpZ3VyZSB0aGUgdGltZXJzIGludGVydmFsLlxyXG4gICAgICAgICAqIEBwYXJhbSBuZXdJbnRlcnZhbCBJZiBzcGVjaWZpZWQsIHNldHMgYSBuZXcgbm9uLW5lZ2F0aXZlIGludGVydmFsIGluIG1pbGxpc2Vjb25kcyB0byByZWZpcmUgdGhlIGNhbGxiYWNrXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGltZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKG5ld0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgIGlmICghIW5ld0ludGVydmFsICYmIG5ld0ludGVydmFsID49IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBuZXdJbnRlcnZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS5nZXRUaW1lUnVubmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsVGltZUFsaXZlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGF1c2VzIHRoZSB0aW1lciBzbyB0aGF0IG5vIG1vcmUgdGltZSB3aWxsIGJlIGluY3JlbWVudGVkIHRvd2FyZHMgdGhlIG5leHQgY2FsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVucGF1c2VzIHRoZSB0aW1lci4gVGltZSB3aWxsIG5vdyBpbmNyZW1lbnQgdG93YXJkcyB0aGUgbmV4dCBjYWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGltZXIucHJvdG90eXBlLnVucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuY2VscyB0aGUgdGltZXIsIHByZXZlbnRpbmcgYW55IGZ1cnRoZXIgZXhlY3V0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUaW1lci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5jYW5jZWxUaW1lcih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRpbWVyO1xyXG4gICAgfSgpKTtcclxuICAgIFRpbWVyLmlkID0gMDtcclxuICAgIGV4cG9ydHMuVGltZXIgPSBUaW1lcjtcclxufSk7XHJcbmRlZmluZShcIlRyaWdnZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiQWN0aW9ucy9BY3Rpb25cIiwgXCJFdmVudERpc3BhdGNoZXJcIiwgXCJBY3RvclwiLCBcIkFsZ2VicmFcIiwgXCJFdmVudHNcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xvcl8xNiwgQWN0aW9uXzEsIEV2ZW50RGlzcGF0Y2hlcl8xLCBBY3Rvcl84LCBBbGdlYnJhXzE3LCBFdmVudHNfNSwgVXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgdHJpZ2dlckRlZmF1bHRzID0ge1xyXG4gICAgICAgIHBvczogQWxnZWJyYV8xNy5WZWN0b3IuWmVyby5jbG9uZSgpLFxyXG4gICAgICAgIHdpZHRoOiAxMCxcclxuICAgICAgICBoZWlnaHQ6IDEwLFxyXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm47IH0sXHJcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxyXG4gICAgICAgIHJlcGVhdDogLTFcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIGFyZSBhIG1ldGhvZCBvZiBmaXJpbmcgYXJiaXRyYXJ5IGNvZGUgb24gY29sbGlzaW9uLiBUaGVzZSBhcmUgdXNlZnVsXHJcbiAgICAgKiBhcyAnYnV0dG9ucycsICdzd2l0Y2hlcycsIG9yIHRvIHRyaWdnZXIgZWZmZWN0cyBpbiBhIGdhbWUuIEJ5IGRlZmF1bHQgdHJpZ2dlcnNcclxuICAgICAqIGFyZSBpbnZpc2libGUsIGFuZCBjYW4gb25seSBiZSBzZWVuIHdoZW4gW1tUcmlnZ2VyLnZpc2libGVdXSBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpUcmlnZ2Vycy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBUcmlnZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVHJpZ2dlciwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBvcHRzIFRyaWdnZXIgb3B0aW9uc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFRyaWdnZXIob3B0cykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzLnBvcy54LCBvcHRzLnBvcy55LCBvcHRzLndpZHRoLCBvcHRzLmhlaWdodCkgfHwgdGhpcztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFjdGlvbiB0byBmaXJlIHdoZW4gdHJpZ2dlcmVkIGJ5IGNvbGxpc2lvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuYWN0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaWx0ZXIgdG8gYWRkIGFkZGl0aW9uYWwgZ3JhbnVsYXJpdHkgdG8gYWN0aW9uIGRpc3BhdGNoLCBpZiBhIGZpbHRlciBpcyBzcGVjaWZpZWQgdGhlIGFjdGlvbiB3aWxsIG9ubHkgZmlyZSB3aGVuXHJcbiAgICAgICAgICAgICAqIGZpbHRlciByZXR1cm4gdHJ1ZSBmb3IgdGhlIGNvbGxpZGVkIGFjdG9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZmlsdGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgYmVmb3JlIGtpbGxpbmcgdGhlIHRyaWdnZXIsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5yZXBlYXQgPSAtMTtcclxuICAgICAgICAgICAgb3B0cyA9IFV0aWwuZXh0ZW5kKHt9LCB0cmlnZ2VyRGVmYXVsdHMsIG9wdHMpO1xyXG4gICAgICAgICAgICBfdGhpcy5maWx0ZXIgPSBvcHRzLmZpbHRlciB8fCBfdGhpcy5maWx0ZXI7XHJcbiAgICAgICAgICAgIF90aGlzLnJlcGVhdCA9IG9wdHMucmVwZWF0IHx8IF90aGlzLnJlcGVhdDtcclxuICAgICAgICAgICAgX3RoaXMuYWN0aW9uID0gb3B0cy5hY3Rpb24gfHwgX3RoaXMuYWN0aW9uO1xyXG4gICAgICAgICAgICBpZiAob3B0cy50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IG9wdHMudGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnZpc2libGUgPSBvcHRzLnZpc2libGU7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbGxpc2lvblR5cGUgPSBBY3Rvcl84LkNvbGxpc2lvblR5cGUuUGFzc2l2ZTtcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlcihfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdGlvblF1ZXVlID0gbmV3IEFjdGlvbl8xLkFjdGlvblF1ZXVlKF90aGlzKTtcclxuICAgICAgICAgICAgX3RoaXMub24oJ2NvbGxpc2lvbnN0YXJ0JywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmZpbHRlcihldnQub3RoZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZW50ZXInLCBuZXcgRXZlbnRzXzUuRW50ZXJUcmlnZ2VyRXZlbnQoX3RoaXMsIGV2dC5vdGhlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwYXRjaEFjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0cmlnZ2VyIGlmIGl0cyBkb25lLCAtMSByZXBlYXQgZm9yZXZlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZXBlYXQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMua2lsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIF90aGlzLm9uKCdjb2xsaXNpb25lbmQnLCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsdGVyKGV2dC5vdGhlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdleGl0JywgbmV3IEV2ZW50c181LkV4aXRUcmlnZ2VyRXZlbnQoX3RoaXMsIGV2dC5vdGhlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJpZ2dlci5wcm90b3R5cGUsIFwidGFyZ2V0XCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gZnVuY3Rpb24gKGFjdG9yKSB7IHJldHVybiBhY3RvciA9PT0gdGFyZ2V0OyB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBUcmlnZ2VyLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5faW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVuZ2luZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRyaWdnZXIucHJvdG90eXBlLl9kaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb24uY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBlYXQtLTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgVHJpZ2dlci5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlYnVnRHJhdy5jYWxsKHRoaXMsIGN0eCk7XHJcbiAgICAgICAgICAgIC8vIE1lYW50IHRvIGRyYXcgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgYWN0b3JzXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5wb3MueCwgdGhpcy5wb3MueSk7XHJcbiAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHZhciB3cCA9IHRoaXMuZ2V0V29ybGRQb3MoKTtcclxuICAgICAgICAgICAgYmIubGVmdCA9IGJiLmxlZnQgLSB3cC54O1xyXG4gICAgICAgICAgICBiYi5yaWdodCA9IGJiLnJpZ2h0IC0gd3AueDtcclxuICAgICAgICAgICAgYmIudG9wID0gYmIudG9wIC0gd3AueTtcclxuICAgICAgICAgICAgYmIuYm90dG9tID0gYmIuYm90dG9tIC0gd3AueTtcclxuICAgICAgICAgICAgLy8gQ3VycmVudGx5IGNvbGxpc2lvbiBwcmltaXRpdmVzIGNhbm5vdCByb3RhdGUgXHJcbiAgICAgICAgICAgIC8vIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8xNi5Db2xvci5WaW9sZXQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3JfMTYuQ29sb3IuVmlvbGV0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCgnVHJpZ2dlcicsIDEwLCAxMCk7XHJcbiAgICAgICAgICAgIGJiLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRyaWdnZXI7XHJcbiAgICB9KEFjdG9yXzguQWN0b3IpKTtcclxuICAgIGV4cG9ydHMuVHJpZ2dlciA9IFRyaWdnZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJBY3Rpb25zL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0aW9ucy9BY3Rpb25Db250ZXh0XCIsIFwiQWN0aW9ucy9Sb3RhdGlvblR5cGVcIiwgXCJBY3Rpb25zL0FjdGlvblwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFjdGlvbkNvbnRleHRfMiwgUm90YXRpb25UeXBlXzEsIGFjdGlvbnMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KEFjdGlvbkNvbnRleHRfMik7XHJcbiAgICBfX2V4cG9ydChSb3RhdGlvblR5cGVfMSk7XHJcbiAgICBleHBvcnRzLkFjdGlvbnMgPSBhY3Rpb25zO1xyXG4gICAgLy8gbGVnYWN5IEludGVybmFsLkFjdGlvbnMgbmFtZXNwYWNlIHN1cHBvcnRcclxuICAgIGV4cG9ydHMuSW50ZXJuYWwgPSB7IEFjdGlvbnM6IGFjdGlvbnMgfTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9EeW5hbWljVHJlZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlBoeXNpY3NcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJVdGlsL0xvZ1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBoeXNpY3NfOCwgQm91bmRpbmdCb3hfNSwgTG9nXzkpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEeW5hbWljIFRyZWUgTm9kZSB1c2VkIGZvciB0cmFja2luZyBib3VuZHMgd2l0aGluIHRoZSB0cmVlXHJcbiAgICAgKi9cclxuICAgIHZhciBUcmVlTm9kZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gVHJlZU5vZGUocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyBCb3VuZGluZ0JveF81LkJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoIXRoaXMubGVmdCAmJiAhdGhpcy5yaWdodCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVHJlZU5vZGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5UcmVlTm9kZSA9IFRyZWVOb2RlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgRHluYW1pY1RyZWVzIHByb3ZpZGVzIGEgc3BhdGlhbCBwYXJ0aWlvbmluZyBkYXRhIHN0cnVjdHVyZSBmb3IgcXVpY2tseSBxdWVyeWluZyBmb3Igb3ZlcmxhcHBpbmcgYm91bmRpbmcgYm94ZXMgZm9yXHJcbiAgICAgKiBhbGwgdHJhY2tlZCBib2RpZXMuIFRoZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIG9mIHRoaXMgaXMgTyhuKmxvZyhuKSkgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIGJvZGllcyBpbiB0aGUgdHJlZS5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbGx5IHRoZSBib3VuZGluZyBib3hlcyBhcmUgb3JnYW5pemVkIGFzIGEgYmFsYW5jZWQgYmluYXJ5IHRyZWUgb2YgYm91bmRpbmcgYm94ZXMsIHdoZXJlIHRoZSBsZWFmIG5vZGVzIGFyZSB0cmFja2VkIGJvZGllcy5cclxuICAgICAqIEV2ZXJ5IG5vbi1sZWFmIG5vZGUgaXMgYSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBjaGlsZCBib3VuZGluZyBib3hlcy5cclxuICAgICAqL1xyXG4gICAgdmFyIER5bmFtaWNUcmVlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEeW5hbWljVHJlZSh3b3JsZEJvdW5kcykge1xyXG4gICAgICAgICAgICBpZiAod29ybGRCb3VuZHMgPT09IHZvaWQgMCkgeyB3b3JsZEJvdW5kcyA9IG5ldyBCb3VuZGluZ0JveF81LkJvdW5kaW5nQm94KC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7IH1cclxuICAgICAgICAgICAgdGhpcy53b3JsZEJvdW5kcyA9IHdvcmxkQm91bmRzO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc2VydHMgYSBub2RlIGludG8gdGhlIGR5bmFtaWMgdHJlZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5faW5zZXJ0ID0gZnVuY3Rpb24gKGxlYWYpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG5vZGVzIGluIHRoZSB0cmVlLCBtYWtlIHRoaXMgdGhlIHJvb3QgbGVhZlxyXG4gICAgICAgICAgICBpZiAodGhpcy5yb290ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBsZWFmO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2VhcmNoIHRoZSB0cmVlIGZvciBhIG5vZGUgdGhhdCBpcyBub3QgYSBsZWFmIGFuZCBmaW5kIHRoZSBiZXN0IHBsYWNlIHRvIGluc2VydFxyXG4gICAgICAgICAgICB2YXIgbGVhZkFBQkIgPSBsZWFmLmJvdW5kcztcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb290ID0gdGhpcy5yb290O1xyXG4gICAgICAgICAgICB3aGlsZSAoIWN1cnJlbnRSb290LmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGN1cnJlbnRSb290LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBjdXJyZW50Um9vdC5yaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBhcmVhID0gY3VycmVudFJvb3QuYm91bmRzLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbWJpbmVkQUFCQiA9IGN1cnJlbnRSb290LmJvdW5kcy5jb21iaW5lKGxlYWZBQUJCKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb21iaW5lZEFyZWEgPSBjb21iaW5lZEFBQkIuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgY29zdCBoZXVyaXN0aWMgZm9yIGNyZWF0aW5nIGEgbmV3IHBhcmVudCBhbmQgbGVhZlxyXG4gICAgICAgICAgICAgICAgdmFyIGNvc3QgPSAyICogY29tYmluZWRBcmVhO1xyXG4gICAgICAgICAgICAgICAgLy8gTWluaW11bSBjb3N0IG9mIHB1c2hpbmcgdGhlIGxlYWYgZG93biB0aGUgdHJlZVxyXG4gICAgICAgICAgICAgICAgdmFyIGluaGVyaXRhbmNlQ29zdCA9IDIgKiAoY29tYmluZWRBcmVhIC0gYXJlYSk7XHJcbiAgICAgICAgICAgICAgICAvLyBDb3N0IG9mIGRlc2NlbmRpbmdcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0Q29zdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdENvbWJpbmVkID0gbGVhZkFBQkIuY29tYmluZShsZWZ0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3QXJlYTtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRBcmVhO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnQuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0Q29zdCA9IGxlZnRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZEFyZWEgPSBsZWZ0LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdBcmVhID0gbGVmdENvbWJpbmVkLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRDb3N0ID0gKG5ld0FyZWEgLSBvbGRBcmVhKSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByaWdodENvc3QgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q29tYmluZWQgPSBsZWFmQUFCQi5jb21iaW5lKHJpZ2h0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodENvc3QgPSByaWdodENvbWJpbmVkLmdldFBlcmltZXRlcigpICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkQXJlYSA9IHJpZ2h0LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdBcmVhID0gcmlnaHRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICByaWdodENvc3QgPSAobmV3QXJlYSAtIG9sZEFyZWEpICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29zdCBpcyBhY2NlcHRhYmxlXHJcbiAgICAgICAgICAgICAgICBpZiAoY29zdCA8IGxlZnRDb3N0ICYmIGNvc3QgPCByaWdodENvc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgdG8gdGhlIGRlcHRoc1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRDb3N0IDwgcmlnaHRDb3N0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvb3QgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvb3QgPSByaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBwYXJlbnQgbm9kZSBhbmQgaW5zZXJ0IGludG8gdGhlIHRyZWVcclxuICAgICAgICAgICAgdmFyIG9sZFBhcmVudCA9IGN1cnJlbnRSb290LnBhcmVudDtcclxuICAgICAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ldyBUcmVlTm9kZShvbGRQYXJlbnQpO1xyXG4gICAgICAgICAgICBuZXdQYXJlbnQuYm91bmRzID0gbGVhZkFBQkIuY29tYmluZShjdXJyZW50Um9vdC5ib3VuZHMpO1xyXG4gICAgICAgICAgICBuZXdQYXJlbnQuaGVpZ2h0ID0gY3VycmVudFJvb3QuaGVpZ2h0ICsgMTtcclxuICAgICAgICAgICAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNpYmxpbmcgbm9kZSB3YXMgbm90IHRoZSByb290XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkUGFyZW50LmxlZnQgPT09IGN1cnJlbnRSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyZW50LmxlZnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQucmlnaHQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQubGVmdCA9IGN1cnJlbnRSb290O1xyXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gbGVhZjtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb290LnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgICAgIGxlYWYucGFyZW50ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNpYmxpbmcgbm9kZSB3YXMgdGhlIHJvb3RcclxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5sZWZ0ID0gY3VycmVudFJvb3Q7XHJcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQucmlnaHQgPSBsZWFmO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvb3QucGFyZW50ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2FsayB1cCB0aGUgdHJlZSBmaXhpbmcgaGVpZ2h0cyBhbmQgQUFCQnNcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gbGVhZi5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLl9iYWxhbmNlKGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudE5vZGUubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IG9mIGN1cnJlbnQgbGVhZiBjYW5ub3QgaGF2ZSBhIG51bGwgbGVmdCBjaGlsZCcgKyBjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnROb2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgb2YgY3VycmVudCBsZWFmIGNhbm5vdCBoYXZlIGEgbnVsbCByaWdodCBjaGlsZCcgKyBjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoY3VycmVudE5vZGUubGVmdC5oZWlnaHQsIGN1cnJlbnROb2RlLnJpZ2h0LmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMgPSBjdXJyZW50Tm9kZS5sZWZ0LmJvdW5kcy5jb21iaW5lKGN1cnJlbnROb2RlLnJpZ2h0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAobGVhZikge1xyXG4gICAgICAgICAgICBpZiAobGVhZiA9PT0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBsZWFmLnBhcmVudDtcclxuICAgICAgICAgICAgdmFyIGdyYW5kUGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgdmFyIHNpYmxpbmc7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQubGVmdCA9PT0gbGVhZikge1xyXG4gICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JhbmRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChncmFuZFBhcmVudC5sZWZ0ID09PSBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFuZFBhcmVudC5sZWZ0ID0gc2libGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYW5kUGFyZW50LnJpZ2h0ID0gc2libGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gZ3JhbmRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBncmFuZFBhcmVudDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy5fYmFsYW5jZShjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzID0gY3VycmVudE5vZGUubGVmdC5ib3VuZHMuY29tYmluZShjdXJyZW50Tm9kZS5yaWdodC5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmhlaWdodCA9IDEgKyBNYXRoLm1heChjdXJyZW50Tm9kZS5sZWZ0LmhlaWdodCwgY3VycmVudE5vZGUucmlnaHQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrcyBhIGJvZHkgaW4gdGhlIGR5bmFtaWMgdHJlZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS50cmFja0JvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBUcmVlTm9kZSgpO1xyXG4gICAgICAgICAgICBub2RlLmJvZHkgPSBib2R5O1xyXG4gICAgICAgICAgICBub2RlLmJvdW5kcyA9IGJvZHkuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLmxlZnQgLT0gMjtcclxuICAgICAgICAgICAgbm9kZS5ib3VuZHMudG9wIC09IDI7XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLnJpZ2h0ICs9IDI7XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLmJvdHRvbSArPSAyO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzW2JvZHkuYWN0b3IuaWRdID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgZHluYW1pYyB0cmVlIGdpdmVuIHRoZSBjdXJyZW50IGJvdW5kcyBvZiBlYWNoIGJvZHkgYmVpbmcgdHJhY2tlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS51cGRhdGVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2JvZHkuYWN0b3IuaWRdO1xyXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYiA9IGJvZHkuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBib2R5IGlzIG91dHNpZGUgdGhlIHdvcmxkIG5vIGxvbmdlciB1cGRhdGUgaXRcclxuICAgICAgICAgICAgaWYgKCF0aGlzLndvcmxkQm91bmRzLmNvbnRhaW5zKGIpKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfOS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdBY3RvciB3aXRoIGlkICcgKyBib2R5LmFjdG9yLmlkICtcclxuICAgICAgICAgICAgICAgICAgICAnIGlzIG91dHNpZGUgdGhlIHdvcmxkIGJvdW5kcyBhbmQgd2lsbCBubyBsb25nZXIgYmUgdHJhY2tlZCBmb3IgcGh5c2ljcycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bnRyYWNrQm9keShib2R5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5ib3VuZHMuY29udGFpbnMoYikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIGIubGVmdCAtPSBQaHlzaWNzXzguUGh5c2ljcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgICAgICBiLnRvcCAtPSBQaHlzaWNzXzguUGh5c2ljcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgICAgICBiLnJpZ2h0ICs9IFBoeXNpY3NfOC5QaHlzaWNzLmJvdW5kc1BhZGRpbmc7XHJcbiAgICAgICAgICAgIGIuYm90dG9tICs9IFBoeXNpY3NfOC5QaHlzaWNzLmJvdW5kc1BhZGRpbmc7XHJcbiAgICAgICAgICAgIHZhciBtdWx0ZHggPSBib2R5LnZlbC54ICogUGh5c2ljc184LlBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGx5ZXI7XHJcbiAgICAgICAgICAgIHZhciBtdWx0ZHkgPSBib2R5LnZlbC55ICogUGh5c2ljc184LlBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGx5ZXI7XHJcbiAgICAgICAgICAgIGlmIChtdWx0ZHggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBiLmxlZnQgKz0gbXVsdGR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYi5yaWdodCArPSBtdWx0ZHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG11bHRkeSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGIudG9wICs9IG11bHRkeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGIuYm90dG9tICs9IG11bHRkeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlLmJvdW5kcyA9IGI7XHJcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnRyYWNrcyBhIGJvZHkgZnJvbSB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnVudHJhY2tCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2JvZHkuYWN0b3IuaWRdO1xyXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZXNbYm9keS5hY3Rvci5pZF0gPSBudWxsO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1tib2R5LmFjdG9yLmlkXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJhbGFuY2VzIHRoZSB0cmVlIGFib3V0IGEgbm9kZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5fYmFsYW5jZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBiYWxhbmNlIGF0IG51bGwgbm9kZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpIHx8IG5vZGUuaGVpZ2h0IDwgMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBhID0gbm9kZTtcclxuICAgICAgICAgICAgdmFyIGIgPSBsZWZ0O1xyXG4gICAgICAgICAgICB2YXIgYyA9IHJpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgZCA9IGxlZnQubGVmdDtcclxuICAgICAgICAgICAgdmFyIGUgPSBsZWZ0LnJpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgZiA9IHJpZ2h0LmxlZnQ7XHJcbiAgICAgICAgICAgIHZhciBnID0gcmlnaHQucmlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBiYWxhbmNlID0gYy5oZWlnaHQgLSBiLmhlaWdodDtcclxuICAgICAgICAgICAgLy8gUm90YXRlIGMgbm9kZSB1cFxyXG4gICAgICAgICAgICBpZiAoYmFsYW5jZSA+IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN3YXAgdGhlIHJpZ2h0IG5vZGUgd2l0aCBpdCdzIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgYy5sZWZ0ID0gYTtcclxuICAgICAgICAgICAgICAgIGMucGFyZW50ID0gYS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBhLnBhcmVudCA9IGM7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgbm9kZSdzIG9sZCBwYXJlbnQgc2hvdWxkIHBvaW50IHRvIHRoZSByaWdodCBub2RlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG1lZ2EgY29uZnVzaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoYy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5wYXJlbnQubGVmdCA9PT0gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLnBhcmVudC5sZWZ0ID0gYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucGFyZW50LnJpZ2h0ID0gYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUm90YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoZi5oZWlnaHQgPiBnLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMucmlnaHQgPSBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGEucmlnaHQgPSBnO1xyXG4gICAgICAgICAgICAgICAgICAgIGcucGFyZW50ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGIuYm91bmRzLmNvbWJpbmUoZy5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShmLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYi5oZWlnaHQsIGcuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBjLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZi5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5yaWdodCA9IGc7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5yaWdodCA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgZi5wYXJlbnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYi5ib3VuZHMuY29tYmluZShmLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGcuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChiLmhlaWdodCwgZi5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBnLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSb3RhdGUgbGVmdCBub2RlIHVwXHJcbiAgICAgICAgICAgIGlmIChiYWxhbmNlIDwgLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN3YXBcclxuICAgICAgICAgICAgICAgIGIubGVmdCA9IGE7XHJcbiAgICAgICAgICAgICAgICBiLnBhcmVudCA9IGEucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgYS5wYXJlbnQgPSBiO1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZSdzIG9sZCBwYXJlbnQgc2hvdWxkIHBvaW50IHRvIGJcclxuICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudC5sZWZ0ID09PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucGFyZW50LmxlZnQgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIucGFyZW50LnJpZ2h0ICE9PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnRXJyb3Igcm90YXRpbmcgRHluYW1pYyBUcmVlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnBhcmVudC5yaWdodCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHJvdGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGQuaGVpZ2h0ID4gZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBiLnJpZ2h0ID0gZDtcclxuICAgICAgICAgICAgICAgICAgICBhLmxlZnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGUucGFyZW50ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGMuYm91bmRzLmNvbWJpbmUoZS5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShkLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYy5oZWlnaHQsIGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBiLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5yaWdodCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5sZWZ0ID0gZDtcclxuICAgICAgICAgICAgICAgICAgICBkLnBhcmVudCA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBjLmJvdW5kcy5jb21iaW5lKGQuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBiLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZS5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGMuaGVpZ2h0LCBkLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgaGVpZ2h0IG9mIHRoZSB0cmVlLCBzaG9ydGVyIHRyZWVzIGFyZSBiZXR0ZXIuIFBlcmZvcm1hbmNlIGRyb3BzIGFzIHRoZSB0cmVlIGdyb3dzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5oZWlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBRdWVyaWVzIHRoZSBEeW5hbWljIEF4aXMgQWxpZ25lZCBUcmVlIGZvciBib2RpZXMgdGhhdCBjb3VsZCBiZSBjb2xsaWRpbmcgd2l0aCB0aGUgcHJvdmlkZWQgYm9keS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEluIHRoZSBxdWVyeSBjYWxsYmFjaywgaXQgd2lsbCBiZSBwYXNzZWQgYSBwb3RlbnRpYWwgY29sbGlkZXIuIFJldHVybmluZyB0cnVlIGZyb20gdGhpcyBjYWxsYmFjayBpbmRpY2F0ZXNcclxuICAgICAgICAgKiB0aGF0IHlvdSBhcmUgY29tcGxldGUgd2l0aCB5b3VyIHF1ZXJ5IGFuZCB5b3UgZG8gbm90IHdhbnQgdG8gY29udGludWUuIFJldHVybmluZyBmYWxzZSB3aWxsIGNvbnRpbnVlIHNlYXJjaGluZ1xyXG4gICAgICAgICAqIHRoZSB0cmVlIHVudGlsIGFsbCBwb3NzaWJsZSBjb2xsaWRlcnMgaGF2ZSBiZWVuIHJldHVybmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChib2R5LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgYm91bmRzID0gYm9keS5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLmJvdW5kcy5jb2xsaWRlcyhib3VuZHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmlzTGVhZigpICYmIGN1cnJlbnROb2RlLmJvZHkgIT09IGJvZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoYm9keSwgY3VycmVudE5vZGUuYm9keSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpIHx8IGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBoZWxwZXIodGhpcy5yb290KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFF1ZXJpZXMgdGhlIER5bmFtaWMgQXhpcyBBbGlnbmVkIFRyZWUgZm9yIGJvZGllcyB0aGF0IGNvdWxkIGJlIGludGVyc2VjdGluZy4gQnkgZGVmYXVsdCB0aGUgcmF5Y2FzdCBxdWVyeSB1c2VzIGFuIGluZmluaXRlbHlcclxuICAgICAgICAgKiBsb25nIHJheSB0byB0ZXN0IHRoZSB0cmVlIHNwZWNpZmllZCBieSBgbWF4YC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEluIHRoZSBxdWVyeSBjYWxsYmFjaywgaXQgd2lsbCBiZSBwYXNzZWQgYSBwb3RlbnRpYWwgYm9keSB0aGF0IGludGVyc2VjdHMgd2l0aCB0aGUgcmFjYXN0LiBSZXR1cm5pbmcgdHJ1ZSBmcm9tIHRoaXNcclxuICAgICAgICAgKiBjYWxsYmFjayBpbmRpY2F0ZXMgdGhhdCB5b3VyIGFyZSBjb21wbGV0ZSB3aXRoIHlvdXIgcXVlcnkgYW5kIGRvIG5vdCB3YW50IHRvIGNvbnRpbnVlLiBSZXR1cm4gZmFsc2Ugd2lsbCBjb250aW51ZSBzZWFyY2hpbmdcclxuICAgICAgICAgKiB0aGUgdHJlZSB1bnRpbCBhbGwgcG9zc2libGUgYm9kaWVzIHRoYXQgd291bGQgaW50ZXJzZWN0IHdpdGggdGhlIHJheSBoYXZlIGJlZW4gcmV0dXJuZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJheUNhc3RRdWVyeSA9IGZ1bmN0aW9uIChyYXksIG1heCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgICAgIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSAmJiBjdXJyZW50Tm9kZS5ib3VuZHMucmF5Q2FzdChyYXksIG1heCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwocmF5LCBjdXJyZW50Tm9kZS5ib2R5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmF5IGhpdCBhIGxlYWYhIHJldHVybiB0aGUgYm9keVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJheSBoaXQgYnV0IG5vdCBhdCBhIGxlYWYsIHJlY3Vyc2UgZGVlcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXIoY3VycmVudE5vZGUubGVmdCkgfHwgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJheSBtaXNzZWQgICAgICAgICBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaGVscGVyKHRoaXMucm9vdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3VycmVudE5vZGVdLmNvbmNhdChoZWxwZXIoY3VycmVudE5vZGUubGVmdCksIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVyKHRoaXMucm9vdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAvLyBkcmF3IGFsbCB0aGUgbm9kZXMgaW4gdGhlIER5bmFtaWMgVHJlZVxyXG4gICAgICAgICAgICB2YXIgaGVscGVyID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3doaXRlJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBoZWxwZXIodGhpcy5yb290KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEeW5hbWljVHJlZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkR5bmFtaWNUcmVlID0gRHluYW1pY1RyZWU7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vSUNvbGxpc2lvblJlc29sdmVyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkNvbGxpc2lvbi9EeW5hbWljVHJlZVwiLCBcIkNvbGxpc2lvbi9QYWlyXCIsIFwiQWxnZWJyYVwiLCBcIkFjdG9yXCIsIFwiVXRpbC9Mb2dcIiwgXCJFdmVudHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzksIER5bmFtaWNUcmVlXzEsIFBhaXJfMiwgQWxnZWJyYV8xOCwgQWN0b3JfOSwgTG9nXzEwLCBFdmVudHNfNikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlID0gbmV3IER5bmFtaWNUcmVlXzEuRHluYW1pY1RyZWUoKTtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnNIYXNoID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrcyBhIHBoeXNpY3MgYm9keSBmb3IgY29sbGlzaW9uc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfMTAuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQ2Fubm90IHRyYWNrIG51bGwgcGh5c2ljcyBib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudHJhY2tCb2R5KHRhcmdldCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnRyYWNrcyBhIHBoeXNpY3MgYm9keVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUudW50cmFjayA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIExvZ18xMC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdDYW5ub3QgdW50cmFjayBhIG51bGwgcGh5c2ljcyBib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudW50cmFja0JvZHkodGFyZ2V0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUuX2NhbkNvbGxpZGUgPSBmdW5jdGlvbiAoYWN0b3JBLCBhY3RvckIpIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbGxpc2lvbiBwYWlyIGhhcyBiZWVuIGNhbGN1bGF0ZWQgYWxyZWFkeSBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gUGFpcl8yLlBhaXIuY2FsY3VsYXRlUGFpckhhc2goYWN0b3JBLmJvZHksIGFjdG9yQi5ib2R5KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxpc2lvbkhhc2hbaGFzaF0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcGFpciBleGlzdHMgZWFzeSBleGl0IHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIGJvdGggYXJlIGZpeGVkIHNob3J0IGNpcmN1aXRcclxuICAgICAgICAgICAgaWYgKGFjdG9yQS5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl85LkNvbGxpc2lvblR5cGUuRml4ZWQgJiYgYWN0b3JCLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzkuQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBvdGhlciBpcyBwcmV2ZW50IGNvbGxpc2lvbiBvciBpcyBkZWFkIHNob3J0IGNpcmN1aXRcclxuICAgICAgICAgICAgaWYgKGFjdG9yQi5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl85LkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbiB8fCBhY3RvckIuaXNLaWxsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoZXkgY2FuIGNvbGxpZGVcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXRlY3RzIHBvdGVudGlhbCBjb2xsaXNpb24gcGFpcnMgaW4gYSBicm9hZHBoYXNlIGFwcHJvYWNoIHdpdGggdGhlIGR5bmFtaWMgYWFiYiB0cmVlIHN0cmF0ZWd5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5icm9hZHBoYXNlID0gZnVuY3Rpb24gKHRhcmdldHMsIGRlbHRhLCBzdGF0cykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgc2Vjb25kcyA9IGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgLy8gVE9ETyBvcHRpbWl6YXRpb24gdXNlIG9ubHkgdGhlIGFjdG9ycyB0aGF0IGFyZSBtb3ZpbmcgdG8gc3RhcnQgXHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBsaXN0IG9mIHBvdGVudGlhbCBjb2xsaWRlcnMsIGV4Y2x1ZGUga2lsbGVkLCBwcmV2ZW50ZWQsIGFuZCBzZWxmXHJcbiAgICAgICAgICAgIHZhciBwb3RlbnRpYWxDb2xsaWRlcnMgPSB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhb3RoZXIuaXNLaWxsZWQoKSAmJiBvdGhlci5jb2xsaXNpb25UeXBlICE9PSBBY3Rvcl85LkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGNsZWFyIG9sZCBsaXN0IG9mIGNvbGxpc2lvbiBwYWlyc1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igbm9ybWFsIGNvbGxpc2lvbiBwYWlyc1xyXG4gICAgICAgICAgICB2YXIgYWN0b3I7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gcG90ZW50aWFsQ29sbGlkZXJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYWN0b3IgPSBwb3RlbnRpYWxDb2xsaWRlcnNbal07XHJcbiAgICAgICAgICAgICAgICAvLyBRdWVyeSB0aGUgY29sbGlzaW9uIHRyZWUgZm9yIHBvdGVudGlhbCBjb2xsaWRlcnNcclxuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnF1ZXJ5KGFjdG9yLmJvZHksIGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fY2FuQ29sbGlkZShhY3Rvciwgb3RoZXIuYWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0gbmV3IFBhaXJfMi5QYWlyKGFjdG9yLmJvZHksIG90aGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NvbGxpc2lvbkhhc2hbcGFpci5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlLnB1c2gocGFpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gZmFsc2UsIHRvIHF1ZXJ5IHdob2xlIHRyZWUuIFJldHVybmluZyB0cnVlIGluIHRoZSBxdWVyeSBtZXRob2Qgc3RvcHMgc2VhcmNoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLnBhaXJzID0gdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDaGVjayBkeW5hbWljIHRyZWUgZm9yIGZhc3QgbW92aW5nIG9iamVjdHNcclxuICAgICAgICAgICAgLy8gRmFzdCBtb3Zpbmcgb2JqZWN0cyBhcmUgdGhvc2UgbW92aW5nIGF0IGxlYXN0IHRoZXJlIHNtYWxsZXN0IGJvdW5kIHBlciBmcmFtZVxyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc185LlBoeXNpY3MuY2hlY2tGb3JGYXN0Qm9kaWVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBvdGVudGlhbENvbGxpZGVyc18xID0gcG90ZW50aWFsQ29sbGlkZXJzOyBfaSA8IHBvdGVudGlhbENvbGxpZGVyc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvciA9IHBvdGVudGlhbENvbGxpZGVyc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIG5vbi1hY3RpdmUgb2JqZWN0cy4gRG9lcyBub3QgbWFrZSBzZW5zZSBvbiBvdGhlciBjb2xsaXNvbiB0eXBlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb2xsaXNpb25UeXBlICE9PSBBY3Rvcl85LkNvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF4aW11bSB0cmF2ZWwgZGlzdGFuY2UgbmV4dCBmcmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVEaXN0YW5jZSA9IChhY3Rvci52ZWwubWFnbml0dWRlKCkgKiBzZWNvbmRzKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChhY3Rvci5hY2MubWFnbml0dWRlKCkgKiAuNSAqIHNlY29uZHMgKiBzZWNvbmRzKTsgLy8gYWNjIHRlcm1cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtaW5pbXVtIGRpbWVuc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5EaW1lbnNpb24gPSBNYXRoLm1pbihhY3Rvci5ib2R5LmdldEJvdW5kcygpLmdldEhlaWdodCgpLCBhY3Rvci5ib2R5LmdldEJvdW5kcygpLmdldFdpZHRoKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzkuUGh5c2ljcy5kaXNhYmxlTWluaW11bVNwZWVkRm9yRmFzdEJvZHkgfHwgdXBkYXRlRGlzdGFuY2UgPiAobWluRGltZW5zaW9uIC8gMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmZhc3RCb2RpZXMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCB3aXRoIHRoZSBvbGRQb3MgYmVjYXVzZSB0aGUgaW50ZWdyYXRpb24gZm9yIGFjdG9ycyBoYXMgYWxyZWFkeSBoYXBwZW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHJlc3Rpbmcgb24gYSBzdXJmYWNlIG1heSBiZSBzbGlnaHRseSBwZW5hdHJhdGluZyBpbiB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlVmVjID0gYWN0b3IucG9zLnN1YihhY3Rvci5vbGRQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyUG9pbnQgPSBhY3Rvci5ib2R5LmNvbGxpc2lvbkFyZWEuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdXJ0aGVzdFBvaW50ID0gYWN0b3IuYm9keS5jb2xsaXNpb25BcmVhLmdldEZ1cnRoZXN0UG9pbnQoYWN0b3IudmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IGZ1cnRoZXN0UG9pbnQuc3ViKHVwZGF0ZVZlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXkgPSBuZXcgQWxnZWJyYV8xOC5SYXkob3JpZ2luLCBhY3Rvci52ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIHRoZSByYXkgdXAgYnkgLTJ4IHN1cmZhY2VFcHNpbG9uIHRvIGFjY291bnQgZm9yIGZhc3QgbW92aW5nIG9iamVjdHMgc3RhcnRpbmcgb24gdGhlIHN1cmZhY2UgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJheS5wb3MgPSByYXkucG9zLmFkZChyYXkuZGlyLnNjYWxlKC0yICogUGh5c2ljc185LlBoeXNpY3Muc3VyZmFjZUVwc2lsb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5UcmFuc2xhdGUgPSBuZXcgQWxnZWJyYV8xOC5WZWN0b3IoSW5maW5pdHksIEluZmluaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUucmF5Q2FzdFF1ZXJ5KHJheSwgdXBkYXRlRGlzdGFuY2UgKyBQaHlzaWNzXzkuUGh5c2ljcy5zdXJmYWNlRXBzaWxvbiAqIDIsIGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmJvZHkgIT09IG90aGVyICYmIG90aGVyLmNvbGxpc2lvbkFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGl0UG9pbnQgPSBvdGhlci5jb2xsaXNpb25BcmVhLnJheUNhc3QocmF5LCB1cGRhdGVEaXN0YW5jZSArIFBoeXNpY3NfOS5QaHlzaWNzLnN1cmZhY2VFcHNpbG9uICogMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaXRQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gaGl0UG9pbnQuc3ViKG9yaWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGUubWFnbml0dWRlKCkgPCBtaW5UcmFuc2xhdGUubWFnbml0dWRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkJvZHkgPSBvdGhlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5Cb2R5ICYmIEFsZ2VicmFfMTguVmVjdG9yLmlzVmFsaWQobWluVHJhbnNsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBuZXcgUGFpcl8yLlBhaXIoYWN0b3IuYm9keSwgbWluQm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NvbGxpc2lvbkhhc2hbcGFpci5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYXNoW3BhaXIuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGZhc3QgbW92aW5nIG9iamVjdCB0byB0aGUgb3RoZXIgYm9keVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBwdXNoIGludG8gdGhlIHN1cmZhY2UgYnkgZXguUGh5c2ljcy5zdXJmYWNlRXBzaWxvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNoaWZ0ID0gY2VudGVyUG9pbnQuc3ViKGZ1cnRoZXN0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IucG9zID0gb3JpZ2luLmFkZChzaGlmdCkuYWRkKG1pblRyYW5zbGF0ZSkuYWRkKHJheS5kaXIuc2NhbGUoMiAqIFBoeXNpY3NfOS5QaHlzaWNzLnN1cmZhY2VFcHNpbG9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5ib2R5LmNvbGxpc2lvbkFyZWEucmVjYWxjKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmZhc3RCb2R5Q29sbGlzaW9ucysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBjYWNoZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyBuYXJyb3cgcGhhc2Ugb24gY29sbGlzaW9uIHBhaXJzIHRvIGZpbmQgYWN0dWFsIGFyZWEgaW50ZXJzZWN0aW9uc1xyXG4gICAgICAgICAqIEFkZHMgYWN0dWFsIGNvbGxpZGluZyBwYWlycyB0byBzdGF0cycgRnJhbWUgZGF0YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUubmFycm93cGhhc2UgPSBmdW5jdGlvbiAocGFpcnMsIHN0YXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhaXJzW2ldLmNvbGxpZGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0cyAmJiBwYWlyc1tpXS5jb2xsaXNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmNvbGxpc2lvbnMrKztcclxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmNvbGxpZGVyc0hhc2hbcGFpcnNbaV0uaWRdID0gcGFpcnNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhaXJzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5jb2xsaXNpb247IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybSBjb2xsaXNpb24gcmVzb2x1dGlvbiBnaXZlbiBhIHN0cmF0ZWd5IChyaWdpZCBib2R5IG9yIGJveCkgYW5kIG1vdmUgb2JqZWN0cyBvdXQgb2YgaW50ZXJzZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChwYWlycywgZGVsdGEsIHN0cmF0ZWd5KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFpcnNfMSA9IHBhaXJzOyBfaSA8IHBhaXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgcGFpci5yZXNvbHZlKHN0cmF0ZWd5KTtcclxuICAgICAgICAgICAgICAgIGlmIChwYWlyLmNvbGxpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIuYm9keUEuYXBwbHlNdHYoKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWlyLmJvZHlCLmFwcGx5TXR2KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbyBzdGlsbCBkb24ndCBsaWtlIHRoaXMsIHRoaXMgaXMgYSBzbWFsbCBpbnRlZ3JhdGlvbiBzdGVwIHRvIHJlc29sdmUgbmFycm93cGhhc2UgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIuYm9keUEuYWN0b3IuaW50ZWdyYXRlKGRlbHRhICogUGh5c2ljc185LlBoeXNpY3MuY29sbGlzaW9uU2hpZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIuYm9keUIuYWN0b3IuaW50ZWdyYXRlKGRlbHRhICogUGh5c2ljc185LlBoeXNpY3MuY29sbGlzaW9uU2hpZnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYWlycy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuY2FuQ29sbGlkZTsgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnJ1bkNvbGxpc2lvblN0YXJ0RW5kID0gZnVuY3Rpb24gKHBhaXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RnJhbWVIYXNoID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFpcnNfMiA9IHBhaXJzOyBfaSA8IHBhaXJzXzIubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhaXJzXzJbX2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9hZCBjdXJyZW50RnJhbWVIYXNoXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWVIYXNoW3AuaWRdID0gcDtcclxuICAgICAgICAgICAgICAgIC8vIGZpbmQgYWxsIG5ldyBjb2xsaXNpb25zXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RGcmFtZVBhaXJzSGFzaFtwLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjEgPSBwLmJvZHlBLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjIgPSBwLmJvZHlCLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMS5lbWl0KCdjb2xsaXNpb25zdGFydCcsIG5ldyBFdmVudHNfNi5Db2xsaXNpb25TdGFydEV2ZW50KGFjdG9yMSwgYWN0b3IyLCBwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IyLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IEV2ZW50c182LkNvbGxpc2lvblN0YXJ0RXZlbnQoYWN0b3IyLCBhY3RvcjEsIHApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmaW5kIGFsbCBvbGQgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gdGhpcy5fbGFzdEZyYW1lUGFpcnM7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IF9iW19hXTtcclxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudEZyYW1lSGFzaFtwLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjEgPSBwLmJvZHlBLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjIgPSBwLmJvZHlCLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMS5lbWl0KCdjb2xsaXNpb25lbmQnLCBuZXcgRXZlbnRzXzYuQ29sbGlzaW9uRW5kRXZlbnQoYWN0b3IxLCBhY3RvcjIpKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjIuZW1pdCgnY29sbGlzaW9uZW5kJywgbmV3IEV2ZW50c182LkNvbGxpc2lvbkVuZEV2ZW50KGFjdG9yMiwgYWN0b3IxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGxhc3QgZnJhbWUgY2FjaGVcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnMgPSBwYWlycztcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnNIYXNoID0gY3VycmVudEZyYW1lSGFzaDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgZHluYW1pYyB0cmVlIHBvc2l0aW9uc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcclxuICAgICAgICAgICAgdmFyIHVwZGF0ZWQgPSAwLCBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudXBkYXRlQm9keSh0YXJnZXRzW2ldLmJvZHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfOS5QaHlzaWNzLmJyb2FkcGhhc2VEZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfOS5QaHlzaWNzLnNob3dDb250YWN0cyB8fCBQaHlzaWNzXzkuUGh5c2ljcy5zaG93Q29sbGlzaW9uTm9ybWFscykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICBwYWlyLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlID0gRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0lQaHlzaWNzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkNvbGxpc2lvbi9Db2xsaXNpb25Db250YWN0XCIsIFwiQ29sbGlzaW9uL1BhaXJcIiwgXCJBY3RvclwiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBoeXNpY3NfMTAsIENvbGxpc2lvbkNvbnRhY3RfMiwgUGFpcl8zLCBBY3Rvcl8xMCwgRXZlbnRzXzcpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVQYWlycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVQYWlyc0hhc2ggPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gcGFzc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS51bnRyYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBwYXNzXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXRlY3RzIHBvdGVudGlhbCBjb2xsaXNpb24gcGFpcnMgaW4gYSBicm9hZHBoYXNlIGFwcHJvYWNoIHdpdGggdGhlIGR5bmFtaWMgYWFiYiB0cmVlIHN0cmF0ZWd5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5icm9hZHBoYXNlID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcclxuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIGxpc3Qgb2YgcG90ZW50aWFsIGNvbGxpZGVycywgZXhjbHVkZSBraWxsZWQsIHByZXZlbnRlZCwgYW5kIHNlbGZcclxuICAgICAgICAgICAgdmFyIHBvdGVudGlhbENvbGxpZGVycyA9IHRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFvdGhlci5pc0tpbGxlZCgpICYmIG90aGVyLmNvbGxpc2lvblR5cGUgIT09IEFjdG9yXzEwLkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBhY3RvcjE7XHJcbiAgICAgICAgICAgIHZhciBhY3RvcjI7XHJcbiAgICAgICAgICAgIHZhciBjb2xsaXNpb25QYWlycyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IHBvdGVudGlhbENvbGxpZGVycy5sZW5ndGg7IGogPCBsOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yMSA9IHBvdGVudGlhbENvbGxpZGVyc1tqXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBqICsgMTsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMiA9IHBvdGVudGlhbENvbGxpZGVyc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IgPSBhY3RvcjEuY29sbGlkZXMoYWN0b3IyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IG5ldyBQYWlyXzMuUGFpcihhY3RvcjEuYm9keSwgYWN0b3IyLmJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyLmNvbGxpc2lvbiA9IG5ldyBDb2xsaXNpb25Db250YWN0XzIuQ29sbGlzaW9uQ29udGFjdChhY3RvcjEuY29sbGlzaW9uQXJlYSwgYWN0b3IyLmNvbGxpc2lvbkFyZWEsIG1pbmltdW1UcmFuc2xhdGlvblZlY3RvciwgYWN0b3IxLnBvcywgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xsaXNpb25QYWlycy5zb21lKGZ1bmN0aW9uIChjcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNwLmlkID09PSBwYWlyLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uUGFpcnMucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uUGFpcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZGVudGlmeSBhY3R1YWwgY29sbGlzaW9ucyBmcm9tIHRob3NlIHBhaXJzLCBhbmQgY2FsY3VsYXRlIGNvbGxpc2lvbiBpbXB1bHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5uYXJyb3dwaGFzZSA9IGZ1bmN0aW9uIChwYWlycykge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFpcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnJ1bkNvbGxpc2lvblN0YXJ0RW5kID0gZnVuY3Rpb24gKHBhaXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RnJhbWVIYXNoID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFpcnNfMyA9IHBhaXJzOyBfaSA8IHBhaXJzXzMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhaXJzXzNbX2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9hZCBjdXJyZW50RnJhbWVIYXNoXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWVIYXNoW3AuaWRdID0gcDtcclxuICAgICAgICAgICAgICAgIC8vIGZpbmQgYWxsIG5ldyBjb2xsaXNpb25zXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RGcmFtZVBhaXJzSGFzaFtwLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjEgPSBwLmJvZHlBLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjIgPSBwLmJvZHlCLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMS5lbWl0KCdjb2xsaXNpb25zdGFydCcsIG5ldyBFdmVudHNfNy5Db2xsaXNpb25TdGFydEV2ZW50KGFjdG9yMSwgYWN0b3IyLCBwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IyLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IEV2ZW50c183LkNvbGxpc2lvblN0YXJ0RXZlbnQoYWN0b3IyLCBhY3RvcjEsIHApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmaW5kIGFsbCBvbGQgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gdGhpcy5fbGFzdEZyYW1lUGFpcnM7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IF9iW19hXTtcclxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudEZyYW1lSGFzaFtwLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjEgPSBwLmJvZHlBLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjIgPSBwLmJvZHlCLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMS5lbWl0KCdjb2xsaXNpb25lbmQnLCBuZXcgRXZlbnRzXzcuQ29sbGlzaW9uRW5kRXZlbnQoYWN0b3IxLCBhY3RvcjIpKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjIuZW1pdCgnY29sbGlzaW9uZW5kJywgbmV3IEV2ZW50c183LkNvbGxpc2lvbkVuZEV2ZW50KGFjdG9yMiwgYWN0b3IxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGxhc3QgZnJhbWUgY2FjaGVcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnMgPSBwYWlycztcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnNIYXNoID0gY3VycmVudEZyYW1lSGFzaDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc29sdmUgdGhlIHBvc2l0aW9uIGFuZCB2ZWxvY2l0eSBvZiB0aGUgcGh5c2ljcyBib2RpZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAocGFpcnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYWlyc180ID0gcGFpcnM7IF9pIDwgcGFpcnNfNC5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNfNFtfaV07XHJcbiAgICAgICAgICAgICAgICBwYWlyLnJlc29sdmUoUGh5c2ljc18xMC5QaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhaXJzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5jYW5Db2xsaWRlOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlID0gTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ29sbGlzaW9uL0JvZHlcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJDb2xsaXNpb24vQ2lyY2xlQXJlYVwiLCBcIkNvbGxpc2lvbi9Db2xsaXNpb25Db250YWN0XCIsIFwiQ29sbGlzaW9uL0NvbGxpc2lvbkp1bXBUYWJsZVwiLCBcIkNvbGxpc2lvbi9EeW5hbWljVHJlZVwiLCBcIkNvbGxpc2lvbi9EeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2VcIiwgXCJDb2xsaXNpb24vRWRnZUFyZWFcIiwgXCJDb2xsaXNpb24vTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlXCIsIFwiQ29sbGlzaW9uL1BhaXJcIiwgXCJDb2xsaXNpb24vUG9seWdvbkFyZWFcIiwgXCJDb2xsaXNpb24vU2lkZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEJvZHlfMSwgQm91bmRpbmdCb3hfNiwgQ2lyY2xlQXJlYV80LCBDb2xsaXNpb25Db250YWN0XzMsIENvbGxpc2lvbkp1bXBUYWJsZV80LCBEeW5hbWljVHJlZV8yLCBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2VfMSwgRWRnZUFyZWFfNCwgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlXzEsIFBhaXJfNCwgUG9seWdvbkFyZWFfNiwgU2lkZV8zKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBfX2V4cG9ydChCb2R5XzEpO1xyXG4gICAgX19leHBvcnQoQm91bmRpbmdCb3hfNik7XHJcbiAgICBfX2V4cG9ydChDaXJjbGVBcmVhXzQpO1xyXG4gICAgX19leHBvcnQoQ29sbGlzaW9uQ29udGFjdF8zKTtcclxuICAgIF9fZXhwb3J0KENvbGxpc2lvbkp1bXBUYWJsZV80KTtcclxuICAgIF9fZXhwb3J0KER5bmFtaWNUcmVlXzIpO1xyXG4gICAgX19leHBvcnQoRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlXzEpO1xyXG4gICAgX19leHBvcnQoRWRnZUFyZWFfNCk7XHJcbiAgICBfX2V4cG9ydChOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2VfMSk7XHJcbiAgICBfX2V4cG9ydChQYWlyXzQpO1xyXG4gICAgX19leHBvcnQoUG9seWdvbkFyZWFfNik7XHJcbiAgICBfX2V4cG9ydChTaWRlXzMpO1xyXG59KTtcclxuZGVmaW5lKFwiRHJhd2luZy9Qb2x5Z29uXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWxnZWJyYVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFsZ2VicmFfMTkpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2xvc2VkIHBvbHlnb24gZHJhd2luZyBnaXZlbiBhIGxpc3Qgb2YgW1tWZWN0b3JdXXMuXHJcbiAgICAgKlxyXG4gICAgICogQHdhcm5pbmcgVXNlIHNwYXJpbmdseSBhcyBQb2x5Z29ucyBhcmUgcGVyZm9ybWFuY2UgaW50ZW5zaXZlXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2x5Z29uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnRzICBUaGUgdmVjdG9ycyB0byB1c2UgdG8gYnVpbGQgdGhlIHBvbHlnb24gaW4gb3JkZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBQb2x5Z29uKHBvaW50cykge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSBsaW5lcyBvZiB0aGUgcG9seWdvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5saW5lV2lkdGggPSA1O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZmlsbGVkIG9yIG5vdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmlsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IG5ldyBBbGdlYnJhXzE5LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBuZXcgQWxnZWJyYV8xOS5WZWN0b3IoMSwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcclxuICAgICAgICAgICAgdmFyIG1pblggPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJldiwgY3Vyci54KTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIHZhciBtYXhYID0gdGhpcy5fcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHByZXYsIGN1cnIueCk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gbWF4WCAtIG1pblg7XHJcbiAgICAgICAgICAgIHZhciBtaW5ZID0gdGhpcy5fcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXYsIGN1cnIueSk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB2YXIgbWF4WSA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChwcmV2LCBjdXJyLnkpO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuICAgICAgICAgICAgdGhpcy5uYXR1cmFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbFdpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG5vdGltcGxlbWVudGVkIEVmZmVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gYFBvbHlnb25gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbi5wcm90b3R5cGUuYWRkRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIG9uIHBvbHlnb25zXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbm90aW1wbGVtZW50ZWQgRWZmZWN0cyBhcmUgbm90IHN1cHBvcnRlZCBvbiBgUG9seWdvbmBcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uLnByb3RvdHlwZS5yZW1vdmVFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgb24gcG9seWdvbnNcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBub3RpbXBsZW1lbnRlZCBFZmZlY3RzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIGBQb2x5Z29uYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb24ucHJvdG90eXBlLmNsZWFyRWZmZWN0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBvbiBwb2x5Z29uc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9seWdvbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vcGFzc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9seWdvbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIHgsIHkpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4ICsgdGhpcy5hbmNob3IueCwgeSArIHRoaXMuYW5jaG9yLnkpO1xyXG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBzdXBwbGllZCBwb2ludHMgYW5kIGNvbnN0cnVjdCBhICdwb2x5Z29uJ1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQb2ludCA9IHRoaXMuX3BvaW50c1swXTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5fcG9pbnRzW2ldLngsIHRoaXMuX3BvaW50c1tpXS55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5maWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGxDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmxpbmVDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLndpZHRoLCAwKTtcclxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZmxpcFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBvbHlnb247XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcclxufSk7XHJcbmRlZmluZShcIkRyYXdpbmcvSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0FuaW1hdGlvblwiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJEcmF3aW5nL1BvbHlnb25cIiwgXCJEcmF3aW5nL1Nwcml0ZVwiLCBcIkRyYXdpbmcvU3ByaXRlU2hlZXRcIiwgXCJEcmF3aW5nL1Nwcml0ZUVmZmVjdHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBbmltYXRpb25fMiwgQ29sb3JfMTcsIFBvbHlnb25fMSwgU3ByaXRlXzMsIFNwcml0ZVNoZWV0XzEsIGVmZmVjdHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KEFuaW1hdGlvbl8yKTtcclxuICAgIF9fZXhwb3J0KENvbG9yXzE3KTtcclxuICAgIF9fZXhwb3J0KFBvbHlnb25fMSk7XHJcbiAgICBfX2V4cG9ydChTcHJpdGVfMyk7XHJcbiAgICBfX2V4cG9ydChTcHJpdGVTaGVldF8xKTtcclxuICAgIGV4cG9ydHMuRWZmZWN0cyA9IGVmZmVjdHM7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnRlcmZhY2VzL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG4vKipcclxuICogUHNldWRvLVJhbmRvbSBVdGlsaXR5XHJcbiAqXHJcbiAqIEEgcHNldWRvLXJhbmRvbSB1dGlsaXR5IHRvIGFkZCBzZWVkZWQgcmFuZG9tIHN1cHBvcnQgZm9yIGhlbHAgaW5cclxuICogZ2VuZXJhdGluZyB0aGluZ3MgbGlrZSB0ZXJyYWluIG9yIHJlcHJvZHVjaWJsZSByYW5kb21uZXNzLiBVc2VzIHRoZVxyXG4gKiBbTWVyc2VubmUgVHdpc3Rlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVyc2VubmVfVHdpc3RlcikgYWxnb3JpdGhtLlxyXG4gKlxyXG4gKiBbW2luY2x1ZGU6UmFuZG9tLm1kXV1cclxuICovXHJcbmRlZmluZShcIk1hdGgvUmFuZG9tXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIDMyLWJpdCBtYXNrXHJcbiAgICAgKi9cclxuICAgIHZhciBCSVRNQVNLMzIgPSAweEZGRkZGRkZGO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgZm9sbG93aW5nIHRoZSBNZXJzZW5uZV9Ud2lzdGVyIGFsZ29yaXRobS4gR2l2ZW4gYSBzZWVkIHRoaXMgZ2VuZXJhdG9yIHdpbGwgcHJvZHVjZSB0aGUgc2FtZSBzZXF1ZW5jZVxyXG4gICAgICogb2YgbnVtYmVycyBlYWNoIHRpbWUgaXQgaXMgY2FsbGVkLlxyXG4gICAgICogU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lcnNlbm5lX1R3aXN0ZXIgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAqIFVzZXMgdGhlIE1UMTk5MzctMzIgKDIwMDIpIGltcGxlbWVudGF0aW9uIGRvY3VtZW50ZWQgaGVyZSBodHRwOi8vd3d3Lm1hdGguc2NpLmhpcm9zaGltYS11LmFjLmpwL35tLW1hdC9NVC9NVDIwMDIvZW10MTk5Mzdhci5odG1sXHJcbiAgICAgKlxyXG4gICAgICogQXBpIGluc3BpcmVkIGJ5IGh0dHA6Ly9jaGFuY2Vqcy5jb20vIyBodHRwczovL2dpdGh1Yi5jb20vY2hhbmNlanMvY2hhbmNlanNcclxuICAgICAqL1xyXG4gICAgdmFyIFJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgbm8gc2VlZCBpcyBzcGVjaWZpZWQsIHRoZSBEYXRlLm5vdygpIGlzIHVzZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSYW5kb20oc2VlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xyXG4gICAgICAgICAgICAvLyBTZXBhcmF0aW9uIHBvaW50IG9mIG9uZSBvbmUgd29yZCwgdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBsb3dlciBiaXRtYXNrIDAgPD0gciA8PSB3LTFcclxuICAgICAgICAgICAgdGhpcy5fbG93ZXJNYXNrID0gMHg3RkZGRkZGRjsgLy8gMzEgYml0cyBzYW1lIGFzIF9yXHJcbiAgICAgICAgICAgIHRoaXMuX3VwcGVyTWFzayA9IDB4ODAwMDAwMDA7IC8vIDM0IGhpZ2ggYml0c1xyXG4gICAgICAgICAgICAvLyBXb3JkIHNpemUsIDY0IGJpdHNcclxuICAgICAgICAgICAgdGhpcy5fdyA9IDMyO1xyXG4gICAgICAgICAgICAvLyBEZWdyZWUgb2YgcmVjdXJyYW5jZVxyXG4gICAgICAgICAgICB0aGlzLl9uID0gNjI0O1xyXG4gICAgICAgICAgICAvLyBNaWRkbGUgd29yZCwgYW4gb2Zmc2V0IHVzZWQgaW4gdGhlIHJlY3VycmFuY2UgZGVmaW5pbmcgdGhlIHNlcmllcyB4LCAxPD1tPG5cclxuICAgICAgICAgICAgdGhpcy5fbSA9IDM5NztcclxuICAgICAgICAgICAgLy8gY29lZmZpY2llbnRzIG9mIHRlaCByYXRpb25hbCBub3JtYWwgZm9ybSB0d2lzdCBtYXRyaXhcclxuICAgICAgICAgICAgdGhpcy5fYSA9IDB4OTkwOEIwREY7XHJcbiAgICAgICAgICAgIC8vIHRlbXBlcmluZyBiaXQgc2hpZnRzIGFuZCBtYXNrc1xyXG4gICAgICAgICAgICB0aGlzLl91ID0gMTE7XHJcbiAgICAgICAgICAgIHRoaXMuX3MgPSA3O1xyXG4gICAgICAgICAgICB0aGlzLl9iID0gMHg5ZDJjNTY4MDtcclxuICAgICAgICAgICAgdGhpcy5fdCA9IDE1O1xyXG4gICAgICAgICAgICB0aGlzLl9jID0gMHhlZmM2MDAwMDtcclxuICAgICAgICAgICAgdGhpcy5fbCA9IDE4O1xyXG4gICAgICAgICAgICB0aGlzLl9mID0gMTgxMjQzMzI1MztcclxuICAgICAgICAgICAgdGhpcy5fbXQgPSBuZXcgQXJyYXkodGhpcy5fbik7XHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gbWFzayB0byBzdXBwb3J0IGhpZ2hlciBiaXQgbWFjaGluZXNcclxuICAgICAgICAgICAgdGhpcy5fbXRbMF0gPSAoc2VlZCB8fCBEYXRlLm5vdygpKSA+Pj4gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLl9uOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy5fbXRbaSAtIDFdIF4gKHRoaXMuX210W2kgLSAxXSA+Pj4gKHRoaXMuX3cgLSAyKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBudW1iZXJzIGFyZSBiaWdnZXIgdGhhbiB0aGUgSlMgbWF4IHNhZmUgaW50LCBhZGQgaW4gMTYtYml0IGNodW5rcyB0byBwcmV2ZW50IElFRUUgcm91bmRpbmcgZXJyb3JzIG9uIGhpZ2ggYml0cyAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbXRbaV0gPSAoKCh0aGlzLl9mICogKChzICYgMHhGRkZGMDAwMCkgPj4+IDE2KSkgPDwgMTYpICsgKHRoaXMuX2YgKiAocyAmIDB4RkZGRikpICsgaSkgPj4+IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faW5kZXggPSB0aGlzLl9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBseSB0aGUgdHdpc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLl90d2lzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG1hZzAxID0gWzB4MCwgdGhpcy5fYV07XHJcbiAgICAgICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9uIC0gdGhpcy5fbTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gKHRoaXMuX210W2ldICYgdGhpcy5fdXBwZXJNYXNrKSB8ICh0aGlzLl9tdFtpICsgMV0gJiB0aGlzLl9sb3dlck1hc2spO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbXRbaV0gPSB0aGlzLl9tdFtpICsgdGhpcy5fbV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXSAmIEJJVE1BU0szMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRoaXMuX24gLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbaV0gJiB0aGlzLl91cHBlck1hc2spIHwgKHRoaXMuX210W2kgKyAxXSAmIHRoaXMuX2xvd2VyTWFzayk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tdFtpXSA9IHRoaXMuX210W2kgKyAodGhpcy5fbSAtIHRoaXMuX24pXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdICYgQklUTUFTSzMyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbdGhpcy5fbiAtIDFdICYgdGhpcy5fdXBwZXJNYXNrKSB8ICh0aGlzLl9tdFswXSAmIHRoaXMuX2xvd2VyTWFzayk7XHJcbiAgICAgICAgICAgIHRoaXMuX210W3RoaXMuX24gLSAxXSA9IHRoaXMuX210W3RoaXMuX20gLSAxXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdICYgQklUTUFTSzMyO1xyXG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gbmV4dCAzMiBiaXQgaW50ZWdlciBudW1iZXIgaW4gc2VxdWVuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLm5leHRJbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90d2lzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5fbXRbdGhpcy5faW5kZXgrK107XHJcbiAgICAgICAgICAgIHkgXj0geSA+Pj4gdGhpcy5fdTtcclxuICAgICAgICAgICAgeSBePSAoKHkgPDwgdGhpcy5fcykgJiB0aGlzLl9iKTtcclxuICAgICAgICAgICAgeSBePSAoKHkgPDwgdGhpcy5fdCkgJiB0aGlzLl9jKTtcclxuICAgICAgICAgICAgeSBePSAoeSA+Pj4gdGhpcy5fbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB5ID4+PiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGEgcmFuZG9tIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIFswLCAxKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dEludCgpICogKDEuMCAvIDQyOTQ5NjcyOTYuMCk7IC8vIGRpdmlkZWQgYnkgMl4zMlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGEgcmFuZG9tIGZsb2F0aW5nIHBvaW50IGluIHJhbmdlIFttaW4sIG1heCkgbWluIGlzIGluY2x1ZGVkLCBtYXggaXMgbm90IGluY2x1ZGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5mbG9hdGluZyA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG1heCAtIG1pbikgKiB0aGlzLm5leHQoKSArIG1pbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGluIHJhbmdlIFttaW4sIG1heF0gbWluIGlzIGluY2x1ZGVkLCBtYXggaXMgaW5jbHVkZWQuXHJcbiAgICAgICAgICogSW1wbGVtZW50ZWQgd2l0aCByZWplY3Rpb24gc2FtcGxpbmcsIHNlZSBodHRwczovL21lZGl1bS5jb20vQGJldGFibGUvdGlmdS1ieS11c2luZy1tYXRoLXJhbmRvbS1mMWMzMDhjNGZkOWQjLmkxM3RkaXU1YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuaW50ZWdlciA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigobWF4IC0gbWluICsgMSkgKiB0aGlzLm5leHQoKSArIG1pbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgcmFuZG9tbHkgd2l0aCA1MC81MCBvZGRzIGJ5IGRlZmF1bHQuXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGUgbGlrZWxpaG9vZCBvZiByZXR1cm5pbmcgYSB0cnVlIGlzIC41ICg1MCUpLlxyXG4gICAgICAgICAqIEBwYXJhbSBsaWtlbGlob29kIHRha2VzIHZhbHVlcyBiZXR3ZWVuIFswLCAxXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIChsaWtlbGlob29kKSB7XHJcbiAgICAgICAgICAgIGlmIChsaWtlbGlob29kID09PSB2b2lkIDApIHsgbGlrZWxpaG9vZCA9IC41OyB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQoKSA8PSBsaWtlbGlob29kO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBvbmUgZWxlbWVudCBmcm9tIGFuIGFycmF5IGF0IHJhbmRvbVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUucGlja09uZSA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlbdGhpcy5pbnRlZ2VyKDAsIGFycmF5Lmxlbmd0aCAtIDEpXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgcmFuZG9tIHBpY2tpbmcgZWxlbWVudHMgZnJvbSB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgKiBAcGFyYW0gYXJyYXkgT3JpZ2luYWwgYXJyYXkgdG8gcGljayBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIG51bVBpY2tzIGNhbiBiZSBhbnkgcG9zaXRpdmUgbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIGFsbG93RHVwbGljYXRlcyBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcmV0dXJuZWQgc2V0IGlzIGFsbG93ZWQgZHVwbGljYXRlcyAoaXQgZG9lcyBub3QgbWVhbiB0aGVyZSB3aWxsIGFsd2F5cyBiZSBkdXBsaWNhdGVzXHJcbiAgICAgICAgICoganVzdCB0aGF0IGl0IGlzIHBvc3NpYmxlKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUucGlja1NldCA9IGZ1bmN0aW9uIChhcnJheSwgbnVtUGlja3MsIGFsbG93RHVwbGljYXRlcykge1xyXG4gICAgICAgICAgICBpZiAoYWxsb3dEdXBsaWNhdGVzID09PSB2b2lkIDApIHsgYWxsb3dEdXBsaWNhdGVzID0gZmFsc2U7IH1cclxuICAgICAgICAgICAgaWYgKGFsbG93RHVwbGljYXRlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BpY2tTZXRXaXRoRHVwbGljYXRlcyhhcnJheSwgbnVtUGlja3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BpY2tTZXRXaXRob3V0RHVwbGljYXRlcyhhcnJheSwgbnVtUGlja3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHJhbmRvbWx5IHBpY2tpbmcgZWxlbWVudHMgaW4gdGhlIG9yaWdpbmFsIChub3QgcmV1c2VkKVxyXG4gICAgICAgICAqIEBwYXJhbSBudW1QaWNrcyBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLl9waWNrU2V0V2l0aG91dER1cGxpY2F0ZXMgPSBmdW5jdGlvbiAoYXJyYXksIG51bVBpY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChudW1QaWNrcyA+IGFycmF5Lmxlbmd0aCB8fCBudW1QaWNrcyA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgZWxlbWVudHMgdG8gcGljaywgbXVzdCBwaWNrIGEgdmFsdWUgMCA8IG4gPD0gbGVuZ3RoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG51bVBpY2tzID09PSBhcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG51bVBpY2tzKTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQaWNrID0gMDtcclxuICAgICAgICAgICAgdmFyIHRlbXBBcnJheSA9IGFycmF5LnNsaWNlKDApO1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudFBpY2sgPCBudW1QaWNrcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbnRlZ2VyKDAsIHRlbXBBcnJheS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyZW50UGljaysrXSA9IHRlbXBBcnJheVtpbmRleF07XHJcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBhcnJheSByYW5kb20gcGlja2luZyBlbGVtZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBhbGxvd2luZyBkdXBsaWNhdGVzXHJcbiAgICAgICAgICogQHBhcmFtIG51bVBpY2tzIGNhbiBiZSBhbnkgcG9zaXRpdmUgbnVtYmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5fcGlja1NldFdpdGhEdXBsaWNhdGVzID0gZnVuY3Rpb24gKGFycmF5LCBudW1QaWNrcykge1xyXG4gICAgICAgICAgICAvLyBUeXBlc2NyaXB0IG51bWJlcnMgYXJlIGFsbCBmbG9hdGluZyBwb2ludCwgc28gZG8gd2UgYWRkIGNoZWNrIGZvciBpbnQ/IChvciBmbG9vciB0aGUgaW5wdXQ/KVxyXG4gICAgICAgICAgICBpZiAobnVtUGlja3MgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHBpY2ssIG11c3QgcGljayBhIHZhbHVlIDAgPD0gbiA8IE1BWF9JTlQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG51bVBpY2tzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1QaWNrczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnBpY2tPbmUoYXJyYXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBhcnJheSB0aGF0IGhhcyBpdHMgZWxlbWVudHMgc2h1ZmZsZWQuIFVzaW5nIHRoZSBGaXNoZXIvWWF0ZXMgbWV0aG9kXHJcbiAgICAgICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyJUUyJTgwJTkzWWF0ZXNfc2h1ZmZsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuc2h1ZmZsZSA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5ID0gYXJyYXkuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIHZhciBzd2FwID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wQXJyYXkubGVuZ3RoIC0gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFuZG9tSW5kZXggPSB0aGlzLmludGVnZXIoaSwgdGVtcEFycmF5Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgc3dhcCA9IHRlbXBBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgIHRlbXBBcnJheVtpXSA9IHRlbXBBcnJheVtyYW5kb21JbmRleF07XHJcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXlbcmFuZG9tSW5kZXhdID0gc3dhcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGVtcEFycmF5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGUgYSBsaXN0IG9mIHJhbmRvbSBpbnRlZ2VyIG51bWJlcnNcclxuICAgICAgICAgKiBAcGFyYW0gbGVuZ3RoIHRoZSBsZW5ndGggb2YgdGhlIGZpbmFsIGFycmF5XHJcbiAgICAgICAgICogQHBhcmFtIG1pbiB0aGUgbWluaW11bSBpbnRlZ2VyIG51bWJlciB0byBnZW5lcmF0ZSBpbmNsdXNpdmVcclxuICAgICAgICAgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGludGVnZXIgbnVtYmVyIHRvIGdlbmVyYXRlIGluY2x1c2l2ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAobGVuZ3RoLCBtaW4sIG1heCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuaW50ZWdlcihtaW4sIG1heCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQ0IGRpY2Ugcm9sbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuZDQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgNCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkNiBkaWNlIHJvbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmQ2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDYpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDggZGljZSByb2xsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5kOCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCA4KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQxMCBkaWNlIHJvbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmQxMCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCAxMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkMTIgZGljZSByb2xsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5kMTIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgMTIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDIwIGRpY2Ugcm9sbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuZDIwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDIwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSYW5kb207XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5SYW5kb20gPSBSYW5kb207XHJcbn0pO1xyXG5kZWZpbmUoXCJNYXRoL1Blcmxpbk5vaXNlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiTWF0aC9SYW5kb21cIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUmFuZG9tXzEsIENvbG9yXzE4LCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGZ1bmN0aW9uIF9sZXJwKHRpbWUsIGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYSArIHRpbWUgKiAoYiAtIGEpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX2ZhZGUodCkge1xyXG4gICAgICAgIHJldHVybiB0ICogdCAqIHQgKiAodCAqICh0ICogNiAtIDE1KSArIDEwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHBlcmxpbiBub2lzZSBiYXNlZCBvbiB0aGUgMjAwMiBTaWdncmFwaCBwYXBlciBodHRwOi8vbXJsLm55dS5lZHUvfnBlcmxpbi9ub2lzZS9cclxuICAgICAqIEFsc28gaHR0cHM6Ly9mbGFmbGEyLmdpdGh1Yi5pby8yMDE0LzA4LzA5L3Blcmxpbm5vaXNlLmh0bWxcclxuICAgICAqL1xyXG4gICAgdmFyIFBlcmxpbkdlbmVyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUGVybGluR2VuZXJhdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGVybSA9IFsxNTEsIDE2MCwgMTM3LCA5MSwgOTAsIDE1LCAxMzEsIDEzLCAyMDEsIDk1LCA5NiwgNTMsIDE5NCwgMjMzLCA3LCAyMjUsXHJcbiAgICAgICAgICAgICAgICAxNDAsIDM2LCAxMDMsIDMwLCA2OSwgMTQyLCA4LCA5OSwgMzcsIDI0MCwgMjEsIDEwLCAyMywgMTkwLCA2LCAxNDgsIDI0NywgMTIwLCAyMzQsIDc1LCAwLCAyNixcclxuICAgICAgICAgICAgICAgIDE5NywgNjIsIDk0LCAyNTIsIDIxOSwgMjAzLCAxMTcsIDM1LCAxMSwgMzIsIDU3LCAxNzcsIDMzLCA4OCwgMjM3LCAxNDksIDU2LCA4NywgMTc0LCAyMCwgMTI1LCAxMzYsXHJcbiAgICAgICAgICAgICAgICAxNzEsIDE2OCwgNjgsIDE3NSwgNzQsIDE2NSwgNzEsIDEzNCwgMTM5LCA0OCwgMjcsIDE2NiwgNzcsIDE0NiwgMTU4LCAyMzEsIDgzLCAxMTEsIDIyOSwgMTIyLCA2MCxcclxuICAgICAgICAgICAgICAgIDIxMSwgMTMzLCAyMzAsIDIyMCwgMTA1LCA5MiwgNDEsIDU1LCA0NiwgMjQ1LCA0MCwgMjQ0LCAxMDIsIDE0MywgNTQsIDY1LCAyNSwgNjMsIDE2MSwgMSwgMjE2LCA4MCxcclxuICAgICAgICAgICAgICAgIDczLCAyMDksIDc2LCAxMzIsIDE4NywgMjA4LCA4OSwgMTgsIDE2OSwgMjAwLCAxOTYsIDEzNSwgMTMwLCAxMTYsIDE4OCwgMTU5LCA4NiwgMTY0LCAxMDAsIDEwOSwgMTk4LFxyXG4gICAgICAgICAgICAgICAgMTczLCAxODYsIDMsIDY0LCA1MiwgMjE3LCAyMjYsIDI1MCwgMTI0LCAxMjMsIDUsIDIwMiwgMzgsIDE0NywgMTE4LCAxMjYsIDI1NSwgODIsIDg1LCAyMTIsIDIwNywgMjA2LFxyXG4gICAgICAgICAgICAgICAgNTksIDIyNywgNDcsIDE2LCA1OCwgMTcsIDE4MiwgMTg5LCAyOCwgNDIsIDIyMywgMTgzLCAxNzAsIDIxMywgMTE5LCAyNDgsIDE1MiwgMiwgNDQsIDE1NCwgMTYzLCA3MCxcclxuICAgICAgICAgICAgICAgIDIyMSwgMTUzLCAxMDEsIDE1NSwgMTY3LCA0MywgMTcyLCA5LCAxMjksIDIyLCAzOSwgMjUzLCAxOSwgOTgsIDEwOCwgMTEwLCA3OSwgMTEzLCAyMjQsIDIzMiwgMTc4LFxyXG4gICAgICAgICAgICAgICAgMTg1LCAxMTIsIDEwNCwgMjE4LCAyNDYsIDk3LCAyMjgsIDI1MSwgMzQsIDI0MiwgMTkzLCAyMzgsIDIxMCwgMTQ0LCAxMiwgMTkxLCAxNzksIDE2MiwgMjQxLCA4MSxcclxuICAgICAgICAgICAgICAgIDUxLCAxNDUsIDIzNSwgMjQ5LCAxNCwgMjM5LCAxMDcsIDQ5LCAxOTIsIDIxNCwgMzEsIDE4MSwgMTk5LCAxMDYsIDE1NywgMTg0LCA4NCwgMjA0LCAxNzYsIDExNSxcclxuICAgICAgICAgICAgICAgIDEyMSwgNTAsIDQ1LCAxMjcsIDQsIDE1MCwgMjU0LCAxMzgsIDIzNiwgMjA1LCA5MywgMjIyLCAxMTQsIDY3LCAyOSwgMjQsIDcyLCAyNDMsIDE0MSwgMTI4LCAxOTUsXHJcbiAgICAgICAgICAgICAgICA3OCwgNjYsIDIxNSwgNjEsIDE1NiwgMTgwXTtcclxuICAgICAgICAgICAgdGhpcy5fcCA9IG5ldyBVaW50OEFycmF5KDUxMik7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRQZXJsaW5PcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgb2N0YXZlczogMSxcclxuICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogMSxcclxuICAgICAgICAgICAgICAgIGFtcGxpdHVkZTogMSxcclxuICAgICAgICAgICAgICAgIHBlcnNpc3RhbmNlOiAuNVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIHRoaXMuX2RlZmF1bHRQZXJsaW5PcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5wZXJzaXN0YW5jZSA9IG9wdGlvbnMucGVyc2lzdGFuY2U7XHJcbiAgICAgICAgICAgIHRoaXMuYW1wbGl0dWRlID0gb3B0aW9ucy5hbXBsaXR1ZGU7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gb3B0aW9ucy5mcmVxdWVuY3k7XHJcbiAgICAgICAgICAgIHRoaXMub2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZG9tID0gbmV3IFJhbmRvbV8xLlJhbmRvbShvcHRpb25zLnNlZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZG9tID0gbmV3IFJhbmRvbV8xLlJhbmRvbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Blcm0gPSB0aGlzLl9yYW5kb20uc2h1ZmZsZSh0aGlzLl9wZXJtKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MTI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcFtpXSA9IHRoaXMuX3Blcm1baSAlIDI1Nl0gJiAweEZGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBlcmxpbkdlbmVyYXRvci5wcm90b3R5cGUubm9pc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhbXAgPSB0aGlzLmFtcGxpdHVkZTtcclxuICAgICAgICAgICAgdmFyIGZyZXEgPSB0aGlzLmZyZXF1ZW5jeTtcclxuICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcclxuICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9jdGF2ZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB0aGlzLl9ub2lzZTFkKGFyZ3VtZW50c1swXSAqIGZyZXEpICogYW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuX25vaXNlMmQoYXJndW1lbnRzWzBdICogZnJlcSwgYXJndW1lbnRzWzFdICogZnJlcSkgKiBhbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fbm9pc2UzZChhcmd1bWVudHNbMF0gKiBmcmVxLCBhcmd1bWVudHNbMV0gKiBmcmVxLCBhcmd1bWVudHNbMl0gKiBmcmVxKSAqIGFtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBwZXJsaW4gbm9pc2UnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1heFZhbHVlICs9IGFtcDtcclxuICAgICAgICAgICAgICAgIGFtcCAqPSB0aGlzLnBlcnNpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgZnJlcSAqPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCAvIG1heFZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGVzIGEgbGlzdCBzdGFydGluZyBhdCAwIGFuZCBlbmRpbmcgYXQgMSBvZiBjb250aW91cyBwZXJsaW4gbm9pc2UsIGJ5IGRlZmF1bHQgdGhlIHN0ZXAgaXMgMS9sZW5ndGg7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLnNlcXVlbmNlID0gZnVuY3Rpb24gKGxlbmd0aCwgc3RlcCkge1xyXG4gICAgICAgICAgICBpZiAoIXN0ZXApIHtcclxuICAgICAgICAgICAgICAgIHN0ZXAgPSAxIC8gbGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHRoaXMubm9pc2UoaSAqIHN0ZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdlbmVyYXRlcyBhIDJEIGdyaWQgb2YgcGVybGluIG5vaXNlIGdpdmVuIGEgc3RlcCB2YWx1ZSBwYWNrZWQgaW50byBhIDFEIGFycmF5IGkgPSAoeCArIHkqd2lkdGgpLFxyXG4gICAgICAgICAqIGJ5IGRlZmF1bHQgdGhlIHN0ZXAgd2lsbCAxLyhtaW4oZGltZW5zaW9uKSlcclxuICAgICAgICAgKi9cclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLmdyaWQgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgc3RlcCkge1xyXG4gICAgICAgICAgICBpZiAoIXN0ZXApIHtcclxuICAgICAgICAgICAgICAgIHN0ZXAgPSAxIC8gKE1hdGgubWluKHdpZHRoLCBoZWlnaHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkod2lkdGggKiBoZWlnaHQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVt4ICsgeSAqIHdpZHRoXSA9IHRoaXMubm9pc2UoeCAqIHN0ZXAsIHkgKiBzdGVwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLl9ncmFkaWVudDNkID0gZnVuY3Rpb24gKGhhc2gsIHgsIHksIHopIHtcclxuICAgICAgICAgICAgdmFyIGggPSBoYXNoICYgMHhGO1xyXG4gICAgICAgICAgICB2YXIgdSA9IGggPCA4ID8geCA6IHk7XHJcbiAgICAgICAgICAgIHZhciB2ID0gaCA8IDQgPyB5IDogKChoID09PSAxMiB8fCBoID09PSAxNCkgPyB4IDogeik7XHJcbiAgICAgICAgICAgIHJldHVybiAoKGggJiAxKSA9PT0gMCA/IHUgOiAtdSkgKyAoKGggJiAyKSA9PT0gMCA/IHYgOiAtdik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLl9ncmFkaWVudDJkID0gZnVuY3Rpb24gKGhhc2gsIHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gKGhhc2ggJiAxKSA9PT0gMCA/IHggOiB5O1xyXG4gICAgICAgICAgICByZXR1cm4gKGhhc2ggJiAyKSA9PT0gMCA/IC12YWx1ZSA6IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5fZ3JhZGllbnQxZCA9IGZ1bmN0aW9uIChoYXNoLCB4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoaGFzaCAmIDEpID09PSAwID8gLXggOiB4O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5fbm9pc2UxZCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHZhciBpbnRYID0gTWF0aC5mbG9vcih4KSAmIDB4RkY7IC8vIGZvcmNlIDAtMjU1IGludGVnZXJzIHRvIGxvb2t1cCBpbiBwZXJtdXRhdGlvblxyXG4gICAgICAgICAgICB4IC09IE1hdGguZmxvb3IoeCk7XHJcbiAgICAgICAgICAgIHZhciBmYWRlWCA9IF9mYWRlKHgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDFkKHRoaXMuX3BbaW50WF0sIHgpLCB0aGlzLl9ncmFkaWVudDFkKHRoaXMuX3BbaW50WCArIDFdLCB4IC0gMSkpICsgMSkgLyAyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5fbm9pc2UyZCA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIHZhciBpbnRYID0gTWF0aC5mbG9vcih4KSAmIDB4RkY7XHJcbiAgICAgICAgICAgIHZhciBpbnRZID0gTWF0aC5mbG9vcih5KSAmIDB4RkY7XHJcbiAgICAgICAgICAgIHggLT0gTWF0aC5mbG9vcih4KTtcclxuICAgICAgICAgICAgeSAtPSBNYXRoLmZsb29yKHkpO1xyXG4gICAgICAgICAgICB2YXIgZmFkZVggPSBfZmFkZSh4KTtcclxuICAgICAgICAgICAgdmFyIGZhZGVZID0gX2ZhZGUoeSk7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5fcFtpbnRYXSArIGludFk7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5fcFtpbnRYICsgMV0gKyBpbnRZO1xyXG4gICAgICAgICAgICByZXR1cm4gKF9sZXJwKGZhZGVZLCBfbGVycChmYWRlWCwgdGhpcy5fZ3JhZGllbnQyZCh0aGlzLl9wW2FdLCB4LCB5KSwgdGhpcy5fZ3JhZGllbnQyZCh0aGlzLl9wW2JdLCB4IC0gMSwgeSkpLCBfbGVycChmYWRlWCwgdGhpcy5fZ3JhZGllbnQyZCh0aGlzLl9wW2EgKyAxXSwgeCwgeSAtIDEpLCB0aGlzLl9ncmFkaWVudDJkKHRoaXMuX3BbYiArIDFdLCB4IC0gMSwgeSAtIDEpKSkgKyAxKSAvIDI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLl9ub2lzZTNkID0gZnVuY3Rpb24gKHgsIHksIHopIHtcclxuICAgICAgICAgICAgdmFyIGludFggPSBNYXRoLmZsb29yKHgpICYgMHhGRjtcclxuICAgICAgICAgICAgdmFyIGludFkgPSBNYXRoLmZsb29yKHkpICYgMHhGRjtcclxuICAgICAgICAgICAgdmFyIGludFogPSBNYXRoLmZsb29yKHopICYgMHhGRjtcclxuICAgICAgICAgICAgeCAtPSBNYXRoLmZsb29yKHgpO1xyXG4gICAgICAgICAgICB5IC09IE1hdGguZmxvb3IoeSk7XHJcbiAgICAgICAgICAgIHogLT0gTWF0aC5mbG9vcih6KTtcclxuICAgICAgICAgICAgdmFyIGZhZGVYID0gX2ZhZGUoeCk7XHJcbiAgICAgICAgICAgIHZhciBmYWRlWSA9IF9mYWRlKHkpO1xyXG4gICAgICAgICAgICB2YXIgZmFkZVogPSBfZmFkZSh6KTtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLl9wW2ludFhdICsgaW50WTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9wW2ludFggKyAxXSArIGludFk7XHJcbiAgICAgICAgICAgIHZhciBhYSA9IHRoaXMuX3BbYV0gKyBpbnRaO1xyXG4gICAgICAgICAgICB2YXIgYmEgPSB0aGlzLl9wW2JdICsgaW50WjtcclxuICAgICAgICAgICAgdmFyIGFiID0gdGhpcy5fcFthICsgMV0gKyBpbnRaO1xyXG4gICAgICAgICAgICB2YXIgYmIgPSB0aGlzLl9wW2IgKyAxXSArIGludFo7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2xlcnAoZmFkZVosIF9sZXJwKGZhZGVZLCBfbGVycChmYWRlWCwgdGhpcy5fZ3JhZGllbnQzZCh0aGlzLl9wW2FhXSwgeCwgeSwgeiksIHRoaXMuX2dyYWRpZW50M2QodGhpcy5fcFtiYV0sIHggLSAxLCB5LCB6KSksIF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYWJdLCB4LCB5IC0gMSwgeiksIHRoaXMuX2dyYWRpZW50M2QodGhpcy5fcFtiYl0sIHggLSAxLCB5IC0gMSwgeikpKSwgX2xlcnAoZmFkZVksIF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYWEgKyAxXSwgeCwgeSwgeiAtIDEpLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYmEgKyAxXSwgeCAtIDEsIHksIHogLSAxKSksIF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYWIgKyAxXSwgeCwgeSAtIDEsIHogLSAxKSwgdGhpcy5fZ3JhZGllbnQzZCh0aGlzLl9wW2JiICsgMV0sIHggLSAxLCB5IC0gMSwgeiAtIDEpKSkpICsgMSkgLyAyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBlcmxpbkdlbmVyYXRvcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlBlcmxpbkdlbmVyYXRvciA9IFBlcmxpbkdlbmVyYXRvcjtcclxuICAgIC8qKlxyXG4gICAgICogQSBoZWxwZXIgdG8gZHJhdyAyRCBwZXJsaW4gbWFwcyBnaXZlbiBhIHBlcmxpbiBnZW5lcmF0b3IgYW5kIGEgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgdmFyIFBlcmxpbkRyYXdlcjJEID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZ2VuZXJhdG9yIC0gQW4gZXhpc3RpbmcgcGVybGluIGdlbmVyYXRvclxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xvckZjbiAtIEEgY29sb3IgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZhbHVlIGJldHdlZW4gWzAsIDI1NV0gZGVyaXZlZCBmcm9tIHRoZSBwZXJsaW4gZ2VuZXJhdG9yLCBhbmQgcmV0dXJucyBhIGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUGVybGluRHJhd2VyMkQoZ2VuZXJhdG9yLCBjb2xvckZjbikge1xyXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcclxuICAgICAgICAgICAgdGhpcy5jb2xvckZjbiA9IGNvbG9yRmNuO1xyXG4gICAgICAgICAgICBpZiAoIWNvbG9yRmNuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yRmNuID0gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsIDwgMTI1ID8gQ29sb3JfMTguQ29sb3IuQmxhY2sgOiBDb2xvcl8xOC5Db2xvci5XaGl0ZTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFuIGltYWdlIG9mIDJEIHBlcmxpbiBub2lzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBlcmxpbkRyYXdlcjJELnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhdyhjdHgsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgZHJhd3MgYSAyRCBwZXJsaW4gZ3JpZCBvbiBhIGNhbnZhcyBjb250ZXh0LCBub3QgcmVjb21tZW5kZWQgdG8gYmUgY2FsbGVkIGV2ZXJ5IGZyYW1lIGR1ZSB0byBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBlcmxpbkRyYXdlcjJELnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2VuZXJhdG9yLmdyaWQod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZ3JpZFtpICsgd2lkdGggKiBqXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IE1hdGguZmxvb3IodmFsICogMjU1KSAmIDB4ZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gKGkgKyBqICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5jb2xvckZjbihjKTtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YVtwaXhlbF0gPSBjb2xvci5yO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW3BpeGVsICsgMV0gPSBjb2xvci5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW3BpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW3BpeGVsICsgM10gPSBNYXRoLmZsb29yKGNvbG9yLmEgKiAyNTUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCB4LCB5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQZXJsaW5EcmF3ZXIyRDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlBlcmxpbkRyYXdlcjJEID0gUGVybGluRHJhd2VyMkQ7XHJcbn0pO1xyXG5kZWZpbmUoXCJNYXRoL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiTWF0aC9QZXJsaW5Ob2lzZVwiLCBcIk1hdGgvUmFuZG9tXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUGVybGluTm9pc2VfMSwgUmFuZG9tXzIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KFBlcmxpbk5vaXNlXzEpO1xyXG4gICAgX19leHBvcnQoUmFuZG9tXzIpO1xyXG59KTtcclxuZGVmaW5lKFwiUG9zdFByb2Nlc3NpbmcvSVBvc3RQcm9jZXNzb3JcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIlBvc3RQcm9jZXNzaW5nL0NvbG9yQmxpbmRDb3JyZWN0b3JcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL0xvZ1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIExvZ18xMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgQ29sb3JCbGluZG5lc3M7XHJcbiAgICAoZnVuY3Rpb24gKENvbG9yQmxpbmRuZXNzKSB7XHJcbiAgICAgICAgQ29sb3JCbGluZG5lc3NbQ29sb3JCbGluZG5lc3NbXCJQcm90YW5vcGVcIl0gPSAwXSA9IFwiUHJvdGFub3BlXCI7XHJcbiAgICAgICAgQ29sb3JCbGluZG5lc3NbQ29sb3JCbGluZG5lc3NbXCJEZXV0ZXJhbm9wZVwiXSA9IDFdID0gXCJEZXV0ZXJhbm9wZVwiO1xyXG4gICAgICAgIENvbG9yQmxpbmRuZXNzW0NvbG9yQmxpbmRuZXNzW1wiVHJpdGFub3BlXCJdID0gMl0gPSBcIlRyaXRhbm9wZVwiO1xyXG4gICAgfSkoQ29sb3JCbGluZG5lc3MgPSBleHBvcnRzLkNvbG9yQmxpbmRuZXNzIHx8IChleHBvcnRzLkNvbG9yQmxpbmRuZXNzID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBwb3N0IHByb2Nlc3NvciBjYW4gY29ycmVjdCBjb2xvcnMgYW5kIHNpbXVsYXRlIGNvbG9yIGJsaW5kbmVzcy5cclxuICAgICAqIEl0IGlzIHBvc3NpYmxlIHRvIHVzZSB0aGlzIG9uIGV2ZXJ5IGdhbWUsIGJ1dCB0aGUgZ2FtZSdzIHBlcmZvcm1hbmNlXHJcbiAgICAgKiB3aWxsIHN1ZmZlciBtZWFzdXJhYmx5LiBJdCdzIGJldHRlciB0byB1c2UgaXQgYXMgYSBoZWxwZnVsIHRvb2wgd2hpbGUgZGV2ZWxvcGluZyB5b3VyIGdhbWUuXHJcbiAgICAgKiBSZW1lbWJlciwgdGhlIGJlc3QgcHJhY3RpY2UgaXMgdG8gZGVzaWduIHdpdGggY29sb3IgYmxpbmRuZXNzIGluIG1pbmQuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkNvbG9yQmxpbmQubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sb3JCbGluZENvcnJlY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ29sb3JCbGluZENvcnJlY3RvcihlbmdpbmUsIHNpbXVsYXRlLCBjb2xvck1vZGUpIHtcclxuICAgICAgICAgICAgaWYgKHNpbXVsYXRlID09PSB2b2lkIDApIHsgc2ltdWxhdGUgPSBmYWxzZTsgfVxyXG4gICAgICAgICAgICBpZiAoY29sb3JNb2RlID09PSB2b2lkIDApIHsgY29sb3JNb2RlID0gQ29sb3JCbGluZG5lc3MuUHJvdGFub3BlOyB9XHJcbiAgICAgICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRlID0gc2ltdWxhdGU7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JNb2RlID0gY29sb3JNb2RlO1xyXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhTaGFkZXIgPSAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnICtcclxuICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkOycgK1xyXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyArXHJcbiAgICAgICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7JyArXHJcbiAgICAgICAgICAgICAgICAndm9pZCBtYWluKCkgeycgK1xyXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgcmVjdGFuZ2xlIGZyb20gcGl4ZWxzIHRvIDAuMCB0byAxLjBcclxuICAgICAgICAgICAgICAgICd2ZWMyIHplcm9Ub09uZSA9IGFfcG9zaXRpb24gLyB1X3Jlc29sdXRpb247JyArXHJcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gMC0+MSB0byAwLT4yXHJcbiAgICAgICAgICAgICAgICAndmVjMiB6ZXJvVG9Ud28gPSB6ZXJvVG9PbmUgKiAyLjA7JyArXHJcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gMC0+MiB0byAtMS0+KzEgKGNsaXBzcGFjZSlcclxuICAgICAgICAgICAgICAgICd2ZWMyIGNsaXBTcGFjZSA9IHplcm9Ub1R3byAtIDEuMDsnICtcclxuICAgICAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlICogdmVjMigxLCAtMSksIDAsIDEpOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gcGFzcyB0aGUgdGV4Q29vcmQgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIEdQVSB3aWxsIGludGVycG9sYXRlIHRoaXMgdmFsdWUgYmV0d2VlbiBwb2ludHMuXHJcbiAgICAgICAgICAgICAgICAndl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7JyArXHJcbiAgICAgICAgICAgICAgICAnfSc7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycgK1xyXG4gICAgICAgICAgICAgICAgLy8gb3VyIHRleHR1cmVcclxuICAgICAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHRleENvb3JkcyBwYXNzZWQgaW4gZnJvbSB0aGUgdmVydGV4IHNoYWRlci5cclxuICAgICAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDsnICtcclxuICAgICAgICAgICAgICAgIC8vIENvbG9yIGJsaW5kIGNvbnZlcnNpb25zXHJcbiAgICAgICAgICAgICAgICAvKidtYXQzIG1bOV0gPScgK1xyXG4gICAgICAgICAgICAgICAgJ3snICtcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDEuMCwgMC4wLCAwLjAsICAwLjAsIDEuMCwgMC4wLCAgMC4wLCAwLjAsIDEuMCAgKSwnICsgLy8gbm9ybWFsXHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjU2NywgMC40MzMsIDAuMCwgIDAuNTU4LCAwLjQ0MiwgMC4wLCAgMC4wLCAwLjI0MiwgMC43NTgpLCcgKyAvLyBwcm90YW5vcGlhXHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjgxNywgMC4xODMsIDAuMCwgIDAuMzMzLCAwLjY2NywgMC4wLCAgMC4wLCAwLjEyNSwwLjg3NSksJyArIC8vIHByb3Rhbm9tYWx5XHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjYyNSwgMC4zNzUsIDAuMCwgIDAuNywgMC4zLCAwLjAsICAwLjAsIDAuMywwLjcgICksJyArIC8vIGRldXRlcmFub3BpYVxyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMC44LCAwLjIsIDAuMCwgIDAuMjU4LCAwLjc0MiwgMC4wLCAgMC4wLCAwLjE0MiwwLjg1OCksJyArIC8vIGRldXRlcmFub21hbHlcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuOTUsIDAuMDUsIDAuMCwgIDAuMCwgMC40MzMsIDAuNTY3LCAgMC4wLCAwLjQ3NSwwLjUyNSksJyArIC8vIHRyaXRhbm9waWFcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuOTY3LCAwLjAzMywgMC4wLCAgMC4wLCAwLjczMywgMC4yNjcsICAwLjAsIDAuMTgzLDAuODE3KSwnICsgLy8gdHJpdGFub21hbHlcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuMjk5LCAwLjU4NywgMC4xMTQsICAwLjI5OSwgMC41ODcsIDAuMTE0LCAgMC4yOTksIDAuNTg3LDAuMTE0KSwnICsgLy8gYWNocm9tYXRvcHNpYVxyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMC42MTgsIDAuMzIwLCAwLjA2MiwgIDAuMTYzLCAwLjc3NSwgMC4wNjIsICAwLjE2MywgMC4zMjAsMC41MTYpJyArICAvLyBhY2hyb21hdG9tYWx5XHJcbiAgICAgICAgICAgICAgICAnfTsnICsqL1xyXG4gICAgICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnICtcclxuICAgICAgICAgICAgICAgICd2ZWM0IG8gPSAgdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gUkdCIHRvIExNUyBtYXRyaXggY29udmVyc2lvblxyXG4gICAgICAgICAgICAgICAgJ2Zsb2F0IEwgPSAoMTcuODgyNCAqIG8ucikgKyAoNDMuNTE2MSAqIG8uZykgKyAoNC4xMTkzNSAqIG8uYik7JyArXHJcbiAgICAgICAgICAgICAgICAnZmxvYXQgTSA9ICgzLjQ1NTY1ICogby5yKSArICgyNy4xNTU0ICogby5nKSArICgzLjg2NzE0ICogby5iKTsnICtcclxuICAgICAgICAgICAgICAgICdmbG9hdCBTID0gKDAuMDI5OTU2NiAqIG8ucikgKyAoMC4xODQzMDkgKiBvLmcpICsgKDEuNDY3MDkgKiBvLmIpOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gU2ltdWxhdGUgY29sb3IgYmxpbmRuZXNzXHJcbiAgICAgICAgICAgICAgICAnLy9NT0RFIENPREUvLycgK1xyXG4gICAgICAgICAgICAgICAgLyogRGV1dGVyYW5vcGUgZm9yIHRlc3RpbmdcclxuICAgICAgICAgICAgICAgICdmbG9hdCBsID0gMS4wICogTCArIDAuMCAqIE0gKyAwLjAgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IG0gPSAwLjQ5NDIwNyAqIEwgKyAwLjAgKiBNICsgMS4yNDgyNyAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQgcyA9IDAuMCAqIEwgKyAwLjAgKiBNICsgMS4wICogUzsnICsqL1xyXG4gICAgICAgICAgICAgICAgLy8gTE1TIHRvIFJHQiBtYXRyaXggY29udmVyc2lvblxyXG4gICAgICAgICAgICAgICAgJ3ZlYzQgZXJyb3I7JyArXHJcbiAgICAgICAgICAgICAgICAnZXJyb3IuciA9ICgwLjA4MDk0NDQ0NzkgKiBsKSArICgtMC4xMzA1MDQ0MDkgKiBtKSArICgwLjExNjcyMTA2NiAqIHMpOycgK1xyXG4gICAgICAgICAgICAgICAgJ2Vycm9yLmcgPSAoLTAuMDEwMjQ4NTMzNSAqIGwpICsgKDAuMDU0MDE5MzI2NiAqIG0pICsgKC0wLjExMzYxNDcwOCAqIHMpOycgK1xyXG4gICAgICAgICAgICAgICAgJ2Vycm9yLmIgPSAoLTAuMDAwMzY1Mjk2OTM4ICogbCkgKyAoLTAuMDA0MTIxNjE0NjkgKiBtKSArICgwLjY5MzUxMTQwNSAqIHMpOycgK1xyXG4gICAgICAgICAgICAgICAgJ2Vycm9yLmEgPSAxLjA7JyArXHJcbiAgICAgICAgICAgICAgICAndmVjNCBkaWZmID0gbyAtIGVycm9yOycgK1xyXG4gICAgICAgICAgICAgICAgJ3ZlYzQgY29ycmVjdGlvbjsnICtcclxuICAgICAgICAgICAgICAgICdjb3JyZWN0aW9uLnIgPSAwLjA7JyArXHJcbiAgICAgICAgICAgICAgICAnY29ycmVjdGlvbi5nID0gIChkaWZmLnIgKiAwLjcpICsgKGRpZmYuZyAqIDEuMCk7JyArXHJcbiAgICAgICAgICAgICAgICAnY29ycmVjdGlvbi5iID0gIChkaWZmLnIgKiAwLjcpICsgKGRpZmYuYiAqIDEuMCk7JyArXHJcbiAgICAgICAgICAgICAgICAnY29ycmVjdGlvbiA9IG8gKyBjb3JyZWN0aW9uOycgK1xyXG4gICAgICAgICAgICAgICAgJ2NvcnJlY3Rpb24uYSA9IG8uYTsnICtcclxuICAgICAgICAgICAgICAgICcvL1NJTVVMQVRFLy8nICtcclxuICAgICAgICAgICAgICAgICd9JztcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxDYW52YXMud2lkdGggPSBlbmdpbmUuZHJhd1dpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbENhbnZhcy5oZWlnaHQgPSBlbmdpbmUuZHJhd0hlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5fZ2wgPSB0aGlzLl9pbnRlcm5hbENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHsgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtID0gdGhpcy5fZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLl9nZXRTaGFkZXIoJ0ZyYWdtZW50JywgdGhpcy5fZ2V0RnJhZ21lbnRTaGFkZXJCeU1vZGUoY29sb3JNb2RlKSk7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXh0U2hhZGVyID0gdGhpcy5fZ2V0U2hhZGVyKCdWZXJ0ZXgnLCB0aGlzLl92ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5hdHRhY2hTaGFkZXIodGhpcy5fcHJvZ3JhbSwgdmVydGV4dFNoYWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmF0dGFjaFNoYWRlcih0aGlzLl9wcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmxpbmtQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5fcHJvZ3JhbSwgdGhpcy5fZ2wuTElOS19TVEFUVVMpKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfMTEuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ1VuYWJsZSB0byBsaW5rIHNoYWRlciBwcm9ncmFtIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVzZVByb2dyYW0odGhpcy5fcHJvZ3JhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENvbG9yQmxpbmRDb3JyZWN0b3IucHJvdG90eXBlLl9nZXRGcmFnbWVudFNoYWRlckJ5TW9kZSA9IGZ1bmN0aW9uIChjb2xvck1vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvZGUgPSAnJztcclxuICAgICAgICAgICAgaWYgKGNvbG9yTW9kZSA9PT0gQ29sb3JCbGluZG5lc3MuUHJvdGFub3BlKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID1cclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbCA9IDAuMCAqIEwgKyAyLjAyMzQ0ICogTSArIC0yLjUyNTgxICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IG0gPSAwLjAgKiBMICsgMS4wICogTSArIDAuMCAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBzID0gMC4wICogTCArIDAuMCAqIE0gKyAxLjAgKiBTOyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3JNb2RlID09PSBDb2xvckJsaW5kbmVzcy5EZXV0ZXJhbm9wZSkge1xyXG4gICAgICAgICAgICAgICAgY29kZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IGwgPSAxLjAgKiBMICsgMC4wICogTSArIDAuMCAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBtID0gMC40OTQyMDcgKiBMICsgMC4wICogTSArIDEuMjQ4MjcgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQgcyA9IDAuMCAqIEwgKyAwLjAgKiBNICsgMS4wICogUzsnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yTW9kZSA9PT0gQ29sb3JCbGluZG5lc3MuVHJpdGFub3BlKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID1cclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbCA9IDEuMCAqIEwgKyAwLjAgKiBNICsgMC4wICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IG0gPSAwLjAgKiBMICsgMS4wICogTSArIDAuMCAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBzID0gLTAuMzk1OTEzICogTCArIDAuODAxMTA5ICogTSArIDAuMCAqIFM7JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaW11bGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSB0aGlzLl9mcmFnbWVudFNoYWRlci5yZXBsYWNlKCcvL1NJTVVMQVRFLy8nLCAnZ2xfRnJhZ0NvbG9yID0gZXJyb3IucmdiYTsnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gdGhpcy5fZnJhZ21lbnRTaGFkZXIucmVwbGFjZSgnLy9TSU1VTEFURS8vJywgJ2dsX0ZyYWdDb2xvciA9IGNvcnJlY3Rpb24ucmdiYTsnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJhZ21lbnRTaGFkZXIucmVwbGFjZSgnLy9NT0RFIENPREUvLycsIGNvZGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29sb3JCbGluZENvcnJlY3Rvci5wcm90b3R5cGUuX3NldFJlY3RhbmdsZSA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciB4MSA9IHg7XHJcbiAgICAgICAgICAgIHZhciB4MiA9IHggKyB3aWR0aDtcclxuICAgICAgICAgICAgdmFyIHkxID0geTtcclxuICAgICAgICAgICAgdmFyIHkyID0geSArIGhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgeDEsIHkxLFxyXG4gICAgICAgICAgICAgICAgeDIsIHkxLFxyXG4gICAgICAgICAgICAgICAgeDEsIHkyLFxyXG4gICAgICAgICAgICAgICAgeDEsIHkyLFxyXG4gICAgICAgICAgICAgICAgeDIsIHkxLFxyXG4gICAgICAgICAgICAgICAgeDIsIHkyXHJcbiAgICAgICAgICAgIF0pLCB0aGlzLl9nbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xvckJsaW5kQ29ycmVjdG9yLnByb3RvdHlwZS5fZ2V0U2hhZGVyID0gZnVuY3Rpb24gKHR5cGUsIHByb2dyYW0pIHtcclxuICAgICAgICAgICAgdmFyIHNoYWRlcjtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdGcmFnbWVudCcpIHtcclxuICAgICAgICAgICAgICAgIHNoYWRlciA9IHRoaXMuX2dsLmNyZWF0ZVNoYWRlcih0aGlzLl9nbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdWZXJ0ZXgnKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFkZXIgPSB0aGlzLl9nbC5jcmVhdGVTaGFkZXIodGhpcy5fZ2wuVkVSVEVYX1NIQURFUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfMTEuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Vycm9yIHVua25vd24gc2hhZGVyIHR5cGUnLCB0eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBwcm9ncmFtKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2dsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuX2dsLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzExLkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdVbmFibGUgdG8gY29tcGlsZSBzaGFkZXIhJywgdGhpcy5fZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xvckJsaW5kQ29ycmVjdG9yLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGltYWdlLCBvdXQpIHtcclxuICAgICAgICAgICAgLy8gbG9vayB1cCB3aGVyZSB0aGUgdmVydGV4IGRhdGEgbmVlZHMgdG8gZ28uXHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uID0gdGhpcy5fZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgJ2FfcG9zaXRpb24nKTtcclxuICAgICAgICAgICAgdmFyIHRleENvb3JkTG9jYXRpb24gPSB0aGlzLl9nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9wcm9ncmFtLCAnYV90ZXhDb29yZCcpO1xyXG4gICAgICAgICAgICB2YXIgdGV4Q29vcmRCdWZmZXIgPSB0aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIHRleENvb3JkQnVmZmVyKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgMC4wLCAwLjAsXHJcbiAgICAgICAgICAgICAgICAxLjAsIDAuMCxcclxuICAgICAgICAgICAgICAgIDAuMCwgMS4wLFxyXG4gICAgICAgICAgICAgICAgMC4wLCAxLjAsXHJcbiAgICAgICAgICAgICAgICAxLjAsIDAuMCxcclxuICAgICAgICAgICAgICAgIDEuMCwgMS4wXHJcbiAgICAgICAgICAgIF0pLCB0aGlzLl9nbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRleENvb3JkTG9jYXRpb24sIDIsIHRoaXMuX2dsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRleHR1cmUuXHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl9nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBwYXJhbWV0ZXJzIHNvIHdlIGNhbiByZW5kZXIgYW55IHNpemUgaW1hZ2UuXHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuX2dsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl9nbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELCB0aGlzLl9nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuX2dsLk5FQVJFU1QpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgICAgIC8vIEZsaXAgdGhlIHRleHR1cmUgd2hlbiB1bnBhY2tpbmcgaW50byB0aGUgZ2wgY29udGV4dCwgZ2wgcmVhZHMgdGV4dHVyZXMgaW4gdGhlIG9wcG9zaXRlIG9yZGVyIGFzIGV2ZXJ5dGhpbmcgZWxzZSA6L1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5waXhlbFN0b3JlaSh0aGlzLl9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCAxKTtcclxuICAgICAgICAgICAgLy8gVXBsb2FkIHRoZSBpbWFnZSBpbnRvIHRoZSB0ZXh0dXJlLlxyXG4gICAgICAgICAgICB0aGlzLl9nbC50ZXhJbWFnZTJEKHRoaXMuX2dsLlRFWFRVUkVfMkQsIDAsIHRoaXMuX2dsLlJHQkEsIHRoaXMuX2dsLlJHQkEsIHRoaXMuX2dsLlVOU0lHTkVEX0JZVEUsIGltYWdlKTtcclxuICAgICAgICAgICAgLy8gbG9va3VwIHVuaWZvcm1zXHJcbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uTG9jYXRpb24gPSB0aGlzLl9nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpO1xyXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHJlc29sdXRpb25cclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgdGhpcy5faW50ZXJuYWxDYW52YXMud2lkdGgsIHRoaXMuX2ludGVybmFsQ2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGJ1ZmZlciBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSByZWN0YW5nbGUgY29ybmVycy5cclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uQnVmZmVyID0gdGhpcy5fZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sIDIsIHRoaXMuX2dsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIC8vIFNldCBhIHJlY3RhbmdsZSB0aGUgc2FtZSBzaXplIGFzIHRoZSBpbWFnZS5cclxuICAgICAgICAgICAgdGhpcy5fc2V0UmVjdGFuZ2xlKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSByZWN0YW5nbGUuXHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmRyYXdBcnJheXModGhpcy5fZ2wuVFJJQU5HTEVTLCAwLCA2KTtcclxuICAgICAgICAgICAgLy8gR3JhYiB0cmFuZm9ybWVkIGltYWdlIGZyb20gaW50ZXJuYWwgY2FudmFzXHJcbiAgICAgICAgICAgIHZhciBwaXhlbERhdGEgPSBuZXcgVWludDhBcnJheShpbWFnZS53aWR0aCAqIGltYWdlLmhlaWdodCAqIDQpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5yZWFkUGl4ZWxzKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHRoaXMuX2dsLlJHQkEsIHRoaXMuX2dsLlVOU0lHTkVEX0JZVEUsIHBpeGVsRGF0YSk7XHJcbiAgICAgICAgICAgIGltYWdlLmRhdGEuc2V0KHBpeGVsRGF0YSk7XHJcbiAgICAgICAgICAgIG91dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENvbG9yQmxpbmRDb3JyZWN0b3I7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Db2xvckJsaW5kQ29ycmVjdG9yID0gQ29sb3JCbGluZENvcnJlY3RvcjtcclxufSk7XHJcbmRlZmluZShcIlBvc3RQcm9jZXNzaW5nL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUG9zdFByb2Nlc3NpbmcvQ29sb3JCbGluZENvcnJlY3RvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbG9yQmxpbmRDb3JyZWN0b3JfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgX19leHBvcnQoQ29sb3JCbGluZENvcnJlY3Rvcl8xKTtcclxufSk7XHJcbmRlZmluZShcIlJlc291cmNlcy9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlJlc291cmNlcy9SZXNvdXJjZVwiLCBcIlJlc291cmNlcy9Tb3VuZFwiLCBcIlJlc291cmNlcy9UZXh0dXJlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUmVzb3VyY2VfMiwgU291bmRfMiwgVGV4dHVyZV8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBfX2V4cG9ydChSZXNvdXJjZV8yKTtcclxuICAgIF9fZXhwb3J0KFNvdW5kXzIpO1xyXG4gICAgX19leHBvcnQoVGV4dHVyZV8xKTtcclxufSk7XHJcbmRlZmluZShcIklucHV0L0dhbWVwYWRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDbGFzc1wiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENsYXNzXzUsIEV2ZW50c184KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRXhjYWxpYnVyIGxldmVyYWdlcyB0aGUgSFRNTDUgR2FtZXBhZCBBUEkgW3doZXJlIGl0IGlzIHN1cHBvcnRlZF0oaHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWdhbWVwYWQpXHJcbiAgICAgKiB0byBwcm92aWRlIGNvbnRyb2xsZXIgc3VwcG9ydCBmb3IgeW91ciBnYW1lcy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6R2FtZXBhZHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZXBhZHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkcywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lcGFkcyhlbmdpbmUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHBvbGwgZm9yIEdhbWVwYWQgaW5wdXQgKGRlZmF1bHQ6IGBmYWxzZWApXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBHYW1lcGFkIEFQSSBpcyBzdXBwb3J0ZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnN1cHBvcnRlZCA9ICEhbmF2aWdhdG9yLmdldEdhbWVwYWRzO1xyXG4gICAgICAgICAgICBfdGhpcy5fZ2FtZVBhZFRpbWVTdGFtcHMgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgICAgIF90aGlzLl9vbGRQYWRzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9wYWRzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9pbml0U3VjY2VzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fbmF2aWdhdG9yID0gbmF2aWdhdG9yO1xyXG4gICAgICAgICAgICBfdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRTdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSW4gQ2hyb21lLCB0aGlzIHdpbGwgcmV0dXJuIDQgdW5kZWZpbmVkIGl0ZW1zIHVudGlsIGEgYnV0dG9uIGlzIHByZXNzZWRcclxuICAgICAgICAgICAgLy8gSW4gRkYsIHRoaXMgd2lsbCBub3QgcmV0dXJuIGFueSBpdGVtcyB1bnRpbCBhIGJ1dHRvbiBpcyBwcmVzc2VkXHJcbiAgICAgICAgICAgIHRoaXMuX29sZFBhZHMgPSB0aGlzLl9jbG9uZVBhZHModGhpcy5fbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fb2xkUGFkcy5sZW5ndGggJiYgdGhpcy5fb2xkUGFkc1swXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBtaW5pbXVtIGdhbWVwYWQgY29uZmlndXJhdGlvbiwgZm9yIGV4YW1wbGUge2F4aXM6IDQsIGJ1dHRvbnM6IDR9IG1lYW5zXHJcbiAgICAgICAgICogdGhpcyBnYW1lIHJlcXVpcmVzIGF0IG1pbmltdW0gNCBheGlzIGlucHV0cyBhbmQgNCBidXR0b25zLCB0aGlzIGlzIG5vdCByZXN0cmljdGl2ZVxyXG4gICAgICAgICAqIGFsbCBvdGhlciBjb250cm9sbGVycyB3aXRoIG1vcmUgYXhpcyBvciBidXR0b25zIGFyZSB2YWxpZCBhcyB3ZWxsLiBJZiBubyBtaW5pbXVtXHJcbiAgICAgICAgICogY29uZmlndXJhdGlvbiBpcyBzZXQgYWxsIHBhZHMgYXJlIHZhbGlkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5zZXRNaW5pbXVtR2FtZXBhZENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpOyAvLyBpZiBjb25maWcgaXMgdXNlZCwgaW1wbGljaXRseSBlbmFibGVcclxuICAgICAgICAgICAgdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24gPSBjb25maWc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIGltcGxpY2l0bHkgZW5hYmxlZCwgc2V0IHRoZSBlbmFibGVkIGZsYWcgYW5kIHJ1biBhbiB1cGRhdGUgc28gaW5mb3JtYXRpb24gaXMgdXBkYXRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5fZW5hYmxlQW5kVXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBhIG5hdmlnYXRvciBnYW1lcGFkIGFnYWluc3QgdGhlIG1pbmltdW0gY29uZmlndXJhdGlvbiBpZiBwcmVzZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5faXNHYW1lcGFkVmFsaWQgPSBmdW5jdGlvbiAocGFkKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgaWYgKCFwYWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIHZhciBheGVzTGVuZ3RoID0gcGFkLmF4ZXMuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH0pLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvbkxlbmd0aCA9IHBhZC5idXR0b25zLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiBheGVzTGVuZ3RoID49IHRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uLmF4aXMgJiZcclxuICAgICAgICAgICAgICAgIGJ1dHRvbkxlbmd0aCA+PSB0aGlzLl9taW5pbXVtQ29uZmlndXJhdGlvbi5idXR0b25zICYmXHJcbiAgICAgICAgICAgICAgICBwYWQuY29ubmVjdGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVBbmRVcGRhdGUoKTsgLy8gaW1wbGljaXRseSBlbmFibGVcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVBbmRVcGRhdGUoKTsgLy8gaW1wbGljaXRseSBlbmFibGVcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vZmYuY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBHYW1lcGFkIHN0YXRlIGFuZCBwdWJsaXNoZXMgR2FtZXBhZCBldmVudHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5zdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgICAgICAgICAgdmFyIGdhbWVwYWRzID0gdGhpcy5fbmF2aWdhdG9yLmdldEdhbWVwYWRzKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FtZXBhZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICghZ2FtZXBhZHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtZXBhZCA9IHRoaXMuYXQoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2FzIGNvbm5lY3RlZCwgYnV0IG5vdyBpc24ndCBlbWl0IHRoZSBkaXNjb25uZWN0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVwYWQuY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBuZXcgRXZlbnRzXzguR2FtZXBhZERpc2Nvbm5lY3RFdmVudChpLCBnYW1lcGFkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGNvbm5lY3Rpb24gc3RhdHVzXHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZXBhZC5jb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdChpKS5jb25uZWN0ZWQgJiYgdGhpcy5faXNHYW1lcGFkVmFsaWQoZ2FtZXBhZHNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2Nvbm5lY3QnLCBuZXcgRXZlbnRzXzguR2FtZXBhZENvbm5lY3RFdmVudChpLCB0aGlzLmF0KGkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBjb25uZWN0aW9uIHN0YXR1c1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuY29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgc3VwcG9ydGVkIGluIENocm9tZVxyXG4gICAgICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLnRpbWVzdGFtcCAmJiBnYW1lcGFkc1tpXS50aW1lc3RhbXAgPT09IHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nYW1lUGFkVGltZVN0YW1wc1tpXSA9IGdhbWVwYWRzW2ldLnRpbWVzdGFtcDtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCByZWZlcmVuY2UgdG8gbmF2aWdhdG9yIGdhbWVwYWRcclxuICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkubmF2aWdhdG9yR2FtZXBhZCA9IGdhbWVwYWRzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gQnV0dG9uc1xyXG4gICAgICAgICAgICAgICAgdmFyIGIsIGJpLCBhLCBhaSwgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGIgaW4gQnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpID0gQnV0dG9uc1tiXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZHNbaV0uYnV0dG9uc1tiaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2FtZXBhZHNbaV0uYnV0dG9uc1tiaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX29sZFBhZHNbaV0uZ2V0QnV0dG9uKGJpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkc1tpXS5idXR0b25zW2JpXS5wcmVzc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQnV0dG9uKGJpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2J1dHRvbicsIG5ldyBFdmVudHNfOC5HYW1lcGFkQnV0dG9uRXZlbnQoYmksIHZhbHVlLCB0aGlzLmF0KGkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUJ1dHRvbihiaSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQXhlc1xyXG4gICAgICAgICAgICAgICAgZm9yIChhIGluIEF4ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBhaSA9IEF4ZXNbYV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhaSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnYW1lcGFkc1tpXS5heGVzW2FpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9vbGRQYWRzW2ldLmdldEF4ZXMoYWkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUF4ZXMoYWksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2F4aXMnLCBuZXcgRXZlbnRzXzguR2FtZXBhZEF4aXNFdmVudChhaSwgdmFsdWUsIHRoaXMuYXQoaSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX29sZFBhZHNbaV0gPSB0aGlzLl9jbG9uZVBhZChnYW1lcGFkc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNhZmVseSByZXRyaWV2ZXMgYSBHYW1lcGFkIGF0IGEgc3BlY2lmaWMgaW5kZXggYW5kIGNyZWF0ZXMgb25lIGlmIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpOyAvLyBpbXBsaWNpdGx5IGVuYWJsZSBnYW1lcGFkcyB3aGVuIGF0KCkgaXMgY2FsbGVkICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9wYWRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGEgcGFkIHRvIHJldHJpZXZlXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fcGFkcy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFkcy5wdXNoKG5ldyBHYW1lcGFkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29sZFBhZHMucHVzaChuZXcgR2FtZXBhZCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFkc1tpbmRleF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdmFsaWQgZ2FtZXBhZHMgdGhhdCBtZWV0IHRoZSBtaW5pbXVtIGNvbmZpZ3VyYXRpb24gcmVxdWlyZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLmdldFZhbGlkR2FtZXBhZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGFkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzR2FtZXBhZFZhbGlkKHRoaXMuYXQoaSkubmF2aWdhdG9yR2FtZXBhZCkgJiYgdGhpcy5hdChpKS5jb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmF0KGkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbm5lY3RlZCBnYW1lcGFkc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmNvbm5lY3RlZDsgfSkubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLl9jbG9uZVBhZHMgPSBmdW5jdGlvbiAocGFkcykge1xyXG4gICAgICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLl9jbG9uZVBhZChwYWRzW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhc3Rlc3Qgd2F5IHRvIGNsb25lIGEga25vd24gb2JqZWN0IGlzIHRvIGRvIGl0IHlvdXJzZWxmXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLl9jbG9uZVBhZCA9IGZ1bmN0aW9uIChwYWQpIHtcclxuICAgICAgICAgICAgdmFyIGksIGxlbjtcclxuICAgICAgICAgICAgdmFyIGNsb25lZFBhZCA9IG5ldyBHYW1lcGFkKCk7XHJcbiAgICAgICAgICAgIGlmICghcGFkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhZC5idXR0b25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFkLmJ1dHRvbnNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZWRQYWQudXBkYXRlQnV0dG9uKGksIHBhZC5idXR0b25zW2ldLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYWQuYXhlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2xvbmVkUGFkLnVwZGF0ZUF4ZXMoaSwgcGFkLmF4ZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gR2FtZXBhZHM7XHJcbiAgICB9KENsYXNzXzUuQ2xhc3MpKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1pbmltdW0gdmFsdWUgYW4gYXhpcyBoYXMgdG8gbW92ZSBiZWZvcmUgY29uc2lkZXJpbmcgaXQgYSBjaGFuZ2VcclxuICAgICAqL1xyXG4gICAgR2FtZXBhZHMuTWluQXhpc01vdmVUaHJlc2hvbGQgPSAwLjA1O1xyXG4gICAgZXhwb3J0cy5HYW1lcGFkcyA9IEdhbWVwYWRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYW1lcGFkIGhvbGRzIHN0YXRlIGluZm9ybWF0aW9uIGZvciBhIGNvbm5lY3RlZCBjb250cm9sbGVyLiBTZWUgW1tHYW1lcGFkc11dXHJcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBoYW5kbGluZyBjb250cm9sbGVyIGlucHV0LlxyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZXBhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEdhbWVwYWQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZXBhZCgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLl9idXR0b25zID0gbmV3IEFycmF5KDE2KTtcclxuICAgICAgICAgICAgX3RoaXMuX2F4ZXMgPSBuZXcgQXJyYXkoNCk7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3RoaXMuX2J1dHRvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9idXR0b25zW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3RoaXMuX2F4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9heGVzW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBidXR0b24gaXMgcHJlc3NlZFxyXG4gICAgICAgICAqIEBwYXJhbSBidXR0b24gICAgIFRoZSBidXR0b24gdG8gcXVlcnlcclxuICAgICAgICAgKiBAcGFyYW0gdGhyZXNob2xkICBUaGUgdGhyZXNob2xkIG92ZXIgd2hpY2ggdGhlIGJ1dHRvbiBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNzZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5pc0J1dHRvblByZXNzZWQgPSBmdW5jdGlvbiAoYnV0dG9uLCB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7IHRocmVzaG9sZCA9IDE7IH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbnNbYnV0dG9uXSA+PSB0aHJlc2hvbGQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBnaXZlbiBidXR0b24gdmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUuZ2V0QnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uc1tidXR0b25dO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZ2l2ZW4gYXhpcyB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxLiBWYWx1ZXMgYmVsb3dcclxuICAgICAgICAgKiBbW01pbkF4aXNNb3ZlVGhyZXNob2xkXV0gYXJlIGNvbnNpZGVyZWQgMC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKGF4ZXMpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fYXhlc1theGVzXTtcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8IEdhbWVwYWRzLk1pbkF4aXNNb3ZlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUudXBkYXRlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbkluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9idXR0b25zW2J1dHRvbkluZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUudXBkYXRlQXhlcyA9IGZ1bmN0aW9uIChheGVzSW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2F4ZXNbYXhlc0luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEdhbWVwYWQ7XHJcbiAgICB9KENsYXNzXzUuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuR2FtZXBhZCA9IEdhbWVwYWQ7XHJcbiAgICAvKipcclxuICAgICAqIEdhbWVwYWQgQnV0dG9ucyBlbnVtZXJhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgQnV0dG9ucztcclxuICAgIChmdW5jdGlvbiAoQnV0dG9ucykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhY2UgMSBidXR0b24gKGUuZy4gQSlcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlMVwiXSA9IDBdID0gXCJGYWNlMVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhY2UgMiBidXR0b24gKGUuZy4gQilcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlMlwiXSA9IDFdID0gXCJGYWNlMlwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhY2UgMyBidXR0b24gKGUuZy4gWClcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlM1wiXSA9IDJdID0gXCJGYWNlM1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhY2UgNCBidXR0b24gKGUuZy4gWSlcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlNFwiXSA9IDNdID0gXCJGYWNlNFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlZnQgYnVtcGVyIGJ1dHRvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkxlZnRCdW1wZXJcIl0gPSA0XSA9IFwiTGVmdEJ1bXBlclwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJpZ2h0IGJ1bXBlciBidXR0b25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodEJ1bXBlclwiXSA9IDVdID0gXCJSaWdodEJ1bXBlclwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlZnQgdHJpZ2dlciBidXR0b25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0VHJpZ2dlclwiXSA9IDZdID0gXCJMZWZ0VHJpZ2dlclwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJpZ2h0IHRyaWdnZXIgYnV0dG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiUmlnaHRUcmlnZ2VyXCJdID0gN10gPSBcIlJpZ2h0VHJpZ2dlclwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlbGVjdCBidXR0b25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJTZWxlY3RcIl0gPSA4XSA9IFwiU2VsZWN0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RhcnQgYnV0dG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiU3RhcnRcIl0gPSA5XSA9IFwiU3RhcnRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMZWZ0IGFuYWxvZyBzdGljayBwcmVzcyAoZS5nLiBMMylcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0U3RpY2tcIl0gPSAxMF0gPSBcIkxlZnRTdGlja1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJpZ2h0IGFuYWxvZyBzdGljayBwcmVzcyAoZS5nLiBSMylcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodFN0aWNrXCJdID0gMTFdID0gXCJSaWdodFN0aWNrXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRC1wYWQgdXBcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkVXBcIl0gPSAxMl0gPSBcIkRwYWRVcFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEQtcGFkIGRvd25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkRG93blwiXSA9IDEzXSA9IFwiRHBhZERvd25cIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBELXBhZCBsZWZ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZExlZnRcIl0gPSAxNF0gPSBcIkRwYWRMZWZ0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRC1wYWQgcmlnaHRcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkUmlnaHRcIl0gPSAxNV0gPSBcIkRwYWRSaWdodFwiO1xyXG4gICAgfSkoQnV0dG9ucyA9IGV4cG9ydHMuQnV0dG9ucyB8fCAoZXhwb3J0cy5CdXR0b25zID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogR2FtZXBhZCBBeGVzIGVudW1lcmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBBeGVzO1xyXG4gICAgKGZ1bmN0aW9uIChBeGVzKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVmdCBhbmFsb2d1ZSBzdGljayBYIGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF4ZXNbQXhlc1tcIkxlZnRTdGlja1hcIl0gPSAwXSA9IFwiTGVmdFN0aWNrWFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlZnQgYW5hbG9ndWUgc3RpY2sgWSBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBeGVzW0F4ZXNbXCJMZWZ0U3RpY2tZXCJdID0gMV0gPSBcIkxlZnRTdGlja1lcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSaWdodCBhbmFsb2d1ZSBzdGljayBYIGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF4ZXNbQXhlc1tcIlJpZ2h0U3RpY2tYXCJdID0gMl0gPSBcIlJpZ2h0U3RpY2tYXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmlnaHQgYW5hbG9ndWUgc3RpY2sgWSBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBeGVzW0F4ZXNbXCJSaWdodFN0aWNrWVwiXSA9IDNdID0gXCJSaWdodFN0aWNrWVwiO1xyXG4gICAgfSkoQXhlcyA9IGV4cG9ydHMuQXhlcyB8fCAoZXhwb3J0cy5BeGVzID0ge30pKTtcclxufSk7XHJcbmRlZmluZShcIklucHV0L1BvaW50ZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJFbmdpbmVcIiwgXCJFdmVudHNcIiwgXCJVSUFjdG9yXCIsIFwiQWxnZWJyYVwiLCBcIkNsYXNzXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgRW5naW5lXzEsIEV2ZW50c185LCBVSUFjdG9yXzEsIEFsZ2VicmFfMjAsIENsYXNzXzYsIFV0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHlwZSBvZiBwb2ludGVyIGZvciBhIFtbUG9pbnRlckV2ZW50XV0uXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2ludGVyVHlwZTtcclxuICAgIChmdW5jdGlvbiAoUG9pbnRlclR5cGUpIHtcclxuICAgICAgICBQb2ludGVyVHlwZVtQb2ludGVyVHlwZVtcIlRvdWNoXCJdID0gMF0gPSBcIlRvdWNoXCI7XHJcbiAgICAgICAgUG9pbnRlclR5cGVbUG9pbnRlclR5cGVbXCJNb3VzZVwiXSA9IDFdID0gXCJNb3VzZVwiO1xyXG4gICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiUGVuXCJdID0gMl0gPSBcIlBlblwiO1xyXG4gICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiVW5rbm93blwiXSA9IDNdID0gXCJVbmtub3duXCI7XHJcbiAgICB9KShQb2ludGVyVHlwZSA9IGV4cG9ydHMuUG9pbnRlclR5cGUgfHwgKGV4cG9ydHMuUG9pbnRlclR5cGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbW91c2UgYnV0dG9uIGJlaW5nIHByZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2ludGVyQnV0dG9uO1xyXG4gICAgKGZ1bmN0aW9uIChQb2ludGVyQnV0dG9uKSB7XHJcbiAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XHJcbiAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiTWlkZGxlXCJdID0gMV0gPSBcIk1pZGRsZVwiO1xyXG4gICAgICAgIFBvaW50ZXJCdXR0b25bUG9pbnRlckJ1dHRvbltcIlJpZ2h0XCJdID0gMl0gPSBcIlJpZ2h0XCI7XHJcbiAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiVW5rbm93blwiXSA9IDNdID0gXCJVbmtub3duXCI7XHJcbiAgICB9KShQb2ludGVyQnV0dG9uID0gZXhwb3J0cy5Qb2ludGVyQnV0dG9uIHx8IChleHBvcnRzLlBvaW50ZXJCdXR0b24gPSB7fSkpO1xyXG4gICAgdmFyIFdoZWVsRGVsdGFNb2RlO1xyXG4gICAgKGZ1bmN0aW9uIChXaGVlbERlbHRhTW9kZSkge1xyXG4gICAgICAgIFdoZWVsRGVsdGFNb2RlW1doZWVsRGVsdGFNb2RlW1wiUGl4ZWxcIl0gPSAwXSA9IFwiUGl4ZWxcIjtcclxuICAgICAgICBXaGVlbERlbHRhTW9kZVtXaGVlbERlbHRhTW9kZVtcIkxpbmVcIl0gPSAxXSA9IFwiTGluZVwiO1xyXG4gICAgICAgIFdoZWVsRGVsdGFNb2RlW1doZWVsRGVsdGFNb2RlW1wiUGFnZVwiXSA9IDJdID0gXCJQYWdlXCI7XHJcbiAgICB9KShXaGVlbERlbHRhTW9kZSA9IGV4cG9ydHMuV2hlZWxEZWx0YU1vZGUgfHwgKGV4cG9ydHMuV2hlZWxEZWx0YU1vZGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBzY29wZSBvZiBoYW5kbGluZyBtb3VzZS90b3VjaCBldmVudHMuIFNlZSBbW1BvaW50ZXJzXV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2ludGVyU2NvcGU7XHJcbiAgICAoZnVuY3Rpb24gKFBvaW50ZXJTY29wZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZSBldmVudHMgb24gdGhlIGBjYW52YXNgIGVsZW1lbnQgb25seS4gRXZlbnRzIG9yaWdpbmF0aW5nIG91dHNpZGUgdGhlXHJcbiAgICAgICAgICogYGNhbnZhc2Agd2lsbCBub3QgYmUgaGFuZGxlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVyU2NvcGVbUG9pbnRlclNjb3BlW1wiQ2FudmFzXCJdID0gMF0gPSBcIkNhbnZhc1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgZXZlbnRzIG9uIHRoZSBlbnRpcmUgZG9jdW1lbnQuIEFsbCBldmVudHMgd2lsbCBiZSBoYW5kbGVkIGJ5IEV4Y2FsaWJ1ci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVyU2NvcGVbUG9pbnRlclNjb3BlW1wiRG9jdW1lbnRcIl0gPSAxXSA9IFwiRG9jdW1lbnRcIjtcclxuICAgIH0pKFBvaW50ZXJTY29wZSA9IGV4cG9ydHMuUG9pbnRlclNjb3BlIHx8IChleHBvcnRzLlBvaW50ZXJTY29wZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgY29uc3RhbnQgdXNlZCB0byBub3JtYWxpemUgd2hlZWwgZXZlbnRzIGFjcm9zcyBkaWZmZXJlbnQgYnJvd3NlcnNcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG5vcm1hbGl6YXRpb24gZmFjdG9yIGlzIHB1bGxlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy93aGVlbCNMaXN0ZW5pbmdfdG9fdGhpc19ldmVudF9hY3Jvc3NfYnJvd3NlclxyXG4gICAgICovXHJcbiAgICB2YXIgU2Nyb2xsV2hlZWxOb3JtYWxpemF0aW9uRmFjdG9yID0gLTEgLyA0MDtcclxuICAgIC8qKlxyXG4gICAgICogUG9pbnRlciBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgbW91c2UsIHRvdWNoLCBvciBzdHlsdXMgZXZlbnQuIFNlZSBbW1BvaW50ZXJzXV0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb25cclxuICAgICAqIGhhbmRsaW5nIHBvaW50ZXIgaW5wdXQuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIG1vdXNlLWJhc2VkIGV2ZW50cywgeW91IGNhbiBpbnNwZWN0IFtbUG9pbnRlckV2ZW50LmJ1dHRvbl1dIHRvIHNlZSB3aGF0IGJ1dHRvbiB3YXMgcHJlc3NlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIFBvaW50ZXJFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBvaW50ZXJFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gcGFnZVggICAgICAgIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIGRvY3VtZW50IGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBwYWdlWSAgICAgICAgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gZG9jdW1lbnQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHNjcmVlblggICAgICBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBzY3JlZW4gY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHNjcmVlblkgICAgICBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBzY3JlZW4gY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHBvaW50ZXIgKHplcm8tYmFzZWQpXHJcbiAgICAgICAgICogQHBhcmFtIHBvaW50ZXJUeXBlICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgICAgICogQHBhcmFtIGJ1dHRvbiAgICAgICBUaGUgYnV0dG9uIHByZXNzZWQgKGlmIFtbUG9pbnRlclR5cGUuTW91c2VdXSlcclxuICAgICAgICAgKiBAcGFyYW0gZXYgICAgICAgICAgIFRoZSByYXcgRE9NIGV2ZW50IGJlaW5nIGhhbmRsZWRcclxuICAgICAgICAgKiBAcGFyYW0gcG9zICAgICAgICAgIChXaWxsIGJlIGFkZGVkIHRvIHNpZ25hdHVyZSBpbiAwLjE0LjAgcmVsZWFzZSkgVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUG9pbnRlckV2ZW50KHgsIHksIHBhZ2VYLCBwYWdlWSwgc2NyZWVuWCwgc2NyZWVuWSwgaW5kZXgsIHBvaW50ZXJUeXBlLCBidXR0b24sIGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnggPSB4O1xyXG4gICAgICAgICAgICBfdGhpcy55ID0geTtcclxuICAgICAgICAgICAgX3RoaXMucGFnZVggPSBwYWdlWDtcclxuICAgICAgICAgICAgX3RoaXMucGFnZVkgPSBwYWdlWTtcclxuICAgICAgICAgICAgX3RoaXMuc2NyZWVuWCA9IHNjcmVlblg7XHJcbiAgICAgICAgICAgIF90aGlzLnNjcmVlblkgPSBzY3JlZW5ZO1xyXG4gICAgICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICBfdGhpcy5wb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xyXG4gICAgICAgICAgICBfdGhpcy5idXR0b24gPSBidXR0b247XHJcbiAgICAgICAgICAgIF90aGlzLmV2ID0gZXY7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvaW50ZXJFdmVudC5wcm90b3R5cGUsIFwicG9zXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjAuVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudDtcclxuICAgIH0oRXZlbnRzXzkuR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlBvaW50ZXJFdmVudCA9IFBvaW50ZXJFdmVudDtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogV2hlZWwgRXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogUmVwcmVzZW50cyBhIG1vdXNlIHdoZWVsIGV2ZW50LiBTZWUgW1tQb2ludGVyc11dIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uXHJcbiAgICAgKiBoYW5kbGluZyBwb2ludCBpbnB1dC5cclxuICAgICAqL1xyXG4gICAgdmFyIFdoZWVsRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhXaGVlbEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgICAgICAgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgICAgICBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiB3b3JsZCBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gcGFnZVggICAgICAgIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIGRvY3VtZW50IGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBwYWdlWSAgICAgICAgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gZG9jdW1lbnQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHNjcmVlblggICAgICBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBzY3JlZW4gY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHNjcmVlblkgICAgICBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBzY3JlZW4gY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHBvaW50ZXIgKHplcm8tYmFzZWQpXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhWCAgICAgICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhWSAgICAgICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhWiAgICAgICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhTW9kZSAgICBUaGUgdHlwZSBvZiBtb3ZlbWVudCBbW1doZWVsRGVsdGFNb2RlXV1cclxuICAgICAgICAgKiBAcGFyYW0gZXYgICAgICAgICAgIFRoZSByYXcgRE9NIGV2ZW50IGJlaW5nIGhhbmRsZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBXaGVlbEV2ZW50KHgsIHksIHBhZ2VYLCBwYWdlWSwgc2NyZWVuWCwgc2NyZWVuWSwgaW5kZXgsIGRlbHRhWCwgZGVsdGFZLCBkZWx0YVosIGRlbHRhTW9kZSwgZXYpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIF90aGlzLnkgPSB5O1xyXG4gICAgICAgICAgICBfdGhpcy5wYWdlWCA9IHBhZ2VYO1xyXG4gICAgICAgICAgICBfdGhpcy5wYWdlWSA9IHBhZ2VZO1xyXG4gICAgICAgICAgICBfdGhpcy5zY3JlZW5YID0gc2NyZWVuWDtcclxuICAgICAgICAgICAgX3RoaXMuc2NyZWVuWSA9IHNjcmVlblk7XHJcbiAgICAgICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhWCA9IGRlbHRhWDtcclxuICAgICAgICAgICAgX3RoaXMuZGVsdGFZID0gZGVsdGFZO1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YVogPSBkZWx0YVo7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhTW9kZSA9IGRlbHRhTW9kZTtcclxuICAgICAgICAgICAgX3RoaXMuZXYgPSBldjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gV2hlZWxFdmVudDtcclxuICAgIH0oRXZlbnRzXzkuR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLldoZWVsRXZlbnQgPSBXaGVlbEV2ZW50O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHBvaW50ZXIgZXZlbnRzIChtb3VzZSwgdG91Y2gsIHN0eWx1cywgZXRjLikgYW5kIG5vcm1hbGl6ZXMgdG9cclxuICAgICAqIFtXM0MgUG9pbnRlciBFdmVudHNdKGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvKS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6UG9pbnRlcnMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgUG9pbnRlcnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb2ludGVycywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQb2ludGVycyhlbmdpbmUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuX3BvaW50ZXJEb3duID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9wb2ludGVyVXAgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX3BvaW50ZXJNb3ZlID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9wb2ludGVyQ2FuY2VsID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl93aGVlbCA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fcG9pbnRlcnMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIF90aGlzLl9wb2ludGVycy5wdXNoKG5ldyBQb2ludGVyKCkpO1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnMgPSBbLTFdO1xyXG4gICAgICAgICAgICBfdGhpcy5wcmltYXJ5ID0gX3RoaXMuX3BvaW50ZXJzWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBwb2ludGVyIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5fZW5naW5lLmNhbnZhcztcclxuICAgICAgICAgICAgLy8gVG91Y2ggRXZlbnRzXHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5faGFuZGxlVG91Y2hFdmVudCgnZG93bicsIHRoaXMuX3BvaW50ZXJEb3duKSk7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoJ3VwJywgdGhpcy5fcG9pbnRlclVwKSk7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KCdtb3ZlJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5faGFuZGxlVG91Y2hFdmVudCgnY2FuY2VsJywgdGhpcy5fcG9pbnRlckNhbmNlbCkpO1xyXG4gICAgICAgICAgICAvLyBXM0MgUG9pbnRlciBFdmVudHNcclxuICAgICAgICAgICAgLy8gQ3VycmVudDogSUUxMSwgSUUxMFxyXG4gICAgICAgICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSUUxMVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnZG93bicsIHRoaXMuX3BvaW50ZXJEb3duKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCd1cCcsIHRoaXMuX3BvaW50ZXJVcCkpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdtb3ZlJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdjYW5jZWwnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSUUxMFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNhbnZhcy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlckRvd24nLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ2Rvd24nLCB0aGlzLl9wb2ludGVyRG93bikpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlclVwJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCd1cCcsIHRoaXMuX3BvaW50ZXJVcCkpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ21vdmUnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlckNhbmNlbCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnY2FuY2VsJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE1vdXNlIEV2ZW50c1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoJ2Rvd24nLCB0aGlzLl9wb2ludGVyRG93bikpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KCd1cCcsIHRoaXMuX3BvaW50ZXJVcCkpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdmUnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1ETiBNb3VzZVdoZWVsRXZlbnRcclxuICAgICAgICAgICAgaWYgKCdvbndoZWVsJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTW9kZXJuIEJyb3dzZXJzXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9oYW5kbGVXaGVlbEV2ZW50KCd3aGVlbCcsIHRoaXMuX3doZWVsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlYmtpdCBhbmQgSUVcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5faGFuZGxlV2hlZWxFdmVudCgnd2hlZWwnLCB0aGlzLl93aGVlbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtYWluaW5nIGJyb3dzZXIgYW5kIG9sZGVyIEZpcmVmb3hcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgdGhpcy5faGFuZGxlV2hlZWxFdmVudCgnd2hlZWwnLCB0aGlzLl93aGVlbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludGVyVXAubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRlckRvd24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRlck1vdmUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRlckNhbmNlbC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl93aGVlbC5sZW5ndGggPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2FmZWx5IGdldHMgYSBQb2ludGVyIGF0IGEgc3BlY2lmaWMgaW5kZXggYW5kIGluaXRpYWxpemVzIG9uZSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgVGhlIHBvaW50ZXIgaW5kZXggdG8gcmV0cmlldmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX3BvaW50ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGEgcG9pbnRlciB0byByZXRyaWV2ZVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3BvaW50ZXJzLmxlbmd0aCAtIDEsIG1heCA9IGluZGV4OyBpIDwgbWF4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVycy5wdXNoKG5ldyBQb2ludGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBvaW50ZXJzLnB1c2goLTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVyc1tpbmRleF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgbnVtYmVyIG9mIHBvaW50ZXJzIGJlaW5nIHdhdGNoZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVycy5sZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wb2dhdGVzIGV2ZW50cyB0byBhY3RvciBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUucHJvcG9nYXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1VJQWN0b3IgPSBhY3RvciBpbnN0YW5jZW9mIFVJQWN0b3JfMS5VSUFjdG9yO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3BvaW50ZXJVcC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnModGhpcy5fcG9pbnRlclVwW2ldLngsIHRoaXMuX3BvaW50ZXJVcFtpXS55LCAhaXNVSUFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVydXAnLCB0aGlzLl9wb2ludGVyVXBbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICBsZW4gPSB0aGlzLl9wb2ludGVyRG93bi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnModGhpcy5fcG9pbnRlckRvd25baV0ueCwgdGhpcy5fcG9pbnRlckRvd25baV0ueSwgIWlzVUlBY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIuZW1pdCgncG9pbnRlcmRvd24nLCB0aGlzLl9wb2ludGVyRG93bltpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFjdG9yLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVNb3ZlRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuX3BvaW50ZXJNb3ZlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKHRoaXMuX3BvaW50ZXJNb3ZlW2ldLngsIHRoaXMuX3BvaW50ZXJNb3ZlW2ldLnksICFpc1VJQWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVybW92ZScsIHRoaXMuX3BvaW50ZXJNb3ZlW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIGxlbiA9IHRoaXMuX3BvaW50ZXJDYW5jZWwubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKHRoaXMuX3BvaW50ZXJDYW5jZWxbaV0ueCwgdGhpcy5fcG9pbnRlckNhbmNlbFtpXS55LCAhaXNVSUFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVyY2FuY2VsJywgdGhpcy5fcG9pbnRlckNhbmNlbFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIGxlbiA9IHRoaXMuX3doZWVsLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb250YWlucyh0aGlzLl93aGVlbFtpXS54LCB0aGlzLl93aGVlbFtpXS55LCAhaXNVSUFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVyd2hlZWwnLCB0aGlzLl93aGVlbFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5faGFuZGxlTW91c2VFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBlLnBhZ2VYIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gZS5wYWdlWSAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludCA9IF90aGlzLl9lbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzIwLlZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGUgPSBuZXcgUG9pbnRlckV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBlLnBhZ2VYLCBlLnBhZ2VZLCB4LCB5LCAwLCBQb2ludGVyVHlwZS5Nb3VzZSwgZS5idXR0b24sIGUpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaChwZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hdCgwKS5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIHBlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5faGFuZGxlVG91Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSA/IF90aGlzLl9nZXRQb2ludGVySW5kZXgoZS5jaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VYIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGUuY2hhbmdlZFRvdWNoZXNbaV0ucGFnZVkgLSBVdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS55O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50ID0gX3RoaXMuX2VuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMjAuVmVjdG9yKHgsIHkpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGUgPSBuZXcgUG9pbnRlckV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VYLCBlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VZLCB4LCB5LCBpbmRleCwgUG9pbnRlclR5cGUuVG91Y2gsIFBvaW50ZXJCdXR0b24uVW5rbm93biwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaChwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgd2l0aCBtdWx0aS1wb2ludGVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9wb2ludGVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICd1cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwb2ludGVyIElEIGZyb20gcG9vbCB3aGVuIHBvaW50ZXIgaXMgbGlmdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnROYW1lID09PSAnZG93bicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIElEIHRvIGdpdmVuIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gZS5jaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9oYW5kbGVQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFycikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggZm9yIHRoaXMgcG9pbnRlciBJRCBpZiBtdWx0aS1wb2ludGVyIGlzIGFza2VkIGZvclxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEgPyBfdGhpcy5fZ2V0UG9pbnRlckluZGV4KGUucG9pbnRlcklkKSA6IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBlLnBhZ2VYIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gZS5wYWdlWSAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludCA9IF90aGlzLl9lbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzIwLlZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGUgPSBuZXcgUG9pbnRlckV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBlLnBhZ2VYLCBlLnBhZ2VZLCB4LCB5LCBpbmRleCwgX3RoaXMuX3N0cmluZ1RvUG9pbnRlclR5cGUoZS5wb2ludGVyVHlwZSksIGUuYnV0dG9uLCBlKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgcGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSB3aXRoIG11bHRpLXBvaW50ZXJcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICd1cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXIgSUQgZnJvbSBwb29sIHdoZW4gcG9pbnRlciBpcyBsaWZ0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUgPT09ICdkb3duJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBJRCB0byBnaXZlbiBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gZS5wb2ludGVySWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9oYW5kbGVXaGVlbEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcnIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgd2UgcHJldmVudCBwYWdlIHNjcm9sbCBiZWNhdXNlIG9mIHRoaXMgZXZlbnRcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZW5naW5lLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9PT0gRW5naW5lXzEuU2Nyb2xsUHJldmVudGlvbk1vZGUuQWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKF90aGlzLl9lbmdpbmUucGFnZVNjcm9sbFByZXZlbnRpb25Nb2RlID09PSBFbmdpbmVfMS5TY3JvbGxQcmV2ZW50aW9uTW9kZS5DYW52YXMgJiYgZS50YXJnZXQgPT09IF90aGlzLl9lbmdpbmUuY2FudmFzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB4ID0gZS5wYWdlWCAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUucGFnZVkgLSBVdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnQgPSBfdGhpcy5fZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgQWxnZWJyYV8yMC5WZWN0b3IoeCwgeSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsdGFYLCBkZWx0YVksIGFuZCBkZWx0YVogYXJlIHRoZSBzdGFuZGFyZCBtb2Rlcm4gcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlZWxEZWx0YVgsIHdoZWVsRGVsdGFZLCBhcmUgbGVnYWN5IHByb3BlcnRpZXMgaW4gd2Via2l0IGJyb3dzZXJzIGFuZCBvbGRlciBJRVxyXG4gICAgICAgICAgICAgICAgLy8gZS5kZXRhaWwgaXMgb25seSB1c2VkIGluIG9wZXJhXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gZS5kZWx0YVggfHxcclxuICAgICAgICAgICAgICAgICAgICAoZS53aGVlbERlbHRhWCAqIFNjcm9sbFdoZWVsTm9ybWFsaXphdGlvbkZhY3RvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhWSA9IGUuZGVsdGFZIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGUud2hlZWxEZWx0YVkgKiBTY3JvbGxXaGVlbE5vcm1hbGl6YXRpb25GYWN0b3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGUud2hlZWxEZWx0YSAqIFNjcm9sbFdoZWVsTm9ybWFsaXphdGlvbkZhY3RvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICBlLmRldGFpbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFaID0gZS5kZWx0YVogfHwgMDtcclxuICAgICAgICAgICAgICAgIHZhciBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5QaXhlbDtcclxuICAgICAgICAgICAgICAgIGlmIChlLmRlbHRhTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5MaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlLmRlbHRhTW9kZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5QYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB3ZSA9IG5ldyBXaGVlbEV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBlLnBhZ2VYLCBlLnBhZ2VZLCB4LCB5LCAwLCBkZWx0YVgsIGRlbHRhWSwgZGVsdGFaLCBkZWx0YU1vZGUsIGUpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaCh3ZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hdCgwKS5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIHdlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBwb2ludGVyIHNwZWNpZmllZCBmb3IgdGhlIGdpdmVuIHBvaW50ZXIgSUQgb3IgZmluZHMgdGhlIG5leHQgZW1wdHkgcG9pbnRlciBzbG90IGF2YWlsYWJsZS5cclxuICAgICAgICAgKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgSUUxMC8xMSB1c2VzIGluY3JlbWVudGluZyBwb2ludGVyIElEcyBzbyB3ZSBuZWVkIHRvIHN0b3JlIGEgbWFwcGluZyBvZiBJRCA9PiBpZHhcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2dldFBvaW50ZXJJbmRleCA9IGZ1bmN0aW9uIChwb2ludGVySWQpIHtcclxuICAgICAgICAgICAgdmFyIGlkeDtcclxuICAgICAgICAgICAgaWYgKChpZHggPSB0aGlzLl9hY3RpdmVQb2ludGVycy5pbmRleE9mKHBvaW50ZXJJZCkpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hY3RpdmVQb2ludGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVBvaW50ZXJzW2ldID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSBwb2ludGVyIGJlY2F1c2UgZ2FtZSBpc24ndCB3YXRjaGluZ1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX3N0cmluZ1RvUG9pbnRlclR5cGUgPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvdWNoJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuVG91Y2g7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtb3VzZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJUeXBlLk1vdXNlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncGVuJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuUGVuO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuVW5rbm93bjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBvaW50ZXJzO1xyXG4gICAgfShDbGFzc182LkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLlBvaW50ZXJzID0gUG9pbnRlcnM7XHJcbiAgICAvKipcclxuICAgICAqIENhcHR1cmVzIGFuZCBkaXNwYXRjaGVzIFBvaW50ZXJFdmVudHNcclxuICAgICAqL1xyXG4gICAgdmFyIFBvaW50ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb2ludGVyLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvaW50ZXIoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiBvbiB0aGUgZG9jdW1lbnQgdGhpcyBwb2ludGVyIHdhcyBhdC4gQ2FuIGJlIGBudWxsYCBpZiBwb2ludGVyIHdhcyBuZXZlciBhY3RpdmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5sYXN0UGFnZVBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuIHRoaXMgcG9pbnRlciB3YXMgYXQuIENhbiBiZSBgbnVsbGAgaWYgcG9pbnRlciB3YXMgbmV2ZXIgYWN0aXZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubGFzdFNjcmVlblBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB3b3JsZCBjb29yZGluYXRlcyB0aGlzIHBvaW50ZXIgd2FzIGF0LiBDYW4gYmUgYG51bGxgIGlmIHBvaW50ZXIgd2FzIG5ldmVyIGFjdGl2ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmxhc3RXb3JsZFBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLm9uKCdtb3ZlJywgX3RoaXMuX29uUG9pbnRlck1vdmUpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBvaW50ZXIucHJvdG90eXBlLl9vblBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFdvcmxkUG9zID0gbmV3IEFsZ2VicmFfMjAuVmVjdG9yKGV2LngsIGV2LnkpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RQYWdlUG9zID0gbmV3IEFsZ2VicmFfMjAuVmVjdG9yKGV2LnBhZ2VYLCBldi5wYWdlWSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFNjcmVlblBvcyA9IG5ldyBBbGdlYnJhXzIwLlZlY3Rvcihldi5zY3JlZW5YLCBldi5zY3JlZW5ZKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQb2ludGVyO1xyXG4gICAgfShDbGFzc182LkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLlBvaW50ZXIgPSBQb2ludGVyO1xyXG59KTtcclxuZGVmaW5lKFwiSW5wdXQvS2V5Ym9hcmRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDbGFzc1wiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENsYXNzXzcsIEV2ZW50c18xMCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIGlucHV0IGtleSBjb2Rlc1xyXG4gICAgICovXHJcbiAgICB2YXIgS2V5cztcclxuICAgIChmdW5jdGlvbiAoS2V5cykge1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTFcIl0gPSA5N10gPSBcIk51bTFcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW0yXCJdID0gOThdID0gXCJOdW0yXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtM1wiXSA9IDk5XSA9IFwiTnVtM1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTRcIl0gPSAxMDBdID0gXCJOdW00XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtNVwiXSA9IDEwMV0gPSBcIk51bTVcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW02XCJdID0gMTAyXSA9IFwiTnVtNlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTdcIl0gPSAxMDNdID0gXCJOdW03XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtOFwiXSA9IDEwNF0gPSBcIk51bThcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW05XCJdID0gMTA1XSA9IFwiTnVtOVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTBcIl0gPSA5Nl0gPSBcIk51bTBcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW1sb2NrXCJdID0gMTQ0XSA9IFwiTnVtbG9ja1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlNlbWljb2xvblwiXSA9IDE4Nl0gPSBcIlNlbWljb2xvblwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkFcIl0gPSA2NV0gPSBcIkFcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJCXCJdID0gNjZdID0gXCJCXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiQ1wiXSA9IDY3XSA9IFwiQ1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkRcIl0gPSA2OF0gPSBcIkRcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJFXCJdID0gNjldID0gXCJFXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiRlwiXSA9IDcwXSA9IFwiRlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkdcIl0gPSA3MV0gPSBcIkdcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJIXCJdID0gNzJdID0gXCJIXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiSVwiXSA9IDczXSA9IFwiSVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkpcIl0gPSA3NF0gPSBcIkpcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJLXCJdID0gNzVdID0gXCJLXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTFwiXSA9IDc2XSA9IFwiTFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk1cIl0gPSA3N10gPSBcIk1cIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOXCJdID0gNzhdID0gXCJOXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiT1wiXSA9IDc5XSA9IFwiT1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlBcIl0gPSA4MF0gPSBcIlBcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJRXCJdID0gODFdID0gXCJRXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiUlwiXSA9IDgyXSA9IFwiUlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlNcIl0gPSA4M10gPSBcIlNcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJUXCJdID0gODRdID0gXCJUXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiVVwiXSA9IDg1XSA9IFwiVVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlZcIl0gPSA4Nl0gPSBcIlZcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJXXCJdID0gODddID0gXCJXXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiWFwiXSA9IDg4XSA9IFwiWFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIllcIl0gPSA4OV0gPSBcIllcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJaXCJdID0gOTBdID0gXCJaXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiU2hpZnRcIl0gPSAxNl0gPSBcIlNoaWZ0XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiQWx0XCJdID0gMThdID0gXCJBbHRcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJVcFwiXSA9IDM4XSA9IFwiVXBcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJEb3duXCJdID0gNDBdID0gXCJEb3duXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTGVmdFwiXSA9IDM3XSA9IFwiTGVmdFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlJpZ2h0XCJdID0gMzldID0gXCJSaWdodFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlNwYWNlXCJdID0gMzJdID0gXCJTcGFjZVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkVzY1wiXSA9IDI3XSA9IFwiRXNjXCI7XHJcbiAgICB9KShLZXlzID0gZXhwb3J0cy5LZXlzIHx8IChleHBvcnRzLktleXMgPSB7fSkpO1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYSBnYW1lIG9iamVjdCBmb3IgYSBrZXkgZXZlbnRcclxuICAgICAqL1xyXG4gICAgdmFyIEtleUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoS2V5RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGtleSAgVGhlIGtleSByZXNwb25zaWJsZSBmb3IgdGhyb3dpbmcgdGhlIGV2ZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gS2V5RXZlbnQoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmtleSA9IGtleTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gS2V5RXZlbnQ7XHJcbiAgICB9KEV2ZW50c18xMC5HYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuS2V5RXZlbnQgPSBLZXlFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMga2V5Ym9hcmQgc3VwcG9ydCBmb3IgRXhjYWxpYnVyLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpLZXlib2FyZC5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBLZXlib2FyZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEtleWJvYXJkLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEtleWJvYXJkKGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5fa2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fa2V5c1VwID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9rZXlzRG93biA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplIEtleWJvYXJkIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGdsb2JhbCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBnbG9iYWwgPSBnbG9iYWwgfHwgd2luZG93O1xyXG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzLmxlbmd0aCA9IDA7IC8vIGVtcHRpZXMgYXJyYXkgZWZmaWNpZW50bHlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGtleSB1cCBpcyBvbiB3aW5kb3cgYmVjYXVzZSBjYW52YXMgY2Fubm90IGhhdmUgZm9jdXNcclxuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IF90aGlzLl9ub3JtYWxpemVLZXlDb2RlKGV2LmtleUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF90aGlzLl9rZXlzLmluZGV4T2YoY29kZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5zcGxpY2Uoa2V5LCAxKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzVXAucHVzaChjb2RlKTtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlFdmVudCA9IG5ldyBLZXlFdmVudChjb2RlKTtcclxuICAgICAgICAgICAgICAgIC8vIGFsaWFzIHRoZSBvbGQgYXBpLCB3ZSBtYXkgd2FudCB0byBkZXByZWNhdGUgdGhpcyBpbiB0aGUgZnV0dXJlXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgndXAnLCBrZXlFdmVudCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgncmVsZWFzZScsIGtleUV2ZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGtleSBkb3duIGlzIG9uIHdpbmRvdyBiZWNhdXNlIGNhbnZhcyBjYW5ub3QgaGF2ZSBmb2N1c1xyXG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBfdGhpcy5fbm9ybWFsaXplS2V5Q29kZShldi5rZXlDb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fa2V5cy5pbmRleE9mKGNvZGUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzLnB1c2goY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleXNEb3duLnB1c2goY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUV2ZW50ID0gbmV3IEtleUV2ZW50KGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdkb3duJywga2V5RXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwcmVzcycsIGtleUV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBrZXlzRG93biBhbmQga2V5c1VwIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZVxyXG4gICAgICAgICAgICB0aGlzLl9rZXlzRG93bi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9rZXlzVXAubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgLy8gRW1pdCBzeW50aGV0aWMgXCJob2xkXCIgZXZlbnRcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdob2xkJywgbmV3IEtleUV2ZW50KHRoaXMuX2tleXNbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBsaXN0IG9mIGtleXMgYmVpbmcgcHJlc3NlZCBkb3duXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBjZXJ0YWluIGtleSB3YXMganVzdCBwcmVzc2VkIHRoaXMgZnJhbWUuIFRoaXMgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIHRoZSB1cGRhdGUgZnJhbWUuXHJcbiAgICAgICAgICogQHBhcmFtIGtleSBUZXN0IHdoZXRoZXIgYSBrZXkgd2FzIGp1c3QgcHJlc3NlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS53YXNQcmVzc2VkID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5c0Rvd24uaW5kZXhPZihrZXkpID4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGNlcnRhaW4ga2V5IGlzIGhlbGQgZG93bi4gVGhpcyBpcyBwZXJzaXN0ZWQgYmV0d2VlbiBmcmFtZXMuXHJcbiAgICAgICAgICogQHBhcmFtIGtleSAgVGVzdCB3aGV0aGVyIGEga2V5IGlzIGhlbGQgZG93blxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5pc0hlbGQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBjZXJ0YWluIGtleSB3YXMganVzdCByZWxlYXNlZCB0aGlzIGZyYW1lLiBUaGlzIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiB0aGUgdXBkYXRlIGZyYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSBrZXkgIFRlc3Qgd2hldGhlciBhIGtleSB3YXMganVzdCByZWxlYXNlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS53YXNSZWxlYXNlZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXNVcC5pbmRleE9mKGtleSkgPiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5vcm1hbGl6ZXMgc29tZSBicm93c2VyIGV2ZW50IGtleSBjb2RlcyB0byBtYXAgdG8gc3RhbmRhcmQgRXhjYWxpYnVyIGtleSBjb2Rlc1xyXG4gICAgICAgICAqIEBwYXJhbSBjb2RlIEV2ZW50IGtleUNvZGVcclxuICAgICAgICAgKiBAc2VlIGh0dHA6Ly91bml4cGFwYS5jb20vanMva2V5Lmh0bWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuX25vcm1hbGl6ZUtleUNvZGUgPSBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEtleXMuU2VtaWNvbG9uO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEtleWJvYXJkO1xyXG4gICAgfShDbGFzc183LkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLktleWJvYXJkID0gS2V5Ym9hcmQ7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnB1dC9JRW5naW5lSW5wdXRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBzdXBwb3J0IGZvciBtaWNlLCBrZXlib2FyZHMsIGFuZCBjb250cm9sbGVycy5cclxuICpcclxuICogW1tpbmNsdWRlOklucHV0Lm1kXV1cclxuICovXHJcbmRlZmluZShcIklucHV0L0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiSW5wdXQvR2FtZXBhZFwiLCBcIklucHV0L1BvaW50ZXJcIiwgXCJJbnB1dC9LZXlib2FyZFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEdhbWVwYWRfMSwgUG9pbnRlcl8xLCBLZXlib2FyZF8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlZG9jXHJcbiAgICAgKi9cclxuICAgIF9fZXhwb3J0KEdhbWVwYWRfMSk7XHJcbiAgICBfX2V4cG9ydChQb2ludGVyXzEpO1xyXG4gICAgX19leHBvcnQoS2V5Ym9hcmRfMSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVXRpbC9VdGlsXCIsIFwiVXRpbC9EcmF3VXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFV0aWxfMywgZHJhd1V0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KFV0aWxfMyk7XHJcbiAgICBleHBvcnRzLkRyYXdVdGlsID0gZHJhd1V0aWw7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0RldGVjdG9yXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVXRpbC9Mb2dcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBMb2dfMTIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBsaXN0IG9mIGZlYXR1cmVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGxvZyB0aGUgc3VwcG9ydGVkXHJcbiAgICAgKiBmZWF0dXJlcyB0byB0aGUgY29uc29sZSB3aGVuIERldGVjdG9yLmxvZ0Jyb3dzZXJGZWF0dXJlcygpIGlzIGNhbGxlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIFJFUE9SVEVEX0ZFQVRVUkVTID0ge1xyXG4gICAgICAgIHdlYmdsOiAnV2ViR0wnLFxyXG4gICAgICAgIHdlYmF1ZGlvOiAnV2ViQXVkaW8nLFxyXG4gICAgICAgIGdhbWVwYWRhcGk6ICdHYW1lcGFkIEFQSSdcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4Y2FsaWJ1ciBpbnRlcm5hbCBmZWF0dXJlIGRldGVjdGlvbiBoZWxwZXIgY2xhc3NcclxuICAgICAqL1xyXG4gICAgdmFyIERldGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEZXRlY3RvcigpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZFRlc3RzID0gW107XHJcbiAgICAgICAgICAgIC8vIGNyaXRpY2FsIGJyb3dzZXIgZmVhdHVyZXMgcmVxdWlyZWQgZm9yIGV4IHRvIHJ1blxyXG4gICAgICAgICAgICB0aGlzLl9jcml0aWNhbFRlc3RzID0ge1xyXG4gICAgICAgICAgICAgICAgLy8gVGVzdCBjYW52YXMvMmQgY29udGV4dCBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICBjYW52YXNTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISEoZWxlbS5nZXRDb250ZXh0ICYmIGVsZW0uZ2V0Q29udGV4dCgnMmQnKSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gVGVzdCBhcnJheSBidWZmZXIgc3VwcG9ydCBleCB1c2VzIGZvciBkb3dubG9hZGluZyBiaW5hcnkgZGF0YVxyXG4gICAgICAgICAgICAgICAgYXJyYXlCdWZmZXJTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCAnLycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZGF0YSB1cmxzIGV4IHVzZXMgZm9yIHNwcml0ZXNcclxuICAgICAgICAgICAgICAgIGRhdGFVcmxTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKS5pbmRleE9mKCdkYXRhOmltYWdlL3BuZycpID09PSAwO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIFRlc3Qgb2JqZWN0IHVybCBzdXBwb3J0IGZvciBsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICBvYmplY3RVcmxTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnVVJMJyBpbiB3aW5kb3cpICYmICgncmV2b2tlT2JqZWN0VVJMJyBpbiBVUkwpICYmICgnY3JlYXRlT2JqZWN0VVJMJyBpbiBVUkwpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIFJHQkEgc3VwcG9ydCBmb3IgY29sb3JzXHJcbiAgICAgICAgICAgICAgICByZ2JhU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKS5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5jc3NUZXh0ID0gJ2JhY2tncm91bmQtY29sb3I6cmdiYSgxNTAsMjU1LDE1MCwuNSknO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJycgKyBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IpLmluZGV4T2YoJ3JnYmEnKSA+IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyB3YXJuaW5ncyBleGNhbGlidXIgcGVyZm9ybWFuY2Ugd2lsbCBiZSBkZWdyYWRlZFxyXG4gICAgICAgICAgICB0aGlzLl93YXJuaW5nVGVzdCA9IHtcclxuICAgICAgICAgICAgICAgIHdlYkF1ZGlvU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhISh3aW5kb3cuQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1vekF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubXNBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9BdWRpb0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHdlYmdsU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhKGVsZW0uZ2V0Q29udGV4dCAmJiBlbGVtLmdldENvbnRleHQoJ3dlYmdsJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlcyA9IHRoaXMuX2xvYWRCcm93c2VyRmVhdHVyZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIG1hcCBvZiBjdXJyZW50bHkgc3VwcG9ydGVkIGJyb3dzZXIgZmVhdHVyZXMuIFRoaXMgbWV0aG9kXHJcbiAgICAgICAgICogdHJlYXRzIHRoZSBmZWF0dXJlcyBhcyBhIHNpbmdsZXRvbiBhbmQgd2lsbCBvbmx5IGNhbGN1bGF0ZSBmZWF0dXJlXHJcbiAgICAgICAgICogc3VwcG9ydCBpZiBpdCBoYXMgbm90IHByZXZpb3VzbHkgYmVlbiBkb25lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERldGVjdG9yLnByb3RvdHlwZS5nZXRCcm93c2VyRmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9mZWF0dXJlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSB0aGlzLl9sb2FkQnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVwb3J0IG9uIG5vbi1jcml0aWNhbCBicm93c2VyIHN1cHBvcnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuICAgICAgICAgKiBVc2UgbmF0aXZlIGJyb3dzZXIgY29uc29sZSBjb2xvcnMgZm9yIHZpc2liaWxpdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGV0ZWN0b3IucHJvdG90eXBlLmxvZ0Jyb3dzZXJGZWF0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG1zZyA9ICclY1NVUFBPUlRFRCBCUk9XU0VSIEZFQVRVUkVTXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT0lY1xcbic7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW1xyXG4gICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0OiBib2xkOyBjb2xvcjogbmF2eScsXHJcbiAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQ6IG5vcm1hbDsgY29sb3I6IGluaGVyaXQnXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHZhciBzdXBwb3J0ZWQgPSB0aGlzLmdldEJyb3dzZXJGZWF0dXJlcygpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMoUkVQT1JURURfRkVBVFVSRVMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydGVkW2ZlYXR1cmVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9ICcoJWNcXHUyNzEzJWMpJzsgLy8gKOKckylcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2ZvbnQtd2VpZ2h0OiBib2xkOyBjb2xvcjogZ3JlZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2ZvbnQtd2VpZ2h0OiBub3JtYWw7IGNvbG9yOiBpbmhlcml0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJyglY1xcdTI3MTclYyknOyAvLyAo4pyXKVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiByZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2ZvbnQtd2VpZ2h0OiBub3JtYWw7IGNvbG9yOiBpbmhlcml0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gJyAnICsgUkVQT1JURURfRkVBVFVSRVNbZmVhdHVyZV0gKyAnXFxuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQobXNnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFeGVjdXRlcyBzZXZlcmFsIElJRkUncyB0byBnZXQgYSBjb25zdGFudCByZWZlcmVuY2UgdG8gc3VwcG9ydGVkXHJcbiAgICAgICAgICogZmVhdHVyZXMgd2l0aGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERldGVjdG9yLnByb3RvdHlwZS5fbG9hZEJyb3dzZXJGZWF0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgY2FudmFzIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIGNhbnZhczogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NyaXRpY2FsVGVzdHMuY2FudmFzU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgYXJyYXlidWZmZXIgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgYXJyYXlidWZmZXI6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcml0aWNhbFRlc3RzLmFycmF5QnVmZmVyU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgZGF0YXVybCBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICBkYXRhdXJsOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY3JpdGljYWxUZXN0cy5kYXRhVXJsU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgb2JqZWN0dXJsIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIG9iamVjdHVybDogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NyaXRpY2FsVGVzdHMub2JqZWN0VXJsU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgcmdiYSBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICByZ2JhOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY3JpdGljYWxUZXN0cy5yZ2JhU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgd2ViYXVkaW8gc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgd2ViYXVkaW86IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl93YXJuaW5nVGVzdC53ZWJBdWRpb1N1cHBvcnQoKTtcclxuICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIHdlYmdsIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIHdlYmdsOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fd2FybmluZ1Rlc3Qud2ViZ2xTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayBnYW1lcGFkYXBpIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIGdhbWVwYWRhcGk6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhbmF2aWdhdG9yLmdldEdhbWVwYWRzO1xyXG4gICAgICAgICAgICAgICAgfSkoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGV0ZWN0b3IucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIENyaXRpY2FsIHRlc3Qgd2lsbCBmb3IgZXggbm90IHRvIHJ1blxyXG4gICAgICAgICAgICB2YXIgZmFpbGVkQ3JpdGljYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgdGVzdCBpbiB0aGlzLl9jcml0aWNhbFRlc3RzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NyaXRpY2FsVGVzdHNbdGVzdF0uY2FsbCh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbGVkVGVzdHMucHVzaCh0ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfMTIuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0NyaXRpY2FsIGJyb3dzZXIgZmVhdHVyZSBtaXNzaW5nLCBFeGNhbGlidXIgcmVxdWlyZXM6JywgdGVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkQ3JpdGljYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmYWlsZWRDcml0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdhcm5pbmcgdGVzdHMgZG8gbm90IGZvciBleCB0byByZXR1cm4gZmFsc2UgdG8gY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICBmb3IgKHZhciB3YXJuaW5nIGluIHRoaXMuX3dhcm5pbmdUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dhcm5pbmdUZXN0W3dhcm5pbmddKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfMTIuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignV2FybmluZyBicm93c2VyIGZlYXR1cmUgbWlzc2luZywgRXhjYWxpYnVyIHdpbGwgaGF2ZSByZWR1Y2VkIHBlcmZvcm1hbmNlOicsIHdhcm5pbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERldGVjdG9yO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRGV0ZWN0b3IgPSBEZXRlY3RvcjtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvU29ydGVkTGlzdFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNvcnRlZCBsaXN0IGltcGxlbWVudGF0aW9uLiBOT1RFOiB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCBzZWxmLWJhbGFuY2luZ1xyXG4gICAgICovXHJcbiAgICB2YXIgU29ydGVkTGlzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gU29ydGVkTGlzdChnZXRDb21wYXJhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dldENvbXBhcmFibGUgPSBnZXRDb21wYXJhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmQodGhpcy5fcm9vdCwgZWxlbWVudCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5fZmluZCA9IGZ1bmN0aW9uIChub2RlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCkgPT09IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldERhdGEoKS5pbmRleE9mKGVsZW1lbnQpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCkgPCBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZChub2RlLmdldExlZnQoKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZChub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyByZXR1cm5zIHRoZSBhcnJheSBvZiBlbGVtZW50cyBhdCBhIHNwZWNpZmljIGtleSB2YWx1ZVxyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldCh0aGlzLl9yb290LCBrZXkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uIChub2RlLCBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQobm9kZS5nZXRMZWZ0KCksIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KG5vZGUuZ2V0UmlnaHQoKSwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvb3QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IG5ldyBCaW5hcnlUcmVlTm9kZSh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCksIFtlbGVtZW50XSwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnQodGhpcy5fcm9vdCwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLl9pbnNlcnQgPSBmdW5jdGlvbiAobm9kZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpID09PSBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0RGF0YSgpLmluZGV4T2YoZWxlbWVudCkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHRoZSBlbGVtZW50IHdlJ3JlIHRyeWluZyB0byBpbnNlcnQgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZ2V0RGF0YSgpLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldExlZnQobmV3IEJpbmFyeVRyZWVOb2RlKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSwgW2VsZW1lbnRdLCBudWxsLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChub2RlLmdldExlZnQoKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQobmV3IEJpbmFyeVRyZWVOb2RlKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSwgW2VsZW1lbnRdLCBudWxsLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5yZW1vdmVCeUNvbXBhcmFibGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5fcmVtb3ZlKHRoaXMuX3Jvb3QsIGVsZW1lbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChub2RlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRJbmRleCA9IG5vZGUuZ2V0RGF0YSgpLmluZGV4T2YoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBjb250YWlucyB0aGUgZWxlbWVudCwgcmVtb3ZlIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmdldERhdGEoKS5zcGxpY2UoZWxlbWVudEluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlbW92ZWQgdGhlIGxhc3QgZWxlbWVudCBhdCB0aGlzIG5vZGUsIHJlbW92ZSB0aGUgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdldERhdGEoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgYSBsZWFmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdldExlZnQoKSA9PSBudWxsICYmIG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmdldExlZnQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRSaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRMZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm9kZSBoYXMgMiBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMuX2ZpbmRNaW5Ob2RlKG5vZGUuZ2V0UmlnaHQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0S2V5KHRlbXAuZ2V0S2V5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldERhdGEodGVtcC5nZXREYXRhKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldFJpZ2h0KHRoaXMuX2NsZWFudXAobm9kZS5nZXRSaWdodCgpLCB0ZW1wKSk7IC8vXCJjbGVhbnVwIG5vZGVzXCIgKG1vdmUgdGhlbSB1cCByZWN1cnNpdmVseSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHByZXZlbnRzIHRoZSBub2RlIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSBpdCBzdGlsbCBjb250YWlucyBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpIDwgbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRMZWZ0KHRoaXMuX3JlbW92ZShub2RlLmdldExlZnQoKSwgZWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldFJpZ2h0KHRoaXMuX3JlbW92ZShub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gY2FsbGVkIG9uY2Ugd2UgaGF2ZSBzdWNjZXNzZnVsbHkgcmVtb3ZlZCB0aGUgZWxlbWVudCB3ZSB3YW50ZWQsIHJlY3Vyc2l2ZWx5IGNvcnJlY3RzIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIGJlbG93IHRoZSByZW1vdmVkIG5vZGVcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uIChub2RlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wYXJhYmxlID0gZWxlbWVudC5nZXRLZXkoKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyYWJsZSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgYSBsZWFmXHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCAmJiBub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldFJpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldExlZnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIDIgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5fZmluZE1pbk5vZGUobm9kZS5nZXRSaWdodCgpKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0S2V5KHRlbXAuZ2V0S2V5KCkpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXREYXRhKHRlbXAuZ2V0RGF0YSgpKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQodGhpcy5fY2xlYW51cChub2RlLmdldFJpZ2h0KCksIHRlbXApKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0TGVmdCh0aGlzLl9jbGVhbnVwKG5vZGUuZ2V0TGVmdCgpLCBlbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQodGhpcy5fY2xlYW51cChub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5fZmluZE1pbk5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50LmdldExlZnQoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5nZXRMZWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0KHRoaXMuX3Jvb3QsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLl9saXN0ID0gZnVuY3Rpb24gKHRyZWVOb2RlLCByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmVlTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0KHRyZWVOb2RlLmdldExlZnQoKSwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICB0cmVlTm9kZS5nZXREYXRhKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdCh0cmVlTm9kZS5nZXRSaWdodCgpLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNvcnRlZExpc3Q7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Tb3J0ZWRMaXN0ID0gU29ydGVkTGlzdDtcclxuICAgIC8qKlxyXG4gICAgICogQSB0cmVlIG5vZGUgcGFydCBvZiBbW1NvcnRlZExpc3RdXVxyXG4gICAgICovXHJcbiAgICB2YXIgQmluYXJ5VHJlZU5vZGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEJpbmFyeVRyZWVOb2RlKGtleSwgZGF0YSwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLnNldExlZnQgPSBmdW5jdGlvbiAobGVmdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLnNldFJpZ2h0ID0gZnVuY3Rpb24gKHJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQmluYXJ5VHJlZU5vZGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5CaW5hcnlUcmVlTm9kZSA9IEJpbmFyeVRyZWVOb2RlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb2NrIGVsZW1lbnQgZm9yIHRlc3RpbmdcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdmFyIE1vY2tlZEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE1vY2tlZEVsZW1lbnQoa2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTW9ja2VkRWxlbWVudC5wcm90b3R5cGUuZ2V0VGhlS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTW9ja2VkRWxlbWVudC5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTW9ja2VkRWxlbWVudDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLk1vY2tlZEVsZW1lbnQgPSBNb2NrZWRFbGVtZW50O1xyXG59KTtcclxuZGVmaW5lKFwiSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBY3RvclwiLCBcIkFsZ2VicmFcIiwgXCJDYW1lcmFcIiwgXCJDbGFzc1wiLCBcIkRlYnVnXCIsIFwiRW5naW5lXCIsIFwiRXZlbnREaXNwYXRjaGVyXCIsIFwiRXZlbnRzXCIsIFwiR3JvdXBcIiwgXCJMYWJlbFwiLCBcIkxvYWRlclwiLCBcIlBhcnRpY2xlc1wiLCBcIlBoeXNpY3NcIiwgXCJQcm9taXNlc1wiLCBcIlNjZW5lXCIsIFwiVGlsZU1hcFwiLCBcIlRpbWVyXCIsIFwiVHJpZ2dlclwiLCBcIlVJQWN0b3JcIiwgXCJBY3Rpb25zL0luZGV4XCIsIFwiQ29sbGlzaW9uL0luZGV4XCIsIFwiRHJhd2luZy9JbmRleFwiLCBcIk1hdGgvSW5kZXhcIiwgXCJQb3N0UHJvY2Vzc2luZy9JbmRleFwiLCBcIlJlc291cmNlcy9JbmRleFwiLCBcIkV2ZW50c1wiLCBcIklucHV0L0luZGV4XCIsIFwiVHJhaXRzL0luZGV4XCIsIFwiVXRpbC9JbmRleFwiLCBcIlV0aWwvRGVjb3JhdG9yc1wiLCBcIlV0aWwvRGV0ZWN0b3JcIiwgXCJVdGlsL0N1bGxpbmdCb3hcIiwgXCJVdGlsL0Vhc2luZ0Z1bmN0aW9uc1wiLCBcIlV0aWwvTG9nXCIsIFwiVXRpbC9Tb3J0ZWRMaXN0XCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWN0b3JfMTEsIEFsZ2VicmFfMjEsIENhbWVyYV8xLCBDbGFzc184LCBEZWJ1Z18xLCBFbmdpbmVfMiwgRXZlbnREaXNwYXRjaGVyXzIsIEV2ZW50c18xMSwgR3JvdXBfMSwgTGFiZWxfMiwgTG9hZGVyXzEsIFBhcnRpY2xlc18xLCBQaHlzaWNzXzExLCBQcm9taXNlc183LCBTY2VuZV8xLCBUaWxlTWFwXzEsIFRpbWVyXzEsIFRyaWdnZXJfMSwgVUlBY3Rvcl8yLCBJbmRleF8xLCBJbmRleF8yLCBJbmRleF8zLCBJbmRleF80LCBJbmRleF81LCBJbmRleF82LCBldmVudHMsIGlucHV0LCB0cmFpdHMsIHV0aWwsIERlY29yYXRvcnNfMiwgRGV0ZWN0b3JfMSwgQ3VsbGluZ0JveF8yLCBFYXNpbmdGdW5jdGlvbnNfMywgTG9nXzEzLCBTb3J0ZWRMaXN0XzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgRXhjYWxpYnVyIHZlcnNpb24gc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydHMuRVhfVkVSU0lPTiA9ICcwLjE0LjAnO1xyXG4gICAgLy8gVGhpcyBmaWxlIGlzIHVzZWQgYXMgdGhlIGJ1bmRsZSBlbnRyeXBvaW50IGFuZCBleHBvcnRzIGV2ZXJ5dGhpbmdcclxuICAgIC8vIHRoYXQgd2lsbCBiZSBleHBvc2VkIGFzIHRoZSBgZXhgIGdsb2JhbCB2YXJpYWJsZS5cclxuICAgIF9fZXhwb3J0KEFjdG9yXzExKTtcclxuICAgIF9fZXhwb3J0KEFsZ2VicmFfMjEpO1xyXG4gICAgX19leHBvcnQoQ2FtZXJhXzEpO1xyXG4gICAgX19leHBvcnQoQ2xhc3NfOCk7XHJcbiAgICBfX2V4cG9ydChEZWJ1Z18xKTtcclxuICAgIF9fZXhwb3J0KEVuZ2luZV8yKTtcclxuICAgIF9fZXhwb3J0KEV2ZW50RGlzcGF0Y2hlcl8yKTtcclxuICAgIF9fZXhwb3J0KEV2ZW50c18xMSk7XHJcbiAgICBfX2V4cG9ydChHcm91cF8xKTtcclxuICAgIF9fZXhwb3J0KExhYmVsXzIpO1xyXG4gICAgX19leHBvcnQoTG9hZGVyXzEpO1xyXG4gICAgX19leHBvcnQoUGFydGljbGVzXzEpO1xyXG4gICAgX19leHBvcnQoUGh5c2ljc18xMSk7XHJcbiAgICBfX2V4cG9ydChQcm9taXNlc183KTtcclxuICAgIF9fZXhwb3J0KFNjZW5lXzEpO1xyXG4gICAgX19leHBvcnQoVGlsZU1hcF8xKTtcclxuICAgIF9fZXhwb3J0KFRpbWVyXzEpO1xyXG4gICAgX19leHBvcnQoVHJpZ2dlcl8xKTtcclxuICAgIF9fZXhwb3J0KFVJQWN0b3JfMik7XHJcbiAgICBfX2V4cG9ydChJbmRleF8xKTtcclxuICAgIF9fZXhwb3J0KEluZGV4XzIpO1xyXG4gICAgX19leHBvcnQoSW5kZXhfMyk7XHJcbiAgICBfX2V4cG9ydChJbmRleF80KTtcclxuICAgIF9fZXhwb3J0KEluZGV4XzUpO1xyXG4gICAgX19leHBvcnQoSW5kZXhfNik7XHJcbiAgICBleHBvcnRzLkV2ZW50cyA9IGV2ZW50cztcclxuICAgIGV4cG9ydHMuSW5wdXQgPSBpbnB1dDtcclxuICAgIGV4cG9ydHMuVHJhaXRzID0gdHJhaXRzO1xyXG4gICAgZXhwb3J0cy5VdGlsID0gdXRpbDtcclxuICAgIF9fZXhwb3J0KERlY29yYXRvcnNfMik7XHJcbiAgICBfX2V4cG9ydChEZXRlY3Rvcl8xKTtcclxuICAgIF9fZXhwb3J0KEN1bGxpbmdCb3hfMik7XHJcbiAgICBfX2V4cG9ydChFYXNpbmdGdW5jdGlvbnNfMyk7XHJcbiAgICBfX2V4cG9ydChMb2dfMTMpO1xyXG4gICAgX19leHBvcnQoU29ydGVkTGlzdF8xKTtcclxufSk7XHJcbmRlZmluZShcIkVuZ2luZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkluZGV4XCIsIFwiUHJvbWlzZXNcIiwgXCJBbGdlYnJhXCIsIFwiVUlBY3RvclwiLCBcIkFjdG9yXCIsIFwiVGltZXJcIiwgXCJUaWxlTWFwXCIsIFwiTG9hZGVyXCIsIFwiVXRpbC9EZXRlY3RvclwiLCBcIkV2ZW50c1wiLCBcIlV0aWwvTG9nXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIlNjZW5lXCIsIFwiRGVidWdcIiwgXCJDbGFzc1wiLCBcIklucHV0L0luZGV4XCIsIFwiVXRpbC9VdGlsXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgSW5kZXhfNywgUHJvbWlzZXNfOCwgQWxnZWJyYV8yMiwgVUlBY3Rvcl8zLCBBY3Rvcl8xMiwgVGltZXJfMiwgVGlsZU1hcF8yLCBMb2FkZXJfMiwgRGV0ZWN0b3JfMiwgRXZlbnRzXzEyLCBMb2dfMTQsIENvbG9yXzE5LCBTY2VuZV8yLCBEZWJ1Z18yLCBDbGFzc185LCBJbnB1dCwgVXRpbCwgQm91bmRpbmdCb3hfNykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgZGlzcGxheSBtb2RlcyBhdmFpbGFibGUgdG8gRXhjYWxpYnVyXHJcbiAgICAgKi9cclxuICAgIHZhciBEaXNwbGF5TW9kZTtcclxuICAgIChmdW5jdGlvbiAoRGlzcGxheU1vZGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93IHRoZSBnYW1lIGFzIGZ1bGwgc2NyZWVuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGlzcGxheU1vZGVbRGlzcGxheU1vZGVbXCJGdWxsU2NyZWVuXCJdID0gMF0gPSBcIkZ1bGxTY3JlZW5cIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTY2FsZSB0aGUgZ2FtZSB0byB0aGUgcGFyZW50IERPTSBjb250YWluZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBEaXNwbGF5TW9kZVtEaXNwbGF5TW9kZVtcIkNvbnRhaW5lclwiXSA9IDFdID0gXCJDb250YWluZXJcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93IHRoZSBnYW1lIGFzIGEgZml4ZWQgc2l6ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERpc3BsYXlNb2RlW0Rpc3BsYXlNb2RlW1wiRml4ZWRcIl0gPSAyXSA9IFwiRml4ZWRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGxvdyB0aGUgZ2FtZSB0byBiZSBwb3NpdGlvbmVkIHdpdGggdGhlIFtbSUVuZ2luZU9wdGlvbnMucG9zaXRpb25dXSBvcHRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBEaXNwbGF5TW9kZVtEaXNwbGF5TW9kZVtcIlBvc2l0aW9uXCJdID0gM10gPSBcIlBvc2l0aW9uXCI7XHJcbiAgICB9KShEaXNwbGF5TW9kZSA9IGV4cG9ydHMuRGlzcGxheU1vZGUgfHwgKGV4cG9ydHMuRGlzcGxheU1vZGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IG1vdXNld2hlZWwgZXZlbnQgYnViYmxlIHByZXZlbnRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIFNjcm9sbFByZXZlbnRpb25Nb2RlO1xyXG4gICAgKGZ1bmN0aW9uIChTY3JvbGxQcmV2ZW50aW9uTW9kZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERvIG5vdCBwcmV2ZW50IGFueSBwYWdlIHNjcm9sbGluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjcm9sbFByZXZlbnRpb25Nb2RlW1Njcm9sbFByZXZlbnRpb25Nb2RlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJldmVudCBwYWdlIHNjcm9sbCBpZiBtb3VzZSBpcyBvdmVyIHRoZSBnYW1lIGNhbnZhc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjcm9sbFByZXZlbnRpb25Nb2RlW1Njcm9sbFByZXZlbnRpb25Nb2RlW1wiQ2FudmFzXCJdID0gMV0gPSBcIkNhbnZhc1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByZXZlbnQgYWxsIHBhZ2Ugc2Nyb2xsaW5nIHZpYSBtb3VzZSB3aGVlbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjcm9sbFByZXZlbnRpb25Nb2RlW1Njcm9sbFByZXZlbnRpb25Nb2RlW1wiQWxsXCJdID0gMl0gPSBcIkFsbFwiO1xyXG4gICAgfSkoU2Nyb2xsUHJldmVudGlvbk1vZGUgPSBleHBvcnRzLlNjcm9sbFByZXZlbnRpb25Nb2RlIHx8IChleHBvcnRzLlNjcm9sbFByZXZlbnRpb25Nb2RlID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIEV4Y2FsaWJ1ciBFbmdpbmVcclxuICAgICAqXHJcbiAgICAgKiBUaGUgW1tFbmdpbmVdXSBpcyB0aGUgbWFpbiBkcml2ZXIgZm9yIGEgZ2FtZS4gSXQgaXMgcmVzcG9uc2libGUgZm9yXHJcbiAgICAgKiBzdGFydGluZy9zdG9wcGluZyB0aGUgZ2FtZSwgbWFpbnRhaW5pbmcgc3RhdGUsIHRyYW5zbWl0dGluZyBldmVudHMsXHJcbiAgICAgKiBsb2FkaW5nIHJlc291cmNlcywgYW5kIG1hbmFnaW5nIHRoZSBzY2VuZS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6RW5naW5lLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIEVuZ2luZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEVuZ2luZSwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGdhbWUgdXNpbmcgdGhlIGdpdmVuIFtbSUVuZ2luZU9wdGlvbnNdXS4gQnkgZGVmYXVsdCwgaWYgbm8gb3B0aW9ucyBhcmUgcHJvdmlkZWQsXHJcbiAgICAgICAgICogdGhlIGdhbWUgd2lsbCBiZSByZW5kZXJlZCBmdWxsIHNjcmVlbiAodGFraW5nIHVwIGFsbCBhdmFpbGFibGUgYnJvd3NlciB3aW5kb3cgc3BhY2UpLlxyXG4gICAgICAgICAqIFlvdSBjYW4gY3VzdG9taXplIHRoZSBnYW1lIHJlbmRlcmluZyB0aHJvdWdoIFtbSUVuZ2luZU9wdGlvbnNdXS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEV4YW1wbGU6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGBqc1xyXG4gICAgICAgICAqIHZhciBnYW1lID0gbmV3IGV4LkVuZ2luZSh7XHJcbiAgICAgICAgICogICB3aWR0aDogMCwgLy8gdGhlIHdpZHRoIG9mIHRoZSBjYW52YXNcclxuICAgICAgICAgKiAgIGhlaWdodDogMCwgLy8gdGhlIGhlaWdodCBvZiB0aGUgY2FudmFzXHJcbiAgICAgICAgICogICBjYW52YXNFbGVtZW50SWQ6ICcnLCAvLyB0aGUgRE9NIGNhbnZhcyBlbGVtZW50IElELCBpZiB5b3UgYXJlIHByb3ZpZGluZyB5b3VyIG93blxyXG4gICAgICAgICAqICAgZGlzcGxheU1vZGU6IGV4LkRpc3BsYXlNb2RlLkZ1bGxTY3JlZW4sIC8vIHRoZSBkaXNwbGF5IG1vZGVcclxuICAgICAgICAgKiAgIHBvaW50ZXJTY29wZTogZXguSW5wdXQuUG9pbnRlclNjb3BlLkRvY3VtZW50LCAvLyB0aGUgc2NvcGUgb2YgY2FwdHVyaW5nIHBvaW50ZXIgKG1vdXNlL3RvdWNoKSBldmVudHNcclxuICAgICAgICAgKiAgIGJhY2tncm91bmRDb2xvcjogZXguQ29sb3IuZnJvbUhleCgnIzIxODVkMCcpIC8vIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIGVuZ2luZVxyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gY2FsbCBnYW1lLnN0YXJ0LCB3aGljaCBpcyBhIFByb21pc2VcclxuICAgICAgICAgKiBnYW1lLnN0YXJ0KCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICogICAvLyByZWFkeSwgc2V0LCBnbyFcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKiBgYGBcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBFbmdpbmUob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5faGFzU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWNjZXNzIEV4Y2FsaWJ1ciBkZWJ1Z2dpbmcgZnVuY3Rpb25hbGl0eS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmRlYnVnID0gbmV3IERlYnVnXzIuRGVidWcoKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGlzdCBvZiBwb3N0IHByb2Nlc3NvcnMgdG8gYXBwbHkgYXQgdGhlIGVuZCBvZiBkcmF3aW5nIGEgZnJhbWUgKHN1Y2ggYXMgW1tDb2xvckJsaW5kQ29ycmVjdG9yXV0pXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5wb3N0UHJvY2Vzc29ycyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29udGFpbnMgYWxsIHRoZSBzY2VuZXMgY3VycmVudGx5IHJlZ2lzdGVyZWQgd2l0aCBFeGNhbGlidXJcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnNjZW5lcyA9IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBpcyBzZXQgdG8gZnVsbHNjcmVlbiBvciBub3RcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmlzRnVsbHNjcmVlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHRoZSBjdXJyZW50IFtbRGlzcGxheU1vZGVdXSBvZiB0aGUgZW5naW5lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZGlzcGxheU1vZGUgPSBEaXNwbGF5TW9kZS5GdWxsU2NyZWVuO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYXVkaW8gc2hvdWxkIGJlIHBhdXNlZCB3aGVuIHRoZSBnYW1lIGlzIG5vIGxvbmdlciB2aXNpYmxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucGF1c2VBdWRpb1doZW5IaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBzaG91bGQgZHJhdyB3aXRoIGRlYnVnIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5pc0RlYnVnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLmRlYnVnQ29sb3IgPSBuZXcgQ29sb3JfMTkuQ29sb3IoMjU1LCAyNTUsIDI1NSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgYWN0aW9uIHRvIHRha2Ugd2hlbiBhIGZhdGFsIGV4Y2VwdGlvbiBpcyB0aHJvd25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm9uRmF0YWxFeGNlcHRpb24gPSBmdW5jdGlvbiAoZSkgeyBMb2dfMTQuTG9nZ2VyLmdldEluc3RhbmNlKCkuZmF0YWwoZSk7IH07XHJcbiAgICAgICAgICAgIF90aGlzLl9pc1Ntb290aGluZ0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBfdGhpcy5fdGltZXNjYWxlID0gMS4wO1xyXG4gICAgICAgICAgICBfdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgRW5naW5lLl9EZWZhdWx0RW5naW5lT3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGNvbXBhdGliaWxpdHkgXHJcbiAgICAgICAgICAgIHZhciBkZXRlY3RvciA9IG5ldyBEZXRlY3Rvcl8yLkRldGVjdG9yKCk7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zdXBwcmVzc01pbmltdW1Ccm93c2VyRmVhdHVyZURldGVjdGlvbiAmJiAhKF90aGlzLl9jb21wYXRpYmxlID0gZGV0ZWN0b3IudGVzdCgpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5uZXJUZXh0ID0gJ1NvcnJ5LCB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhbGwgdGhlIGZlYXR1cmVzIG5lZWRlZCBmb3IgRXhjYWxpYnVyJztcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBkZXRlY3Rvci5mYWlsZWRUZXN0cy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RNZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdE1lc3NhZ2UuaW5uZXJUZXh0ID0gJ0Jyb3dzZXIgZmVhdHVyZSBtaXNzaW5nICcgKyB0ZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVzdE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW52YXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoY2FudmFzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fY29tcGF0aWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXNlIG5hdGl2ZSBjb25zb2xlIEFQSSBmb3IgY29sb3IgZnVuXHJcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZyAmJiAhb3B0aW9ucy5zdXBwcmVzc0NvbnNvbGVCb290TWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIlY1Bvd2VyZWQgYnkgRXhjYWxpYnVyLmpzICh2XCIgKyBJbmRleF83LkVYX1ZFUlNJT04gKyBcIilcIiwgJ2JhY2tncm91bmQ6ICMxNzZCQUE7IGNvbG9yOiB3aGl0ZTsgYm9yZGVyLXJhZGl1czogNXB4OyBwYWRkaW5nOiAxNXB4OyBmb250LXNpemU6IDEuNWVtOyBsaW5lLWhlaWdodDogODBweDsnKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdcXG5cXFxyXG4gICAgICAvfCBfX19fX19fX19fX19fX19fXFxuXFxcclxuT3w9PT18KiA+X19fX19fX19fX19fX19fXz5cXG5cXFxyXG4gICAgICBcXFxcfCcpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Zpc2l0JywgJ2h0dHA6Ly9leGNhbGlidXJqcy5jb20nLCAnZm9yIG1vcmUgaW5mb3JtYXRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyID0gTG9nXzE0LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAvLyBJZiBkZWJ1ZyBpcyBlbmFibGVkLCBsZXQncyBsb2cgYnJvd3NlciBmZWF0dXJlcyB0byB0aGUgY29uc29sZS5cclxuICAgICAgICAgICAgaWYgKF90aGlzLl9sb2dnZXIuZGVmYXVsdExldmVsID09PSBMb2dfMTQuTG9nTGV2ZWwuRGVidWcpIHtcclxuICAgICAgICAgICAgICAgIGRldGVjdG9yLmxvZ0Jyb3dzZXJGZWF0dXJlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ0J1aWxkaW5nIGVuZ2luZS4uLicpO1xyXG4gICAgICAgICAgICBfdGhpcy5jYW52YXNFbGVtZW50SWQgPSBvcHRpb25zLmNhbnZhc0VsZW1lbnRJZDtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FudmFzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdVc2luZyBDYW52YXMgZWxlbWVudCBzcGVjaWZpZWQ6ICcgKyBvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdVc2luZyBnZW5lcmF0ZWQgY2FudmFzIGVsZW1lbnQnKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kaXNwbGF5TW9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcGxheU1vZGUgPSBEaXNwbGF5TW9kZS5GaXhlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ0VuZ2luZSB2aWV3cG9ydCBpcyBzaXplICcgKyBvcHRpb25zLndpZHRoICsgJyB4ICcgKyBvcHRpb25zLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW52YXMud2lkdGggPSBvcHRpb25zLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLmRpc3BsYXlNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdFbmdpbmUgdmlld3BvcnQgaXMgZnVsbHNjcmVlbicpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGxheU1vZGUgPSBEaXNwbGF5TW9kZS5GdWxsU2NyZWVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IuY2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fbG9hZGVyID0gbmV3IExvYWRlcl8yLkxvYWRlcigpO1xyXG4gICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZShvcHRpb25zKTtcclxuICAgICAgICAgICAgX3RoaXMucm9vdFNjZW5lID0gX3RoaXMuY3VycmVudFNjZW5lID0gbmV3IFNjZW5lXzIuU2NlbmUoX3RoaXMpO1xyXG4gICAgICAgICAgICBfdGhpcy5hZGRTY2VuZSgncm9vdCcsIF90aGlzLnJvb3RTY2VuZSk7XHJcbiAgICAgICAgICAgIF90aGlzLmdvVG9TY2VuZSgncm9vdCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImNhbnZhc1dpZHRoXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzIChwaHlzaWNhbCB3aWR0aCBjb21wb25lbnQgb2YgdGhlXHJcbiAgICAgICAgICAgICAqIHJlc29sdXRpb24gb2YgdGhlIGNhbnZhcyBlbGVtZW50KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImhhbGZDYW52YXNXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGhhbGYgd2lkdGggb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscyAoaGFsZiBwaHlzaWNhbCB3aWR0aCBjb21wb25lbnQpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImNhbnZhc0hlaWdodFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMsIChwaHlzaWNhbCBoZWlnaHQgY29tcG9uZW50IG9mXHJcbiAgICAgICAgICAgICAqIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmhlaWdodDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwiaGFsZkNhbnZhc0hlaWdodFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGhhbGYgaGVpZ2h0IG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgaGVpZ2h0IGNvbXBvbmVudClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImRyYXdXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2FudmFzV2lkdGggLyB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Wm9vbSgpKSAvIHRoaXMucGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhc1dpZHRoIC8gdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJoYWxmRHJhd1dpZHRoXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgaGFsZiB0aGUgd2lkdGggb2YgdGhlIGVuZ2luZSdzIHZpc2libGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscyBpbmNsdWRpbmcgem9vbSBhbmQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kcmF3V2lkdGggLyAyO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJkcmF3SGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2FudmFzSGVpZ2h0IC8gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldFpvb20oKSkgLyB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNIZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImhhbGZEcmF3SGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgaGFsZiB0aGUgaGVpZ2h0IG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhd0hlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImlzSGlEcGlcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIGV4Y2FsaWJ1ciBkZXRlY3RzIHRoZSBjdXJyZW50IHNjcmVlbiB0byBiZSBIaURQSVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5waXhlbFJhdGlvICE9PSAxO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJzdGF0c1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBY2Nlc3MgW1tzdGF0c11dIHRoYXQgaG9sZHMgZnJhbWUgc3RhdGlzdGljcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVidWcuc3RhdHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcInBpeGVsUmF0aW9cIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCBwaXhlbCByYXRpb24gZm9yIHVzZSBpbiByZW5kZXJpbmdcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIEJvdW5kaW5nQm94IG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHNjcmVlblxyXG4gICAgICAgICAqIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2NyZWVuLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ2V0V29ybGRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMoQWxnZWJyYV8yMi5WZWN0b3IuWmVybykueDtcclxuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKEFsZ2VicmFfMjIuVmVjdG9yLlplcm8pLnk7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyB0aGlzLmRyYXdXaWR0aDtcclxuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIHRoaXMuZHJhd0hlaWdodDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveF83LkJvdW5kaW5nQm94KGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJ0aW1lc2NhbGVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCBlbmdpbmUgdGltZXNjYWxlIGZhY3RvciAoZGVmYXVsdCBpcyAxLjAgd2hpY2ggaXMgMToxIHRpbWUpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lc2NhbGU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGVuZ2luZSB0aW1lc2NhbGUgZmFjdG9yLiBVc2VmdWwgZm9yIGNyZWF0aW5nIHNsb3ctbW90aW9uIGVmZmVjdHMgb3IgZmFzdC1mb3J3YXJkIGVmZmVjdHNcclxuICAgICAgICAgICAgICogd2hlbiB1c2luZyB0aW1lLWJhc2VkIG1vdmVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzE0LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDYW5ub3Qgc2V0IGVuZ2luZS50aW1lc2NhbGUgdG8gYSB2YWx1ZSBvZiAwIG9yIGxlc3MgdGhhbiAwLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVzY2FsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbGF5cyBhIHNwcml0ZSBhbmltYXRpb24gb24gdGhlIHNjcmVlbiBhdCB0aGUgc3BlY2lmaWVkIGB4YCBhbmQgYHlgXHJcbiAgICAgICAgICogKGluIGdhbWUgY29vcmRpbmF0ZXMsIG5vdCBzY3JlZW4gcGl4ZWxzKS4gVGhlc2UgYW5pbWF0aW9ucyBwbGF5XHJcbiAgICAgICAgICogaW5kZXBlbmRlbnQgb2YgYWN0b3JzLCBhbmQgd2lsbCBiZSBjbGVhbmVkIHVwIGludGVybmFsbHkgYXMgc29vblxyXG4gICAgICAgICAqIGFzIHRoZXkgYXJlIGNvbXBsZXRlLiBOb3RlIGFuaW1hdGlvbnMgdGhhdCBsb29wIHdpbGwgbmV2ZXIgYmVcclxuICAgICAgICAgKiBjbGVhbmVkIHVwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGFuaW1hdGlvbiAgQW5pbWF0aW9uIHRvIHBsYXlcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICAgICB4IGdhbWUgY29vcmRpbmF0ZSB0byBwbGF5IHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICAgICB5IGdhbWUgY29vcmRpbmF0ZSB0byBwbGF5IHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbWF0aW9uLCB4LCB5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnMucHVzaChuZXcgQW5pbWF0aW9uTm9kZShhbmltYXRpb24sIHgsIHkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBbW1RpbGVNYXBdXSB0byB0aGUgW1tjdXJyZW50U2NlbmVdXSwgb25jZSB0aGlzIGlzIGRvbmUgdGhlIFRpbGVNYXBcclxuICAgICAgICAgKiB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkVGlsZU1hcCA9IGZ1bmN0aW9uICh0aWxlTWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZFRpbGVNYXAodGlsZU1hcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgW1tUaWxlTWFwXV0gZnJvbSB0aGUgW1tjdXJyZW50U2NlbmVdXSwgaXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZVRpbGVNYXAgPSBmdW5jdGlvbiAodGlsZU1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVUaWxlTWFwKHRpbGVNYXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIFtbVGltZXJdXSB0byB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byBhZGQgdG8gdGhlIFtbY3VycmVudFNjZW5lXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5hZGRUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2NlbmUuYWRkVGltZXIodGltZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIFtbVGltZXJdXSBmcm9tIHRoZSBbW2N1cnJlbnRTY2VuZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIHJlbW92ZSB0byB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZVRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVUaW1lcih0aW1lcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgW1tTY2VuZV1dIHRvIHRoZSBlbmdpbmUsIHRoaW5rIG9mIHNjZW5lcyBpbiBFeGNhbGlidXIgYXMgeW91XHJcbiAgICAgICAgICogd291bGQgbGV2ZWxzIG9yIG1lbnVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGtleSAgVGhlIG5hbWUgb2YgdGhlIHNjZW5lLCBtdXN0IGJlIHVuaXF1ZVxyXG4gICAgICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgc2NlbmUgdG8gYWRkIHRvIHRoZSBlbmdpbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZFNjZW5lID0gZnVuY3Rpb24gKGtleSwgc2NlbmUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdTY2VuZScsIGtleSwgJ2FscmVhZHkgZXhpc3RzIG92ZXJ3cml0aW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zY2VuZXNba2V5XSA9IHNjZW5lO1xyXG4gICAgICAgICAgICBzY2VuZS5lbmdpbmUgPSB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmVTY2VuZSA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFNjZW5lXzIuU2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzY2VuZVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuc2NlbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzW2tleV0gPT09IGVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgc2NlbmVcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lc1tlbnRpdHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFVJQWN0b3JfMy5VSUFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGRVSUFjdG9yKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEFjdG9yXzEyLkFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRDaGlsZChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBUaW1lcl8yLlRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbWVyKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbGVNYXBfMi5UaWxlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbGVNYXAoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2VuZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVUlBY3Rvcl8zLlVJQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZVVJQWN0b3IoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgQWN0b3JfMTIuQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNoaWxkKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbWVyXzIuVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGlsZU1hcF8yLlRpbGVNYXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZU1hcChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBTY2VuZV8yLlNjZW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNjZW5lKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNjZW5lKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW4gYWN0b3IgdG8gdGhlIFtbY3VycmVudFNjZW5lXV0gb2YgdGhlIGdhbWUuIFRoaXMgaXMgc3lub255bW91c1xyXG4gICAgICAgICAqIHRvIGNhbGxpbmcgYGVuZ2luZS5jdXJyZW50U2NlbmUuYWRkKGFjdG9yKWAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBBY3RvcnMgY2FuIG9ubHkgYmUgZHJhd24gaWYgdGhleSBhcmUgYSBtZW1iZXIgb2YgYSBzY2VuZSwgYW5kIG9ubHlcclxuICAgICAgICAgKiB0aGUgW1tjdXJyZW50U2NlbmVdXSBtYXkgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciAgVGhlIGFjdG9yIHRvIGFkZCB0byB0aGUgW1tjdXJyZW50U2NlbmVdXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuX2FkZENoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZChhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGZyb20gdGhlIFtbY3VycmVudFNjZW5lXV0gb2YgdGhlIGdhbWUuIFRoaXMgaXMgc3lub255bW91c1xyXG4gICAgICAgICAqIHRvIGNhbGxpbmcgYGVuZ2luZS5jdXJyZW50U2NlbmUucmVtb3ZlKGFjdG9yKWAuXHJcbiAgICAgICAgICogQWN0b3JzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBhIHNjZW5lIHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgIFRoZSBhY3RvciB0byByZW1vdmUgZnJvbSB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLl9yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmUoYWN0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgY3VycmVudGx5IHVwZGF0aW5nIGFuZCBkcmF3aW5nIHNjZW5lIHRvIGEgZGlmZmVyZW50LFxyXG4gICAgICAgICAqIG5hbWVkIHNjZW5lLiBDYWxscyB0aGUgW1tTY2VuZV1dIGxpZmVjeWNsZSBldmVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIGtleSAgVGhlIGtleSBvZiB0aGUgc2NlbmUgdG8gdHJhbnNpdGlvbiB0by5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmdvVG9TY2VuZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRTY2VuZSA9IHRoaXMuY3VycmVudFNjZW5lO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1NjZW5lID0gdGhpcy5zY2VuZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnR29pbmcgdG8gc2NlbmU6Jywga2V5KTtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZGVhY3RpdmF0ZSB3aGVuIGluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uRGVhY3RpdmF0ZS5jYWxsKHRoaXMuY3VycmVudFNjZW5lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5ldmVudERpc3BhdGNoZXIuZW1pdCgnZGVhY3RpdmF0ZScsIG5ldyBFdmVudHNfMTIuRGVhY3RpdmF0ZUV2ZW50KG5ld1NjZW5lLCB0aGlzLmN1cnJlbnRTY2VuZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IGN1cnJlbnQgc2NlbmUgdG8gbmV3IG9uZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUgPSBuZXdTY2VuZTtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGN1cnJlbnQgc2NlbmUgaWYgaGFzIG5vdCBiZWVuIGFscmVhZHlcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLl9pbml0aWFsaXplKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25BY3RpdmF0ZS5jYWxsKHRoaXMuY3VycmVudFNjZW5lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdhY3RpdmF0ZScsIG5ldyBFdmVudHNfMTIuQWN0aXZhdGVFdmVudChvbGRTY2VuZSwgdGhpcy5jdXJyZW50U2NlbmUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignU2NlbmUnLCBrZXksICdkb2VzIG5vdCBleGlzdCEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhbnNmb3JtcyB0aGUgY3VycmVudCB4LCB5IGZyb20gc2NyZWVuIGNvb3JkaW5hdGVzIHRvIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICogQHBhcmFtIHBvaW50ICBTY3JlZW4gY29vcmRpbmF0ZSB0byBjb252ZXJ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1ggPSBwb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgbmV3WSA9IHBvaW50Lnk7XHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBiYWNrIHRvIHdvcmxkIHNwYWNlXHJcbiAgICAgICAgICAgIG5ld1ggPSAobmV3WCAvIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoKSAqIHRoaXMuZHJhd1dpZHRoO1xyXG4gICAgICAgICAgICBuZXdZID0gKG5ld1kgLyB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpICogdGhpcy5kcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gYmFzZWQgb24gem9vbVxyXG4gICAgICAgICAgICBuZXdYID0gbmV3WCAtIHRoaXMuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICAgICAgbmV3WSA9IG5ld1kgLSB0aGlzLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyBzaGlmdCBieSBmb2N1c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIG5ld1ggKz0gZm9jdXMueDtcclxuICAgICAgICAgICAgICAgIG5ld1kgKz0gZm9jdXMueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjIuVmVjdG9yKE1hdGguZmxvb3IobmV3WCksIE1hdGguZmxvb3IobmV3WSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhbnNmb3JtcyBhIHdvcmxkIGNvb3JkaW5hdGUsIHRvIGEgc2NyZWVuIGNvb3JkaW5hdGVcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnQgIFdvcmxkIGNvb3JkaW5hdGUgdG8gY29udmVydFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzY3JlZW5YID0gcG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIHNjcmVlblkgPSBwb2ludC55O1xyXG4gICAgICAgICAgICAvLyBzaGlmdCBieSBmb2N1c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIHNjcmVlblggLT0gZm9jdXMueDtcclxuICAgICAgICAgICAgICAgIHNjcmVlblkgLT0gZm9jdXMueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gYmFjayBvbiB6b29tXHJcbiAgICAgICAgICAgIHNjcmVlblggPSBzY3JlZW5YICsgdGhpcy5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgICAgICBzY3JlZW5ZID0gc2NyZWVuWSArIHRoaXMuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBiYWNrIHRvIHNjcmVlbiBzcGFjZVxyXG4gICAgICAgICAgICBzY3JlZW5YID0gKHNjcmVlblggKiB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCkgLyB0aGlzLmRyYXdXaWR0aDtcclxuICAgICAgICAgICAgc2NyZWVuWSA9IChzY3JlZW5ZICogdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KSAvIHRoaXMuZHJhd0hlaWdodDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzIyLlZlY3RvcihNYXRoLmZsb29yKHNjcmVlblgpLCBNYXRoLmZsb29yKHNjcmVlblkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGludGVybmFsIGNhbnZhcyBoZWlnaHQgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGRpc3BsYXkgbW9kZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLl9zZXRIZWlnaHRCeURpc3BsYXlNb2RlID0gZnVuY3Rpb24gKHBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZ1bGxTY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHBhcmVudC5pbm5lcldpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGFyZW50LmlubmVySGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgY2FudmFzLCByZW5kZXJpbmcgY29udGV4dCwgZGlzcGxheW1vZGUsIGFuZCBuYXRpdmUgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpc3BsYXlNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlNb2RlID0gb3B0aW9ucy5kaXNwbGF5TW9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuRnVsbFNjcmVlbiB8fCB0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5Db250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuQ29udGFpbmVyID9cclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5jYW52YXMucGFyZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KSA6IHdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRIZWlnaHRCeURpc3BsYXlNb2RlKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ1ZpZXcgcG9ydCByZXNpemVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldEhlaWdodEJ5RGlzcGxheU1vZGUocGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmluZm8oJ3BhcmVudC5jbGllbnRIZWlnaHQgJyArIHBhcmVudC5jbGllbnRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEFudGlhbGlhc2luZyhfdGhpcy5faXNTbW9vdGhpbmdFbmFibGVkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLlBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRpYWxpemVEaXNwbGF5TW9kZVBvc2l0aW9uKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgaW5wdXRzXHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB7XHJcbiAgICAgICAgICAgICAgICBrZXlib2FyZDogbmV3IElucHV0LktleWJvYXJkKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRlcnM6IG5ldyBJbnB1dC5Qb2ludGVycyh0aGlzKSxcclxuICAgICAgICAgICAgICAgIGdhbWVwYWRzOiBuZXcgSW5wdXQuR2FtZXBhZHModGhpcylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5rZXlib2FyZC5pbml0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucG9pbnRlcnMuaW5pdChvcHRpb25zICYmIG9wdGlvbnMucG9pbnRlclNjb3BlID09PSBJbnB1dC5Qb2ludGVyU2NvcGUuRG9jdW1lbnQgPyBkb2N1bWVudCA6IHRoaXMuY2FudmFzKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5nYW1lcGFkcy5pbml0KCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFnZVNjcm9sbFByZXZlbnRpb25Nb2RlID0gb3B0aW9ucy5zY3JvbGxQcmV2ZW50aW9uTW9kZTtcclxuICAgICAgICAgICAgLy8gSXNzdWUgIzM4NSBtYWtlIHVzZSBvZiB0aGUgdmlzaWJpbGl0eSBhcGlcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvVXNlcl9leHBlcmllbmNlL1VzaW5nX3RoZV9QYWdlX1Zpc2liaWxpdHlfQVBJXHJcbiAgICAgICAgICAgIHZhciBoaWRkZW4sIHZpc2liaWxpdHlDaGFuZ2U7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuaGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCdtc0hpZGRlbicgaW4gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdtc0hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21zdmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJ3dlYmtpdEhpZGRlbicgaW4gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHZpc2liaWxpdHlDaGFuZ2UsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudFtoaWRkZW5dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2hpZGRlbicsIG5ldyBFdmVudHNfMTIuSGlkZGVuRXZlbnQoX3RoaXMpKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdXaW5kb3cgaGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgndmlzaWJsZScsIG5ldyBFdmVudHNfMTIuVmlzaWJsZUV2ZW50KF90aGlzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZygnV2luZG93IHZpc2libGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN1cHByZXNzSGlEUElTY2FsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSGlEcGkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FudmFzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5faW50aWFsaXplRGlzcGxheU1vZGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaXNwbGF5TW9kZSBvZiBQb3NpdGlvbiB3YXMgc2VsZWN0ZWQgYnV0IG5vIHBvc2l0aW9uIG9wdGlvbiB3YXMgZ2l2ZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBvc2l0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGVjaWZpZWRQb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb24uc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNwZWNpZmllZFBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSAnMHB4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYm90dG9tID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9ICc1MCUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSAtdGhpcy5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLm1hcmdpblRvcCA9IG9mZnNldFkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBvc2l0aW9uIEdpdmVuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZWRQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNwZWNpZmllZFBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucmlnaHQgPSAnMHB4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9ICc1MCUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRYID0gLXRoaXMuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5tYXJnaW5MZWZ0ID0gb2Zmc2V0WC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUG9zaXRpb24gR2l2ZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLnRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5wb3NpdGlvbi50b3AgPT09ICdudW1iZXInID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IG9wdGlvbnMucG9zaXRpb24udG9wLnRvU3RyaW5nKCkgKyAncHgnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IG9wdGlvbnMucG9zaXRpb24udG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5wb3NpdGlvbi5yaWdodCA9PT0gJ251bWJlcicgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucmlnaHQgPSBvcHRpb25zLnBvc2l0aW9uLnJpZ2h0LnRvU3RyaW5nKCkgKyAncHgnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnJpZ2h0ID0gb3B0aW9ucy5wb3NpdGlvbi5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24uYm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBvc2l0aW9uLmJvdHRvbSA9PT0gJ251bWJlcicgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYm90dG9tID0gb3B0aW9ucy5wb3NpdGlvbi5ib3R0b20udG9TdHJpbmcoKSArICdweCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYm90dG9tID0gb3B0aW9ucy5wb3NpdGlvbi5ib3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMucG9zaXRpb24ubGVmdCA9PT0gJ251bWJlcicgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IG9wdGlvbnMucG9zaXRpb24ubGVmdC50b1N0cmluZygpICsgJ3B4JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gb3B0aW9ucy5wb3NpdGlvbi5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5faW5pdGlhbGl6ZUhpRHBpID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBTY2FsZSB0aGUgY2FudmFzIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0hpRHBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkV2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IG9sZFdpZHRoICogdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gb2xkSGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSBvbGRXaWR0aCArICdweCc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvbGRIZWlnaHQgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJIaSBEUEkgc2NyZWVuIGRldGVjdGVkLCByZXNldHRpbmcgY2FudmFzIHJlc29sdXRpb24gZnJvbSBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcIiArIG9sZFdpZHRoICsgXCJ4XCIgKyBvbGRIZWlnaHQgKyBcIiB0byBcIiArIHRoaXMuY2FudmFzLndpZHRoICsgXCJ4XCIgKyB0aGlzLmNhbnZhcy5oZWlnaHQgKyBcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjc3Mgc2l6ZSB3aWxsIHJlbWFpbiBcIiArIG9sZFdpZHRoICsgXCJ4XCIgKyBvbGRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHguc2NhbGUodGhpcy5waXhlbFJhdGlvLCB0aGlzLnBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJDYW52YXMgZHJhd2luZyBjb250ZXh0IHdhcyBzY2FsZWQgYnkgXCIgKyB0aGlzLnBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIHRoaXMgd2lsbCBzZXQgdGhlIGFudGlhbGlhc2luZyBmbGFnIG9uIHRoZVxyXG4gICAgICAgICAqIGNhbnZhcy4gU2V0IHRoaXMgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCBhICdqYWdnZWQnIHBpeGVsIGFydCBsb29rIHRvIHlvdXJcclxuICAgICAgICAgKiBpbWFnZSByZXNvdXJjZXMuXHJcbiAgICAgICAgICogQHBhcmFtIGlzU21vb3RoICBTZXQgc21vb3RoaW5nIHRvIHRydWUgb3IgZmFsc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNldEFudGlhbGlhc2luZyA9IGZ1bmN0aW9uIChpc1Ntb290aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1Ntb290aGluZ0VuYWJsZWQgPSBpc1Ntb290aDtcclxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gaXNTbW9vdGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBbJ3dlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCcsICdtb3pJbWFnZVNtb290aGluZ0VuYWJsZWQnLCAnbXNJbWFnZVNtb290aGluZ0VuYWJsZWQnXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbW9vdGhpbmcgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoaW5nIGluIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFtzbW9vdGhpbmddID0gaXNTbW9vdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHNtb290aGluZyBzdGF0dXMgb2YgdGhlIGNhbnZhc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ2V0QW50aWFsaWFzaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBlbnRpcmUgc3RhdGUgb2YgdGhlIGdhbWVcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN1c3BlbmQgdXBkYXRlcyB1bnRpbGwgbG9hZGluZyBpcyBmaW5pc2hlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLnVwZGF0ZSh0aGlzLCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgaW5wdXQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5wb2ludGVycy51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgRXZlbnRzXzEyLlByZVVwZGF0ZUV2ZW50KHRoaXMsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZW5naW5lIGxldmVsIGV2ZW50c1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS51cGRhdGUodGhpcywgZGVsdGEpO1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgYW5pbWF0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25zID0gdGhpcy5fYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhYS5hbmltYXRpb24uaXNEb25lKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgaW5wdXQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQua2V5Ym9hcmQudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucG9pbnRlcnMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggdXBkYXRlIGV2ZW50XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBFdmVudHNfMTIuUG9zdFVwZGF0ZUV2ZW50KHRoaXMsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3cyB0aGUgZW50aXJlIGdhbWVcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBkcmF3LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWRyYXcnLCBuZXcgRXZlbnRzXzEyLlByZURyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5kcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgLy8gRHJhd2luZyBub3RoaW5nIGVsc2Ugd2hpbGUgbG9hZGluZ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZHJhdyh0aGlzLmN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICAvLyB0b2RvIG5lZWRzIHRvIGJlIGEgYmV0dGVyIHdheSBvZiBkb2luZyB0aGlzXHJcbiAgICAgICAgICAgIHZhciBhID0gMCwgbGVuID0gdGhpcy5fYW5pbWF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoYTsgYSA8IGxlbjsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25zW2FdLmFuaW1hdGlvbi5kcmF3KGN0eCwgdGhpcy5fYW5pbWF0aW9uc1thXS54LCB0aGlzLl9hbmltYXRpb25zW2FdLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERyYXcgZGVidWcgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZm9udCA9ICdDb25zb2xhcyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmRlYnVnQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5pbnB1dC5rZXlib2FyZC5nZXRLZXlzKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChrZXlzW2pdLnRvU3RyaW5nKCkgKyAnIDogJyArIChJbnB1dC5LZXlzW2tleXNbal1dID8gSW5wdXQuS2V5c1trZXlzW2pdXSA6ICdOb3QgTWFwcGVkJyksIDEwMCwgMTAgKiBqICsgMTApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoJ0ZQUzonICsgdGhpcy5zdGF0cy5jdXJyRnJhbWUuZnBzLnRvRml4ZWQoMikudG9TdHJpbmcoKSwgMTAsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQb3N0IHByb2Nlc3NpbmdcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc3RQcm9jZXNzb3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3RQcm9jZXNzb3JzW2ldLnByb2Nlc3ModGhpcy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0KSwgdGhpcy5jdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdGRyYXcnLCBuZXcgRXZlbnRzXzEyLlBvc3REcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RhcnRzIHRoZSBpbnRlcm5hbCBnYW1lIGxvb3AgZm9yIEV4Y2FsaWJ1ciBhZnRlciBsb2FkaW5nXHJcbiAgICAgICAgICogYW55IHByb3ZpZGVkIGFzc2V0cy5cclxuICAgICAgICAgKiBAcGFyYW0gbG9hZGVyICBPcHRpb25hbCBbW0lMb2FkZXJdXSB0byB1c2UgdG8gbG9hZCByZXNvdXJjZXMuIFRoZSBkZWZhdWx0IGxvYWRlciBpcyBbW0xvYWRlcl1dLCBvdmVycmlkZSB0byBwcm92aWRlIHlvdXIgb3duXHJcbiAgICAgICAgICogY3VzdG9tIGxvYWRlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBhdGlibGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2VzXzguUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UucmVqZWN0KCdFeGNhbGlidXIgaXMgaW5jb21wYXRpYmxlIHdpdGggeW91ciBicm93c2VyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxvYWRpbmdDb21wbGV0ZTtcclxuICAgICAgICAgICAgaWYgKGxvYWRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLndpcmVFbmdpbmUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBsb2FkaW5nQ29tcGxldGUgPSB0aGlzLmxvYWQodGhpcy5fbG9hZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvYWRpbmdDb21wbGV0ZSA9IFByb21pc2VzXzguUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9hZGluZ0NvbXBsZXRlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnc3RhcnQnLCBuZXcgRXZlbnRzXzEyLkdhbWVTdGFydEV2ZW50KF90aGlzKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhc1N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTdGFydGluZyBnYW1lLi4uJyk7XHJcbiAgICAgICAgICAgICAgICBFbmdpbmUuY3JlYXRlTWFpbkxvb3AodGhpcywgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSwgRGF0ZS5ub3cpKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0dhbWUgc3RhcnRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gR2FtZSBhbHJlYWR5IHN0YXJ0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmdDb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVuZ2luZS5jcmVhdGVNYWluTG9vcCA9IGZ1bmN0aW9uIChnYW1lLCByYWYsIG5vd0ZuKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0VGltZSA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBtYWlubG9vcCgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZ2FtZS5faGFzU3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5fcmVxdWVzdElkID0gcmFmKG1haW5sb29wKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLmVtaXQoJ3ByZWZyYW1lJywgbmV3IEV2ZW50c18xMi5QcmVGcmFtZUV2ZW50KGdhbWUsIGdhbWUuc3RhdHMucHJldkZyYW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0aW1lIHRvIGNhbGN1bGF0ZSB0aW1lLWVsYXBzZWRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gbm93Rm4oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxhcHNlZCA9IE1hdGguZmxvb3Iobm93IC0gbGFzdFRpbWUpIHx8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZXMgaXNzdWUgIzEzOCBpZiB0aGUgZ2FtZSBoYXMgYmVlbiBwYXVzZWQsIG9yIGJsdXJyZWQgZm9yIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgdGhhbiBhIDIwMCBtaWxsaXNlY29uZHMsIHJlc2V0IGVsYXBzZWQgdGltZSB0byAxLiBUaGlzIGltcHJvdmVzIHJlbGlhYmlsaXR5IFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm92aWRlcyBtb3JlIGV4cGVjdGVkIGJlaGF2aW9yIHdoZW4gdGhlIGVuZ2luZSBjb21lcyBiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50byBmb2N1c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGFwc2VkID4gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsYXBzZWQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBlbGFwc2VkICogZ2FtZS50aW1lc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgZnJhbWUgc3RhdHMgKHJldXNlIGV4aXN0aW5nIGluc3RhbmNlcylcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVJZCA9IGdhbWUuc3RhdHMucHJldkZyYW1lLmlkICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLnByZXZGcmFtZS5yZXNldChnYW1lLnN0YXRzLmN1cnJGcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5pZCA9IGZyYW1lSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5mcHMgPSAxLjAgLyAoZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlVXBkYXRlID0gbm93Rm4oKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLl91cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZnRlclVwZGF0ZSA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5fZHJhdyhkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFmdGVyRHJhdyA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuZHVyYXRpb24udXBkYXRlID0gYWZ0ZXJVcGRhdGUgLSBiZWZvcmVVcGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuZHVyYXRpb24uZHJhdyA9IGFmdGVyRHJhdyAtIGFmdGVyVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lID0gbm93O1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuZW1pdCgncG9zdGZyYW1lJywgbmV3IEV2ZW50c18xMi5Qb3N0RnJhbWVFdmVudChnYW1lLCBnYW1lLnN0YXRzLmN1cnJGcmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoZ2FtZS5fcmVxdWVzdElkKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLm9uRmF0YWxFeGNlcHRpb24oZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9wcyBFeGNhbGlidXIncyBtYWluIGxvb3AsIHVzZWZ1bCBmb3IgcGF1c2luZyB0aGUgZ2FtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNTdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnLCBuZXcgRXZlbnRzXzEyLkdhbWVTdG9wRXZlbnQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdHYW1lIHN0b3BwZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgRW5naW5lJ3MgUnVubmluZyBzdGF0dXMsIFVzZWZ1bCBmb3IgY2hlY2tpbmcgd2hldGhlciBlbmdpbmUgaXMgcnVubmluZyBvciBwYXVzZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEodGhpcy5faGFzU3RhcnRlZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBhIHNjcmVlbiBzaG90IG9mIHRoZSBjdXJyZW50IHZpZXdwb3J0IGFuZCByZXR1cm5zIGl0IGFzIGFuXHJcbiAgICAgICAgICogSFRNTCBJbWFnZSBFbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2NyZWVuc2hvdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5jYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcclxuICAgICAgICAgICAgcmVzdWx0LnNyYyA9IHJhdztcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFub3RoZXIgb3B0aW9uIGF2YWlsYWJsZSB0byB5b3UgdG8gbG9hZCByZXNvdXJjZXMgaW50byB0aGUgZ2FtZS5cclxuICAgICAgICAgKiBJbW1lZGlhdGVseSBhZnRlciBjYWxsaW5nIHRoaXMgdGhlIGdhbWUgd2lsbCBwYXVzZSBhbmQgdGhlIGxvYWRpbmcgc2NyZWVuXHJcbiAgICAgICAgICogd2lsbCBhcHBlYXIuXHJcbiAgICAgICAgICogQHBhcmFtIGxvYWRlciAgU29tZSBbW0lMb2FkYWJsZV1dIHN1Y2ggYXMgYSBbW0xvYWRlcl1dIGNvbGxlY3Rpb24sIFtbU291bmRdXSwgb3IgW1tUZXh0dXJlXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGxvYWRlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgUHJvbWlzZXNfOC5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGxvYWRlci5sb2FkKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSwgNTAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFbmdpbmU7XHJcbiAgICB9KENsYXNzXzkuQ2xhc3MpKTtcclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBbW0lFbmdpbmVPcHRpb25zXV1cclxuICAgICAqL1xyXG4gICAgRW5naW5lLl9EZWZhdWx0RW5naW5lT3B0aW9ucyA9IHtcclxuICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICBoZWlnaHQ6IDAsXHJcbiAgICAgICAgY2FudmFzRWxlbWVudElkOiAnJyxcclxuICAgICAgICBwb2ludGVyU2NvcGU6IElucHV0LlBvaW50ZXJTY29wZS5Eb2N1bWVudCxcclxuICAgICAgICBzdXBwcmVzc0NvbnNvbGVCb290TWVzc2FnZTogbnVsbCxcclxuICAgICAgICBzdXBwcmVzc01pbmltdW1Ccm93c2VyRmVhdHVyZURldGVjdGlvbjogbnVsbCxcclxuICAgICAgICBzdXBwcmVzc0hpRFBJU2NhbGluZzogbnVsbCxcclxuICAgICAgICBzY3JvbGxQcmV2ZW50aW9uTW9kZTogU2Nyb2xsUHJldmVudGlvbk1vZGUuQ2FudmFzLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogQ29sb3JfMTkuQ29sb3IuZnJvbUhleCgnIzIxODVkMCcpIC8vIEV4Y2FsaWJ1ciBibHVlXHJcbiAgICB9O1xyXG4gICAgZXhwb3J0cy5FbmdpbmUgPSBFbmdpbmU7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB2YXIgQW5pbWF0aW9uTm9kZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uTm9kZShhbmltYXRpb24sIHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBBbmltYXRpb25Ob2RlO1xyXG4gICAgfSgpKTtcclxufSk7XHJcbmRlZmluZShcIlVJQWN0b3JcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBbGdlYnJhXCIsIFwiQWN0b3JcIiwgXCJUcmFpdHMvSW5kZXhcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBbGdlYnJhXzIzLCBBY3Rvcl8xMywgVHJhaXRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIFtbQWN0b3JdXSBwcmltaXRpdmUgZm9yIGRyYXdpbmcgVUkncywgb3B0aW1pemVkIGZvciBVSSBkcmF3aW5nLiBEb2VzXHJcbiAgICAgKiBub3QgcGFydGljaXBhdGUgaW4gY29sbGlzaW9ucy4gRHJhd24gb24gdG9wIG9mIGFsbCBvdGhlciBhY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHZhciBVSUFjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVUlBY3RvciwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICBUaGUgc3RhcnRpbmcgeCBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgIFRoZSBzdGFydGluZyB5IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHdpZHRoICAgVGhlIHN0YXJ0aW5nIHdpZHRoIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgIFRoZSBzdGFydGluZyBoZWlnaHQgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVUlBY3Rvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRyYWl0cyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy50cmFpdHMucHVzaChuZXcgVHJhaXRzLkNhcHR1cmVQb2ludGVyKCkpO1xyXG4gICAgICAgICAgICBfdGhpcy5hbmNob3Iuc2V0VG8oMCwgMCk7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbGxpc2lvblR5cGUgPSBBY3Rvcl8xMy5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgICAgIF90aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBVSUFjdG9yLnByb3RvdHlwZS5vbkluaXRpYWxpemUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFVJQWN0b3IucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHksIHVzZVdvcmxkKSB7XHJcbiAgICAgICAgICAgIGlmICh1c2VXb3JsZCA9PT0gdm9pZCAwKSB7IHVzZVdvcmxkID0gdHJ1ZTsgfVxyXG4gICAgICAgICAgICBpZiAodXNlV29ybGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbnRhaW5zLmNhbGwodGhpcywgeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2VuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMjMuVmVjdG9yKHgsIHkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29udGFpbnMuY2FsbCh0aGlzLCBjb29yZHMueCwgY29vcmRzLnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFVJQWN0b3I7XHJcbiAgICB9KEFjdG9yXzEzLkFjdG9yKSk7XHJcbiAgICBleHBvcnRzLlVJQWN0b3IgPSBVSUFjdG9yO1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9BY3RvcnNcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVSUFjdG9yXCIsIFwiTGFiZWxcIiwgXCJUcmlnZ2VyXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgVUlBY3Rvcl80LCBMYWJlbF8zLCBUcmlnZ2VyXzIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZnVuY3Rpb24gaXNWYW5pbGxhQWN0b3IoYWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gIShhY3RvciBpbnN0YW5jZW9mIFVJQWN0b3JfNC5VSUFjdG9yKSAmJlxyXG4gICAgICAgICAgICAhKGFjdG9yIGluc3RhbmNlb2YgVHJpZ2dlcl8yLlRyaWdnZXIpICYmXHJcbiAgICAgICAgICAgICEoYWN0b3IgaW5zdGFuY2VvZiBMYWJlbF8zLkxhYmVsKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuaXNWYW5pbGxhQWN0b3IgPSBpc1ZhbmlsbGFBY3RvcjtcclxuICAgIGZ1bmN0aW9uIGlzVUlBY3RvcihhY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBhY3RvciBpbnN0YW5jZW9mIFVJQWN0b3JfNC5VSUFjdG9yO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5pc1VJQWN0b3IgPSBpc1VJQWN0b3I7XHJcbn0pO1xyXG5kZWZpbmUoXCJTY2VuZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlVJQWN0b3JcIiwgXCJQaHlzaWNzXCIsIFwiRXZlbnRzXCIsIFwiVXRpbC9Mb2dcIiwgXCJUaW1lclwiLCBcIkNvbGxpc2lvbi9EeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2VcIiwgXCJVdGlsL1NvcnRlZExpc3RcIiwgXCJHcm91cFwiLCBcIlRpbGVNYXBcIiwgXCJDYW1lcmFcIiwgXCJBY3RvclwiLCBcIkNsYXNzXCIsIFwiVXRpbC9VdGlsXCIsIFwiVXRpbC9BY3RvcnNcIiwgXCJUcmlnZ2VyXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgVUlBY3Rvcl81LCBQaHlzaWNzXzEyLCBFdmVudHNfMTMsIExvZ18xNSwgVGltZXJfMywgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlXzIsIFNvcnRlZExpc3RfMiwgR3JvdXBfMiwgVGlsZU1hcF8zLCBDYW1lcmFfMiwgQWN0b3JfMTQsIENsYXNzXzEwLCBVdGlsLCBBY3RvclV0aWxzLCBUcmlnZ2VyXzMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBbW0FjdG9yfEFjdG9yc11dIGFyZSBjb21wb3NlZCB0b2dldGhlciBpbnRvIGdyb3VwaW5ncyBjYWxsZWQgU2NlbmVzIGluXHJcbiAgICAgKiBFeGNhbGlidXIuIFRoZSBtZXRhcGhvciBtb2RlbHMgdGhlIHNhbWUgaWRlYSBiZWhpbmQgcmVhbCB3b3JsZFxyXG4gICAgICogYWN0b3JzIGluIGEgc2NlbmUuIE9ubHkgYWN0b3JzIGluIHNjZW5lcyB3aWxsIGJlIHVwZGF0ZWQgYW5kIGRyYXduLlxyXG4gICAgICpcclxuICAgICAqIFR5cGljYWwgdXNhZ2VzIG9mIGEgc2NlbmUgaW5jbHVkZTogbGV2ZWxzLCBtZW51cywgbG9hZGluZyBzY3JlZW5zLCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlNjZW5lcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBTY2VuZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNjZW5lLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNjZW5lKGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGFjdG9ycyBpbiB0aGUgY3VycmVudCBzY2VuZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuYWN0b3JzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgdHJpZ2dlcnMgaW4gdGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXJzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgW1tUaWxlTWFwXV1zIGluIHRoZSBzY2VuZSwgaWYgYW55XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy50aWxlTWFwcyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIFtbR3JvdXBdXXMgaW4gdGhlIHNjZW5lLCBpZiBhbnlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmdyb3VwcyA9IHt9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIFtbVUlBY3Rvcl1dcyBpbiBhIHNjZW5lLCBpZiBhbnk7IHRoZXNlIGFyZSBkcmF3biBsYXN0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy51aUFjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fc29ydGVkRHJhd2luZ1RyZWUgPSBuZXcgU29ydGVkTGlzdF8yLlNvcnRlZExpc3QoQWN0b3JfMTQuQWN0b3IucHJvdG90eXBlLmdldFpJbmRleCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9icm9hZHBoYXNlID0gbmV3IER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZV8yLkR5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5fa2lsbFF1ZXVlID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyS2lsbFF1ZXVlID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl90aW1lcnMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2NhbmNlbFF1ZXVlID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIgPSBMb2dfMTUuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIF90aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmFfMi5CYXNlQ2FtZXJhKCk7XHJcbiAgICAgICAgICAgIGlmIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNhbWVyYS54ID0gZW5naW5lLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW1lcmEueSA9IGVuZ2luZS5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBvZiB0aGUgW1tTY2VuZV1dLiBJbml0aWFsaXplcyBzY2VuZSBtZW1iZXJzIGxpa2UgdGhlIGNhbWVyYS4gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmVcclxuICAgICAgICAgKiBvdmVycmlkZGVuLiBUaGlzIGlzIHdoZXJlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkIGFjdG9ycyBzaG91bGQgdGFrZSBwbGFjZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUub25Jbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS54ID0gZW5naW5lLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS55ID0gZW5naW5lLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU2NlbmUub25Jbml0aWFsaXplJywgdGhpcywgZW5naW5lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIG1hZGUgYWN0aXZlIGFuZCBzdGFydGVkLiBJdCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4sXHJcbiAgICAgICAgICogdGhpcyBpcyB3aGVyZSB5b3Ugc2hvdWxkIHNldHVwIGFueSBET00gVUkgb3IgZXZlbnQgaGFuZGxlcnMgbmVlZGVkIGZvciB0aGUgc2NlbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1NjZW5lLm9uQWN0aXZhdGUnLCB0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIG1hZGUgdHJhbnNpdGlvbmVkIGF3YXkgZnJvbSBhbmQgc3RvcHBlZC4gSXQgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuLFxyXG4gICAgICAgICAqIHRoaXMgaXMgd2hlcmUgeW91IHNob3VsZCBjbGVhbnVwIGFueSBET00gVUkgb3IgZXZlbnQgaGFuZGxlcnMgbmVlZGVkIGZvciB0aGUgc2NlbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU2NlbmUub25EZWFjdGl2YXRlJywgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhY3RvcnMgaW4gdGhlIHNjZW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLl9pbml0aWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmFjdG9yczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGNoaWxkLl9pbml0aWFsaXplKHRoaXMuZW5naW5lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjZW5lLnByb3RvdHlwZSwgXCJpc0luaXRpYWxpemVkXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIFtbU2NlbmVdXSBoYXMgYmVlbiBpbml0aWFsaXplZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIHNjZW5lIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlLCBtZWFudCB0byBiZSBjYWxsZWQgYnkgZW5naW5lIG5vdCBieSB1c2VycyBvZlxyXG4gICAgICAgICAqIEV4Y2FsaWJ1clxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Jbml0aWFsaXplLmNhbGwodGhpcywgZW5naW5lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2luaXRpYWxpemUnLCBuZXcgRXZlbnRzXzEzLkluaXRpYWxpemVFdmVudChlbmdpbmUsIHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIHRoZSBhY3RvcnMgYW5kIHRpbWVycyBpbiB0aGUgc2NlbmUuIENhbGxlZCBieSB0aGUgW1tFbmdpbmVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgRW5naW5lXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJldXBkYXRlJywgbmV3IEV2ZW50c18xMy5QcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW47XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aW1lcnMgaW4gdGhlIGNhbmNlbCBxdWV1ZSBiZWZvcmUgdXBkYXRpbmcgdGhlbVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9jYW5jZWxRdWV1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcih0aGlzLl9jYW5jZWxRdWV1ZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsUXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCB0aW1lcnMgdXBkYXRpbmcgdGltZXJzXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl90aW1lcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZXIgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0aW1lci51cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCBhY3RvcnMgdXBkYXRpbmcgVUkgYWN0b3JzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudWlBY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudWlBY3RvcnNbaV0udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggYWN0b3JzIHVwZGF0aW5nIHRpbGUgbWFwc1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnRpbGVNYXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVNYXBzW2ldLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIGFjdG9ycyB1cGRhdGluZyBhY3RvcnNcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5hY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JzW2ldLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIHRyaWdnZXJzIHVwZGF0aW5nXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudHJpZ2dlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcnNbaV0udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3RBY3RvclN0YXRzKGVuZ2luZSk7XHJcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgYnJvYWRwaGFzZSBhbmQgbmFycm93cGhhc2VcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2Jyb2FkcGhhc2UgJiYgUGh5c2ljc18xMi5QaHlzaWNzLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiZWZvcmVCcm9hZHBoYXNlID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jyb2FkcGhhc2UudXBkYXRlKHRoaXMuYWN0b3JzLCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFpcnMgPSB0aGlzLl9icm9hZHBoYXNlLmJyb2FkcGhhc2UodGhpcy5hY3RvcnMsIGRlbHRhLCBlbmdpbmUuc3RhdHMuY3VyckZyYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciBhZnRlckJyb2FkcGhhc2UgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZU5hcnJvd3BoYXNlID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVyID0gUGh5c2ljc18xMi5QaHlzaWNzLmNvbGxpc2lvblBhc3NlcztcclxuICAgICAgICAgICAgICAgIHZhciBjb2xsaXNpb25EZWx0YSA9IGRlbHRhIC8gaXRlcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpdGVyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB0aGUgbmFycm93cGhhc2VcclxuICAgICAgICAgICAgICAgICAgICBwYWlycyA9IHRoaXMuX2Jyb2FkcGhhc2UubmFycm93cGhhc2UocGFpcnMsIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biBjb2xsaXNpb24gcmVzb2x1dGlvbiBzdHJhdGVneVxyXG4gICAgICAgICAgICAgICAgICAgIHBhaXJzID0gdGhpcy5fYnJvYWRwaGFzZS5yZXNvbHZlKHBhaXJzLCBjb2xsaXNpb25EZWx0YSwgUGh5c2ljc18xMi5QaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS5ydW5Db2xsaXNpb25TdGFydEVuZChwYWlycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlci0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGFmdGVyTmFycm93cGhhc2UgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5waHlzaWNzLmJyb2FkcGhhc2UgPSBhZnRlckJyb2FkcGhhc2UgLSBiZWZvcmVCcm9hZHBoYXNlO1xyXG4gICAgICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5waHlzaWNzLm5hcnJvd3BoYXNlID0gYWZ0ZXJOYXJyb3dwaGFzZSAtIGJlZm9yZU5hcnJvd3BoYXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLmtpbGxlZCA9IHRoaXMuX2tpbGxRdWV1ZS5sZW5ndGggKyB0aGlzLl90cmlnZ2VyS2lsbFF1ZXVlLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0tpbGxRdWV1ZSh0aGlzLl9raWxsUXVldWUsIHRoaXMuYWN0b3JzKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0tpbGxRdWV1ZSh0aGlzLl90cmlnZ2VyS2lsbFF1ZXVlLCB0aGlzLnRyaWdnZXJzKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0dXBkYXRlJywgbmV3IEV2ZW50c18xMy5Qb3N0VXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLl9wcm9jZXNzS2lsbFF1ZXVlID0gZnVuY3Rpb24gKGtpbGxRdWV1ZSwgY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgYWN0b3JzIGZyb20gc2NlbmUgZ3JhcGggYWZ0ZXIgYmVpbmcga2lsbGVkXHJcbiAgICAgICAgICAgIHZhciBhY3RvckluZGV4O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGtpbGxRdWV1ZV8xID0ga2lsbFF1ZXVlOyBfaSA8IGtpbGxRdWV1ZV8xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtpbGxlZCA9IGtpbGxRdWV1ZV8xW19pXTtcclxuICAgICAgICAgICAgICAgIGFjdG9ySW5kZXggPSBjb2xsZWN0aW9uLmluZGV4T2Yoa2lsbGVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChhY3RvckluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3J0ZWREcmF3aW5nVHJlZS5yZW1vdmVCeUNvbXBhcmFibGUoa2lsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnNwbGljZShhY3RvckluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBraWxsUXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYXdzIGFsbCB0aGUgYWN0b3JzIGluIHRoZSBTY2VuZS4gQ2FsbGVkIGJ5IHRoZSBbW0VuZ2luZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggICAgVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGRyYXdcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZHJhdycsIG5ldyBFdmVudHNfMTMuUHJlRHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS5kcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGksIGxlbjtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy50aWxlTWFwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlTWFwc1tpXS5kcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzb3J0ZWRDaGlsZHJlbiA9IHRoaXMuX3NvcnRlZERyYXdpbmdUcmVlLmxpc3QoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc29ydGVkQ2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZHJhdyBhY3RvcnMgdGhhdCBhcmUgdmlzaWJsZSBhbmQgb24gc2NyZWVuXHJcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkQ2hpbGRyZW5baV0udmlzaWJsZSAmJiAhc29ydGVkQ2hpbGRyZW5baV0uaXNPZmZTY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRDaGlsZHJlbltpXS5kcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZSAmJiB0aGlzLmVuZ2luZS5pc0RlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAneWVsbG93JztcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy51aUFjdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkcmF3IHVpIGFjdG9ycyB0aGF0IGFyZSB2aXNpYmxlIGFuZCBvbiBzY3JlZW5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVpQWN0b3JzW2ldLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVpQWN0b3JzW2ldLmRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lICYmIHRoaXMuZW5naW5lLmlzRGVidWcpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudWlBY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVpQWN0b3JzW2ldLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdGRyYXcnLCBuZXcgRXZlbnRzXzEzLlBvc3REcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgYWxsIHRoZSBhY3RvcnMnIGRlYnVnIGluZm9ybWF0aW9uIGluIHRoZSBTY2VuZS4gQ2FsbGVkIGJ5IHRoZSBbW0VuZ2luZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggIFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWRlYnVnZHJhdycsIG5ldyBFdmVudHNfMTMuUHJlRGVidWdEcmF3RXZlbnQoY3R4LCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW47XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudGlsZU1hcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGlsZU1hcHNbaV0uZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5hY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JzW2ldLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudHJpZ2dlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcnNbaV0uZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS5kZWJ1Z0RyYXcoY3R4LCAyMCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkZWJ1Z2RyYXcnLCBuZXcgRXZlbnRzXzEzLlBvc3REZWJ1Z0RyYXdFdmVudChjdHgsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGFjdG9yIGlzIGNvbnRhaW5lZCBpbiB0aGlzIHNjZW5lIG9yIG5vdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RvcnMuaW5kZXhPZihhY3RvcikgPiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBBY3Rvcl8xNC5BY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LnVua2lsbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBVSUFjdG9yXzUuVUlBY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFVdGlsLmNvbnRhaW5zKHRoaXMudWlBY3RvcnMsIGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFVJQWN0b3IoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgQWN0b3JfMTQuQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICghVXRpbC5jb250YWlucyh0aGlzLmFjdG9ycywgZW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbWVyXzMuVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghVXRpbC5jb250YWlucyh0aGlzLl90aW1lcnMsIGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbWVyKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbGVNYXBfMy5UaWxlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIVV0aWwuY29udGFpbnModGhpcy50aWxlTWFwcywgZW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGlsZU1hcChlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVUlBY3Rvcl81LlVJQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVUlBY3RvcihlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBBY3Rvcl8xNC5BY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS51bnRyYWNrKGVudGl0eS5ib2R5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNoaWxkKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbWVyXzMuVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGlsZU1hcF8zLlRpbGVNYXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZU1hcChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIChhbnkpIGFjdG9yIHRvIGFjdCBhcyBhIHBpZWNlIG9mIFVJLCBtZWFuaW5nIGl0IGlzIGFsd2F5cyBwb3NpdGlvbmVkXHJcbiAgICAgICAgICogaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBVSSBhY3RvcnMgZG8gbm90IHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnMuXHJcbiAgICAgICAgICogQHRvZG8gU2hvdWxkIHRoaXMgYmUgYFVJQWN0b3JgIG9ubHk/XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZFVJQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy51aUFjdG9ycy5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgYWN0b3Iuc2NlbmUgPSB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbiBhY3RvciBhcyBhIHBpZWNlIG9mIFVJXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZVVJQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy51aUFjdG9ycy5pbmRleE9mKGFjdG9yKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudWlBY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbiBhY3RvciB0byB0aGUgc2NlbmUsIG9uY2UgdGhpcyBpcyBkb25lIHRoZSBhY3RvciB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5fYWRkQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS50cmFjayhhY3Rvci5ib2R5KTtcclxuICAgICAgICAgICAgYWN0b3Iuc2NlbmUgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3IgaW5zdGFuY2VvZiBUcmlnZ2VyXzMuVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2Vycy5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JzLnB1c2goYWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZERyYXdpbmdUcmVlLmFkZChhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgW1tUaWxlTWFwXV0gdG8gdGhlIHNjZW5lLCBvbmNlIHRoaXMgaXMgZG9uZSB0aGUgVGlsZU1hcCB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcclxuICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5wdXNoKHRpbGVNYXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIFtbVGlsZU1hcF1dIGZyb20gdGhlIHNjZW5lLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy50aWxlTWFwcy5pbmRleE9mKHRpbGVNYXApO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGZyb20gdGhlIHNjZW5lLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5fcmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS51bnRyYWNrKGFjdG9yLmJvZHkpO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3IgaW5zdGFuY2VvZiBUcmlnZ2VyXzMuVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcktpbGxRdWV1ZS5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tpbGxRdWV1ZS5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3Rvci5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIFtbVGltZXJdXSB0byB0aGUgc2NlbmVcclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byBhZGRcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuYWRkVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGltZXJzLnB1c2godGltZXIpO1xyXG4gICAgICAgICAgICB0aW1lci5zY2VuZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aW1lcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBbW1RpbWVyXV0gZnJvbSB0aGUgc2NlbmUuXHJcbiAgICAgICAgICogQHdhcm5pbmcgQ2FuIGJlIGRhbmdlcm91cywgdXNlIFtbY2FuY2VsVGltZXJdXSBpbnN0ZWFkXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gcmVtb3ZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZVRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fdGltZXJzLmluZGV4T2YodGltZXIpO1xyXG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuY2VscyBhIFtbVGltZXJdXSwgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgc2NlbmUgbmljZWx5XHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gY2FuY2VsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmNhbmNlbFRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlLnB1c2godGltZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGltZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyB3aGV0aGVyIGEgW1tUaW1lcl1dIGlzIGFjdGl2ZSBpbiB0aGUgc2NlbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuaXNUaW1lckFjdGl2ZSA9IGZ1bmN0aW9uICh0aW1lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3RpbWVycy5pbmRleE9mKHRpbWVyKSA+IC0xICYmICF0aW1lci5jb21wbGV0ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIGEgW1tHcm91cF1dIHRvIHRoZSBzY2VuZSB3aXRoIGEgbmFtZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5jcmVhdGVHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3JvdXBfMi5Hcm91cChuYW1lLCB0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBbW0dyb3VwXV0gYnkgbmFtZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5nZXRHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyb3Vwc1tuYW1lXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGdyb3VwID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW2dyb3VwXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChncm91cCBpbnN0YW5jZW9mIEdyb3VwXzIuR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tncm91cC5uYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignSW52YWxpZCBhcmd1bWVudHMgdG8gcmVtb3ZlR3JvdXAnLCBncm91cCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGFjdG9yIGZyb20gdGhlIHNvcnRlZCBkcmF3aW5nIHRyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuY2xlYW51cERyYXdUcmVlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZERyYXdpbmdUcmVlLnJlbW92ZUJ5Q29tcGFyYWJsZShhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBnaXZlbiBhY3RvcidzIHBvc2l0aW9uIGluIHRoZSBzb3J0ZWQgZHJhd2luZyB0cmVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnVwZGF0ZURyYXdUcmVlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZERyYXdpbmdUcmVlLmFkZChhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuX2NvbGxlY3RBY3RvclN0YXRzID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy51aUFjdG9yczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdWkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy51aSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLmFjdG9yczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhY3RvciA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLmFsaXZlKys7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gYWN0b3IuY2hpbGRyZW47IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2VbX2RdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBY3RvclV0aWxzLmlzVUlBY3RvcihjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5hY3RvcnMudWkrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLmFsaXZlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2NlbmU7XHJcbiAgICB9KENsYXNzXzEwLkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLlNjZW5lID0gU2NlbmU7XHJcbn0pO1xyXG5kZWZpbmUoXCJFdmVudHNcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBldmVudCB0eXBlIGluIEV4Y2FsaWJ1ciB0aGF0IGFsbCBvdGhlciBldmVudCB0eXBlcyBkZXJpdmUgZnJvbS4gTm90IGFsbCBldmVudCB0eXBlcyBhcmUgdGhyb3duIG9uIGFsbCBFeGNhbGlidXIgZ2FtZSBvYmplY3RzLFxyXG4gICAgICogc29tZSBldmVudHMgYXJlIHVuaXF1ZSB0byBhIHR5cGUsIG90aGVycyBhcmUgbm90LlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVFdmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZUV2ZW50KCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR2FtZUV2ZW50O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuR2FtZUV2ZW50ID0gR2FtZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ2tpbGwnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzIHdoZW4gaXQgaXMga2lsbGVkLiBUaGUgdGFyZ2V0IGlzIHRoZSBhY3RvciB0aGF0IHdhcyBraWxsZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciBLaWxsRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhLaWxsRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gS2lsbEV2ZW50KHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEtpbGxFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLktpbGxFdmVudCA9IEtpbGxFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdzdGFydCcgZXZlbnQgaXMgZW1pdHRlZCBvbiBlbmdpbmUgd2hlbiBoYXMgc3RhcnRlZCBhbmQgaXMgcmVhZHkgZm9yIGludGVyYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZVN0YXJ0RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lU3RhcnRFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lU3RhcnRFdmVudCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lU3RhcnRFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkdhbWVTdGFydEV2ZW50ID0gR2FtZVN0YXJ0RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAnc3RvcCcgZXZlbnQgaXMgZW1pdHRlZCBvbiBlbmdpbmUgd2hlbiBoYXMgYmVlbiBzdG9wcGVkIGFuZCB3aWxsIG5vIGxvbmdlciB0YWtlIGlucHV0LCB1cGRhdGUgb3IgZHJhdy5cclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVTdG9wRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lU3RvcEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVTdG9wRXZlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR2FtZVN0b3BFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkdhbWVTdG9wRXZlbnQgPSBHYW1lU3RvcEV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3ByZWRyYXcnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYmVmb3JlIGRyYXdpbmcgc3RhcnRzLiBBY3RvcnMnIHByZWRyYXcgaGFwcGVucyBpbnNpZGUgdGhlaXIgZ3JhcGhpY3NcclxuICAgICAqIHRyYW5zZm9ybSBzbyB0aGF0IGFsbCBkcmF3aW5nIHRha2VzIHBsYWNlIHdpdGggdGhlIGFjdG9yIGFzIHRoZSBvcmlnaW4uXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICB2YXIgUHJlRHJhd0V2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUHJlRHJhd0V2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFByZURyYXdFdmVudChjdHgsIGRlbHRhLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByZURyYXdFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlByZURyYXdFdmVudCA9IFByZURyYXdFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwb3N0ZHJhdycgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgYW5kIGVuZ2luZSBhZnRlciBkcmF3aW5nIGZpbmlzaGVzLiBBY3RvcnMnIHBvc3RkcmF3IGhhcHBlbnMgaW5zaWRlIHRoZWlyIGdyYXBoaWNzXHJcbiAgICAgKiB0cmFuc2Zvcm0gc28gdGhhdCBhbGwgZHJhd2luZyB0YWtlcyBwbGFjZSB3aXRoIHRoZSBhY3RvciBhcyB0aGUgb3JpZ2luLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdmFyIFBvc3REcmF3RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb3N0RHJhd0V2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvc3REcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICAgICAgX3RoaXMuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQb3N0RHJhd0V2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUG9zdERyYXdFdmVudCA9IFBvc3REcmF3RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAncHJlZGVidWdkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGJlZm9yZSBkZWJ1ZyBkcmF3aW5nIHN0YXJ0cy5cclxuICAgICAqL1xyXG4gICAgdmFyIFByZURlYnVnRHJhd0V2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUHJlRGVidWdEcmF3RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUHJlRGVidWdEcmF3RXZlbnQoY3R4LCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByZURlYnVnRHJhd0V2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUHJlRGVidWdEcmF3RXZlbnQgPSBQcmVEZWJ1Z0RyYXdFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwb3N0ZGVidWdkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGFmdGVyIGRlYnVnIGRyYXdpbmcgc3RhcnRzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUG9zdERlYnVnRHJhd0V2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUG9zdERlYnVnRHJhd0V2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvc3REZWJ1Z0RyYXdFdmVudChjdHgsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5jdHggPSBjdHg7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUG9zdERlYnVnRHJhd0V2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUG9zdERlYnVnRHJhd0V2ZW50ID0gUG9zdERlYnVnRHJhd0V2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3ByZXVwZGF0ZScgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgYW5kIGVuZ2luZSBiZWZvcmUgdGhlIHVwZGF0ZSBzdGFydHMuXHJcbiAgICAgKi9cclxuICAgIHZhciBQcmVVcGRhdGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFByZVVwZGF0ZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFByZVVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJlVXBkYXRlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5QcmVVcGRhdGVFdmVudCA9IFByZVVwZGF0ZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3Bvc3R1cGRhdGUnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYWZ0ZXIgdGhlIHVwZGF0ZSBlbmRzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUG9zdFVwZGF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUG9zdFVwZGF0ZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvc3RVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBvc3RVcGRhdGVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlBvc3RVcGRhdGVFdmVudCA9IFBvc3RVcGRhdGVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwcmVmcmFtZScgZXZlbnQgaXMgZW1pdHRlZCBvbiB0aGUgZW5naW5lLCBiZWZvcmUgdGhlIGZyYW1lIGJlZ2lucy5cclxuICAgICAqL1xyXG4gICAgdmFyIFByZUZyYW1lRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQcmVGcmFtZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFByZUZyYW1lRXZlbnQoZW5naW5lLCBwcmV2U3RhdHMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICBfdGhpcy5wcmV2U3RhdHMgPSBwcmV2U3RhdHM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IGVuZ2luZTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJlRnJhbWVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlByZUZyYW1lRXZlbnQgPSBQcmVGcmFtZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3Bvc3RmcmFtZScgZXZlbnQgaXMgZW1pdHRlZCBvbiB0aGUgZW5naW5lLCBhZnRlciBhIGZyYW1lIGVuZHMuXHJcbiAgICAgKi9cclxuICAgIHZhciBQb3N0RnJhbWVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBvc3RGcmFtZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvc3RGcmFtZUV2ZW50KGVuZ2luZSwgc3RhdHMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0cyA9IHN0YXRzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBvc3RGcmFtZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUG9zdEZyYW1lRXZlbnQgPSBQb3N0RnJhbWVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgcmVjZWl2ZWQgd2hlbiBhIGdhbWVwYWQgaXMgY29ubmVjdGVkIHRvIEV4Y2FsaWJ1ci4gW1tHYW1lcGFkc11dIHJlY2VpdmVzIHRoaXMgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lcGFkQ29ubmVjdEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZENvbm5lY3RFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lcGFkQ29ubmVjdEV2ZW50KGluZGV4LCBnYW1lcGFkKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIF90aGlzLmdhbWVwYWQgPSBnYW1lcGFkO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBnYW1lcGFkO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lcGFkQ29ubmVjdEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuR2FtZXBhZENvbm5lY3RFdmVudCA9IEdhbWVwYWRDb25uZWN0RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHJlY2VpdmVkIHdoZW4gYSBnYW1lcGFkIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIEV4Y2FsaWJ1ci4gW1tHYW1lcGFkc11dIHJlY2VpdmVzIHRoaXMgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lcGFkRGlzY29ubmVjdEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZERpc2Nvbm5lY3RFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lcGFkRGlzY29ubmVjdEV2ZW50KGluZGV4LCBnYW1lcGFkKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIF90aGlzLmdhbWVwYWQgPSBnYW1lcGFkO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBnYW1lcGFkO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lcGFkRGlzY29ubmVjdEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuR2FtZXBhZERpc2Nvbm5lY3RFdmVudCA9IEdhbWVwYWREaXNjb25uZWN0RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEdhbWVwYWQgYnV0dG9uIGV2ZW50LiBTZWUgW1tHYW1lcGFkc11dIGZvciBpbmZvcm1hdGlvbiBvbiByZXNwb25kaW5nIHRvIGNvbnRyb2xsZXIgaW5wdXQuIFtbR2FtZXBhZF1dIGluc3RhbmNlcyByZWNlaXZlIHRoaXMgZXZlbnQ7XHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lcGFkQnV0dG9uRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkQnV0dG9uRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGJ1dHRvbiAgVGhlIEdhbWVwYWQgYnV0dG9uXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlICAgQSBudW1lcmljIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRCdXR0b25FdmVudChidXR0b24sIHZhbHVlLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuYnV0dG9uID0gYnV0dG9uO1xyXG4gICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdhbWVwYWRCdXR0b25FdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkdhbWVwYWRCdXR0b25FdmVudCA9IEdhbWVwYWRCdXR0b25FdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogR2FtZXBhZCBheGlzIGV2ZW50LiBTZWUgW1tHYW1lcGFkc11dIGZvciBpbmZvcm1hdGlvbiBvbiByZXNwb25kaW5nIHRvIGNvbnRyb2xsZXIgaW5wdXQuIFtbR2FtZXBhZF1dIGluc3RhbmNlcyByZWNlaXZlIHRoaXMgZXZlbnQ7XHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lcGFkQXhpc0V2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZEF4aXNFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gYXhpcyAgVGhlIEdhbWVwYWQgYXhpc1xyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBBIG51bWVyaWMgdmFsdWUgYmV0d2VlbiAtMSBhbmQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRBeGlzRXZlbnQoYXhpcywgdmFsdWUsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5heGlzID0gYXhpcztcclxuICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lcGFkQXhpc0V2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuR2FtZXBhZEF4aXNFdmVudCA9IEdhbWVwYWRBeGlzRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBldmVudCB0aHJvd24gd2hlbiBoYW5kbGVycyBmb3IgZXZlbnRzIG90aGVyIHRoYW4gc3Vic2NyaWJlIGFyZSBhZGRlZC4gTWV0YSBldmVudCB0aGF0IGlzIHJlY2VpdmVkIGJ5XHJcbiAgICAgKiBbW0V2ZW50RGlzcGF0Y2hlcnxldmVudCBkaXNwYXRjaGVyc11dLlxyXG4gICAgICovXHJcbiAgICB2YXIgU3Vic2NyaWJlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTdWJzY3JpYmVFdmVudCh0b3BpYywgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50b3BpYyA9IHRvcGljO1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU3Vic2NyaWJlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5TdWJzY3JpYmVFdmVudCA9IFN1YnNjcmliZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZSBldmVudCB0aHJvd24gd2hlbiBoYW5kbGVycyBmb3IgZXZlbnRzIG90aGVyIHRoYW4gdW5zdWJzY3JpYmUgYXJlIHJlbW92ZWQuIE1ldGEgZXZlbnQgdGhhdCBpcyByZWNlaXZlZCBieVxyXG4gICAgICogW1tFdmVudERpc3BhdGNoZXJ8ZXZlbnQgZGlzcGF0Y2hlcnNdXS5cclxuICAgICAqL1xyXG4gICAgdmFyIFVuc3Vic2NyaWJlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhVbnN1YnNjcmliZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFVuc3Vic2NyaWJlRXZlbnQodG9waWMsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudG9waWMgPSB0b3BpYztcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFVuc3Vic2NyaWJlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5VbnN1YnNjcmliZUV2ZW50ID0gVW5zdWJzY3JpYmVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgcmVjZWl2ZWQgYnkgdGhlIFtbRW5naW5lXV0gd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgdmlzaWJsZSBvbiBhIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgdmFyIFZpc2libGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFZpc2libGVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBWaXNpYmxlRXZlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVmlzaWJsZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuVmlzaWJsZUV2ZW50ID0gVmlzaWJsZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCByZWNlaXZlZCBieSB0aGUgW1tFbmdpbmVdXSB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyBoaWRkZW4gZnJvbSBhbGwgc2NyZWVucy5cclxuICAgICAqL1xyXG4gICAgdmFyIEhpZGRlbkV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoSGlkZGVuRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gSGlkZGVuRXZlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSGlkZGVuRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5IaWRkZW5FdmVudCA9IEhpZGRlbkV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3RvcnxhY3Rvcl1dIHdoZW4gYSBjb2xsaXNpb24gd2lsbCBvY2N1ciB0aGlzIGZyYW1lIGlmIGl0IHJlc29sdmVzXHJcbiAgICAgKi9cclxuICAgIHZhciBQcmVDb2xsaXNpb25FdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFByZUNvbGxpc2lvbkV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciAgICAgICAgIFRoZSBhY3RvciB0aGUgZXZlbnQgd2FzIHRocm93biBvblxyXG4gICAgICAgICAqIEBwYXJhbSBvdGhlciAgICAgICAgIFRoZSBhY3RvciB0aGF0IHdpbGwgY29sbGlkZWQgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBzaWRlICAgICAgICAgIFRoZSBzaWRlIHRoYXQgd2lsbCBiZSBjb2xsaWRlZCB3aXRoIHRoZSBjdXJyZW50IGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGludGVyc2VjdGlvbiAgSW50ZXJzZWN0aW9uIHZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFByZUNvbGxpc2lvbkV2ZW50KGFjdG9yLCBvdGhlciwgc2lkZSwgaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIF90aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgICAgIF90aGlzLnNpZGUgPSBzaWRlO1xyXG4gICAgICAgICAgICBfdGhpcy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcmVDb2xsaXNpb25FdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlByZUNvbGxpc2lvbkV2ZW50ID0gUHJlQ29sbGlzaW9uRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yfGFjdG9yXV0gd2hlbiBhIGNvbGxpc2lvbiBoYXMgYmVlbiByZXNvbHZlZCAoYm9keSByZWFjdGVkKSB0aGlzIGZyYW1lXHJcbiAgICAgKi9cclxuICAgIHZhciBQb3N0Q29sbGlzaW9uRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb3N0Q29sbGlzaW9uRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICAgICAgICAgVGhlIGFjdG9yIHRoZSBldmVudCB3YXMgdGhyb3duIG9uXHJcbiAgICAgICAgICogQHBhcmFtIG90aGVyICAgICAgICAgVGhlIGFjdG9yIHRoYXQgZGlkIGNvbGxpZGUgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBzaWRlICAgICAgICAgIFRoZSBzaWRlIHRoYXQgZGlkIGNvbGxpZGUgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBpbnRlcnNlY3Rpb24gIEludGVyc2VjdGlvbiB2ZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBQb3N0Q29sbGlzaW9uRXZlbnQoYWN0b3IsIG90aGVyLCBzaWRlLCBpbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgX3RoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICAgICAgX3RoaXMuc2lkZSA9IHNpZGU7XHJcbiAgICAgICAgICAgIF90aGlzLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBvc3RDb2xsaXNpb25FdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlBvc3RDb2xsaXNpb25FdmVudCA9IFBvc3RDb2xsaXNpb25FdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIHRoZSBmaXJzdCB0aW1lIGFuIFtbQWN0b3J8YWN0b3JdXSBjb2xsaWRlcyB3aXRoIGFub3RoZXIsIGFmdGVyIGFuIGFjdG9yIGlzIGluIGNvbnRhY3Qgbm9ybWFsIGNvbGxpc2lvbiBldmVudHMgYXJlIGZpcmVkLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sbGlzaW9uU3RhcnRFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKENvbGxpc2lvblN0YXJ0RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDb2xsaXNpb25TdGFydEV2ZW50KGFjdG9yLCBvdGhlciwgcGFpcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICBfdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgICAgICBfdGhpcy5wYWlyID0gcGFpcjtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvblN0YXJ0RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Db2xsaXNpb25TdGFydEV2ZW50ID0gQ29sbGlzaW9uU3RhcnRFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIHdoZW4gdGhlIFtbQWN0b3J8YWN0b3JdXSBpcyBubyBsb25nZXIgY29sbGlkaW5nIHdpdGggYW5vdGhlclxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sbGlzaW9uRW5kRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhDb2xsaXNpb25FbmRFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbGxpc2lvbkVuZEV2ZW50KGFjdG9yLCBvdGhlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICBfdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uRW5kRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Db2xsaXNpb25FbmRFdmVudCA9IENvbGxpc2lvbkVuZEV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3Rvcl1dIGFuZCBhIFtbU2NlbmVdXSBvbmx5IG9uY2UgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgY2FsbFxyXG4gICAgICovXHJcbiAgICB2YXIgSW5pdGlhbGl6ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoSW5pdGlhbGl6ZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUgIFRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZW5naW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBJbml0aWFsaXplRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Jbml0aWFsaXplRXZlbnQgPSBJbml0aWFsaXplRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhIFtbU2NlbmVdXSBvbiBhY3RpdmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBBY3RpdmF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoQWN0aXZhdGVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gb2xkU2NlbmUgIFRoZSByZWZlcmVuY2UgdG8gdGhlIG9sZCBzY2VuZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEFjdGl2YXRlRXZlbnQob2xkU2NlbmUsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5vbGRTY2VuZSA9IG9sZFNjZW5lO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFjdGl2YXRlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5BY3RpdmF0ZUV2ZW50ID0gQWN0aXZhdGVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGEgW1tTY2VuZV1dIG9uIGRlYWN0aXZhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgRGVhY3RpdmF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRGVhY3RpdmF0ZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBuZXdTY2VuZSAgVGhlIHJlZmVyZW5jZSB0byB0aGUgbmV3IHNjZW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRGVhY3RpdmF0ZUV2ZW50KG5ld1NjZW5lLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMubmV3U2NlbmUgPSBuZXdTY2VuZTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBEZWFjdGl2YXRlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5EZWFjdGl2YXRlRXZlbnQgPSBEZWFjdGl2YXRlRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yXV0gd2hlbiBpdCBjb21wbGV0ZWx5IGxlYXZlcyB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICB2YXIgRXhpdFZpZXdQb3J0RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhFeGl0Vmlld1BvcnRFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBFeGl0Vmlld1BvcnRFdmVudCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFeGl0Vmlld1BvcnRFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkV4aXRWaWV3UG9ydEV2ZW50ID0gRXhpdFZpZXdQb3J0RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yXV0gd2hlbiBpdCBjb21wbGV0ZWx5IGxlYXZlcyB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICB2YXIgRW50ZXJWaWV3UG9ydEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRW50ZXJWaWV3UG9ydEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEVudGVyVmlld1BvcnRFdmVudCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFbnRlclZpZXdQb3J0RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5FbnRlclZpZXdQb3J0RXZlbnQgPSBFbnRlclZpZXdQb3J0RXZlbnQ7XHJcbiAgICB2YXIgRW50ZXJUcmlnZ2VyRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhFbnRlclRyaWdnZXJFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBFbnRlclRyaWdnZXJFdmVudCh0YXJnZXQsIGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgX3RoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRW50ZXJUcmlnZ2VyRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5FbnRlclRyaWdnZXJFdmVudCA9IEVudGVyVHJpZ2dlckV2ZW50O1xyXG4gICAgdmFyIEV4aXRUcmlnZ2VyRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhFeGl0VHJpZ2dlckV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEV4aXRUcmlnZ2VyRXZlbnQodGFyZ2V0LCBhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEV4aXRUcmlnZ2VyRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5FeGl0VHJpZ2dlckV2ZW50ID0gRXhpdFRyaWdnZXJFdmVudDtcclxufSk7XHJcbmRlZmluZShcIkNsYXNzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRXZlbnREaXNwYXRjaGVyXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgRXZlbnREaXNwYXRjaGVyXzMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGNhbGlidXIgYmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIGJhc2ljIGZ1bmN0aW9uYWxpdHkgc3VjaCBhcyBbW0V2ZW50RGlzcGF0Y2hlcl1dXHJcbiAgICAgKiBhbmQgZXh0ZW5kaW5nIGFiaWxpdGllcyBmb3IgdmFuaWxsYSBKYXZhc2NyaXB0IHByb2plY3RzXHJcbiAgICAgKi9cclxuICAgIHZhciBDbGFzcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ2xhc3MoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcl8zLkV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxpYXMgZm9yIGBhZGRFdmVudExpc3RlbmVyYC4gWW91IGNhbiBsaXN0ZW4gZm9yIGEgdmFyaWV0eSBvZlxyXG4gICAgICAgICAqIGV2ZW50cyBvZmYgb2YgdGhlIGVuZ2luZTsgc2VlIHRoZSBldmVudHMgc2VjdGlvbiBiZWxvdyBmb3IgYSBjb21wbGV0ZSBsaXN0LlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciAgICBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2xhc3MucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxpYXMgZm9yIGByZW1vdmVFdmVudExpc3RlbmVyYC4gSWYgb25seSB0aGUgZXZlbnROYW1lIGlzIHNwZWNpZmllZFxyXG4gICAgICAgICAqIGl0IHdpbGwgcmVtb3ZlIGFsbCBoYW5kbGVycyByZWdpc3RlcmVkIGZvciB0aGF0IHNwZWNpZmljIGV2ZW50LiBJZiB0aGUgZXZlbnROYW1lXHJcbiAgICAgICAgICogYW5kIHRoZSBoYW5kbGVyIGluc3RhbmNlIGFyZSBzcGVjaWZpZWQgb25seSB0aGF0IGhhbmRsZXIgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAgTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxyXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyICAgIEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBDbGFzcy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVtaXRzIGEgbmV3IGV2ZW50XHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAgIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXRcclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnRPYmplY3QgRGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRPYmplY3QpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIGV2ZW50T2JqZWN0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9uY2UgbGlzdGVucyB0byBhbiBldmVudCBvbmUgdGltZSwgdGhlbiB1bnN1YnNjcmliZXMgZnJvbSB0aGF0IGV2ZW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG8gb25jZVxyXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyICAgVGhlIGhhbmRsZXIgb2YgdGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBhdXRvIHVuc3Vic2NyaWJlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBZb3UgbWF5IHdpc2ggdG8gZXh0ZW5kIG5hdGl2ZSBFeGNhbGlidXIgZnVuY3Rpb25hbGl0eSBpbiB2YW5pbGxhIEphdmFzY3JpcHQuXHJcbiAgICAgICAgICogQW55IG1ldGhvZCBvbiBhIGNsYXNzIGluaGVyaXRpbmcgW1tDbGFzc11dIG1heSBiZSBleHRlbmRlZCB0byBzdXBwb3J0XHJcbiAgICAgICAgICogYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5LiBJbiB0aGUgZXhhbXBsZSBiZWxvdyB3ZSBjcmVhdGUgYSBuZXcgdHlwZSBjYWxsZWQgYE15QWN0b3JgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGBqc1xyXG4gICAgICAgICAqIHZhciBNeUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgKiAgICAgICB0aGlzLm5ld3Byb3AgPSAnc29tZXRoaW5nJztcclxuICAgICAgICAgKiAgICAgICBBY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAqICAgIH0sXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgKiAgICAgICAvLyBJbXBsZW1lbnQgY3VzdG9tIHVwZGF0ZVxyXG4gICAgICAgICAqICAgICAgIC8vIENhbGwgc3VwZXIgY29uc3RydWN0b3IgdXBkYXRlXHJcbiAgICAgICAgICogICAgICAgQWN0b3IucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgY29uc29sZS5sb2coXCJTb21ldGhpbmcgY29vbCFcIik7XHJcbiAgICAgICAgICogICAgfVxyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogdmFyIG15QWN0b3IgPSBuZXcgTXlBY3RvcigxMDAsIDEwMCwgMTAwLCAxMDAsIENvbG9yLkF6dXJlKTtcclxuICAgICAgICAgKiBgYGBcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEluIFR5cGVTY3JpcHQsIHlvdSBvbmx5IG5lZWQgdG8gdXNlIHRoZSBgZXh0ZW5kc2Agc3ludGF4LCB5b3UgZG8gbm90IG5lZWRcclxuICAgICAgICAgKiB0byB1c2UgdGhpcyBtZXRob2Qgb2YgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGhvZHMgQSBKU09OIG9iamVjdCBjb250YWluIGFueSBtZXRob2RzL3Byb3BlcnRpZXMgeW91IHdhbnQgdG8gZXh0ZW5kXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZHMgJiYgbWV0aG9kcy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBtZXRob2RzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBVc2luZyBjb25zdHJ1Y3RvciBhbGxvd3MgSlMgdG8gbGF6aWx5IGluc3RhbnRpYXRlIHN1cGVyIGNsYXNzZXNcclxuICAgICAgICAgICAgdmFyIFN1cGVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH07XHJcbiAgICAgICAgICAgIFN1cGVyLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXBlcjtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gbWV0aG9kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZVtwcm9wXSA9IG1ldGhvZHNbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3ViY2xhc3NlcyBleHRlbmRhYmxlXHJcbiAgICAgICAgICAgIGNoaWxkLmV4dGVuZCA9IENsYXNzLmV4dGVuZDtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENsYXNzO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcclxufSk7XHJcbmRlZmluZShcIkFjdG9yXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkNsYXNzXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFwiUmVzb3VyY2VzL1RleHR1cmVcIiwgXCJFdmVudHNcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiRHJhd2luZy9TcHJpdGVcIiwgXCJVdGlsL0xvZ1wiLCBcIkFjdGlvbnMvQWN0aW9uQ29udGV4dFwiLCBcIkFjdGlvbnMvQWN0aW9uXCIsIFwiQWxnZWJyYVwiLCBcIkNvbGxpc2lvbi9Cb2R5XCIsIFwiQ29sbGlzaW9uL1NpZGVcIiwgXCJUcmFpdHMvSW5kZXhcIiwgXCJEcmF3aW5nL1Nwcml0ZUVmZmVjdHNcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzEzLCBDbGFzc18xMSwgQm91bmRpbmdCb3hfOCwgVGV4dHVyZV8yLCBFdmVudHNfMTQsIENvbG9yXzIwLCBTcHJpdGVfNCwgTG9nXzE2LCBBY3Rpb25Db250ZXh0XzMsIEFjdGlvbl8yLCBBbGdlYnJhXzI0LCBCb2R5XzIsIFNpZGVfNCwgVHJhaXRzLCBFZmZlY3RzLCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgaW1wb3J0YW50IHByaW1pdGl2ZSBpbiBFeGNhbGlidXIgaXMgYW4gYEFjdG9yYC4gQW55dGhpbmcgdGhhdFxyXG4gICAgICogY2FuIG1vdmUgb24gdGhlIHNjcmVlbiwgY29sbGlkZSB3aXRoIGFub3RoZXIgYEFjdG9yYCwgcmVzcG9uZCB0byBldmVudHMsXHJcbiAgICAgKiBvciBpbnRlcmFjdCB3aXRoIHRoZSBjdXJyZW50IHNjZW5lLCBtdXN0IGJlIGFuIGFjdG9yLiBBbiBgQWN0b3JgICoqbXVzdCoqXHJcbiAgICAgKiBiZSBwYXJ0IG9mIGEgW1tTY2VuZV1dIGZvciBpdCB0byBiZSBkcmF3biB0byB0aGUgc2NyZWVuLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpBY3RvcnMubWRdXVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdmFyIEFjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoQWN0b3IsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgVGhlIHN0YXJ0aW5nIHggY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICBUaGUgc3RhcnRpbmcgeSBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCAgIFRoZSBzdGFydGluZyB3aWR0aCBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0ICBUaGUgc3RhcnRpbmcgaGVpZ2h0IG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xvciAgIFRoZSBzdGFydGluZyBjb2xvciBvZiB0aGUgYWN0b3IuIExlYXZlIG51bGwgdG8gZHJhdyBhIHRyYW5zcGFyZW50IGFjdG9yLiBUaGUgb3BhY2l0eSBvZiB0aGUgY29sb3Igd2lsbCBiZSB1c2VkIGFzIHRoZVxyXG4gICAgICAgICAqIGluaXRpYWwgW1tvcGFjaXR5XV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQWN0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5pZCA9IEFjdG9yLm1heElkKys7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcGh5c2ljcyBib2R5IHRoZSBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBhY3Rvci4gVGhlIGJvZHkgaXMgdGhlIGNvbnRhaW5lciBmb3IgYWxsIHBoeXNpY2FsIHByb3BlcnRpZXMsIGxpa2UgcG9zaXRpb24sIHZlbG9jaXR5LFxyXG4gICAgICAgICAgICAgKiBhY2NlbGVyYXRpb24sIG1hc3MsIGluZXJ0aWEsIGV0Yy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmJvZHkgPSBuZXcgQm9keV8yLkJvZHkoX3RoaXMpO1xyXG4gICAgICAgICAgICBfdGhpcy5faGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX3dpZHRoID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBzY2FsZSB2ZWN0b3Igb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5zY2FsZSA9IG5ldyBBbGdlYnJhXzI0LlZlY3RvcigxLCAxKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB4IHNjYWxhciB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gc2NhbGUvc2Vjb25kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5zeCA9IDA7IC8vc2NhbGUvc2VjXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgeSBzY2FsYXIgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHNjYWxlL3NlY29uZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuc3kgPSAwOyAvL3NjYWxlL3NlY1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFjdG9yIGlzIHBoeXNpY2FsbHkgaW4gdGhlIHZpZXdwb3J0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5pc09mZlNjcmVlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHZpc2liaWxpdHkgb2YgYW4gYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIG9wYWNpdHkgb2YgYW4gYWN0b3IuIFBhc3NpbmcgaW4gYSBjb2xvciBpbiB0aGUgW1tjb25zdHJ1Y3Rvcl1dIHdpbGwgdXNlIHRoZVxyXG4gICAgICAgICAgICAgKiBjb2xvcidzIG9wYWNpdHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICAgICAgX3RoaXMucHJldmlvdXNPcGFjaXR5ID0gMTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnZlbmllbmNlIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIGxvZ2dlclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubG9nZ2VyID0gTG9nXzE2LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHNjZW5lIHRoYXQgdGhlIGFjdG9yIGlzIGluXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5zY2VuZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcGFyZW50IG9mIHRoaXMgYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIHRoZSBuZXcgYWN0b3IgY29sbGVjdGlvbiBvbmNlIHotaW5kZXhpbmcgaXMgYnVpbHRcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjaGlsZHJlbiBvZiB0aGlzIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IGNvbGxpc2lvbiB0eXBlIG9mIHRoaXMgYWN0b3IuIEJ5XHJcbiAgICAgICAgICAgICAqIGRlZmF1bHQgaXQgaXMgKFtbQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uXV0pLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuY29sbGlzaW9uVHlwZSA9IENvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgX3RoaXMuY29sbGlzaW9uR3JvdXBzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9jb2xsaXNpb25IYW5kbGVycyA9IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5mcmFtZXMgPSB7fTtcclxuICAgICAgICAgICAgX3RoaXMuX2VmZmVjdHNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWNjZXNzIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcgZm9yIHRoZSBhY3RvciwgdGhpcyBjYW4gYmVcclxuICAgICAgICAgICAgICogYW4gW1tBbmltYXRpb25dXSwgW1tTcHJpdGVdXSwgb3IgW1tQb2x5Z29uXV0uXHJcbiAgICAgICAgICAgICAqIFNldCBkcmF3aW5ncyB3aXRoIFtbc2V0RHJhd2luZ11dLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuY3VycmVudERyYXdpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTW9kaWZ5IHRoZSBjdXJyZW50IGFjdG9yIHVwZGF0ZSBwaXBlbGluZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnRyYWl0cyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gZW5hYmxlIHRoZSBbW0NhcHR1cmVQb2ludGVyXV0gdHJhaXQgdGhhdCBwcm9wYWdhdGVzXHJcbiAgICAgICAgICAgICAqIHBvaW50ZXIgZXZlbnRzIHRvIHRoaXMgYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25maWd1cmF0aW9uIGZvciBbW0NhcHR1cmVQb2ludGVyXV0gdHJhaXRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmNhcHR1cmVQb2ludGVyID0ge1xyXG4gICAgICAgICAgICAgICAgY2FwdHVyZU1vdmVFdmVudHM6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLl96SW5kZXggPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5faXNLaWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX29wYWNpdHlGeCA9IG5ldyBFZmZlY3RzLk9wYWNpdHkoX3RoaXMub3BhY2l0eSk7XHJcbiAgICAgICAgICAgIF90aGlzLnBvcy54ID0geCB8fCAwO1xyXG4gICAgICAgICAgICBfdGhpcy5wb3MueSA9IHkgfHwgMDtcclxuICAgICAgICAgICAgX3RoaXMuX3dpZHRoID0gd2lkdGggfHwgMDtcclxuICAgICAgICAgICAgX3RoaXMuX2hlaWdodCA9IGhlaWdodCB8fCAwO1xyXG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgZGVmYXVsdCBvcGFjaXR5IG9mIGFuIGFjdG9yIHRvIHRoZSBjb2xvclxyXG4gICAgICAgICAgICAgICAgX3RoaXMub3BhY2l0eSA9IGNvbG9yLmE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQnVpbGQgZGVmYXVsdCBwaXBlbGluZVxyXG4gICAgICAgICAgICAvL3RoaXMudHJhaXRzLnB1c2gobmV3IGV4LlRyYWl0cy5FdWxlck1vdmVtZW50KCkpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBUaWxlTWFwcyBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgY29sbGlzaW9uIGFyZWFcclxuICAgICAgICAgICAgX3RoaXMudHJhaXRzLnB1c2gobmV3IFRyYWl0cy5UaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uKCkpO1xyXG4gICAgICAgICAgICBfdGhpcy50cmFpdHMucHVzaChuZXcgVHJhaXRzLk9mZnNjcmVlbkN1bGxpbmcoKSk7XHJcbiAgICAgICAgICAgIF90aGlzLnRyYWl0cy5wdXNoKG5ldyBUcmFpdHMuQ2FwdHVyZVBvaW50ZXIoKSk7XHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBhY3Rpb24gcXVldWVcclxuICAgICAgICAgICAgX3RoaXMuYWN0aW9uUXVldWUgPSBuZXcgQWN0aW9uXzIuQWN0aW9uUXVldWUoX3RoaXMpO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25zID0gbmV3IEFjdGlvbkNvbnRleHRfMy5BY3Rpb25Db250ZXh0KF90aGlzKTtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdCBhbmNob3IgaXMgaW4gdGhlIG1pZGRsZVxyXG4gICAgICAgICAgICBfdGhpcy5hbmNob3IgPSBuZXcgQWxnZWJyYV8yNC5WZWN0b3IoLjUsIC41KTtcclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBkZWZhdWx0IGNvbGxpc2lvbiBhcmVhIHRvIGJlIGJveFxyXG4gICAgICAgICAgICBfdGhpcy5ib2R5LnVzZUJveENvbGxpc2lvbigpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rvci5wcm90b3R5cGUsIFwiY29sbGlzaW9uQXJlYVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBjb2xsaXNpb24gYXJlYSBzaGFwZSB0byB1c2UgZm9yIGNvbGxpc2lvbiBwb3NzaWJsZSBvcHRpb25zIGFyZSBbQ2lyY2xlQXJlYXxjaXJjbGVzXSwgW1BvbHlnb25BcmVhfHBvbHlnb25zXSwgYW5kXHJcbiAgICAgICAgICAgICAqIFtFZGdlQXJlYXxlZGdlc10uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuY29sbGlzaW9uQXJlYTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGNvbGxpc2lvbiBhcmVhIHNoYXBlIHRvIHVzZSBmb3IgY29sbGlzaW9uIHBvc3NpYmxlIG9wdGlvbnMgYXJlIFtDaXJjbGVBcmVhfGNpcmNsZXNdLCBbUG9seWdvbkFyZWF8cG9seWdvbnNdLCBhbmRcclxuICAgICAgICAgICAgICogW0VkZ2VBcmVhfGVkZ2VzXS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5jb2xsaXNpb25BcmVhID0gYXJlYTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9yLnByb3RvdHlwZSwgXCJ4XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHggcG9zaXRpb24gb2YgdGhlIGFjdG9yIHJlbGF0aXZlIHRvIGl0J3MgcGFyZW50IChpZiBhbnkpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucG9zLng7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBhY3RvciByZWxhdGl2ZSB0byBpdCdzIHBhcmVudCAoaWYgYW55KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlWCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnBvcy54ID0gdGhlWDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9yLnByb3RvdHlwZSwgXCJ5XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGFjdG9yIHJlbGF0aXZlIHRvIGl0J3MgcGFyZW50IChpZiBhbnkpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucG9zLnk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBhY3RvciByZWxhdGl2ZSB0byBpdCdzIHBhcmVudCAoaWYgYW55KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlWSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnBvcy55ID0gdGhlWTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9yLnByb3RvdHlwZSwgXCJwb3NcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgcG9zaXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wb3M7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVsc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlUG9zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkucG9zLnNldFRvKHRoZVBvcy54LCB0aGVQb3MueSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rvci5wcm90b3R5cGUsIFwib2xkUG9zXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHBvc2l0aW9uIHZlY3RvciBvZiB0aGUgYWN0b3IgZnJvbSB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm9sZFBvcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIHZlY3RvciBvZiB0aGUgYWN0b3IgaW4gdGhlIGxhc3QgZnJhbWVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVBvcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm9sZFBvcy5zZXRUbyh0aGVQb3MueCwgdGhlUG9zLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3IucHJvdG90eXBlLCBcInZlbFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS52ZWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVZlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnZlbC5zZXRUbyh0aGVWZWwueCwgdGhlVmVsLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3IucHJvdG90eXBlLCBcIm9sZFZlbFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5vbGRWZWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVZlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm9sZFZlbC5zZXRUbyh0aGVWZWwueCwgdGhlVmVsLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3IucHJvdG90eXBlLCBcImFjY1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBhY2NlbGVyYXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kL3NlY29uZC4gQW4gYWNjZWxlcmF0aW9uIHBvaW50aW5nIGRvd24gc3VjaCBhcyAoMCwgMTAwKSBtYXkgYmVcclxuICAgICAgICAgICAgICogdXNlZnVsIHRvIHNpbXVsYXRlIGEgZ3Jhdml0YXRpb25hbCBlZmZlY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuYWNjO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgYWNjZWxlcmF0aW9uIHZlY3RvciBvZiB0ZWggYWN0b3IgaW4gcGl4ZWxzL3NlY29uZC9zZWNvbmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZUFjYykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LmFjYy5zZXRUbyh0aGVBY2MueCwgdGhlQWNjLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3IucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBhY3RvciBpbiByYWRpYW5zLiAxIHJhZGlhbiA9IDE4MC9QSSBEZWdyZWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgcm90YXRpb24gb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMuIDEgcmFkaWFuID0gMTgwL1BJIERlZ3JlZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVBbmdsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnJvdGF0aW9uID0gdGhlQW5nbGU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rvci5wcm90b3R5cGUsIFwicnhcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy9zZWNvbmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5yeDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMvc2VjXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhbmd1bGFyVmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5yeCA9IGFuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9yLnByb3RvdHlwZSwgXCJ0b3JxdWVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB0b3JxdWUgYXBwbGllZCB0byB0aGUgYWN0b3IuIFRvcnF1ZSBjYW4gYmUgdGhvdWdodCBvZiBhcyByb3RhdGlvbmFsIGZvcmNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkudG9ycXVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY3VycmVudCB0b3JxdWUgYXBwbGllZCB0byB0aGUgYWN0b3IuIFRvcnF1ZSBjYW4gYmUgdGhvdWdodCBvZiBhcyByb3RhdGlvbmFsIGZvcmNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVUb3JxdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS50b3JxdWUgPSB0aGVUb3JxdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rvci5wcm90b3R5cGUsIFwibWFzc1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbWFzcyBvZiB0aGUgYWN0b3IsIG1hc3MgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJlc2lzdGFuY2UgdG8gYWNjZWxlcmF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm1hc3M7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBtYXNzIG9mIHRoZSBhY3RvciwgbWFzcyBjYW4gYmUgdGhvdWdodCBvZiBhcyB0aGUgcmVzaXN0YW5jZSB0byBhY2NlbGVyYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVNYXNzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkubWFzcyA9IHRoZU1hc3M7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rvci5wcm90b3R5cGUsIFwibW9pXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbW9tZW50IG9mIGluZXJ0aWEsIG1vaSBjYW4gYmUgdGhvdWdodCBvZiBhcyB0aGUgcmVzaXN0YW5jZSB0byByb3RhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5tb2k7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IG1vbWVudCBvZiBpbmVydGlhLCBtb2kgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJlc2lzdGFuY2UgdG8gcm90YXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVNb2kpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2kgPSB0aGVNb2k7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rvci5wcm90b3R5cGUsIFwiZnJpY3Rpb25cIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY29lZmZpY2llbnQgb2YgZnJpY3Rpb24gb24gdGhpcyBhY3RvciwgdGhpcyBjYW4gYmUgdGhvdWdodCBvZiBhcyBob3cgc3RpY2t5IG9yIHNsaXBwZXJ5IGFuIG9iamVjdCBpcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5mcmljdGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGNvZWZmaWNpZW50IG9mIGZyaWN0aW9uIG9mIHRoaXMgYWN0b3IsIHRoaXMgY2FuIHZlIHRob3VnaHQgb2YgYXMgaG93IHN0aWNrIG9yIHNsaXBwZXJ5IGFuIG9iamVjdCBpcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkuZnJpY3Rpb24gPSB0aGVGcmljdGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9yLnByb3RvdHlwZSwgXCJyZXN0aXR1dGlvblwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbiBvZiB0aGlzIGFjdG9yLCByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgZW5lcmd5IHByZXNlcnZlZCBhZnRlciBjb2xsaXNpb24uIFRoaW5rIG9mIHRoaXNcclxuICAgICAgICAgICAgICogYXMgYm91bmNpbmVzcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5yZXN0aXR1dGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGNvZWZmaWNpZW50IG9mIHJlc3RpdHV0aW9uIG9mIHRoaXMgYWN0b3IsIHJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiBlbmVyZ3kgcHJlc2VydmVkIGFmdGVyIGNvbGxpc2lvbi4gVGhpbmsgb2YgdGhpc1xyXG4gICAgICAgICAgICAgKiBhcyBib3VuY2luZXNzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlUmVzdGl0dXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5yZXN0aXR1dGlvbiA9IHRoZVJlc3RpdHV0aW9uO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3IucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGNvbG9yIG9mIHRoZSBhY3Rvci4gQSByZWN0YW5nbGUgb2YgdGhpcyBjb2xvciB3aWxsIGJlXHJcbiAgICAgICAgICAgICAqIGRyYXduIGlmIG5vIFtbSURyYXdhYmxlXV0gaXMgc3BlY2lmaWVkIGFzIHRoZSBhY3RvcnMgZHJhd2luZy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogVGhlIGRlZmF1bHQgaXMgYG51bGxgIHdoaWNoIHByZXZlbnRzIGEgcmVjdGFuZ2xlIGZyb20gYmVpbmcgZHJhd24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3IgPSB2LmNsb25lKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlIG9mIHRoZSBhY3Rvci4gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmVcclxuICAgICAgICAgKiBvdmVycmlkZGVuLiBUaGlzIGlzIHdoZXJlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkIGFjdG9ycyBzaG91bGQgdGFrZSBwbGFjZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUub25Jbml0aWFsaXplID0gZnVuY3Rpb24gKF9lbmdpbmUpIHtcclxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rvci5wcm90b3R5cGUsIFwiaXNJbml0aWFsaXplZFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHdldGhlciB0aGUgYWN0b3IgaXMgSW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5pdGlhbGl6ZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoaXMgYWN0b3IgYW5kIGFsbCBpdCdzIGNoaWxkIGFjdG9ycywgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IHRoZSBTY2VuZSBiZWZvcmUgZmlyc3QgdXBkYXRlIG5vdCBieSB1c2VycyBvZiBFeGNhbGlidXIuXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkluaXRpYWxpemUoZW5naW5lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2luaXRpYWxpemUnLCBuZXcgRXZlbnRzXzE0LkluaXRpYWxpemVFdmVudChlbmdpbmUsIHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNoaWxkcmVuOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuX2luaXRpYWxpemUoZW5naW5lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLl9jaGVja0ZvclBvaW50ZXJPcHRJbiA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkID09PSAncG9pbnRlcnVwJyB8fCBub3JtYWxpemVkID09PSAncG9pbnRlcmRvd24nIHx8IG5vcm1hbGl6ZWQgPT09ICdwb2ludGVybW92ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZCA9PT0gJ3BvaW50ZXJtb3ZlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVNb3ZlRXZlbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JQb2ludGVyT3B0SW4oZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jaGVja0ZvclBvaW50ZXJPcHRJbihldmVudE5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgY3VycmVudCBhY3RvciBpcyBhIG1lbWJlciBvZiB0aGUgc2NlbmUsIHRoaXMgd2lsbCByZW1vdmVcclxuICAgICAgICAgKiBpdCBmcm9tIHRoZSBzY2VuZSBncmFwaC4gSXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgna2lsbCcsIG5ldyBFdmVudHNfMTQuS2lsbEV2ZW50KHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNLaWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignQ2Fubm90IGtpbGwgYWN0b3IsIGl0IHdhcyBuZXZlciBhZGRlZCB0byB0aGUgU2NlbmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIGN1cnJlbnQgYWN0b3IgaXMga2lsbGVkLCBpdCB3aWxsIG5vdyBub3QgYmUga2lsbGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS51bmtpbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzS2lsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2V0aGVyIHRoZSBhY3RvciBoYXMgYmVlbiBraWxsZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmlzS2lsbGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNLaWxsZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY2hpbGQgYWN0b3IgdG8gdGhpcyBhY3Rvci4gQWxsIG1vdmVtZW50IG9mIHRoZSBjaGlsZCBhY3RvciB3aWxsIGJlXHJcbiAgICAgICAgICogcmVsYXRpdmUgdG8gdGhlIHBhcmVudCBhY3Rvci4gTWVhbmluZyBpZiB0aGUgcGFyZW50IG1vdmVzIHRoZSBjaGlsZCB3aWxsXHJcbiAgICAgICAgICogbW92ZSB3aXRoIGl0LlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciBUaGUgY2hpbGQgYWN0b3IgdG8gYWRkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICBhY3Rvci5jb2xsaXNpb25UeXBlID0gQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgICAgICBpZiAoVXRpbC5hZGRJdGVtVG9BcnJheShhY3RvciwgdGhpcy5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBjaGlsZCBhY3RvciBmcm9tIHRoaXMgYWN0b3IuXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIFRoZSBjaGlsZCBhY3RvciB0byByZW1vdmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChVdGlsLnJlbW92ZUl0ZW1Gcm9tQXJyYXkoYWN0b3IsIHRoaXMuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rvci5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUuc2V0RHJhd2luZyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmF3aW5nICE9PSB0aGlzLmZyYW1lc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmFtZXNba2V5XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNba2V5XS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSB0aGlzLmZyYW1lc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzE2LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCd0aGUgc3BlY2lmaWVkIGRyYXdpbmcga2V5IFxcJycgKyBrZXkgKyAnXFwnIGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5hZGREcmF3aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbYXJndW1lbnRzWzBdXSA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50RHJhd2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lZmZlY3RzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFNwcml0ZV80LlNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRHJhd2luZygnZGVmYXVsdCcsIGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgVGV4dHVyZV8yLlRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERyYXdpbmcoJ2RlZmF1bHQnLCBhcmd1bWVudHNbMF0uYXNTcHJpdGUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rvci5wcm90b3R5cGUsIFwielwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0WkluZGV4KCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1opIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4KG5ld1opO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSB6LWluZGV4IG9mIGFuIGFjdG9yLiBUaGUgei1pbmRleCBkZXRlcm1pbmVzIHRoZSByZWxhdGl2ZSBvcmRlciBhbiBhY3RvciBpcyBkcmF3biBpbi5cclxuICAgICAgICAgKiBBY3RvcnMgd2l0aCBhIGhpZ2hlciB6LWluZGV4IGFyZSBkcmF3biBvbiB0b3Agb2YgYWN0b3JzIHdpdGggYSBsb3dlciB6LWluZGV4XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pJbmRleDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHotaW5kZXggb2YgYW4gYWN0b3IgYW5kIHVwZGF0ZXMgaXQgaW4gdGhlIGRyYXdpbmcgbGlzdCBmb3IgdGhlIHNjZW5lLlxyXG4gICAgICAgICAqIFRoZSB6LWluZGV4IGRldGVybWluZXMgdGhlIHJlbGF0aXZlIG9yZGVyIGFuIGFjdG9yIGlzIGRyYXduIGluLlxyXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIGEgaGlnaGVyIHotaW5kZXggYXJlIGRyYXduIG9uIHRvcCBvZiBhY3RvcnMgd2l0aCBhIGxvd2VyIHotaW5kZXhcclxuICAgICAgICAgKiBAcGFyYW0gbmV3SW5kZXggbmV3IHotaW5kZXggdG8gYXNzaWduXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnNldFpJbmRleCA9IGZ1bmN0aW9uIChuZXdJbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLmNsZWFudXBEcmF3VHJlZSh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fekluZGV4ID0gbmV3SW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUudXBkYXRlRHJhd1RyZWUodGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIGEgY29sbGlzaW9uIGdyb3VwLiBBY3RvcnMgd2l0aCBubyBuYW1lZCBjb2xsaXNpb24gZ3JvdXBzIGFyZVxyXG4gICAgICAgICAqIGNvbnNpZGVyZWQgdG8gYmUgaW4gZXZlcnkgY29sbGlzaW9uIGdyb3VwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogT25jZSBpbiBhIGNvbGxpc2lvbiBncm91cChzKSBhY3RvcnMgd2lsbCBvbmx5IGNvbGxpZGUgd2l0aCBvdGhlciBhY3RvcnMgaW5cclxuICAgICAgICAgKiB0aGF0IGdyb3VwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbGxpc2lvbiBncm91cFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5hZGRDb2xsaXNpb25Hcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uR3JvdXBzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGZyb20gYSBjb2xsaXNpb24gZ3JvdXAuXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbGxpc2lvbiBncm91cFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5yZW1vdmVDb2xsaXNpb25Hcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29sbGlzaW9uR3JvdXBzLmluZGV4T2YobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uR3JvdXBzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgY2VudGVyIHBvaW50IG9mIGFuIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzI0LlZlY3Rvcih0aGlzLnBvcy54ICsgdGhpcy5nZXRXaWR0aCgpIC8gMiAtIHRoaXMuYW5jaG9yLnggKiB0aGlzLmdldFdpZHRoKCksIHRoaXMucG9zLnkgKyB0aGlzLmdldEhlaWdodCgpIC8gMiAtIHRoaXMuYW5jaG9yLnkgKiB0aGlzLmdldEhlaWdodCgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNhbGN1bGF0ZWQgd2lkdGggb2YgYW4gYWN0b3IsIGZhY3RvcmluZyBpbiBzY2FsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoICogdGhpcy5nZXRHbG9iYWxTY2FsZSgpLng7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB3aWR0aCBvZiBhbiBhY3RvciwgZmFjdG9yaW5nIGluIHRoZSBjdXJyZW50IHNjYWxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGggLyB0aGlzLnNjYWxlLng7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjYWxjdWxhdGVkIGhlaWdodCBvZiBhbiBhY3RvciwgZmFjdG9yaW5nIGluIHNjYWxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodCAqIHRoaXMuZ2V0R2xvYmFsU2NhbGUoKS55O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIGFuIGFjdG9yLCBmYWN0b3JpbmcgaW4gdGhlIGN1cnJlbnQgc2NhbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQgLyB0aGlzLnNjYWxlLnk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpLmxlZnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSByaWdodCBlZGdlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkucmlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSB0b3AgZWRnZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS50b3A7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBib3R0b20gZWRnZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5ib3R0b207XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoaXMgYWN0b3IncyByb3RhdGlvbiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBwYXJlbnQgcmVsYXRpb25zaGlwc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRXb3JsZFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGlvbiArIHRoaXMucGFyZW50LmdldFdvcmxkUm90YXRpb24oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYW4gYWN0b3IncyB3b3JsZCBwb3NpdGlvbiB0YWtpbmcgaW50byBhY2NvdW50IHBhcmVudCByZWxhdGlvbnNoaXBzLCBzY2FsaW5nLCByb3RhdGlvbiwgYW5kIHRyYW5zbGF0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyBQb3NpdGlvbiBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRXb3JsZFBvcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29sbGVjdCBwYXJlbnRzICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcztcclxuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBmaW5kIHBhcmVudHNcclxuICAgICAgICAgICAgd2hpbGUgKHJvb3QucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICByb290ID0gcm9vdC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocm9vdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHBvc2l0aW9uICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgeCA9IHBhcmVudHMucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHB4LCBwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHggKyAocC5wb3MueCAqIHAuZ2V0R2xvYmFsU2NhbGUoKS54KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBweCArIHAucG9zLng7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBhcmVudHMucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHB5LCBwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHkgKyAocC5wb3MueSAqIHAuZ2V0R2xvYmFsU2NhbGUoKS55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBweSArIHAucG9zLnk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICAvLyByb3RhdGUgYXJvdW5kIHJvb3QgYW5jaG9yXHJcbiAgICAgICAgICAgIHZhciByYSA9IHJvb3QuZ2V0V29ybGRQb3MoKTsgLy8gMTAsIDEwXHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5nZXRXb3JsZFJvdGF0aW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yNC5WZWN0b3IoeCwgeSkucm90YXRlKHIsIHJhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGdsb2JhbCBzY2FsZSBvZiB0aGUgQWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0R2xvYmFsU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yNC5WZWN0b3IodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRTY2FsZSA9IHRoaXMucGFyZW50LmdldEdsb2JhbFNjYWxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yNC5WZWN0b3IodGhpcy5zY2FsZS54ICogcGFyZW50U2NhbGUueCwgdGhpcy5zY2FsZS55ICogcGFyZW50U2NhbGUueSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhY3RvcidzIFtbQm91bmRpbmdCb3hdXSBjYWxjdWxhdGVkIGZvciB0aGlzIGluc3RhbnQgaW4gd29ybGQgc3BhY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gdG9kbyBjYWNoZSBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuX2dldENhbGN1bGF0ZWRBbmNob3IoKTtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0V29ybGRQb3MoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveF84LkJvdW5kaW5nQm94KHBvcy54IC0gYW5jaG9yLngsIHBvcy55IC0gYW5jaG9yLnksIHBvcy54ICsgdGhpcy5nZXRXaWR0aCgpIC0gYW5jaG9yLngsIHBvcy55ICsgdGhpcy5nZXRIZWlnaHQoKSAtIGFuY2hvci55KS5yb3RhdGUodGhpcy5yb3RhdGlvbiwgcG9zKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFjdG9yJ3MgW1tCb3VuZGluZ0JveF1dIHJlbGF0aXZlIHRvIHRoZSBhY3RvcnMgcG9zaXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldFJlbGF0aXZlQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvIGNhY2hlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZEFuY2hvcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94XzguQm91bmRpbmdCb3goLWFuY2hvci54LCAtYW5jaG9yLnksIHRoaXMuZ2V0V2lkdGgoKSAtIGFuY2hvci54LCB0aGlzLmdldEhlaWdodCgpIC0gYW5jaG9yLnkpLnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIHdoZXRoZXIgdGhlIHgveSBzcGVjaWZpZWQgYXJlIGNvbnRhaW5lZCBpbiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0geCAgWCBjb29yZGluYXRlIHRvIHRlc3QgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSB5ICBZIGNvb3JkaW5hdGUgdG8gdGVzdCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHJlY3Vyc2UgY2hlY2tzIHdoZXRoZXIgdGhlIHgveSBhcmUgY29udGFpbmVkIGluIGFueSBjaGlsZCBhY3RvcnMgKGlmIHRoZXkgZXhpc3QpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5LCByZWN1cnNlKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWN1cnNlID09PSB2b2lkIDApIHsgcmVjdXJzZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgICAgIHZhciBjb250YWlubWVudCA9IHRoaXMuZ2V0Qm91bmRzKCkuY29udGFpbnMobmV3IEFsZ2VicmFfMjQuVmVjdG9yKHgsIHkpKTtcclxuICAgICAgICAgICAgaWYgKHJlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWlubWVudCB8fCB0aGlzLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmNvbnRhaW5zKHgsIHksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5tZW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2lkZSBvZiB0aGUgY29sbGlzaW9uIGJhc2VkIG9uIHRoZSBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0gaW50ZXJzZWN0IFRoZSBkaXNwbGFjZW1lbnQgdmVjdG9yIHJldHVybmVkIGJ5IGEgY29sbGlzaW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldFNpZGVGcm9tSW50ZXJzZWN0ID0gZnVuY3Rpb24gKGludGVyc2VjdCkge1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoaW50ZXJzZWN0LngpID4gTWF0aC5hYnMoaW50ZXJzZWN0LnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdC54IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuUmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5MZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdC55IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuQm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuVG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5Ob25lO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSBhY3RvciBoYXMgY29sbGlkZWQgd2l0aCBhbm90aGVyIGFjdG9yLCByZXR1cm5zIHRoZSBzaWRlIG9mIHRoZSBjdXJyZW50IGFjdG9yIHRoYXQgY29sbGlkZWQuXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIFRoZSBvdGhlciBhY3RvciB0byB0ZXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmNvbGxpZGVzV2l0aFNpZGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb25WZWN0b3IgPSB0aGlzLmNvbGxpZGVzKGFjdG9yKTtcclxuICAgICAgICAgICAgaWYgKCFzZXBhcmF0aW9uVmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuTm9uZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc2VwYXJhdGlvblZlY3Rvci54KSA+IE1hdGguYWJzKHNlcGFyYXRpb25WZWN0b3IueSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcy54IDwgYWN0b3IucG9zLngpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuUmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuTGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcy55IDwgYWN0b3IucG9zLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuQm90dG9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLlRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSBhY3RvciBoYXMgY29sbGlkZWQgd2l0aCBhbm90aGVyIGFjdG9yLCByZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gdmVjdG9yIG9uIGNvbGxpc2lvbi4gUmV0dXJuc1xyXG4gICAgICAgICAqIGBudWxsYCB3aGVuIHRoZXJlIGlzIG5vIGNvbGxpc2lvbjtcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIG90aGVyIGFjdG9yIHRvIHRlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY29sbGlkZXMgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHZhciBvdGhlckJvdW5kcyA9IGFjdG9yLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0ID0gYm91bmRzLmNvbGxpZGVzKG90aGVyQm91bmRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgaGFuZGxlciB0byBmaXJlIHdoZW4gdGhpcyBhY3RvciBjb2xsaWRlcyB3aXRoIGFub3RoZXIgaW4gYSBzcGVjaWZpZWQgZ3JvdXBcclxuICAgICAgICAgKiBAcGFyYW0gZ3JvdXAgVGhlIGdyb3VwIG5hbWUgdG8gbGlzdGVuIGZvclxyXG4gICAgICAgICAqIEBwYXJhbSBmdW5jIFRoZSBjYWxsYmFjayB0byBmaXJlIG9uIGNvbGxpc2lvbiB3aXRoIGFub3RoZXIgYWN0b3IgZnJvbSB0aGUgZ3JvdXAuIFRoZSBjYWxsYmFjayBpcyBwYXNzZWQgdGhlIG90aGVyIGFjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5vbkNvbGxpZGVzV2l0aCA9IGZ1bmN0aW9uIChncm91cCwgZnVuYykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFuZGxlcnNbZ3JvdXBdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFuZGxlcnNbZ3JvdXBdLnB1c2goZnVuYyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsaXNpb25IYW5kbGVycztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGNvbGxpc2lvbiBoYW5kbGVycyBmb3IgdGhpcyBncm91cCBvbiB0aGlzIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGdyb3VwIEdyb3VwIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnMgZm9yIG9uIHRoaXMgYWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnJlbW92ZUNvbGxpZGVzV2l0aCA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0gPSBbXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGFjdG9ycyBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBkaXN0YW5jZSBzcGVjaWZpZWQgZnJvbSBlYWNoIG90aGVyXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICAgICBBY3RvciB0byB0ZXN0XHJcbiAgICAgICAgICogQHBhcmFtIGRpc3RhbmNlICBEaXN0YW5jZSBpbiBwaXhlbHMgdG8gdGVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbiAoYWN0b3IsIGRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5wb3MueCAtIGFjdG9yLnBvcy54LCAyKSArIE1hdGgucG93KHRoaXMucG9zLnkgLSBhY3Rvci5wb3MueSwgMikpIDw9IGRpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLl9nZXRDYWxjdWxhdGVkQW5jaG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjQuVmVjdG9yKHRoaXMuZ2V0V2lkdGgoKSAqIHRoaXMuYW5jaG9yLngsIHRoaXMuZ2V0SGVpZ2h0KCkgKiB0aGlzLmFuY2hvci55KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5fcmVhcHBseUVmZmVjdHMgPSBmdW5jdGlvbiAoZHJhd2luZykge1xyXG4gICAgICAgICAgICBkcmF3aW5nLnJlbW92ZUVmZmVjdCh0aGlzLl9vcGFjaXR5RngpO1xyXG4gICAgICAgICAgICBkcmF3aW5nLmFkZEVmZmVjdCh0aGlzLl9vcGFjaXR5RngpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybSBldWxlciBpbnRlZ3JhdGlvbiBhdCB0aGUgc3BlY2lmaWVkIHRpbWUgc3RlcFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHBsYWNlbWVudHMgYmFzZWQgb24gbGluZWFyIGFsZ2VicmFcclxuICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbEFjYyA9IHRoaXMuYWNjLmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgYWN0aXZlIHZhbmlsbGEgYWN0b3JzIGFyZSBhZmZlY3RlZCBieSBnbG9iYWwgYWNjZWxlcmF0aW9uXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbEFjYy5hZGRFcXVhbChQaHlzaWNzXzEzLlBoeXNpY3MuYWNjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZlbC5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZShzZWNvbmRzKSk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zLmFkZEVxdWFsKHRoaXMudmVsLnNjYWxlKHNlY29uZHMpKS5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZSgwLjUgKiBzZWNvbmRzICogc2Vjb25kcykpO1xyXG4gICAgICAgICAgICB0aGlzLnJ4ICs9IHRoaXMudG9ycXVlICogKDEuMCAvIHRoaXMubW9pKSAqIHNlY29uZHM7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gKz0gdGhpcy5yeCAqIHNlY29uZHM7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCArPSB0aGlzLnN4ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgKz0gdGhpcy5zeSAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHBoeXNpY3MgYm9keVxyXG4gICAgICAgICAgICB0aGlzLmJvZHkudXBkYXRlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIEVuZ2luZSwgdXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSBUaGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgZW5naW5lXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICBUaGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBFdmVudHNfMTQuUHJlVXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWN0aW9uIHF1ZXVlXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGNvbG9yIG9ubHkgb3BhY2l0eVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvci5hID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBjaGFuZ2luZyBvcGFjaXR5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzT3BhY2l0eSAhPT0gdGhpcy5vcGFjaXR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29wYWNpdHlGeC5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWZmZWN0c0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDYXB0dXJlIG9sZCB2YWx1ZXMgYmVmb3JlIGludGVncmF0aW9uIHN0ZXAgdXBkYXRlcyB0aGVtXHJcbiAgICAgICAgICAgIHRoaXMub2xkVmVsLnNldFRvKHRoaXMudmVsLngsIHRoaXMudmVsLnkpO1xyXG4gICAgICAgICAgICB0aGlzLm9sZFBvcy5zZXRUbyh0aGlzLnBvcy54LCB0aGlzLnBvcy55KTtcclxuICAgICAgICAgICAgLy8gUnVuIEV1bGVyIGludGVncmF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuaW50ZWdyYXRlKGRlbHRhKTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGFjdG9yIHBpcGVsaW5lIChtb3ZlbWVudCwgY29sbGlzaW9uIGRldGVjdGlvbiwgZXZlbnQgcHJvcGFnYXRpb24sIG9mZnNjcmVlbiBjdWxsaW5nKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy50cmFpdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhaXQgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0cmFpdC51cGRhdGUodGhpcywgZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGNoaWxkIGFjdG9yc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBFdmVudHNfMTQuUG9zdFVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCBieSB0aGUgRW5naW5lLCBkcmF3cyB0aGUgYWN0b3IgdG8gdGhlIHNjcmVlblxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggICBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgVGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgZHJhdyBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5wb3MueCwgdGhpcy5wb3MueSk7XHJcbiAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSk7XHJcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBjYW52YXMgYnkgYW5jaG9yIG9mZnNldFxyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC0odGhpcy5fd2lkdGggKiB0aGlzLmFuY2hvci54KSwgLSh0aGlzLl9oZWlnaHQgKiB0aGlzLmFuY2hvci55KSk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZHJhdycsIG5ldyBFdmVudHNfMTQuUHJlRHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYXdpbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcmF3aW5nID0gdGhpcy5jdXJyZW50RHJhd2luZztcclxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyL3B1bGwvNjE5IGZvciBkaXNjdXNzaW9uIG9uIHRoaXMgZm9ybXVsYSAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRYID0gKHRoaXMuX3dpZHRoIC0gZHJhd2luZy5uYXR1cmFsV2lkdGggKiBkcmF3aW5nLnNjYWxlLngpICogdGhpcy5hbmNob3IueDtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRZID0gKHRoaXMuX2hlaWdodCAtIGRyYXdpbmcubmF0dXJhbEhlaWdodCAqIGRyYXdpbmcuc2NhbGUueSkgKiB0aGlzLmFuY2hvci55O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VmZmVjdHNEaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYXBwbHlFZmZlY3RzKHRoaXMuY3VycmVudERyYXdpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VmZmVjdHNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZy5kcmF3KGN0eCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIC8vIERyYXcgY2hpbGQgYWN0b3JzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0udmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZHJhdyhjdHgsIGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkcmF3JywgbmV3IEV2ZW50c18xNC5Qb3N0RHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCBieSB0aGUgRW5naW5lLCBkcmF3cyB0aGUgYWN0b3JzIGRlYnVnZ2luZyB0byB0aGUgc2NyZWVuXHJcbiAgICAgICAgICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZGVidWdkcmF3JywgbmV3IEV2ZW50c18xNC5QcmVEZWJ1Z0RyYXdFdmVudChjdHgsIHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5ib2R5LmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAvLyBEcmF3IGFjdG9yIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICBiYi5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgLy8gRHJhdyBhY3RvciBJZFxyXG4gICAgICAgICAgICBjdHguZmlsbFRleHQoJ2lkOiAnICsgdGhpcy5pZCwgYmIubGVmdCArIDMsIGJiLnRvcCArIDEwKTtcclxuICAgICAgICAgICAgLy8gRHJhdyBhY3RvciBhbmNob3IgVmVjdG9yXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8yMC5Db2xvci5ZZWxsb3cudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMuZ2V0V29ybGRQb3MoKS54LCB0aGlzLmdldFdvcmxkUG9zKCkueSwgMywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIC8vIEN1bGxpbmcgQm94IGRlYnVnIGRyYXdcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnRyYWl0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhaXRzW2pdIGluc3RhbmNlb2YgVHJhaXRzLk9mZnNjcmVlbkN1bGxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWl0c1tqXS5jdWxsaW5nQm94LmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVuaXQgQ2lyY2xlIGRlYnVnIGRyYXdcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3JfMjAuQ29sb3IuWWVsbG93LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWluKHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5nZXRXb3JsZFBvcygpLngsIHRoaXMuZ2V0V29ybGRQb3MoKS55LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IHtcclxuICAgICAgICAgICAgICAgICcwIFBpJzogMCxcclxuICAgICAgICAgICAgICAgICdQaS8yJzogTWF0aC5QSSAvIDIsXHJcbiAgICAgICAgICAgICAgICAnUGknOiBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgJzMvMiBQaSc6IDMgKiBNYXRoLlBJIC8gMlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgb2xkRm9udCA9IGN0eC5mb250O1xyXG4gICAgICAgICAgICBmb3IgKHZhciB0aWNrIGluIHRpY2tzKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMjAuQ29sb3IuWWVsbG93LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9ICcxNHB4JztcclxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aWNrLCB0aGlzLmdldFdvcmxkUG9zKCkueCArIE1hdGguY29zKHRpY2tzW3RpY2tdKSAqIChyYWRpdXMgKyAxMCksIHRoaXMuZ2V0V29ybGRQb3MoKS55ICsgTWF0aC5zaW4odGlja3NbdGlja10pICogKHJhZGl1cyArIDEwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LmZvbnQgPSBvbGRGb250O1xyXG4gICAgICAgICAgICAvLyBEcmF3IGNoaWxkIGFjdG9yc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZGVidWdkcmF3JywgbmV3IEV2ZW50c18xNC5Qb3N0RGVidWdEcmF3RXZlbnQoY3R4LCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQWN0b3I7XHJcbiAgICB9KENsYXNzXzExLkNsYXNzKSk7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB0aGUgbmV4dCBpZCB0byBiZSBzZXRcclxuICAgICAqL1xyXG4gICAgQWN0b3IubWF4SWQgPSAwO1xyXG4gICAgZXhwb3J0cy5BY3RvciA9IEFjdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlcyBvZiBjb2xsaXNpb25zIGFjdG9ycyBjYW4gcGFydGljaXBhdGUgaW5cclxuICAgICAqL1xyXG4gICAgdmFyIENvbGxpc2lvblR5cGU7XHJcbiAgICAoZnVuY3Rpb24gKENvbGxpc2lvblR5cGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgYFByZXZlbnRDb2xsaXNpb25gIHNldHRpbmcgZG8gbm90IHBhcnRpY2lwYXRlIGluIGFueVxyXG4gICAgICAgICAqIGNvbGxpc2lvbnMgYW5kIGRvIG5vdCByYWlzZSBjb2xsaXNpb24gZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIlByZXZlbnRDb2xsaXNpb25cIl0gPSAwXSA9IFwiUHJldmVudENvbGxpc2lvblwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBgUGFzc2l2ZWAgc2V0dGluZyBvbmx5IHJhaXNlIGNvbGxpc2lvbiBldmVudHMsIGJ1dCBhcmUgbm90XHJcbiAgICAgICAgICogaW5mbHVlbmNlZCBvciBtb3ZlZCBieSBvdGhlciBhY3RvcnMgYW5kIGRvIG5vdCBpbmZsdWVuY2Ugb3IgbW92ZSBvdGhlciBhY3RvcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiUGFzc2l2ZVwiXSA9IDFdID0gXCJQYXNzaXZlXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIGBBY3RpdmVgIHNldHRpbmcgcmFpc2UgY29sbGlzaW9uIGV2ZW50cyBhbmQgcGFydGljaXBhdGVcclxuICAgICAgICAgKiBpbiBjb2xsaXNpb25zIHdpdGggb3RoZXIgYWN0b3JzIGFuZCB3aWxsIGJlIHB1c2ggb3IgbW92ZWQgYnkgYWN0b3JzIHNoYXJpbmdcclxuICAgICAgICAgKiB0aGUgYEFjdGl2ZWAgb3IgYEZpeGVkYCBzZXR0aW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIkFjdGl2ZVwiXSA9IDJdID0gXCJBY3RpdmVcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgYEZpeGVkYCBzZXR0aW5nIHJhaXNlIGNvbGxpc2lvbiBldmVudHMgYW5kIHBhcnRpY2lwYXRlIGluXHJcbiAgICAgICAgICogY29sbGlzaW9ucyB3aXRoIG90aGVyIGFjdG9ycy4gQWN0b3JzIHdpdGggdGhlIGBGaXhlZGAgc2V0dGluZyB3aWxsIG5vdCBiZVxyXG4gICAgICAgICAqIHB1c2hlZCBvciBtb3ZlZCBieSBvdGhlciBhY3RvcnMgc2hhcmluZyB0aGUgYEZpeGVkYC4gVGhpbmsgb2YgRml4ZWRcclxuICAgICAgICAgKiBhY3RvcnMgYXMgXCJpbW1vdmFibGUvb25zdG9wcGFibGVcIiBvYmplY3RzLiBJZiB0d28gYEZpeGVkYCBhY3RvcnMgbWVldCB0aGV5IHdpbGxcclxuICAgICAgICAgKiBub3QgYmUgcHVzaGVkIG9yIG1vdmVkIGJ5IGVhY2ggb3RoZXIsIHRoZXkgd2lsbCBub3QgaW50ZXJhY3QgZXhjZXB0IHRvIHRocm93XHJcbiAgICAgICAgICogY29sbGlzaW9uIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJGaXhlZFwiXSA9IDNdID0gXCJGaXhlZFwiO1xyXG4gICAgfSkoQ29sbGlzaW9uVHlwZSA9IGV4cG9ydHMuQ29sbGlzaW9uVHlwZSB8fCAoZXhwb3J0cy5Db2xsaXNpb25UeXBlID0ge30pKTtcclxufSk7XHJcbmRlZmluZShcIkFjdGlvbnMvQWN0aW9uXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0aW9ucy9Sb3RhdGlvblR5cGVcIiwgXCJBbGdlYnJhXCIsIFwiVXRpbC9Mb2dcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBSb3RhdGlvblR5cGVfMiwgQWxnZWJyYV8yNSwgTG9nXzE3LCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBFYXNlVG8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEVhc2VUbyhhY3RvciwgeCwgeSwgZHVyYXRpb24sIGVhc2luZ0Zjbikge1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuZWFzaW5nRmNuID0gZWFzaW5nRmNuO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSAxICogMTAwMDsgLy8gMSBzZWNvbmRcclxuICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IoeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEVhc2VUby5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG5ldyBBbGdlYnJhXzI1LlZlY3Rvcih0aGlzLmFjdG9yLnBvcy54LCB0aGlzLmFjdG9yLnBvcy55KTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sZXJwU3RhcnQuZGlzdGFuY2UodGhpcy5fbGVycEVuZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFYXNlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5ld1ggPSB0aGlzLmFjdG9yLnBvcy54O1xyXG4gICAgICAgICAgICB2YXIgbmV3WSA9IHRoaXMuYWN0b3IucG9zLnk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50TGVycFRpbWUgPCB0aGlzLl9sZXJwRHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnggPCB0aGlzLl9sZXJwU3RhcnQueCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ggPSB0aGlzLl9sZXJwU3RhcnQueCAtICh0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLngpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3WCA9IHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnkgPCB0aGlzLl9sZXJwU3RhcnQueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1kgPSB0aGlzLl9sZXJwU3RhcnQueSAtICh0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3WSA9IHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucG9zLnggPSBuZXdYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5wb3MueSA9IG5ld1k7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnBvcy54ID0gdGhpcy5fbGVycEVuZC54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5wb3MueSA9IHRoaXMuX2xlcnBFbmQueTtcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5fbGVycFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5fbGVycEVuZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEVhc2VUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAobmV3IEFsZ2VicmFfMjUuVmVjdG9yKGFjdG9yLnBvcy54LCBhY3Rvci5wb3MueSkpLmRpc3RhbmNlKHRoaXMuX2xlcnBTdGFydCkgPj0gdGhpcy5fZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFYXNlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFYXNlVG87XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5FYXNlVG8gPSBFYXNlVG87XHJcbiAgICB2YXIgTW92ZVRvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBNb3ZlVG8oYWN0b3IsIGRlc3R4LCBkZXN0eSwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9IG5ldyBBbGdlYnJhXzI1LlZlY3RvcihkZXN0eCwgZGVzdHkpO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCA9IHNwZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKHRoaXMuX2FjdG9yLnBvcy54LCB0aGlzLl9hY3Rvci5wb3MueSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3N0YXJ0LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX3N0YXJ0KS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gbS54O1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IG0ueTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLl9hY3RvcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy54ID0gdGhpcy5fZW5kLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueSA9IHRoaXMuX2VuZC55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKG5ldyBBbGdlYnJhXzI1LlZlY3RvcihhY3Rvci5wb3MueCwgYWN0b3IucG9zLnkpKS5kaXN0YW5jZSh0aGlzLl9zdGFydCkgPj0gdGhpcy5fZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1vdmVUby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBNb3ZlVG87XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Nb3ZlVG8gPSBNb3ZlVG87XHJcbiAgICB2YXIgTW92ZUJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBNb3ZlQnkoYWN0b3IsIGRlc3R4LCBkZXN0eSwgdGltZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKGRlc3R4LCBkZXN0eSk7XHJcbiAgICAgICAgICAgIGlmICh0aW1lIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIExvZ18xNy5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQXR0ZW1wdGVkIHRvIG1vdmVCeSB0aW1lIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvIDogJyArIHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbW92ZSBpbiB0aW1lIDw9IDAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGltZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTW92ZUJ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCA9IG5ldyBBbGdlYnJhXzI1LlZlY3Rvcih0aGlzLl9hY3Rvci5wb3MueCwgdGhpcy5fYWN0b3IucG9zLnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zdGFydC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9zdGFydCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZCA9IHRoaXMuX2Rpc3RhbmNlIC8gKHRoaXMuX3RpbWUgLyAxMDAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gbS54O1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IG0ueTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLl9hY3RvcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy54ID0gdGhpcy5fZW5kLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueSA9IHRoaXMuX2VuZC55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb3ZlQnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKG5ldyBBbGdlYnJhXzI1LlZlY3RvcihhY3Rvci5wb3MueCwgYWN0b3IucG9zLnkpKS5kaXN0YW5jZSh0aGlzLl9zdGFydCkgPj0gdGhpcy5fZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb3ZlQnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1vdmVCeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBNb3ZlQnk7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Nb3ZlQnkgPSBNb3ZlQnk7XHJcbiAgICB2YXIgRm9sbG93ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBGb2xsb3coYWN0b3IsIGFjdG9yVG9Gb2xsb3csIGZvbGxvd0Rpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvclRvRm9sbG93ID0gYWN0b3JUb0ZvbGxvdztcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IG5ldyBBbGdlYnJhXzI1LlZlY3Rvcih0aGlzLl9hY3Rvci5wb3MueCwgdGhpcy5fYWN0b3IucG9zLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IoYWN0b3JUb0ZvbGxvdy5wb3MueCwgYWN0b3JUb0ZvbGxvdy5wb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX21heGltdW1EaXN0YW5jZSA9IChmb2xsb3dEaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSA/IGZvbGxvd0Rpc3RhbmNlIDogdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZvbGxvdy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9jdXJyZW50KS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYWN0b3JUb0ZvbGxvd1NwZWVkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuX2FjdG9yVG9Gb2xsb3cudmVsLngsIDIpICsgTWF0aC5wb3codGhpcy5fYWN0b3JUb0ZvbGxvdy52ZWwueSwgMikpO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3JUb0ZvbGxvd1NwZWVkICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZCA9IGFjdG9yVG9Gb2xsb3dTcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50LnggPSB0aGlzLl9hY3Rvci5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudC55ID0gdGhpcy5fYWN0b3IucG9zLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZC54ID0gdGhpcy5fYWN0b3JUb0ZvbGxvdy5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy5fZW5kLnkgPSB0aGlzLl9hY3RvclRvRm9sbG93LnBvcy55O1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPSB0aGlzLl9jdXJyZW50LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXN0YW5jZUJldHdlZW4gPj0gdGhpcy5fbWF4aW11bURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IG0ueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gbS55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBuZXZlciBvY2N1clxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucG9zLnggPSB0aGlzLl9lbmQueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy55ID0gdGhpcy5fZW5kLnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEZvbGxvdy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRm9sbG93LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgYWN0b3IgZm9sbG93aW5nIHNob3VsZCBuZXZlciBzdG9wIHVubGVzcyBzcGVjaWZpZWQgdG8gZG8gc29cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGb2xsb3cucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRm9sbG93O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRm9sbG93ID0gRm9sbG93O1xyXG4gICAgdmFyIE1lZXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE1lZXQoYWN0b3IsIGFjdG9yVG9NZWV0LCBzcGVlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JUb01lZXQgPSBhY3RvclRvTWVldDtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IG5ldyBBbGdlYnJhXzI1LlZlY3Rvcih0aGlzLl9hY3Rvci5wb3MueCwgdGhpcy5fYWN0b3IucG9zLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IoYWN0b3JUb01lZXQucG9zLngsIGFjdG9yVG9NZWV0LnBvcy55KTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZCB8fCAwO1xyXG4gICAgICAgICAgICBpZiAoc3BlZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE1lZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA9IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFjdG9yVG9NZWV0U3BlZWQgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5fYWN0b3JUb01lZXQudmVsLngsIDIpICsgTWF0aC5wb3codGhpcy5fYWN0b3JUb01lZXQudmVsLnksIDIpKTtcclxuICAgICAgICAgICAgaWYgKChhY3RvclRvTWVldFNwZWVkICE9PSAwKSAmJiAoIXRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBhY3RvclRvTWVldFNwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQueCA9IHRoaXMuX2FjdG9yLnBvcy54O1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50LnkgPSB0aGlzLl9hY3Rvci5wb3MueTtcclxuICAgICAgICAgICAgdGhpcy5fZW5kLnggPSB0aGlzLl9hY3RvclRvTWVldC5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy5fZW5kLnkgPSB0aGlzLl9hY3RvclRvTWVldC5wb3MueTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX2N1cnJlbnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gbS54O1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IG0ueTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueCA9IHRoaXMuX2VuZC54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucG9zLnkgPSB0aGlzLl9lbmQueTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTWVldC5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA8PSAxKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1lZXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1lZXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTWVldDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLk1lZXQgPSBNZWV0O1xyXG4gICAgdmFyIFJvdGF0ZVRvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBSb3RhdGVUbyhhY3RvciwgYW5nbGVSYWRpYW5zLCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQgPSBhbmdsZVJhZGlhbnM7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uVHlwZSA9IHJvdGF0aW9uVHlwZSB8fCBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuU2hvcnRlc3RQYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9hY3Rvci5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZTEgPSBNYXRoLmFicyh0aGlzLl9lbmQgLSB0aGlzLl9zdGFydCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UyID0gVXRpbC5Ud29QSSAtIGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZTEgPiBkaXN0YW5jZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydERpc3RhbmNlID0gZGlzdGFuY2UyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEaXN0YW5jZSA9IGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0RGlzdGFuY2UgPSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0Rpc3RhbmNlID0gZGlzdGFuY2UyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSA9ICh0aGlzLl9zdGFydCAtIHRoaXMuX2VuZCArIFV0aWwuVHdvUEkpICUgVXRpbC5Ud29QSSA+PSBNYXRoLlBJO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9yb3RhdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5Mb25nZXN0UGF0aDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuQ2xvY2t3aXNlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuQ291bnRlckNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IucnggPSB0aGlzLl9kaXJlY3Rpb24gKiB0aGlzLl9zcGVlZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5yb3RhdGlvbiA9IHRoaXMuX2VuZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJ4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlVHJhdmVsbGVkID0gTWF0aC5hYnModGhpcy5fYWN0b3Iucm90YXRpb24gLSB0aGlzLl9zdGFydCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChkaXN0YW5jZVRyYXZlbGxlZCA+PSBNYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUm90YXRlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJ4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSb3RhdGVUbztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlJvdGF0ZVRvID0gUm90YXRlVG87XHJcbiAgICB2YXIgUm90YXRlQnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFJvdGF0ZUJ5KGFjdG9yLCBhbmdsZVJhZGlhbnMsIHRpbWUsIHJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gYW5nbGVSYWRpYW5zO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGltZTtcclxuICAgICAgICAgICAgdGhpcy5fcm90YXRpb25UeXBlID0gcm90YXRpb25UeXBlIHx8IFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFJvdGF0ZUJ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX2FjdG9yLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlMSA9IE1hdGguYWJzKHRoaXMuX2VuZCAtIHRoaXMuX3N0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZTIgPSBVdGlsLlR3b1BJIC0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlMSA+IGRpc3RhbmNlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0RGlzdGFuY2UgPSBkaXN0YW5jZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0Rpc3RhbmNlID0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnREaXN0YW5jZSA9IGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGlzdGFuY2UgPSBkaXN0YW5jZTI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlID0gKHRoaXMuX3N0YXJ0IC0gdGhpcy5fZW5kICsgVXRpbC5Ud29QSSkgJSBVdGlsLlR3b1BJID49IE1hdGguUEk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3JvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLlNob3J0ZXN0UGF0aDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLkxvbmdlc3RQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5DbG9ja3dpc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydERpc3RhbmNlID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLkNvdW50ZXJDbG9ja3dpc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnREaXN0YW5jZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gTWF0aC5hYnModGhpcy5fZGlzdGFuY2UgLyB0aGlzLl90aW1lICogMTAwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IucnggPSB0aGlzLl9kaXJlY3Rpb24gKiB0aGlzLl9zcGVlZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5yb3RhdGlvbiA9IHRoaXMuX2VuZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJ4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlVHJhdmVsbGVkID0gTWF0aC5hYnModGhpcy5fYWN0b3Iucm90YXRpb24gLSB0aGlzLl9zdGFydCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChkaXN0YW5jZVRyYXZlbGxlZCA+PSBNYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJ4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSb3RhdGVCeTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlJvdGF0ZUJ5ID0gUm90YXRlQnk7XHJcbiAgICB2YXIgU2NhbGVUbyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gU2NhbGVUbyhhY3Rvciwgc2NhbGVYLCBzY2FsZVksIHNwZWVkWCwgc3BlZWRZKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRYID0gc2NhbGVYO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRZID0gc2NhbGVZO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFggPSBzcGVlZFg7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWSA9IHNwZWVkWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2NhbGVUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gdGhpcy5fYWN0b3Iuc2NhbGUueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IHRoaXMuX2FjdG9yLnNjYWxlLnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVggPSBNYXRoLmFicyh0aGlzLl9lbmRYIC0gdGhpcy5fc3RhcnRYKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlWSA9IE1hdGguYWJzKHRoaXMuX2VuZFkgLSB0aGlzLl9zdGFydFkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghKE1hdGguYWJzKHRoaXMuX2FjdG9yLnNjYWxlLnggLSB0aGlzLl9zdGFydFgpID49IHRoaXMuX2Rpc3RhbmNlWCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25YID0gdGhpcy5fZW5kWSA8IHRoaXMuX3N0YXJ0WSA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gdGhpcy5fc3BlZWRYICogZGlyZWN0aW9uWDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIShNYXRoLmFicyh0aGlzLl9hY3Rvci5zY2FsZS55IC0gdGhpcy5fc3RhcnRZKSA+PSB0aGlzLl9kaXN0YW5jZVkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uWSA9IHRoaXMuX2VuZFkgPCB0aGlzLl9zdGFydFkgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zeSA9IHRoaXMuX3NwZWVkWSAqIGRpcmVjdGlvblk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zeSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zY2FsZS54ID0gdGhpcy5fZW5kWDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnNjYWxlLnkgPSB0aGlzLl9lbmRZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3ggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3kgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2FsZVRvLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoKE1hdGguYWJzKHRoaXMuX2FjdG9yLnNjYWxlLnkgLSB0aGlzLl9zdGFydFgpID49IHRoaXMuX2Rpc3RhbmNlWCkgJiZcclxuICAgICAgICAgICAgICAgIChNYXRoLmFicyh0aGlzLl9hY3Rvci5zY2FsZS55IC0gdGhpcy5fc3RhcnRZKSA+PSB0aGlzLl9kaXN0YW5jZVkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3kgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2NhbGVUbztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNjYWxlVG8gPSBTY2FsZVRvO1xyXG4gICAgdmFyIFNjYWxlQnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFNjYWxlQnkoYWN0b3IsIHNjYWxlWCwgc2NhbGVZLCB0aW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRYID0gc2NhbGVYO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRZID0gc2NhbGVZO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGltZTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRYID0gKHRoaXMuX2VuZFggLSB0aGlzLl9hY3Rvci5zY2FsZS54KSAvIHRpbWUgKiAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFkgPSAodGhpcy5fZW5kWSAtIHRoaXMuX2FjdG9yLnNjYWxlLnkpIC8gdGltZSAqIDEwMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNjYWxlQnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX2FjdG9yLnNjYWxlLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLl9hY3Rvci5zY2FsZS55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VYID0gTWF0aC5hYnModGhpcy5fZW5kWCAtIHRoaXMuX3N0YXJ0WCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVkgPSBNYXRoLmFicyh0aGlzLl9lbmRZIC0gdGhpcy5fc3RhcnRZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uWCA9IHRoaXMuX2VuZFggPCB0aGlzLl9zdGFydFggPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb25ZID0gdGhpcy5fZW5kWSA8IHRoaXMuX3N0YXJ0WSA/IC0xIDogMTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3ggPSB0aGlzLl9zcGVlZFggKiBkaXJlY3Rpb25YO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5zeSA9IHRoaXMuX3NwZWVkWSAqIGRpcmVjdGlvblk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc2NhbGUueCA9IHRoaXMuX2VuZFg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zY2FsZS55ID0gdGhpcy5fZW5kWTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN5ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NhbGVCeS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKChNYXRoLmFicyh0aGlzLl9hY3Rvci5zY2FsZS54IC0gdGhpcy5fc3RhcnRYKSA+PSB0aGlzLl9kaXN0YW5jZVgpICYmXHJcbiAgICAgICAgICAgICAgICAoTWF0aC5hYnModGhpcy5fYWN0b3Iuc2NhbGUueSAtIHRoaXMuX3N0YXJ0WSkgPj0gdGhpcy5fZGlzdGFuY2VZKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5zeCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNjYWxlQnk7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5TY2FsZUJ5ID0gU2NhbGVCeTtcclxuICAgIHZhciBEZWxheSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRGVsYXkoYWN0b3IsIGRlbGF5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gZGVsYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERlbGF5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLl9hY3Rvci5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5fYWN0b3IucG9zLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGVsYXkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLl9lbGFwc2VkVGltZSA+PSB0aGlzLl9kZWxheSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEZWxheS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEZWxheS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERlbGF5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRGVsYXkgPSBEZWxheTtcclxuICAgIHZhciBCbGluayA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQmxpbmsoYWN0b3IsIHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKSB7XHJcbiAgICAgICAgICAgIGlmIChudW1CbGlua3MgPT09IHZvaWQgMCkgeyBudW1CbGlua3MgPSAxOyB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVWaXNpYmxlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdGltZU5vdFZpc2libGUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lVmlzaWJsZSA9IHRpbWVWaXNpYmxlO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lTm90VmlzaWJsZSA9IHRpbWVOb3RWaXNpYmxlO1xyXG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbiA9ICh0aW1lVmlzaWJsZSArIHRpbWVOb3RWaXNpYmxlKSAqIG51bUJsaW5rcztcclxuICAgICAgICB9XHJcbiAgICAgICAgQmxpbmsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICB0aGlzLl90b3RhbFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3Rvci52aXNpYmxlICYmIHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuX3RpbWVWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3Rvci52aXNpYmxlICYmIHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuX3RpbWVOb3RWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCbGluay5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMuX3RvdGFsVGltZSA+PSB0aGlzLl9kdXJhdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCbGluay5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmxpbmsucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBCbGluaztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkJsaW5rID0gQmxpbms7XHJcbiAgICB2YXIgRmFkZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRmFkZShhY3RvciwgZW5kT3BhY2l0eSwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRPcGFjaXR5ID0gZW5kT3BhY2l0eTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgRmFkZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgZGlyZWN0aW9uIHdoZW4gd2Ugc3RhcnRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmRPcGFjaXR5IDwgdGhpcy5fYWN0b3Iub3BhY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGVlZCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLm9wYWNpdHkgKz0gdGhpcy5fbXVsdGlwbGllciAqIChNYXRoLmFicyh0aGlzLl9hY3Rvci5vcGFjaXR5IC0gdGhpcy5fZW5kT3BhY2l0eSkgKiBkZWx0YSkgLyB0aGlzLl9zcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5vcGFjaXR5ID0gdGhpcy5fZW5kT3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMb2dfMTcuTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1tBY3Rpb24gZmFkZV0gQWN0b3Igb3BhY2l0eTonLCB0aGlzLl9hY3Rvci5vcGFjaXR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZhZGUucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChNYXRoLmFicyh0aGlzLl9hY3Rvci5vcGFjaXR5IC0gdGhpcy5fZW5kT3BhY2l0eSkgPCAwLjA1KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZhZGUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmFkZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBGYWRlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRmFkZSA9IEZhZGU7XHJcbiAgICB2YXIgRGllID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEaWUoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEaWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IuYWN0aW9uUXVldWUuY2xlYXJBY3Rpb25zKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLmtpbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEaWUucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGllLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgRGllLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgIHJldHVybiBEaWU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5EaWUgPSBEaWU7XHJcbiAgICB2YXIgQ2FsbE1ldGhvZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ2FsbE1ldGhvZChhY3RvciwgbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21ldGhvZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWV0aG9kLmNhbGwodGhpcy5fYWN0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNCZWVuQ2FsbGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsbE1ldGhvZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENhbGxNZXRob2Q7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5DYWxsTWV0aG9kID0gQ2FsbE1ldGhvZDtcclxuICAgIHZhciBSZXBlYXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlcGVhdChhY3RvciwgcmVwZWF0LCBhY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUgPSBuZXcgQWN0aW9uUXVldWUoYWN0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBlYXQgPSByZXBlYXQ7XHJcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsUmVwZWF0ID0gcmVwZWF0O1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGFjdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uc1tpXS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUuYWRkKGFjdGlvbnNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVwZWF0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5fYWN0b3IucG9zLng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuX2FjdG9yLnBvcy55O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGlvblF1ZXVlLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcGVhdC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXBlYXQucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLl9yZXBlYXQgPD0gMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXBlYXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVwZWF0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVwZWF0ID0gdGhpcy5fb3JpZ2luYWxSZXBlYXQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmVwZWF0O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUmVwZWF0ID0gUmVwZWF0O1xyXG4gICAgdmFyIFJlcGVhdEZvcmV2ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlcGVhdEZvcmV2ZXIoYWN0b3IsIGFjdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZSA9IG5ldyBBY3Rpb25RdWV1ZShhY3Rvcik7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gYWN0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25zW2ldLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5hZGQoYWN0aW9uc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5fYWN0b3IucG9zLng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuX2FjdG9yLnBvcy55O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aW9uUXVldWUuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5jbGVhckFjdGlvbnMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgcmV0dXJuIFJlcGVhdEZvcmV2ZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5SZXBlYXRGb3JldmVyID0gUmVwZWF0Rm9yZXZlcjtcclxuICAgIC8qKlxyXG4gICAgICogQWN0aW9uIFF1ZXVlc1xyXG4gICAgICpcclxuICAgICAqIEFjdGlvbiBxdWV1ZXMgYXJlIHBhcnQgb2YgdGhlIFtbQWN0aW9uQ29udGV4dHxBY3Rpb24gQVBJXV0gYW5kXHJcbiAgICAgKiBzdG9yZSB0aGUgbGlzdCBvZiBhY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIGZvciBhbiBbW0FjdG9yXV0uXHJcbiAgICAgKlxyXG4gICAgICogQWN0b3JzIGltcGxlbWVudCBbW0FjdG9yLmFjdGlvbnNdXSB3aGljaCBjYW4gYmUgbWFuaXB1bGF0ZWQgYnlcclxuICAgICAqIGFkdmFuY2VkIHVzZXJzIHRvIGFkanVzdCB0aGUgYWN0aW9ucyBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQgaW4gdGhlXHJcbiAgICAgKiBxdWV1ZS5cclxuICAgICAqL1xyXG4gICAgdmFyIEFjdGlvblF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBBY3Rpb25RdWV1ZShhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5wdXNoKGFjdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9hY3Rpb25zLmluZGV4T2YoYWN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmNsZWFyQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50QWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmdldEFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmNvbmNhdCh0aGlzLl9jb21wbGV0ZWRBY3Rpb25zKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zID0gdGhpcy5nZXRBY3Rpb25zKCk7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fYWN0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zW2ldLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gdGhpcy5fYWN0aW9uc1swXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24udXBkYXRlKGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50QWN0aW9uLmlzQ29tcGxldGUodGhpcy5fYWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucy5wdXNoKHRoaXMuX2FjdGlvbnMuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBY3Rpb25RdWV1ZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkFjdGlvblF1ZXVlID0gQWN0aW9uUXVldWU7XHJcbn0pO1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHdpbmRvdyA9IHsgYXVkaW9Db250ZXh0OiBmdW5jdGlvbiAoKSB7IHJldHVybjsgfSB9O1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xyXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaykgeyB3aW5kb3cuc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIDEwMDAgLyA2MCk7IH07XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcclxuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgICAgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgIHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5BdWRpb0NvbnRleHQpIHtcclxuICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgIHdpbmRvdy5tb3pBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICB3aW5kb3cubXNBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICB3aW5kb3cub0F1ZGlvQ29udGV4dDtcclxufVxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XHJcbiAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XHJcbn1cclxuLy8gUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXHJcbi8vIFByb2R1Y3Rpb24gc3RlcHMgb2YgRUNNQS0yNjIsIEVkaXRpb24gNSwgMTUuNC40LjE4XHJcbi8vIFJlZmVyZW5jZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMThcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xyXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgICAgICB2YXIgVCwgaztcclxuICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAxLiBMZXQgTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgVG9PYmplY3QgcGFzc2luZyB0aGUgfHRoaXN8IHZhbHVlIGFzIHRoZSBhcmd1bWVudC4gXHJcbiAgICAgICAgdmFyIE8gPSBPYmplY3QodGhpcyk7XHJcbiAgICAgICAgLy8gMi4gTGV0IGxlblZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggdGhlIGFyZ3VtZW50IFwibGVuZ3RoXCIuXHJcbiAgICAgICAgLy8gMy4gTGV0IGxlbiBiZSBUb1VpbnQzMihsZW5WYWx1ZSkuXHJcbiAgICAgICAgdmFyIGxlbiA9IE8ubGVuZ3RoID4+PiAwO1xyXG4gICAgICAgIC8vIDQuIElmIElzQ2FsbGFibGUoY2FsbGJhY2spIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXHJcbiAgICAgICAgLy8gU2VlOiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjExXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA1LiBJZiB0aGlzQXJnIHdhcyBzdXBwbGllZCwgbGV0IFQgYmUgdGhpc0FyZzsgZWxzZSBsZXQgVCBiZSB1bmRlZmluZWQuXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIFQgPSB0aGlzQXJnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LiBMZXQgayBiZSAwXHJcbiAgICAgICAgayA9IDA7XHJcbiAgICAgICAgLy8gNy4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXHJcbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcclxuICAgICAgICAgICAgdmFyIGtWYWx1ZTtcclxuICAgICAgICAgICAgLy8gYS4gTGV0IFBrIGJlIFRvU3RyaW5nKGspLlxyXG4gICAgICAgICAgICAvLyAgIFRoaXMgaXMgaW1wbGljaXQgZm9yIExIUyBvcGVyYW5kcyBvZiB0aGUgaW4gb3BlcmF0b3JcclxuICAgICAgICAgICAgLy8gYi4gTGV0IGtQcmVzZW50IGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgSGFzUHJvcGVydHkgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cclxuICAgICAgICAgICAgLy8gICBUaGlzIHN0ZXAgY2FuIGJlIGNvbWJpbmVkIHdpdGggY1xyXG4gICAgICAgICAgICAvLyBjLiBJZiBrUHJlc2VudCBpcyB0cnVlLCB0aGVuXHJcbiAgICAgICAgICAgIGlmIChrIGluIE8pIHtcclxuICAgICAgICAgICAgICAgIC8vIGkuIExldCBrVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cclxuICAgICAgICAgICAgICAgIGtWYWx1ZSA9IE9ba107XHJcbiAgICAgICAgICAgICAgICAvLyBpaS4gQ2FsbCB0aGUgQ2FsbCBpbnRlcm5hbCBtZXRob2Qgb2YgY2FsbGJhY2sgd2l0aCBUIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gYXJndW1lbnQgbGlzdCBjb250YWluaW5nIGtWYWx1ZSwgaywgYW5kIE8uXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKFQsIGtWYWx1ZSwgaywgTyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZC4gSW5jcmVhc2UgayBieSAxLlxyXG4gICAgICAgICAgICBrKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDguIHJldHVybiB1bmRlZmluZWRcclxuICAgIH07XHJcbn1cclxuLy8gUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmICghQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcclxuICAgIEFycmF5LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGZ1biAvKiwgdGhpc0FyZyAqLykge1xyXG4gICAgICAgICd1c2Ugc3RyaWN0JztcclxuICAgICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcclxuICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmdW4gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbn1cclxuLy8gUG9seWZpbGwgZnJvbSAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCNQb2x5ZmlsbFxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XHJcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDVcclxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmVG9CaW5kID0gdGhpcywgZk5PUCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9LCBmQm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzXHJcbiAgICAgICAgICAgICAgICA/IHRoaXNcclxuICAgICAgICAgICAgICAgIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xyXG4gICAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xyXG4gICAgICAgIHJldHVybiBmQm91bmQ7XHJcbiAgICB9O1xyXG59XHJcbiAgICAvL1RoZSBtb2R1bGVzIGZvciB5b3VyIHByb2plY3Qgd2lsbCBiZSBpbmxpbmVkIGFib3ZlXHJcbiAgICAvL3RoaXMgc25pcHBldC4gQXNrIGFsbW9uZCB0byBzeW5jaHJvbm91c2x5IHJlcXVpcmUgdGhlXHJcbiAgICAvL21vZHVsZSB2YWx1ZSBmb3IgJ21haW4nIGhlcmUgYW5kIHJldHVybiBpdCBhcyB0aGVcclxuICAgIC8vdmFsdWUgdG8gdXNlIGZvciB0aGUgcHVibGljIEFQSSBmb3IgdGhlIGJ1aWx0IGZpbGUuXHJcbiAgICByZXR1cm4gcmVxdWlyZSgnSW5kZXgnKTtcclxufSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGNhbGlidXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhjYWxpYnVyL2Rpc3QvZXhjYWxpYnVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///1\n')},,,,function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar excalibur_1 = __webpack_require__(1);\r\n/**\r\n * Base class which implements stronlgy-typed event handling. Preferd over Excalibur\'s.\r\n */\r\nvar Class = /** @class */ (function () {\r\n    function Class() {\r\n        this.eventDispatcher = new excalibur_1.EventDispatcher(this);\r\n    }\r\n    /**\r\n     * Alias for `addEventListener`. You can listen for a variety of\r\n     * events off of the engine; see the events section below for a complete list.\r\n     * @param eventName  Name of the event to listen for\r\n     * @param handler    Event handler for the thrown event\r\n     */\r\n    Class.prototype.on = function (eventName, handler) {\r\n        this.eventDispatcher.on(eventName, handler);\r\n    };\r\n    /**\r\n     * Alias for `removeEventListener`. If only the eventName is specified\r\n     * it will remove all handlers registered for that specific event. If the eventName\r\n     * and the handler instance are specified only that handler will be removed.\r\n     *\r\n     * @param eventName  Name of the event to listen for\r\n     * @param handler    Event handler for the thrown event\r\n     */\r\n    Class.prototype.off = function (eventName, handler) {\r\n        this.eventDispatcher.off(eventName, handler);\r\n    };\r\n    /**\r\n     * Emits a new event\r\n     * @param eventName   Name of the event to emit\r\n     * @param eventObject Data associated with this event\r\n     */\r\n    Class.prototype.emit = function (eventName, event) {\r\n        this.eventDispatcher.emit(eventName, event);\r\n    };\r\n    /**\r\n     * Once listens to an event one time, then unsubscribes from that event\r\n     *\r\n     * @param eventName The name of the event to subscribe to once\r\n     * @param handler   The handler of the event that will be auto unsubscribed\r\n     */\r\n    Class.prototype.once = function (eventName, handler) {\r\n        this.eventDispatcher.once(eventName, handler);\r\n    };\r\n    return Class;\r\n}());\r\nexports.Class = Class;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvQ2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5Q0FBNEM7QUE4QzVDOztHQUVHO0FBQ0g7SUFPQztRQUNDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSwyQkFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGtCQUFFLEdBQUYsVUFBc0IsU0FBWSxFQUFFLE9BQThCO1FBQ2pFLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxPQUFjLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILG1CQUFHLEdBQUgsVUFBdUIsU0FBWSxFQUFFLE9BQThCO1FBQ2xFLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxPQUFjLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILG9CQUFJLEdBQUosVUFBd0IsU0FBWSxFQUFFLEtBQVc7UUFDaEQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEtBQVksQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILG9CQUFJLEdBQUosVUFBd0IsU0FBWSxFQUFFLE9BQThCO1FBQ25FLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFjLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUYsWUFBQztBQUFELENBQUM7QUFwRFksc0JBQUsiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJleGNhbGlidXJcIjtcblxuaW50ZXJmYWNlIElFdmVudE1hcHBpbmc8VCA9IGFueT4ge1xuXHRba2V5OiBzdHJpbmddOiBUO1xufVxuXG4vKipcbiAqIFN0cm9uZ2x5LXR5cGVkIGV2ZW50IGludGVyZmFjZS4gUHJlZmVyZWQgb3ZlciBFeGNhbGlidXIncy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJRXZlbnRlZDxUID0gSUV2ZW50TWFwcGluZz4ge1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBhbiBldmVudCBmb3IgdGFyZ2V0XG5cdCAqIEBwYXJhbSBldmVudE5hbWUgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBwdWJsaXNoXG5cdCAqIEBwYXJhbSBldmVudCAgICAgIE9wdGlvbmFsbHkgcGFzcyBhbiBldmVudCBkYXRhIG9iamVjdCB0byB0aGUgaGFuZGxlclxuXHQgKi9cblx0ZW1pdDxLIGV4dGVuZHMga2V5b2YgVD4oZXZlbnROYW1lOiBLLCBldmVudDogVFtLXSk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFN1YnNjcmliZSBhbiBldmVudCBoYW5kbGVyIHRvIGEgcGFydGljdWxhciBldmVudCBuYW1lLCBtdWx0aXBsZSBoYW5kbGVycyBwZXIgZXZlbnQgbmFtZSBhcmUgYWxsb3dlZC5cblx0ICogQHBhcmFtIGV2ZW50TmFtZSAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xuXHQgKiBAcGFyYW0gaGFuZGxlciAgICBUaGUgaGFuZGxlciBjYWxsYmFjayB0byBmaXJlIG9uIHRoaXMgZXZlbnRcblx0ICovXG5cdG9uPEsgZXh0ZW5kcyBrZXlvZiBUPihldmVudE5hbWU6IEssIGhhbmRsZXI6IChldmVudDogVFtLXSkgPT4gdm9pZCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFVuc3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXIocykgZnJvbSBhbiBldmVudC4gSWYgYSBzcGVjaWZpYyBoYW5kbGVyXG5cdCAqIGlzIHNwZWNpZmllZCBmb3IgYW4gZXZlbnQsIG9ubHkgdGhhdCBoYW5kbGVyIHdpbGwgYmUgdW5zdWJzY3JpYmVkLlxuXHQgKiBPdGhlcndpc2UgYWxsIGhhbmRsZXJzIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGZvciB0aGF0IGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gZXZlbnROYW1lICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdW5zdWJzY3JpYmVcblx0ICogQHBhcmFtIGhhbmRsZXIgICAgT3B0aW9uYWxseSB0aGUgc3BlY2lmaWMgaGFuZGxlciB0byB1bnN1YnNjcmliZVxuXHQgKlxuXHQgKi9cblx0b2ZmPEsgZXh0ZW5kcyBrZXlvZiBUPihldmVudE5hbWU6IEssIGhhbmRsZXI6IChldmVudDogVFtLXSkgPT4gdm9pZCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIE9uY2UgbGlzdGVucyB0byBhbiBldmVudCBvbmNlIHRoZW4gYXV0byB1bnN1YnNjcmliZXMgZnJvbSB0aGF0IGV2ZW50XG5cdCAqXG5cdCAqIEBwYXJhbSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0byBvbmNlXG5cdCAqIEBwYXJhbSBoYW5kbGVyICAgVGhlIGhhbmRsZXIgb2YgdGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBhdXRvIHVuc3Vic2NyaWJlZFxuXHQgKi9cblx0b25jZTxLIGV4dGVuZHMga2V5b2YgVD4oZXZlbnROYW1lOiBLLCBoYW5kbGVyOiAoZXZlbnQ6IFRbS10pID0+IHZvaWQpOiB2b2lkO1xuXG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIHN0cm9ubGd5LXR5cGVkIGV2ZW50IGhhbmRsaW5nLiBQcmVmZXJkIG92ZXIgRXhjYWxpYnVyJ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBDbGFzczxUID0gSUV2ZW50TWFwcGluZz4gaW1wbGVtZW50cyBJRXZlbnRlZDxUPiB7XG5cblx0LyoqXG5cdCAqIERpcmVjdCBhY2Nlc3MgdG8gdGhlIGdhbWUgb2JqZWN0IGV2ZW50IGRpc3BhdGNoZXIuXG5cdCAqL1xuXHRldmVudERpc3BhdGNoZXI6IEV2ZW50RGlzcGF0Y2hlcjtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG5ldyBFdmVudERpc3BhdGNoZXIodGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogQWxpYXMgZm9yIGBhZGRFdmVudExpc3RlbmVyYC4gWW91IGNhbiBsaXN0ZW4gZm9yIGEgdmFyaWV0eSBvZlxuXHQgKiBldmVudHMgb2ZmIG9mIHRoZSBlbmdpbmU7IHNlZSB0aGUgZXZlbnRzIHNlY3Rpb24gYmVsb3cgZm9yIGEgY29tcGxldGUgbGlzdC5cblx0ICogQHBhcmFtIGV2ZW50TmFtZSAgTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0gaGFuZGxlciAgICBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XG5cdCAqL1xuXHRvbjxLIGV4dGVuZHMga2V5b2YgVD4oZXZlbnROYW1lOiBLLCBoYW5kbGVyOiAoZXZlbnQ6IFRbS10pID0+IHZvaWQpOiB2b2lkIHtcblx0XHR0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbihldmVudE5hbWUsIGhhbmRsZXIgYXMgYW55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBbGlhcyBmb3IgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLiBJZiBvbmx5IHRoZSBldmVudE5hbWUgaXMgc3BlY2lmaWVkXG5cdCAqIGl0IHdpbGwgcmVtb3ZlIGFsbCBoYW5kbGVycyByZWdpc3RlcmVkIGZvciB0aGF0IHNwZWNpZmljIGV2ZW50LiBJZiB0aGUgZXZlbnROYW1lXG5cdCAqIGFuZCB0aGUgaGFuZGxlciBpbnN0YW5jZSBhcmUgc3BlY2lmaWVkIG9ubHkgdGhhdCBoYW5kbGVyIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICpcblx0ICogQHBhcmFtIGV2ZW50TmFtZSAgTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0gaGFuZGxlciAgICBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XG5cdCAqL1xuXHRvZmY8SyBleHRlbmRzIGtleW9mIFQ+KGV2ZW50TmFtZTogSywgaGFuZGxlcjogKGV2ZW50OiBUW0tdKSA9PiB2b2lkKTogdm9pZCB7XG5cdFx0dGhpcy5ldmVudERpc3BhdGNoZXIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlciBhcyBhbnkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVtaXRzIGEgbmV3IGV2ZW50XG5cdCAqIEBwYXJhbSBldmVudE5hbWUgICBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0XG5cdCAqIEBwYXJhbSBldmVudE9iamVjdCBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50XG5cdCAqL1xuXHRlbWl0PEsgZXh0ZW5kcyBrZXlvZiBUPihldmVudE5hbWU6IEssIGV2ZW50OiBUW0tdKTogdm9pZCB7XG5cdFx0dGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIGV2ZW50IGFzIGFueSk7XG5cdH1cblxuXHQvKipcblx0ICogT25jZSBsaXN0ZW5zIHRvIGFuIGV2ZW50IG9uZSB0aW1lLCB0aGVuIHVuc3Vic2NyaWJlcyBmcm9tIHRoYXQgZXZlbnRcblx0ICpcblx0ICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvIG9uY2Vcblx0ICogQHBhcmFtIGhhbmRsZXIgICBUaGUgaGFuZGxlciBvZiB0aGUgZXZlbnQgdGhhdCB3aWxsIGJlIGF1dG8gdW5zdWJzY3JpYmVkXG5cdCAqL1xuXHRvbmNlPEsgZXh0ZW5kcyBrZXlvZiBUPihldmVudE5hbWU6IEssIGhhbmRsZXI6IChldmVudDogVFtLXSkgPT4gdm9pZCk6IHZvaWQge1xuXHRcdHRoaXMuZXZlbnREaXNwYXRjaGVyLm9uY2UoZXZlbnROYW1lLCBoYW5kbGVyIGFzIGFueSk7XG5cdH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvQ2xhc3MudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///5\n')},,function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar excalibur_1 = __webpack_require__(1);\r\nvar resources = {\r\n    crocodile: new excalibur_1.Texture(__webpack_require__(79)),\r\n    seaBed: new excalibur_1.Texture(__webpack_require__(80)),\r\n    sky: new excalibur_1.Texture(__webpack_require__(81)),\r\n    bubble: new excalibur_1.Texture(__webpack_require__(82)),\r\n    vine: new excalibur_1.Texture(__webpack_require__(83)),\r\n    smallRock: new excalibur_1.Texture(__webpack_require__(84)),\r\n    bigRock: new excalibur_1.Texture(__webpack_require__(85))\r\n};\r\nexports.default = resources;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvUmVzb3VyY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQW9DO0FBRXBDLElBQU0sU0FBUyxHQUFHO0lBRWpCLFNBQVMsRUFBRSxJQUFJLG1CQUFPLENBQUMsbUJBQU8sQ0FBQyxFQUFzQyxDQUFDLENBQUM7SUFDdkUsTUFBTSxFQUFFLElBQUksbUJBQU8sQ0FBQyxtQkFBTyxDQUFDLEVBQTRCLENBQUMsQ0FBQztJQUMxRCxHQUFHLEVBQUUsSUFBSSxtQkFBTyxDQUFDLG1CQUFPLENBQUMsRUFBMkIsQ0FBQyxDQUFDO0lBQ3RELE1BQU0sRUFBRSxJQUFJLG1CQUFPLENBQUMsbUJBQU8sQ0FBQyxFQUE0QixDQUFDLENBQUM7SUFDMUQsSUFBSSxFQUFFLElBQUksbUJBQU8sQ0FBQyxtQkFBTyxDQUFDLEVBQTBCLENBQUMsQ0FBQztJQUN0RCxTQUFTLEVBQUUsSUFBSSxtQkFBTyxDQUFDLG1CQUFPLENBQUMsRUFBK0IsQ0FBQyxDQUFDO0lBQ2hFLE9BQU8sRUFBRSxJQUFJLG1CQUFPLENBQUMsbUJBQU8sQ0FBQyxFQUE2QixDQUFDLENBQUM7Q0FFNUQsQ0FBQztBQUVGLGtCQUFlLFNBQVMsQ0FBQyIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gXCJleGNhbGlidXJcIjtcclxuXHJcbmNvbnN0IHJlc291cmNlcyA9IHtcclxuXHJcblx0Y3JvY29kaWxlOiBuZXcgVGV4dHVyZShyZXF1aXJlKFwiLi9TY2VuZXMvTGV2ZWwyL2Nyb2NvZGlsZS1zcHJpdGUucG5nXCIpKSxcclxuXHRzZWFCZWQ6IG5ldyBUZXh0dXJlKHJlcXVpcmUoXCIuL1NjZW5lcy9MZXZlbDIvc2VhYmVkLmpwZ1wiKSksXHJcblx0c2t5OiBuZXcgVGV4dHVyZShyZXF1aXJlKFwiLi9TY2VuZXMvTGV2ZWwyL2Nsb3VkLmpwZ1wiKSksXHJcblx0YnViYmxlOiBuZXcgVGV4dHVyZShyZXF1aXJlKFwiLi9TY2VuZXMvTGV2ZWwyL2J1YmJsZS5wbmdcIikpLFxyXG5cdHZpbmU6IG5ldyBUZXh0dXJlKHJlcXVpcmUoXCIuL1NjZW5lcy9MZXZlbDEvVmluZS5wbmdcIikpLFxyXG5cdHNtYWxsUm9jazogbmV3IFRleHR1cmUocmVxdWlyZShcIi4vU2NlbmVzL0xldmVsMy9zbWFsbFJvY2sucG5nXCIpKSxcclxuXHRiaWdSb2NrOiBuZXcgVGV4dHVyZShyZXF1aXJlKFwiLi9TY2VuZXMvTGV2ZWwzL2JpZ1JvY2sucG5nXCIpKVxyXG5cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHJlc291cmNlcztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvUmVzb3VyY2VzLnRzIl0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///7\n')},,,,,,,function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar excalibur_1 = __webpack_require__(1);\r\nvar NameEnquiry_1 = __webpack_require__(60);\r\nvar ExampleLevel_1 = __webpack_require__(62);\r\nvar Menu_1 = __webpack_require__(63);\r\nvar Intro_1 = __webpack_require__(65);\r\nvar MovementTestLevel_1 = __webpack_require__(68);\r\nvar StateListener_1 = __webpack_require__(71);\r\nvar Level1_1 = __webpack_require__(72);\r\nvar Level2_1 = __webpack_require__(86);\r\nvar Level3_1 = __webpack_require__(94);\r\nvar Level4_1 = __webpack_require__(99);\r\nvar Resources_1 = __webpack_require__(7);\r\n/**\r\n * Determines the reason for GameElement to be done.\r\n */\r\nvar GameElementDoneType;\r\n(function (GameElementDoneType) {\r\n    /**\r\n     * Everything is fine, proceed, or the player has won.\r\n     */\r\n    GameElementDoneType[GameElementDoneType["Finished"] = 0] = "Finished";\r\n    /**\r\n     * An error occurred, don\'t proceed, or the player has died.\r\n     */\r\n    GameElementDoneType[GameElementDoneType["Aborted"] = 1] = "Aborted";\r\n})(GameElementDoneType = exports.GameElementDoneType || (exports.GameElementDoneType = {}));\r\n/**\r\n * Game bootstrap object.\r\n *\r\n * Handles the logic behind switching levels and wiring everything up.\r\n */\r\nvar GameBootstrap = /** @class */ (function () {\r\n    function GameBootstrap(canvasId, overlay) {\r\n        var _this = this;\r\n        this.canvasId = canvasId;\r\n        this.overlay = overlay;\r\n        /**\r\n         * The key of the root (blank) scene.\r\n         */\r\n        this.rootSceneKey = "root";\r\n        this.stateListener = new StateListener_1.default({\r\n            name: null\r\n        });\r\n        this.state = this.stateListener.createListenableObject();\r\n        // create the game engine\r\n        this.engine = new excalibur_1.Engine({\r\n            width: 800,\r\n            height: 600,\r\n            canvasElementId: canvasId,\r\n            backgroundColor: excalibur_1.Color.Black,\r\n            pointerScope: excalibur_1.Input.PointerScope.Canvas\r\n        });\r\n        this.loader = new excalibur_1.Loader();\r\n        this.loader.addResources(Object.values(Resources_1.default));\r\n        this.intro = new Intro_1.default(this);\r\n        this.menu = new Menu_1.default();\r\n        this.exampleLevel = new ExampleLevel_1.default(this);\r\n        this.movementTestLevel = new MovementTestLevel_1.default(this);\r\n        this.level2 = new Level2_1.default(this);\r\n        this.nameEnquiry = new NameEnquiry_1.NameEnquiry();\r\n        this.levels = [{\r\n                name: "Level 1",\r\n                element: new Level1_1.default(this)\r\n            }, {\r\n                name: "Level 2",\r\n                element: new Level2_1.default(this)\r\n            }, {\r\n                name: "Level 3",\r\n                element: new Level3_1.default(this)\r\n            }, {\r\n                name: "Level 4",\r\n                element: new Level4_1.default(this)\r\n            }, {\r\n                name: "Change your name!",\r\n                element: this.nameEnquiry\r\n            }, {\r\n                name: "Intro (Story)",\r\n                element: this.intro\r\n            }, {\r\n                name: "Test player movement",\r\n                element: new MovementTestLevel_1.default(this)\r\n            }, {\r\n                name: "Play a Game!",\r\n                element: this.exampleLevel\r\n            }];\r\n        var _a = this, state = _a.state, levels = _a.levels, menu = _a.menu, intro = _a.intro, exampleLevel = _a.exampleLevel, nameEnquiry = _a.nameEnquiry, stateListener = _a.stateListener;\r\n        // custom event listener logic\r\n        exampleLevel.on("done", function (e) {\r\n            if (e.type === GameElementDoneType.Finished)\r\n                alert("Good job!");\r\n        });\r\n        // state change event bindings\r\n        stateListener.on("name", function (e) {\r\n            var level = levels.find(function (t) { return t.element === nameEnquiry; });\r\n            if (level)\r\n                level.name = "Change your name, " + e.newValue + "!";\r\n            menu.items = levels.map(function (t) { return t.name; });\r\n        });\r\n        // init all levels and subscribe event listeners\r\n        levels.forEach(function (level) {\r\n            // init the level\r\n            if (level.element.init)\r\n                level.element.init(_this);\r\n            // decide what to do when the level is over\r\n            level.element.on("done", function (e) {\r\n                level.element.dispose(); // stop current scene\r\n                menu.start(); // show menu\r\n            });\r\n        });\r\n        // init menu as any other game elementWW\r\n        menu.init(this);\r\n        // assign custom properties\r\n        menu.items = levels.map(function (t) { return t.name; });\r\n    }\r\n    /**\r\n     * Starts the game.\r\n     */\r\n    GameBootstrap.prototype.start = function () {\r\n        var _this = this;\r\n        this.menu.start();\r\n        this.engine.start(this.loader).then(function () {\r\n            _this.menu.on("click", function (e) {\r\n                var level = _this.levels.find(function (t) { return t.name === e.name; });\r\n                _this.menu.dispose(); // stop displaying menu\r\n                if (!level) {\r\n                    throw new Error("level not found");\r\n                }\r\n                level.element.start(); // start the level\r\n            });\r\n        });\r\n    };\r\n    return GameBootstrap;\r\n}());\r\nexports.GameBootstrap = GameBootstrap;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvR2FtZUJvb3RzdHJhcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlDQUE2RTtBQUU3RSw0Q0FBK0Q7QUFDL0QsNkNBQThEO0FBQzlELHFDQUFzQztBQUN0QyxzQ0FBeUM7QUFDekMsa0RBQTZFO0FBQzdFLDhDQUF1RDtBQUN2RCx1Q0FBNEM7QUFDNUMsdUNBQTRDO0FBQzVDLHVDQUE0QztBQUM1Qyx1Q0FBNEM7QUFDNUMseUNBQW9DO0FBZ0JwQzs7R0FFRztBQUNILElBQVksbUJBU1g7QUFURCxXQUFZLG1CQUFtQjtJQUM5Qjs7T0FFRztJQUNILHFFQUFRO0lBQ1I7O09BRUc7SUFDSCxtRUFBTztBQUNSLENBQUMsRUFUVyxtQkFBbUIsR0FBbkIsMkJBQW1CLEtBQW5CLDJCQUFtQixRQVM5QjtBQW9DRDs7OztHQUlHO0FBQ0g7SUE2QkMsdUJBQ2lCLFFBQWdCLEVBQ2hCLE9BQW9CO1FBRnJDLGlCQXNGQztRQXJGZ0IsYUFBUSxHQUFSLFFBQVEsQ0FBUTtRQUNoQixZQUFPLEdBQVAsT0FBTyxDQUFhO1FBakJyQzs7V0FFRztRQUNNLGlCQUFZLEdBQUcsTUFBTSxDQUFDO1FBZ0I5QixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksdUJBQWEsQ0FBc0I7WUFDM0QsSUFBSSxFQUFFLElBQUk7U0FDVixDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztRQUV6RCx5QkFBeUI7UUFDekIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGtCQUFNLENBQUM7WUFDeEIsS0FBSyxFQUFFLEdBQUc7WUFDVixNQUFNLEVBQUUsR0FBRztZQUNYLGVBQWUsRUFBRSxRQUFRO1lBQ3pCLGVBQWUsRUFBRSxpQkFBSyxDQUFDLEtBQUs7WUFDNUIsWUFBWSxFQUFFLGlCQUFLLENBQUMsWUFBWSxDQUFDLE1BQU07U0FDdkMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGtCQUFNLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLG1CQUFTLENBQUMsQ0FBQyxDQUFDO1FBRW5ELElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxlQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLGNBQUksRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxzQkFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLDJCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxnQkFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSx5QkFBVyxFQUFFLENBQUM7UUFFckMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDO2dCQUNkLElBQUksRUFBRSxTQUFTO2dCQUNmLE9BQU8sRUFBRSxJQUFJLGdCQUFNLENBQUMsSUFBSSxDQUFDO2FBQ3pCLEVBQUU7Z0JBQ0YsSUFBSSxFQUFFLFNBQVM7Z0JBQ2YsT0FBTyxFQUFFLElBQUksZ0JBQU0sQ0FBQyxJQUFJLENBQUM7YUFDekIsRUFBRTtnQkFDRixJQUFJLEVBQUUsU0FBUztnQkFDZixPQUFPLEVBQUUsSUFBSSxnQkFBTSxDQUFDLElBQUksQ0FBQzthQUN6QixFQUFFO2dCQUNGLElBQUksRUFBRSxTQUFTO2dCQUNmLE9BQU8sRUFBRSxJQUFJLGdCQUFNLENBQUMsSUFBSSxDQUFDO2FBQ3pCLEVBQUU7Z0JBQ0YsSUFBSSxFQUFFLG1CQUFtQjtnQkFDekIsT0FBTyxFQUFFLElBQUksQ0FBQyxXQUFXO2FBQ3pCLEVBQUU7Z0JBQ0YsSUFBSSxFQUFFLGVBQWU7Z0JBQ3JCLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSzthQUNuQixFQUFFO2dCQUNGLElBQUksRUFBRSxzQkFBc0I7Z0JBQzVCLE9BQU8sRUFBRSxJQUFJLDJCQUFpQixDQUFDLElBQUksQ0FBQzthQUNwQyxFQUFFO2dCQUNGLElBQUksRUFBRSxjQUFjO2dCQUNwQixPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVk7YUFDMUIsQ0FBQyxDQUFDO1FBRUcsYUFBK0UsRUFBN0UsZ0JBQUssRUFBRSxrQkFBTSxFQUFFLGNBQUksRUFBRSxnQkFBSyxFQUFFLDhCQUFZLEVBQUUsNEJBQVcsRUFBRSxnQ0FBYSxDQUFVO1FBRXRGLDhCQUE4QjtRQUM5QixZQUFZLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxXQUFDO1lBQ3hCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssbUJBQW1CLENBQUMsUUFBUSxDQUFDO2dCQUMzQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDckIsQ0FBQyxDQUFDLENBQUM7UUFFSCw4QkFBOEI7UUFDOUIsYUFBYSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsV0FBQztZQUN6QixJQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQUMsSUFBSSxRQUFDLENBQUMsT0FBTyxLQUFLLFdBQVcsRUFBekIsQ0FBeUIsQ0FBQyxDQUFDO1lBQzFELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQztnQkFDVCxLQUFLLENBQUMsSUFBSSxHQUFHLHVCQUFxQixDQUFDLENBQUMsUUFBUSxNQUFHLENBQUM7WUFDakQsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLFdBQUMsSUFBSSxRQUFDLENBQUMsSUFBSSxFQUFOLENBQU0sQ0FBQyxDQUFDO1FBQ3RDLENBQUMsQ0FBQyxDQUFDO1FBRUgsZ0RBQWdEO1FBQ2hELE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBSztZQUNuQixpQkFBaUI7WUFDakIsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7Z0JBQ3RCLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUksQ0FBQyxDQUFDO1lBQzFCLDJDQUEyQztZQUMzQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsV0FBQztnQkFDekIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLHFCQUFxQjtnQkFDOUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsWUFBWTtZQUMzQixDQUFDLENBQUMsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO1FBRUgsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxXQUFDLElBQUksUUFBQyxDQUFDLElBQUksRUFBTixDQUFNLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCw2QkFBSyxHQUFMO1FBQUEsaUJBY0M7UUFiQSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDbkMsS0FBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLFdBQUM7Z0JBQ3RCLElBQU0sS0FBSyxHQUFHLEtBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQUMsSUFBSSxRQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQWpCLENBQWlCLENBQUMsQ0FBQztnQkFDdkQsS0FBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLHVCQUF1QjtnQkFFNUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO29CQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztnQkFDcEMsQ0FBQztnQkFFRCxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsa0JBQWtCO1lBQzFDLENBQUMsQ0FBQyxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBRUYsb0JBQUM7QUFBRCxDQUFDO0FBeElZLHNDQUFhIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW5naW5lLCBHYW1lRXZlbnQsIENvbG9yLCBJbnB1dCwgTG9hZGVyLCBUZXh0dXJlIH0gZnJvbSBcImV4Y2FsaWJ1clwiO1xyXG5pbXBvcnQgeyBJRXZlbnRlZCwgQ2xhc3MgfSBmcm9tIFwiLi9DbGFzc1wiO1xyXG5pbXBvcnQgeyBOYW1lRW5xdWlyeSB9IGZyb20gXCIuL1NjZW5lcy9OYW1lRW5xdWlyeS9OYW1lRW5xdWlyeVwiO1xyXG5pbXBvcnQgRXhhbXBsZUxldmVsIGZyb20gXCIuL1NjZW5lcy9FeGFtcGxlTGV2ZWwvRXhhbXBsZUxldmVsXCI7XHJcbmltcG9ydCBNZW51IGZyb20gXCIuL1NjZW5lcy9NZW51L01lbnVcIjtcclxuaW1wb3J0IEludHJvIGZyb20gXCIuL1NjZW5lcy9JbnRyby9JbnRyb1wiO1xyXG5pbXBvcnQgTW92ZW1lbnRUZXN0TGV2ZWwgZnJvbSBcIi4vU2NlbmVzL01vdmVtZW50VGVzdExldmVsL01vdmVtZW50VGVzdExldmVsXCI7XHJcbmltcG9ydCBTdGF0ZUxpc3RlbmVyIGZyb20gXCIuL0NvbXBvbmVudHMvU3RhdGVMaXN0ZW5lclwiO1xyXG5pbXBvcnQgTGV2ZWwxIGZyb20gXCIuL1NjZW5lcy9MZXZlbDEvTGV2ZWwxXCI7XHJcbmltcG9ydCBMZXZlbDIgZnJvbSBcIi4vU2NlbmVzL0xldmVsMi9MZXZlbDJcIjtcclxuaW1wb3J0IExldmVsMyBmcm9tIFwiLi9TY2VuZXMvTGV2ZWwzL0xldmVsM1wiO1xyXG5pbXBvcnQgTGV2ZWw0IGZyb20gXCIuL1NjZW5lcy9MZXZlbDQvTGV2ZWw0XCI7XHJcbmltcG9ydCByZXNvdXJjZXMgZnJvbSBcIi4vUmVzb3VyY2VzXCI7XHJcblxyXG4vKipcclxuICogQSBnYW1lIGV2ZW50IHRoYXQgY29udGFpbnMgYSByZWxhdGVkIGV2ZW50IHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR2FtZUV2ZW50VmFsdWU8VD4gZXh0ZW5kcyBHYW1lRXZlbnQ8SUdhbWVFbGVtZW50PiB7XHJcblx0dmFsdWU6IFQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFdmVudCBpbnRlcmZhY2UgdXNlZCBieSBgSUdhbWVFbGVtZW50YC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdhbWVFbGVtZW50RG9uZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50PElHYW1lRWxlbWVudD4ge1xyXG5cdHR5cGU6IEdhbWVFbGVtZW50RG9uZVR5cGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHRoZSByZWFzb24gZm9yIEdhbWVFbGVtZW50IHRvIGJlIGRvbmUuXHJcbiAqL1xyXG5leHBvcnQgZW51bSBHYW1lRWxlbWVudERvbmVUeXBlIHtcclxuXHQvKipcclxuXHQgKiBFdmVyeXRoaW5nIGlzIGZpbmUsIHByb2NlZWQsIG9yIHRoZSBwbGF5ZXIgaGFzIHdvbi5cclxuXHQgKi9cclxuXHRGaW5pc2hlZCxcclxuXHQvKipcclxuXHQgKiBBbiBlcnJvciBvY2N1cnJlZCwgZG9uJ3QgcHJvY2VlZCwgb3IgdGhlIHBsYXllciBoYXMgZGllZC5cclxuXHQgKi9cclxuXHRBYm9ydGVkXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IGV2ZW50LW1hcHBpbmcgZm9yIGBJR2FtZUVsZW1lbnRgIGludGVyZmFjZS5cclxuICpcclxuICogSXQgaXMgcmVjb21tZW5kZWQgdG8gaW5oZXJpdCBmcm9tIHRoaXMgaW50ZXJmYWNlIHdoZW4gbmV3IGBJR2FtZUVsZW1lbnRgcyBhcmUgbWFkZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdhbWVFbGVtZW50RXZlbnRzIHtcclxuXHRkb25lOiBJR2FtZUVsZW1lbnREb25lRXZlbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGdhbWUgZWxlbWVudCBpbnRlcmZhY2UuIEluY2x1ZGUgZXZlbnQgbWFwcGluZyB0ZW1wbGF0ZSBwYXJhbXRlcmUgZm9yIHN0cm9uZ2x5LXR5cGVkIGV2ZW50cy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdhbWVFbGVtZW50PFQgZXh0ZW5kcyBJR2FtZUVsZW1lbnRFdmVudHMgPSBJR2FtZUVsZW1lbnRFdmVudHM+IGV4dGVuZHMgSUV2ZW50ZWQ8VD4ge1xyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgc2hvdWxkIHJ1biBpbml0aWFsaXNhdGlvbiBsb2dpYy5cclxuXHQgKi9cclxuXHRpbml0Pyhib290c3RyYXA6IEdhbWVCb290c3RyYXApOiB2b2lkO1xyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHJ1biBhbmQgZGlzcGxheSBpdHMgY29udGVudC4gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBwZXIgY29tcG9uZW50IGluc3RhbmNlLlxyXG5cdCAqL1xyXG5cdHN0YXJ0KCk6IHZvaWQ7XHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBzaG91bGQgaGlkZSBpdHMgY29udGVudCBhbmQgc3RvcCBpdHMgZXhlY3V0aW9uLiBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHBlciBjb21wb25lbnQgaW5zdGFuY2UuXHJcblx0ICovXHJcblx0ZGlzcG9zZSgpOiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogSW50ZXJmYWNlIGZvciBHYW1lQm9vdHN0cmFwIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR2FtZUJvb3RzdHJhcFN0YXRlIHtcclxuXHRuYW1lOiBzdHJpbmcgfCBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogR2FtZSBib290c3RyYXAgb2JqZWN0LlxyXG4gKlxyXG4gKiBIYW5kbGVzIHRoZSBsb2dpYyBiZWhpbmQgc3dpdGNoaW5nIGxldmVscyBhbmQgd2lyaW5nIGV2ZXJ5dGhpbmcgdXAuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2FtZUJvb3RzdHJhcCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFN0YXRlIGxpc3RlbmVyLlxyXG5cdCAqL1xyXG5cdHJlYWRvbmx5IHN0YXRlTGlzdGVuZXI6IFN0YXRlTGlzdGVuZXI8SUdhbWVCb290c3RyYXBTdGF0ZT47XHJcblx0LyoqXHJcblx0ICogU3RhdGUgaG9sZCBnbG9iYWwgZ2FtZSBpbmZvcm1hdGlvbi4gRXZlcnkgR2FtZUVsZW1lbnQgbWF5IGNoYW5nZSB0aGUgc3RhdGUuXHJcblx0ICovXHJcblx0cmVhZG9ubHkgc3RhdGU6IElHYW1lQm9vdHN0cmFwU3RhdGU7XHJcblx0LyoqXHJcblx0ICogRXhjYWxpYnVyanMnIGdhbWUgZW5naW5lLlxyXG5cdCAqL1xyXG5cdHJlYWRvbmx5IGVuZ2luZTogRW5naW5lO1xyXG5cdC8qKlxyXG5cdCAqIFRoZSBrZXkgb2YgdGhlIHJvb3QgKGJsYW5rKSBzY2VuZS5cclxuXHQgKi9cclxuXHRyZWFkb25seSByb290U2NlbmVLZXkgPSBcInJvb3RcIjtcclxuXHJcblx0cmVhZG9ubHkgbG9hZGVyOiBMb2FkZXI7XHJcblxyXG5cdHByaXZhdGUgbWVudTogTWVudTtcclxuXHRwcml2YXRlIGludHJvOiBJbnRybztcclxuXHRwcml2YXRlIGV4YW1wbGVMZXZlbDogRXhhbXBsZUxldmVsO1xyXG5cdHByaXZhdGUgbW92ZW1lbnRUZXN0TGV2ZWw6IE1vdmVtZW50VGVzdExldmVsO1xyXG5cdHByaXZhdGUgbGV2ZWwyOiBMZXZlbDI7XHJcblx0cHJpdmF0ZSBuYW1lRW5xdWlyeTogTmFtZUVucXVpcnk7XHJcblx0cHJpdmF0ZSBsZXZlbHM6IHsgbmFtZTogc3RyaW5nLCBlbGVtZW50OiBJR2FtZUVsZW1lbnQgfVtdO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdHB1YmxpYyByZWFkb25seSBjYW52YXNJZDogc3RyaW5nLFxyXG5cdFx0cHVibGljIHJlYWRvbmx5IG92ZXJsYXk6IEhUTUxFbGVtZW50XHJcblx0KSB7XHJcblx0XHR0aGlzLnN0YXRlTGlzdGVuZXIgPSBuZXcgU3RhdGVMaXN0ZW5lcjxJR2FtZUJvb3RzdHJhcFN0YXRlPih7XHJcblx0XHRcdG5hbWU6IG51bGxcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVMaXN0ZW5lci5jcmVhdGVMaXN0ZW5hYmxlT2JqZWN0KCk7XHJcblxyXG5cdFx0Ly8gY3JlYXRlIHRoZSBnYW1lIGVuZ2luZVxyXG5cdFx0dGhpcy5lbmdpbmUgPSBuZXcgRW5naW5lKHtcclxuXHRcdFx0d2lkdGg6IDgwMCxcclxuXHRcdFx0aGVpZ2h0OiA2MDAsXHJcblx0XHRcdGNhbnZhc0VsZW1lbnRJZDogY2FudmFzSWQsXHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogQ29sb3IuQmxhY2ssXHJcblx0XHRcdHBvaW50ZXJTY29wZTogSW5wdXQuUG9pbnRlclNjb3BlLkNhbnZhc1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5sb2FkZXIgPSBuZXcgTG9hZGVyKCk7XHJcblx0XHR0aGlzLmxvYWRlci5hZGRSZXNvdXJjZXMoT2JqZWN0LnZhbHVlcyhyZXNvdXJjZXMpKTtcclxuXHJcblx0XHR0aGlzLmludHJvID0gbmV3IEludHJvKHRoaXMpO1xyXG5cdFx0dGhpcy5tZW51ID0gbmV3IE1lbnUoKTtcclxuXHRcdHRoaXMuZXhhbXBsZUxldmVsID0gbmV3IEV4YW1wbGVMZXZlbCh0aGlzKTtcclxuXHRcdHRoaXMubW92ZW1lbnRUZXN0TGV2ZWwgPSBuZXcgTW92ZW1lbnRUZXN0TGV2ZWwodGhpcyk7XHJcblx0XHR0aGlzLmxldmVsMiA9IG5ldyBMZXZlbDIodGhpcyk7XHJcblx0XHR0aGlzLm5hbWVFbnF1aXJ5ID0gbmV3IE5hbWVFbnF1aXJ5KCk7XHJcblxyXG5cdFx0dGhpcy5sZXZlbHMgPSBbe1xyXG5cdFx0XHRuYW1lOiBcIkxldmVsIDFcIixcclxuXHRcdFx0ZWxlbWVudDogbmV3IExldmVsMSh0aGlzKVxyXG5cdFx0fSwge1xyXG5cdFx0XHRuYW1lOiBcIkxldmVsIDJcIixcclxuXHRcdFx0ZWxlbWVudDogbmV3IExldmVsMih0aGlzKVxyXG5cdFx0fSwge1xyXG5cdFx0XHRuYW1lOiBcIkxldmVsIDNcIixcclxuXHRcdFx0ZWxlbWVudDogbmV3IExldmVsMyh0aGlzKVxyXG5cdFx0fSwge1xyXG5cdFx0XHRuYW1lOiBcIkxldmVsIDRcIixcclxuXHRcdFx0ZWxlbWVudDogbmV3IExldmVsNCh0aGlzKVxyXG5cdFx0fSwge1xyXG5cdFx0XHRuYW1lOiBcIkNoYW5nZSB5b3VyIG5hbWUhXCIsXHJcblx0XHRcdGVsZW1lbnQ6IHRoaXMubmFtZUVucXVpcnlcclxuXHRcdH0sIHtcclxuXHRcdFx0bmFtZTogXCJJbnRybyAoU3RvcnkpXCIsXHJcblx0XHRcdGVsZW1lbnQ6IHRoaXMuaW50cm9cclxuXHRcdH0sIHtcclxuXHRcdFx0bmFtZTogXCJUZXN0IHBsYXllciBtb3ZlbWVudFwiLFxyXG5cdFx0XHRlbGVtZW50OiBuZXcgTW92ZW1lbnRUZXN0TGV2ZWwodGhpcylcclxuXHRcdH0sIHtcclxuXHRcdFx0bmFtZTogXCJQbGF5IGEgR2FtZSFcIixcclxuXHRcdFx0ZWxlbWVudDogdGhpcy5leGFtcGxlTGV2ZWxcclxuXHRcdH1dO1xyXG5cclxuXHRcdGNvbnN0IHsgc3RhdGUsIGxldmVscywgbWVudSwgaW50cm8sIGV4YW1wbGVMZXZlbCwgbmFtZUVucXVpcnksIHN0YXRlTGlzdGVuZXIgfSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gY3VzdG9tIGV2ZW50IGxpc3RlbmVyIGxvZ2ljXHJcblx0XHRleGFtcGxlTGV2ZWwub24oXCJkb25lXCIsIGUgPT4ge1xyXG5cdFx0XHRpZiAoZS50eXBlID09PSBHYW1lRWxlbWVudERvbmVUeXBlLkZpbmlzaGVkKVxyXG5cdFx0XHRcdGFsZXJ0KFwiR29vZCBqb2IhXCIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gc3RhdGUgY2hhbmdlIGV2ZW50IGJpbmRpbmdzXHJcblx0XHRzdGF0ZUxpc3RlbmVyLm9uKFwibmFtZVwiLCBlID0+IHtcclxuXHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHMuZmluZCh0ID0+IHQuZWxlbWVudCA9PT0gbmFtZUVucXVpcnkpO1xyXG5cdFx0XHRpZiAobGV2ZWwpXHJcblx0XHRcdFx0bGV2ZWwubmFtZSA9IGBDaGFuZ2UgeW91ciBuYW1lLCAke2UubmV3VmFsdWV9IWA7XHJcblx0XHRcdG1lbnUuaXRlbXMgPSBsZXZlbHMubWFwKHQgPT4gdC5uYW1lKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGluaXQgYWxsIGxldmVscyBhbmQgc3Vic2NyaWJlIGV2ZW50IGxpc3RlbmVyc1xyXG5cdFx0bGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xyXG5cdFx0XHQvLyBpbml0IHRoZSBsZXZlbFxyXG5cdFx0XHRpZiAobGV2ZWwuZWxlbWVudC5pbml0KVxyXG5cdFx0XHRcdGxldmVsLmVsZW1lbnQuaW5pdCh0aGlzKTtcclxuXHRcdFx0Ly8gZGVjaWRlIHdoYXQgdG8gZG8gd2hlbiB0aGUgbGV2ZWwgaXMgb3ZlclxyXG5cdFx0XHRsZXZlbC5lbGVtZW50Lm9uKFwiZG9uZVwiLCBlID0+IHtcclxuXHRcdFx0XHRsZXZlbC5lbGVtZW50LmRpc3Bvc2UoKTsgLy8gc3RvcCBjdXJyZW50IHNjZW5lXHJcblx0XHRcdFx0bWVudS5zdGFydCgpOyAvLyBzaG93IG1lbnVcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBpbml0IG1lbnUgYXMgYW55IG90aGVyIGdhbWUgZWxlbWVudFdXXHJcblx0XHRtZW51LmluaXQodGhpcyk7XHJcblx0XHQvLyBhc3NpZ24gY3VzdG9tIHByb3BlcnRpZXNcclxuXHRcdG1lbnUuaXRlbXMgPSBsZXZlbHMubWFwKHQgPT4gdC5uYW1lKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFN0YXJ0cyB0aGUgZ2FtZS5cclxuXHQgKi9cclxuXHRzdGFydCgpIHtcclxuXHRcdHRoaXMubWVudS5zdGFydCgpO1xyXG5cdFx0dGhpcy5lbmdpbmUuc3RhcnQodGhpcy5sb2FkZXIpLnRoZW4oKCkgPT4ge1xyXG5cdFx0XHR0aGlzLm1lbnUub24oXCJjbGlja1wiLCBlID0+IHtcclxuXHRcdFx0XHRjb25zdCBsZXZlbCA9IHRoaXMubGV2ZWxzLmZpbmQodCA9PiB0Lm5hbWUgPT09IGUubmFtZSk7XHJcblx0XHRcdFx0dGhpcy5tZW51LmRpc3Bvc2UoKTsgLy8gc3RvcCBkaXNwbGF5aW5nIG1lbnVcclxuXHJcblx0XHRcdFx0aWYgKCFsZXZlbCkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibGV2ZWwgbm90IGZvdW5kXCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV2ZWwuZWxlbWVudC5zdGFydCgpOyAvLyBzdGFydCB0aGUgbGV2ZWxcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL0dhbWVCb290c3RyYXAudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///14\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar Component = /** @class */ (function () {\r\n    function Component(attrs) {\r\n        /**\r\n         * Current attributes of the component, if any.\r\n         */\r\n        this.attrs = null;\r\n        this.attrs = attrs;\r\n    }\r\n    return Component;\r\n}());\r\nexports.Component = Component;\r\n/**\r\n * CSS properties which get assigned the `px` suffix.\r\n */\r\nexports.numericCSSProperties = [\r\n    "borderBottomLeftRadius",\r\n    "borderBottomRightRadius",\r\n    "borderRadius",\r\n    "borderTopLeftRadius",\r\n    "borderTopRightRadius ",\r\n    "borderWidth",\r\n    "bottom",\r\n    "fontSize",\r\n    "height",\r\n    "left",\r\n    "margin",\r\n    "marginBottom",\r\n    "marginLeft",\r\n    "marginRight",\r\n    "marginTop",\r\n    "padding",\r\n    "paddingBottom",\r\n    "paddingLeft",\r\n    "paddingRight",\r\n    "paddingTop",\r\n    "right",\r\n    "strokeWidth",\r\n    "top",\r\n    "width"\r\n];\r\n/**\r\n * Error to throw when requested DOM content is not yet loaded.\r\n */\r\nvar DOMContentNotLoaded = /** @class */ (function (_super) {\r\n    __extends(DOMContentNotLoaded, _super);\r\n    function DOMContentNotLoaded(message) {\r\n        if (message === void 0) { message = "DOM content not loaded."; }\r\n        return _super.call(this, message) || this;\r\n    }\r\n    return DOMContentNotLoaded;\r\n}(Error));\r\nexports.DOMContentNotLoaded = DOMContentNotLoaded;\r\n/**\r\n * Error to throw when and invalid child object is given to a JSX element.\r\n */\r\nvar InvalidChildElement = /** @class */ (function (_super) {\r\n    __extends(InvalidChildElement, _super);\r\n    function InvalidChildElement(item, message) {\r\n        var _this = _super.call(this, message\r\n            || (item && "Invalid object passed as a child of an JSX element: \\"" + item.toString() + "\\".")\r\n            || "Invalid object passed as a child of an JSX element.") || this;\r\n        _this.item = item;\r\n        return _this;\r\n    }\r\n    return InvalidChildElement;\r\n}(Error));\r\nexports.InvalidChildElement = InvalidChildElement;\r\n/**\r\n * Provides functionalities for manupulating the DOM.\r\n */\r\nvar InterfaceBuilder;\r\n(function (InterfaceBuilder) {\r\n    InterfaceBuilder.canvasId = "canvas";\r\n    InterfaceBuilder.appId = "app";\r\n    InterfaceBuilder.canvasHolderId = "canvas-holder";\r\n    /**\r\n     * Gets the `#canvas-holder` DOM element.\r\n     */\r\n    function getCanvasHolder() {\r\n        return document.getElementById(InterfaceBuilder.canvasHolderId);\r\n    }\r\n    InterfaceBuilder.getCanvasHolder = getCanvasHolder;\r\n    /**\r\n     * Gets the `#canvas` DOM element.\r\n     */\r\n    function getCanvas() {\r\n        return document.getElementById(InterfaceBuilder.canvasId);\r\n    }\r\n    InterfaceBuilder.getCanvas = getCanvas;\r\n    /**\r\n     * Gets the `#app` DOM element.\r\n     */\r\n    function getApp() {\r\n        return document.getElementById(InterfaceBuilder.appId);\r\n    }\r\n    InterfaceBuilder.getApp = getApp;\r\n    function isTruthy(value) {\r\n        return !isFalsy(value);\r\n    }\r\n    InterfaceBuilder.isTruthy = isTruthy;\r\n    function isFalsy(value) {\r\n        return value === false\r\n            || value === null\r\n            || value === undefined;\r\n    }\r\n    InterfaceBuilder.isFalsy = isFalsy;\r\n    function filter(values) {\r\n        if (!values)\r\n            return [];\r\n        else if (Array.isArray(values))\r\n            return values.filter(isTruthy);\r\n        else if (isTruthy(values))\r\n            return [values];\r\n        else\r\n            return [];\r\n    }\r\n    InterfaceBuilder.filter = filter;\r\n    /**\r\n     * Flattens an array of node collections and filters it for truthy values only.\r\n     * @param array Array of nodes collections to flatten.\r\n     */\r\n    function flatten(array) {\r\n        var flattened = [];\r\n        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\r\n            var value = array_1[_i];\r\n            if (isTruthy(value)) {\r\n                if (Array.isArray(value))\r\n                    flattened.push.apply(flattened, value.filter(isTruthy));\r\n                else\r\n                    flattened.push(value);\r\n            }\r\n        }\r\n        return flattened;\r\n    }\r\n    InterfaceBuilder.flatten = flatten;\r\n    function assignStyle(given, actual) {\r\n        for (var prop in given) {\r\n            var value = given[prop];\r\n            if (typeof value === "number" && exports.numericCSSProperties.includes(prop))\r\n                value = value + "px";\r\n            actual[prop] = given[prop];\r\n        }\r\n    }\r\n    function assignAttributes(attrs, element) {\r\n        if (!attrs)\r\n            return;\r\n        for (var attr in attrs) {\r\n            if (attr === "ref")\r\n                continue;\r\n            var value = attrs[attr];\r\n            if (value === null || value === undefined)\r\n                continue;\r\n            if (attr === "style")\r\n                assignStyle(value, element.style);\r\n            else\r\n                element[attr] = value;\r\n        }\r\n    }\r\n    /**\r\n     * Creates DOM element from given tag name.\r\n     * @param name DOM element tag.\r\n     * @param attrs Attributes to assign.\r\n     * @param children Children to append.\r\n     */\r\n    function createIntrinsicElement(name, attrs, children) {\r\n        var elt = document.createElement(name);\r\n        assignAttributes(attrs, elt);\r\n        var str = ""; // optimisation\r\n        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\r\n            var collection = children_1[_i];\r\n            var col = Array.isArray(collection) ? collection : [collection];\r\n            for (var _a = 0, col_1 = col; _a < col_1.length; _a++) {\r\n                var child = col_1[_a];\r\n                if (isTruthy(child)) {\r\n                    if (typeof child === "object") {\r\n                        if (!(child instanceof Element))\r\n                            throw new InvalidChildElement(child);\r\n                        if (str) {\r\n                            elt.insertAdjacentText("beforeend", str);\r\n                            str = "";\r\n                        }\r\n                        elt.insertAdjacentElement("beforeend", child);\r\n                    }\r\n                    else\r\n                        str += child.toString();\r\n                }\r\n            }\r\n        }\r\n        if (str)\r\n            elt.insertAdjacentText("beforeend", str);\r\n        if (attrs && attrs.ref)\r\n            attrs.ref(elt);\r\n        return elt;\r\n    }\r\n    InterfaceBuilder.createIntrinsicElement = createIntrinsicElement;\r\n    /**\r\n     * Retrievers element collection from given provider.\r\n     * @param provider Provider to use.\r\n     * @param attrs Attributes to assign.\r\n     * @param children Children to append.\r\n     */\r\n    function createFunctionalElement(provider, attrs, children) {\r\n        return provider(attrs, flatten(children));\r\n    }\r\n    InterfaceBuilder.createFunctionalElement = createFunctionalElement;\r\n    /**\r\n     * Instantiates given component class and renders it\'s content.\r\n     * @param componentClass Component class to instantiate and use.\r\n     * @param attrs Attributes to assign.\r\n     * @param children Children to append.\r\n     */\r\n    function createComponentClassElement(componentClass, attrs, children) {\r\n        var c = flatten(children);\r\n        var instance;\r\n        if (componentClass.instanceProvider)\r\n            instance = componentClass.instanceProvider(attrs, c);\r\n        if (!instance && componentClass.instance)\r\n            instance = componentClass.instance;\r\n        if (!instance) {\r\n            instance = new componentClass(attrs);\r\n            if (componentClass.instanceCreated)\r\n                componentClass.instanceCreated(instance);\r\n        }\r\n        return instance.render(attrs, c);\r\n    }\r\n    InterfaceBuilder.createComponentClassElement = createComponentClassElement;\r\n    /**\r\n     * Renders contents of a JSX component.\r\n     * @param component Component to render.\r\n     * @param attrs Attributes to assign.\r\n     * @param children Children to append.\r\n     */\r\n    function createComponentInstanceElement(component, attrs, children) {\r\n        if (component.componentWillReceiveAttrs)\r\n            component.componentWillReceiveAttrs(attrs);\r\n        component.attrs = attrs;\r\n        return component.render(attrs, flatten(children));\r\n    }\r\n    InterfaceBuilder.createComponentInstanceElement = createComponentInstanceElement;\r\n    function createElement(factory, attrs) {\r\n        var children = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            children[_i - 2] = arguments[_i];\r\n        }\r\n        if (typeof factory === "string")\r\n            return createIntrinsicElement(factory, attrs, children);\r\n        else if (typeof factory.prototype.render === "function")\r\n            return createComponentClassElement(factory, attrs, children);\r\n        else\r\n            return createFunctionalElement(factory, attrs, children);\r\n    }\r\n    InterfaceBuilder.createElement = createElement;\r\n    /**\r\n     * Creates document fragment which inclueds given elements. Use this to apply multiple elements to the DOM.\r\n     * @param elementCollection Elements to include.\r\n     */\r\n    function createFragment(elementCollection) {\r\n        var fragment = document.createDocumentFragment();\r\n        filter(elementCollection).forEach(function (elt) { return fragment.appendChild(elt); });\r\n        return fragment;\r\n    }\r\n    InterfaceBuilder.createFragment = createFragment;\r\n    /**\r\n     * Appends element to DOM.\r\n     * @param element Element to append to.\r\n     * @param elementCollection Elements to append.\r\n     */\r\n    function append(element, elementCollection) {\r\n        element.appendChild(createFragment(elementCollection));\r\n    }\r\n    InterfaceBuilder.append = append;\r\n    /**\r\n     * Clears all element\'s content.\r\n     * @param element Element which\'s content to clear.\r\n     */\r\n    function clearContent(element) {\r\n        /*\r\n         * This is much faster than elment.innerHTML = "";\r\n         * See https://stackoverflow.com/questions/3955229/remove-all-child-elements-of-a-dom-node-in-javascript\r\n         */\r\n        while (element.firstChild)\r\n            element.removeChild(element.firstChild);\r\n    }\r\n    InterfaceBuilder.clearContent = clearContent;\r\n    /**\r\n     * Replaces element\'s content with given elements.\r\n     * @param element Element which\'s content to replace.\r\n     * @param elementCollection Elements to insert.\r\n     */\r\n    function replaceContent(element, elementCollection) {\r\n        clearContent(element);\r\n        append(element, elementCollection);\r\n    }\r\n    InterfaceBuilder.replaceContent = replaceContent;\r\n    /**\r\n     * Replaces element with other elements.\r\n     * @param element Element to remove and replace.\r\n     * @param elementCollection Elements to insert.\r\n     */\r\n    function replace(element, elementCollection) {\r\n        var parent = element.parentElement;\r\n        if (!parent)\r\n            throw new Error("No parent element found.");\r\n        parent.insertBefore(createFragment(elementCollection), element);\r\n        element.remove();\r\n    }\r\n    InterfaceBuilder.replace = replace;\r\n    /**\r\n     * Hides an HTML element by setting its display CSS property to "none".\r\n     * @param element Element to hide.\r\n     */\r\n    function hideElement(element) {\r\n        element.style.display = "none";\r\n    }\r\n    InterfaceBuilder.hideElement = hideElement;\r\n    /**\r\n     * \tUnhides an HTML elemenet by setting its display CSS property to something other than "none".\r\n     * @param element Element to unhide.\r\n     * @param displayStyle Display CSS property, if other than "block";\r\n     */\r\n    function showElement(element, displayStyle) {\r\n        if (displayStyle === void 0) { displayStyle = "block"; }\r\n        element.style.display = displayStyle;\r\n    }\r\n    InterfaceBuilder.showElement = showElement;\r\n    /**\r\n     * Display given elements in the default interface container (the `#app` element) and hides the default canvas (the `#canvas` element).\r\n     * @param elementCollection Elements to display.\r\n     */\r\n    function displayDefault(elementCollection) {\r\n        var app = getApp();\r\n        var ch = getCanvasHolder();\r\n        if (app && ch) {\r\n            replaceContent(getApp(), elementCollection);\r\n            hideElement(ch);\r\n            showElement(app);\r\n        }\r\n        else\r\n            throw new DOMContentNotLoaded(); // throw if not loaded\r\n    }\r\n    InterfaceBuilder.displayDefault = displayDefault;\r\n    /**\r\n     * Clears and hides application\'s default interface container (the `#app` element) and shows the default canvas (the `#canvas` element).\r\n     */\r\n    function clearDefault() {\r\n        var app = getApp();\r\n        var ch = getCanvasHolder();\r\n        if (app && ch) {\r\n            clearContent(app);\r\n            hideElement(app);\r\n            showElement(ch);\r\n        }\r\n        else\r\n            throw new DOMContentNotLoaded(); // throw if not loaded\r\n    }\r\n    InterfaceBuilder.clearDefault = clearDefault;\r\n    /**\r\n     * Subscribes a listener to DOMContentLoaded event.\r\n     * @param callback Listener to subscribe.\r\n     */\r\n    function onDOMContentLoaded(callback) {\r\n        document.addEventListener("DOMContentLoaded", callback);\r\n    }\r\n    InterfaceBuilder.onDOMContentLoaded = onDOMContentLoaded;\r\n    /**\r\n     * Returns a promise which is resolved when DOM content gets loaded.\r\n     */\r\n    function awaitDOMContentLoaded() {\r\n        return new Promise(function (resolve) { return document.addEventListener("DOMContentLoaded", resolve); });\r\n    }\r\n    InterfaceBuilder.awaitDOMContentLoaded = awaitDOMContentLoaded;\r\n})(InterfaceBuilder = exports.InterfaceBuilder || (exports.InterfaceBuilder = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvSW50ZXJmYWNlQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtJQWFDLG1CQUFZLEtBQTRCO1FBUHhDOztXQUVHO1FBQ0gsVUFBSyxHQUEwQixJQUFJLENBQUM7UUFLbkMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQWdCRixnQkFBQztBQUFELENBQUM7QUEvQnFCLDhCQUFTO0FBMEcvQjs7R0FFRztBQUNVLDRCQUFvQixHQUFHO0lBQ25DLHdCQUF3QjtJQUN4Qix5QkFBeUI7SUFDekIsY0FBYztJQUNkLHFCQUFxQjtJQUNyQix1QkFBdUI7SUFDdkIsYUFBYTtJQUNiLFFBQVE7SUFDUixVQUFVO0lBQ1YsUUFBUTtJQUNSLE1BQU07SUFDTixRQUFRO0lBQ1IsY0FBYztJQUNkLFlBQVk7SUFDWixhQUFhO0lBQ2IsV0FBVztJQUNYLFNBQVM7SUFDVCxlQUFlO0lBQ2YsYUFBYTtJQUNiLGNBQWM7SUFDZCxZQUFZO0lBQ1osT0FBTztJQUNQLGFBQWE7SUFDYixLQUFLO0lBQ0wsT0FBTztDQUNQLENBQUM7QUFFRjs7R0FFRztBQUNIO0lBQXlDLHVDQUFLO0lBQzdDLDZCQUFZLE9BQW1DO1FBQW5DLDZEQUFtQztlQUM5QyxrQkFBTSxPQUFPLENBQUM7SUFDZixDQUFDO0lBQ0YsMEJBQUM7QUFBRCxDQUFDLENBSndDLEtBQUssR0FJN0M7QUFKWSxrREFBbUI7QUFNaEM7O0dBRUc7QUFDSDtJQUF5Qyx1Q0FBSztJQUM3Qyw2QkFBNEIsSUFBUyxFQUFFLE9BQWdCO1FBQXZELFlBQ0Msa0JBQU0sT0FBTztlQUNULENBQUMsSUFBSSxJQUFJLDJEQUF3RCxJQUFJLENBQUMsUUFBUSxFQUFFLFFBQUksQ0FBQztlQUNyRixxREFBcUQsQ0FDeEQsU0FDRDtRQUwyQixVQUFJLEdBQUosSUFBSSxDQUFLOztJQUtyQyxDQUFDO0lBQ0YsMEJBQUM7QUFBRCxDQUFDLENBUHdDLEtBQUssR0FPN0M7QUFQWSxrREFBbUI7QUFTaEM7O0dBRUc7QUFDSCxJQUFpQixnQkFBZ0IsQ0FxV2hDO0FBcldELFdBQWlCLGdCQUFnQjtJQUVuQix5QkFBUSxHQUFHLFFBQVEsQ0FBQztJQUNwQixzQkFBSyxHQUFHLEtBQUssQ0FBQztJQUNkLCtCQUFjLEdBQUcsZUFBZSxDQUFDO0lBRTlDOztPQUVHO0lBQ0g7UUFDQyxNQUFNLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQywrQkFBYyxDQUFtQixDQUFDO0lBQ2xFLENBQUM7SUFGZSxnQ0FBZSxrQkFFOUI7SUFFRDs7T0FFRztJQUNIO1FBQ0MsTUFBTSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMseUJBQVEsQ0FBc0IsQ0FBQztJQUMvRCxDQUFDO0lBRmUsMEJBQVMsWUFFeEI7SUFFRDs7T0FFRztJQUNIO1FBQ0MsTUFBTSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsc0JBQUssQ0FBbUIsQ0FBQztJQUN6RCxDQUFDO0lBRmUsdUJBQU0sU0FFckI7SUFZRCxrQkFBeUIsS0FBVTtRQUNsQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUZlLHlCQUFRLFdBRXZCO0lBWUQsaUJBQXdCLEtBQVU7UUFDakMsTUFBTSxDQUFDLEtBQUssS0FBSyxLQUFLO2VBQ2xCLEtBQUssS0FBSyxJQUFJO2VBQ2QsS0FBSyxLQUFLLFNBQVMsQ0FBQztJQUN6QixDQUFDO0lBSmUsd0JBQU8sVUFJdEI7SUFRRCxnQkFBdUIsTUFBMEI7UUFDaEQsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7WUFDWCxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQ1gsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDOUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFxQixDQUFDO1FBQ3BELElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDekIsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDakIsSUFBSTtZQUNILE1BQU0sQ0FBQyxFQUFFLENBQUM7SUFDWixDQUFDO0lBVGUsdUJBQU0sU0FTckI7SUFFRDs7O09BR0c7SUFDSCxpQkFBd0IsS0FBMkI7UUFDbEQsSUFBTSxTQUFTLEdBQXFCLEVBQUUsQ0FBQztRQUN2QyxHQUFHLENBQUMsQ0FBYyxVQUFLLEVBQUwsZUFBSyxFQUFMLG1CQUFLLEVBQUwsSUFBSztZQUFsQixJQUFJLEtBQUs7WUFDYixFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyQixFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUN4QixTQUFTLENBQUMsSUFBSSxPQUFkLFNBQVMsRUFBUyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBcUIsRUFBRTtnQkFDL0QsSUFBSTtvQkFDSCxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQXVCLENBQUMsQ0FBQztZQUMxQyxDQUFDO1NBQ0Q7UUFDRCxNQUFNLENBQUMsU0FBUyxDQUFDO0lBQ2xCLENBQUM7SUFYZSx3QkFBTyxVQVd0QjtJQUVELHFCQUFxQixLQUF3QixFQUFFLE1BQTJCO1FBQ3pFLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDeEIsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3hCLEVBQUUsQ0FBQyxDQUFDLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSw0QkFBb0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3BFLEtBQUssR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDO1lBQ3JCLE1BQXlCLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hELENBQUM7SUFDRixDQUFDO0lBRUQsMEJBQTZCLEtBQXdCLEVBQUUsT0FBb0I7UUFDMUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFDVixNQUFNLENBQUM7UUFDUixHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3hCLEVBQUUsQ0FBQyxDQUFDLElBQUksS0FBSyxLQUFLLENBQUM7Z0JBQ2xCLFFBQVEsQ0FBQztZQUNWLElBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQVEsQ0FBQztZQUNqQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLENBQUM7Z0JBQ3pDLFFBQVEsQ0FBQztZQUNWLEVBQUUsQ0FBQyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUM7Z0JBQ3BCLFdBQVcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ25DLElBQUk7Z0JBQ0YsT0FBZSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUNqQyxDQUFDO0lBQ0YsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsZ0NBQWdFLElBQVksRUFBRSxLQUF3QixFQUFFLFFBQThCO1FBQ3JJLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRTdCLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLGVBQWU7UUFDN0IsR0FBRyxDQUFDLENBQXFCLFVBQVEsRUFBUixxQkFBUSxFQUFSLHNCQUFRLEVBQVIsSUFBUTtZQUE1QixJQUFNLFVBQVU7WUFDcEIsSUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2xFLEdBQUcsQ0FBQyxDQUFnQixVQUFHLEVBQUgsV0FBRyxFQUFILGlCQUFHLEVBQUgsSUFBRztnQkFBbEIsSUFBTSxLQUFLO2dCQUNmLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3JCLEVBQUUsQ0FBQyxDQUFDLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUM7d0JBQy9CLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLFlBQVksT0FBTyxDQUFDLENBQUM7NEJBQy9CLE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDdEMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzs0QkFDVCxHQUFHLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDOzRCQUN6QyxHQUFHLEdBQUcsRUFBRSxDQUFDO3dCQUNWLENBQUM7d0JBQ0QsR0FBRyxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDL0MsQ0FBQztvQkFBQyxJQUFJO3dCQUNMLEdBQUcsSUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQzFCLENBQUM7YUFDRDtTQUNEO1FBQ0QsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQ1AsR0FBRyxDQUFDLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUUxQyxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUN0QixLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWhCLE1BQU0sQ0FBQyxHQUFHLENBQUM7SUFDWixDQUFDO0lBN0JlLHVDQUFzQix5QkE2QnJDO0lBRUQ7Ozs7O09BS0c7SUFDSCxpQ0FBaUUsUUFBeUIsRUFBRSxLQUF3QixFQUFFLFFBQThCO1FBQ25KLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFGZSx3Q0FBdUIsMEJBRXRDO0lBRUQ7Ozs7O09BS0c7SUFDSCxxQ0FBd0gsY0FBcUMsRUFBRSxLQUF3QixFQUFFLFFBQThCO1FBQ3ROLElBQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM1QixJQUFJLFFBQThCLENBQUM7UUFDbkMsRUFBRSxDQUFDLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDO1lBQ25DLFFBQVEsR0FBRyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3RELEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxJQUFJLGNBQWMsQ0FBQyxRQUFRLENBQUM7WUFDeEMsUUFBUSxHQUFHLGNBQWMsQ0FBQyxRQUFRLENBQUM7UUFDcEMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2YsUUFBUSxHQUFHLElBQUssY0FBNEMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNwRSxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDO2dCQUNsQyxjQUFjLENBQUMsZUFBZSxDQUFDLFFBQWEsQ0FBQyxDQUFDO1FBQ2hELENBQUM7UUFDRCxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQWJlLDRDQUEyQiw4QkFhMUM7SUFFRDs7Ozs7T0FLRztJQUNILHdDQUFrRCxTQUF1QixFQUFFLEtBQVEsRUFBRSxRQUE4QjtRQUNsSCxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMseUJBQXlCLENBQUM7WUFDdkMsU0FBUyxDQUFDLHlCQUF5QixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBTGUsK0NBQThCLGlDQUs3QztJQW1DRCx1QkFDQyxPQUEyRCxFQUMzRCxLQUE0QjtRQUM1QixrQkFBaUM7YUFBakMsVUFBaUMsRUFBakMscUJBQWlDLEVBQWpDLElBQWlDO1lBQWpDLGlDQUFpQzs7UUFFakMsRUFBRSxDQUFDLENBQUMsT0FBTyxPQUFPLEtBQUssUUFBUSxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3pELElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQztZQUN2RCxNQUFNLENBQUMsMkJBQTJCLENBQUMsT0FBYyxFQUFFLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNyRSxJQUFJO1lBQ0gsTUFBTSxDQUFDLHVCQUF1QixDQUFDLE9BQWMsRUFBRSxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQVhlLDhCQUFhLGdCQVc1QjtJQUVEOzs7T0FHRztJQUNILHdCQUErQixpQkFBd0M7UUFDdEUsSUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLHNCQUFzQixFQUFFLENBQUM7UUFDbkQsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsT0FBTyxDQUFDLGFBQUcsSUFBSSxlQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUF6QixDQUF5QixDQUFDLENBQUM7UUFDcEUsTUFBTSxDQUFDLFFBQVEsQ0FBQztJQUNqQixDQUFDO0lBSmUsK0JBQWMsaUJBSTdCO0lBRUQ7Ozs7T0FJRztJQUNILGdCQUF1QixPQUFnQixFQUFFLGlCQUF3QztRQUNoRixPQUFPLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUZlLHVCQUFNLFNBRXJCO0lBRUQ7OztPQUdHO0lBQ0gsc0JBQTZCLE9BQWdCO1FBQzVDOzs7V0FHRztRQUNILE9BQU8sT0FBTyxDQUFDLFVBQVU7WUFDeEIsT0FBTyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQVBlLDZCQUFZLGVBTzNCO0lBRUQ7Ozs7T0FJRztJQUNILHdCQUErQixPQUFnQixFQUFFLGlCQUF3QztRQUN4RixZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEIsTUFBTSxDQUFDLE9BQU8sRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFIZSwrQkFBYyxpQkFHN0I7SUFFRDs7OztPQUlHO0lBQ0gsaUJBQXdCLE9BQWdCLEVBQUUsaUJBQXdDO1FBQ2pGLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUM7UUFDckMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7WUFDWCxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7UUFDN0MsTUFBTSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsaUJBQWlCLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNoRSxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDbEIsQ0FBQztJQU5lLHdCQUFPLFVBTXRCO0lBRUQ7OztPQUdHO0lBQ0gscUJBQTRCLE9BQW9CO1FBQy9DLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztJQUNoQyxDQUFDO0lBRmUsNEJBQVcsY0FFMUI7SUFFRDs7OztPQUlHO0lBQ0gscUJBQTRCLE9BQW9CLEVBQUUsWUFBOEI7UUFBOUIscURBQThCO1FBQy9FLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLFlBQVksQ0FBQztJQUN0QyxDQUFDO0lBRmUsNEJBQVcsY0FFMUI7SUFFRDs7O09BR0c7SUFDSCx3QkFBK0IsaUJBQXdDO1FBQ3RFLElBQU0sR0FBRyxHQUFHLE1BQU0sRUFBRSxDQUFDO1FBQ3JCLElBQU0sRUFBRSxHQUFHLGVBQWUsRUFBRSxDQUFDO1FBQzdCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2YsY0FBYyxDQUFDLE1BQU0sRUFBRSxFQUFFLGlCQUFpQixDQUFDLENBQUM7WUFDNUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2hCLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsQixDQUFDO1FBQUMsSUFBSTtZQUFDLE1BQU0sSUFBSSxtQkFBbUIsRUFBRSxDQUFDLENBQUMsc0JBQXNCO0lBQy9ELENBQUM7SUFSZSwrQkFBYyxpQkFRN0I7SUFFRDs7T0FFRztJQUNIO1FBQ0MsSUFBTSxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUM7UUFDckIsSUFBTSxFQUFFLEdBQUcsZUFBZSxFQUFFLENBQUM7UUFDN0IsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDZixZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbEIsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pCLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNqQixDQUFDO1FBQUMsSUFBSTtZQUFDLE1BQU0sSUFBSSxtQkFBbUIsRUFBRSxDQUFDLENBQUMsc0JBQXNCO0lBQy9ELENBQUM7SUFSZSw2QkFBWSxlQVEzQjtJQUVEOzs7T0FHRztJQUNILDRCQUFtQyxRQUE0QztRQUM5RSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsa0JBQWtCLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUZlLG1DQUFrQixxQkFFakM7SUFFRDs7T0FFRztJQUNIO1FBQ0MsTUFBTSxDQUFDLElBQUksT0FBTyxDQUFDLGlCQUFPLElBQUksZUFBUSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixFQUFFLE9BQU8sQ0FBQyxFQUF0RCxDQUFzRCxDQUFDLENBQUM7SUFDdkYsQ0FBQztJQUZlLHNDQUFxQix3QkFFcEM7QUFFRixDQUFDLEVBcldnQixnQkFBZ0IsR0FBaEIsd0JBQWdCLEtBQWhCLHdCQUFnQixRQXFXaEMiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50PFQgZXh0ZW5kcyBKU1guQXR0cnNUeXBlID0gSlNYLkRlZmF1bHRBdHRycywgRSBleHRlbmRzIEpTWC5FbGVtZW50QmFzZSA9IEpTWC5FbGVtZW50QmFzZT4gaW1wbGVtZW50cyBKU1guQ29tcG9uZW50PFQ+IHtcblxuXHQvKipcblx0ICogVGhpcyB2YWx1ZSB3aWxsIGFsd2F5cyBiZSB1bmRlZmluZWQgdW5sZXNzIG1hbnVhbGx5IHNldC4gVXNlIGBhdHRyc2AgcHJvcGVydHkgaW5zdGVhZC5cblx0ICovXG5cdF9hdHRycz86IEpTWC5BdHRyczxULCBFPjtcblx0LyoqXG5cdCAqIEN1cnJlbnQgYXR0cmlidXRlcyBvZiB0aGUgY29tcG9uZW50LCBpZiBhbnkuXG5cdCAqL1xuXHRhdHRycz86IEpTWC5BdHRyc1ZhbHVlPFQsIEU+ID0gbnVsbDtcblxuXHRjb25zdHJ1Y3RvcigpO1xuXHRjb25zdHJ1Y3RvcihhdHRyczogSlNYLkF0dHJzVmFsdWU8VCwgRT4pO1xuXHRjb25zdHJ1Y3RvcihhdHRycz86IEpTWC5BdHRyc1ZhbHVlPFQsIEU+KSB7XG5cdFx0dGhpcy5hdHRycyA9IGF0dHJzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxlZCBieSBKU1ggZW5naW5lIHdoZW4gYmVmb3JlIHJlbmRlcmluZyBhbmQgYmVmb3JlIG5ldyBhdHRyaWJ1dGVzIHdpbGwgYmUgYXNzaWduZWQuXG5cdCAqIFxuXHQgKiBJbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gYXBwbHkgY3VzdG9tIGxvZ2ljLlxuXHQgKiBAcGFyYW0gbmV4dEF0dHJzIE5ldyBhdHRyaWJ1dGVzLlxuXHQgKi9cblx0Y29tcG9uZW50V2lsbFJlY2VpdmVBdHRycz8obmV4dEF0dHJzOiBKU1guQXR0cnNWYWx1ZTxUPik6IHZvaWQ7XG5cdC8qKlxuXHQgKiBDYWxsZWQgYnkgSlNYIGVuZ2luZSB3aGVuIG5ldyBjb250ZW50IGlzIHRvIGJlIHJlbmRlcmVkLlxuXHQgKiBAcGFyYW0gYXR0cnMgQXR0cmlidXRlcyB0byByZW5kZXIuXG5cdCAqIEBwYXJhbSBjaGlsZHJlbiBDaGlsZHJlbiB0byBhcHBlbmQuXG5cdCAqL1xuXHRhYnN0cmFjdCByZW5kZXIoYXR0cnM6IEpTWC5BdHRyc1ZhbHVlPFQ+LCBjaGlsZHJlbjogSlNYLkNoaWxkcmVuKTogSlNYLkVsZW1lbnRDb2xsZWN0aW9uO1xuXG59XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZHMgb2YgdGhlIEpTWCBgQ29tcG9uZW50YCBjbGFzcyBmb3IgdXNpbmcgdGhlIGRlZmF1bHQgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbXBvbmVudENsYXNzRGVmYXVsdDxUIGV4dGVuZHMgSlNYLkF0dHJzVHlwZSwgRSBleHRlbmRzIEpTWC5FbGVtZW50QmFzZSA9IEpTWC5FbGVtZW50QmFzZT4ge1xuXHRuZXcoKTogQ29tcG9uZW50PFQsIEU+O1xuXHRuZXcoYXR0cnM6IEpTWC5BdHRyc1ZhbHVlPFQ+KTogQ29tcG9uZW50PFQsIEU+O1xuXHRwcm90b3R5cGU6IENvbXBvbmVudDxULCBFPjtcblx0LyoqXG5cdCAqIEluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgZm9yIEpTWCBlbmdpbmUgdG8gcmUtdXNlIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2UuXG5cdCAqIFxuXHQgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIGJlIGlnbm9yZWQgaWYgYGluc3RhbmNlUHJvdmlkZXJgIGlzIHNwZWNpZmllZCBhbmQgd2lsbCByZXR1cm4gYSBjb21wb25lbnQgaW5zdGFuY2UuXG5cdCAqL1xuXHRpbnN0YW5jZT86IENvbXBvbmVudDxULCBFPiB8IHVuc2V0O1xuXHQvKipcblx0ICogSWYgaW1wbGVtZW50ZWQsIHVzZWQgYnkgdGhlIEpTWCBlbmdpbmUgdG8gcmV0cmlldmUgY29tcG9uZW50IGluc3RhbmNlcy4gQW4gZXhpc3Rpbmcgb3IgbmV3bHkgY3JlYXRlZCBpbnN0YW5jZSBtYXkgYmUgcmV0dXJuZWQuIElmIG5vIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgYGluc3RhbmNlYCBwcm9wZXJ0eSBpcyB0YWtlbi5cblx0ICovXG5cdGluc3RhbmNlUHJvdmlkZXI/KGF0dHJzOiBKU1guQXR0cnNWYWx1ZTxUPiwgY2hpbGRyZW46IEpTWC5DaGlsZHJlbik6IENvbXBvbmVudDxULCBFPiB8IHVuc2V0O1xuXHQvKipcblx0ICogQ2FsbGVkIGJ5IHRoZSBKU1ggZW5naW5lIHRvIGxvZyBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCBpbnN0YW5jZSwgaWYgaW1wbGVtZW50ZWQuXG5cdCAqL1xuXHRpbnN0YW5jZUNyZWF0ZWQ/KGluc3RhbmNlOiBDb21wb25lbnQ8VCwgRT4pOiB2b2lkO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2RzIG9mIHRoZSBKU1ggYENvbXBvbmVudGAgY2xhc3MgZm9yIHVzaW5nIGBpbnN0YW5jZWAgZmllbGQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbXBvbmVudENsYXNzSW5zdGFuY2U8VCBleHRlbmRzIEpTWC5BdHRyc1R5cGUsIEUgZXh0ZW5kcyBKU1guRWxlbWVudEJhc2UgPSBKU1guRWxlbWVudEJhc2U+IHtcblx0cHJvdG90eXBlOiBDb21wb25lbnQ8VCwgRT47XG5cdC8qKlxuXHQgKiBJbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGZvciBKU1ggZW5naW5lIHRvIHJlLXVzZSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IGluc3RhbmNlLlxuXHQgKiBcblx0ICogTm90ZSB0aGF0IHRoaXMgd2lsbCBiZSBpZ25vcmVkIGlmIGBpbnN0YW5jZVByb3ZpZGVyYCBpcyBzcGVjaWZpZWQgYW5kIHdpbGwgcmV0dXJuIGEgY29tcG9uZW50IGluc3RhbmNlLlxuXHQgKi9cblx0aW5zdGFuY2U6IENvbXBvbmVudDxULCBFPiB8IHVuc2V0O1xuXHQvKipcblx0ICogSWYgaW1wbGVtZW50ZWQsIHVzZWQgYnkgdGhlIEpTWCBlbmdpbmUgdG8gcmV0cmlldmUgY29tcG9uZW50IGluc3RhbmNlcy4gQW4gZXhpc3Rpbmcgb3IgbmV3bHkgY3JlYXRlZCBpbnN0YW5jZSBtYXkgYmUgcmV0dXJuZWQuIElmIG5vIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgYGluc3RhbmNlYCBwcm9wZXJ0eSBpcyB0YWtlbi5cblx0ICovXG5cdGluc3RhbmNlUHJvdmlkZXI/KGF0dHJzOiBKU1guQXR0cnNWYWx1ZTxUPiwgY2hpbGRyZW46IEpTWC5DaGlsZHJlbik6IENvbXBvbmVudDxULCBFPiB8IHVuc2V0O1xuXHQvKipcblx0ICogQ2FsbGVkIGJ5IHRoZSBKU1ggZW5naW5lIHRvIGxvZyBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCBpbnN0YW5jZSwgaWYgaW1wbGVtZW50ZWQuXG5cdCAqL1xuXHRpbnN0YW5jZUNyZWF0ZWQ/KGluc3RhbmNlOiBDb21wb25lbnQ8VCwgRT4pOiB2b2lkO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2RzIG9mIHRoZSBKU1ggYENvbXBvbmVudGAgY2xhc3MgZm9yIHVzaW5nIGBpbnN0YW5jZVByb3ZpZGVyYCBtZXRob2QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbXBvbmVudENsYXNzSW5zdGFuY2VQcm92aWRlcjxUIGV4dGVuZHMgSlNYLkF0dHJzVHlwZSwgRSBleHRlbmRzIEpTWC5FbGVtZW50QmFzZSA9IEpTWC5FbGVtZW50QmFzZT4ge1xuXHRwcm90b3R5cGU6IENvbXBvbmVudDxULCBFPjtcblx0LyoqXG5cdCAqIEluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgZm9yIEpTWCBlbmdpbmUgdG8gcmUtdXNlIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2UuXG5cdCAqIFxuXHQgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIGJlIGlnbm9yZWQgaWYgYGluc3RhbmNlUHJvdmlkZXJgIGlzIHNwZWNpZmllZCBhbmQgd2lsbCByZXR1cm4gYSBjb21wb25lbnQgaW5zdGFuY2UuXG5cdCAqL1xuXHRpbnN0YW5jZT86IENvbXBvbmVudDxULCBFPiB8IHVuc2V0O1xuXHQvKipcblx0ICogSWYgaW1wbGVtZW50ZWQsIHVzZWQgYnkgdGhlIEpTWCBlbmdpbmUgdG8gcmV0cmlldmUgY29tcG9uZW50IGluc3RhbmNlcy4gQW4gZXhpc3Rpbmcgb3IgbmV3bHkgY3JlYXRlZCBpbnN0YW5jZSBtYXkgYmUgcmV0dXJuZWQuIElmIG5vIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgYGluc3RhbmNlYCBwcm9wZXJ0eSBpcyB0YWtlbi5cblx0ICovXG5cdGluc3RhbmNlUHJvdmlkZXIoYXR0cnM6IEpTWC5BdHRyc1ZhbHVlPFQ+LCBjaGlsZHJlbjogSlNYLkNoaWxkcmVuKTogQ29tcG9uZW50PFQsIEU+IHwgdW5zZXQ7XG5cdC8qKlxuXHQgKiBDYWxsZWQgYnkgdGhlIEpTWCBlbmdpbmUgdG8gbG9nIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50IGluc3RhbmNlLCBpZiBpbXBsZW1lbnRlZC5cblx0ICovXG5cdGluc3RhbmNlQ3JlYXRlZD8oaW5zdGFuY2U6IENvbXBvbmVudDxULCBFPik6IHZvaWQ7XG59XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZHMgb2YgdGhlIEpTWCBgQ29tcG9uZW50YCBjbGFzcy5cbiAqL1xuZXhwb3J0IHR5cGUgSUNvbXBvbmVudENsYXNzPFQgZXh0ZW5kcyBKU1guQXR0cnNUeXBlLCBFIGV4dGVuZHMgSlNYLkVsZW1lbnRCYXNlID0gSlNYLkVsZW1lbnRCYXNlPiA9XG5cdHwgSUNvbXBvbmVudENsYXNzRGVmYXVsdDxULCBFPlxuXHR8IElDb21wb25lbnRDbGFzc0luc3RhbmNlPFQsIEU+XG5cdHwgSUNvbXBvbmVudENsYXNzSW5zdGFuY2VQcm92aWRlcjxULCBFPjtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBnZXQgYXNzaWduZWQgdGhlIGBweGAgc3VmZml4LlxuICovXG5leHBvcnQgY29uc3QgbnVtZXJpY0NTU1Byb3BlcnRpZXMgPSBbXG5cdFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiLFxuXHRcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG5cdFwiYm9yZGVyUmFkaXVzXCIsXG5cdFwiYm9yZGVyVG9wTGVmdFJhZGl1c1wiLFxuXHRcImJvcmRlclRvcFJpZ2h0UmFkaXVzIFwiLFxuXHRcImJvcmRlcldpZHRoXCIsXG5cdFwiYm90dG9tXCIsXG5cdFwiZm9udFNpemVcIixcblx0XCJoZWlnaHRcIixcblx0XCJsZWZ0XCIsXG5cdFwibWFyZ2luXCIsXG5cdFwibWFyZ2luQm90dG9tXCIsXG5cdFwibWFyZ2luTGVmdFwiLFxuXHRcIm1hcmdpblJpZ2h0XCIsXG5cdFwibWFyZ2luVG9wXCIsXG5cdFwicGFkZGluZ1wiLFxuXHRcInBhZGRpbmdCb3R0b21cIixcblx0XCJwYWRkaW5nTGVmdFwiLFxuXHRcInBhZGRpbmdSaWdodFwiLFxuXHRcInBhZGRpbmdUb3BcIixcblx0XCJyaWdodFwiLFxuXHRcInN0cm9rZVdpZHRoXCIsXG5cdFwidG9wXCIsXG5cdFwid2lkdGhcIlxuXTtcblxuLyoqXG4gKiBFcnJvciB0byB0aHJvdyB3aGVuIHJlcXVlc3RlZCBET00gY29udGVudCBpcyBub3QgeWV0IGxvYWRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERPTUNvbnRlbnROb3RMb2FkZWQgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBcIkRPTSBjb250ZW50IG5vdCBsb2FkZWQuXCIpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0fVxufVxuXG4vKipcbiAqIEVycm9yIHRvIHRocm93IHdoZW4gYW5kIGludmFsaWQgY2hpbGQgb2JqZWN0IGlzIGdpdmVuIHRvIGEgSlNYIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQ2hpbGRFbGVtZW50IGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgaXRlbTogYW55LCBtZXNzYWdlPzogc3RyaW5nKSB7XG5cdFx0c3VwZXIobWVzc2FnZVxuXHRcdFx0fHwgKGl0ZW0gJiYgYEludmFsaWQgb2JqZWN0IHBhc3NlZCBhcyBhIGNoaWxkIG9mIGFuIEpTWCBlbGVtZW50OiBcIiR7aXRlbS50b1N0cmluZygpfVwiLmApXG5cdFx0XHR8fCBcIkludmFsaWQgb2JqZWN0IHBhc3NlZCBhcyBhIGNoaWxkIG9mIGFuIEpTWCBlbGVtZW50LlwiXG5cdFx0KTtcblx0fVxufVxuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdGllcyBmb3IgbWFudXB1bGF0aW5nIHRoZSBET00uXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2UgSW50ZXJmYWNlQnVpbGRlciB7XG5cblx0ZXhwb3J0IGNvbnN0IGNhbnZhc0lkID0gXCJjYW52YXNcIjtcblx0ZXhwb3J0IGNvbnN0IGFwcElkID0gXCJhcHBcIjtcblx0ZXhwb3J0IGNvbnN0IGNhbnZhc0hvbGRlcklkID0gXCJjYW52YXMtaG9sZGVyXCI7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGAjY2FudmFzLWhvbGRlcmAgRE9NIGVsZW1lbnQuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gZ2V0Q2FudmFzSG9sZGVyKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNIb2xkZXJJZCkgYXMgSFRNTERpdkVsZW1lbnQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgYCNjYW52YXNgIERPTSBlbGVtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGdldENhbnZhcygpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzSWQpIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGAjYXBwYCBET00gZWxlbWVudC5cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBnZXRBcHAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFwcElkKSBhcyBIVE1MRGl2RWxlbWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgZ2l2ZW4gdmFsdWUgaXMgYSBjYW5kaWRhdGUgdG8gYmUgYXBwZW5kZWQgdG8gRE9NLlxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gaXNUcnV0aHkodmFsdWU6IEpTWC5Ob2RlKTogdmFsdWUgaXMgSlNYLlRydXRoeU5vZGU7XG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgZ2l2ZW4gdmFsdWUgaXMgbm90IGZhbHNlLCBudWxsIG5vciB1bmRlZmluZWQuXG5cdCAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBpc1RydXRoeTxUPih2YWx1ZTogVCk6IHZhbHVlIGlzIFQ7XG5cdGV4cG9ydCBmdW5jdGlvbiBpc1RydXRoeSh2YWx1ZTogYW55KTogYW55IHtcblx0XHRyZXR1cm4gIWlzRmFsc3kodmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBnaXZlbiB2YWx1ZSBpcyBub3QgYSBjYW5kaWRhdGUgdG8gYmUgYXBwZW5kZWQgdG8gRE9NLlxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gaXNGYWxzeSh2YWx1ZTogSlNYLk5vZGUpOiB2YWx1ZSBpcyBKU1guRmFsc3lOb2RlO1xuXHQvKipcblx0ICogQ2hlY2tzIGlmIGdpdmVuIHZhbHVlIGlzIGZhbHNlLCBudWxsIG9yIHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGlzRmFsc3kodmFsdWU6IGFueSk6IHZhbHVlIGlzIGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZDtcblx0ZXhwb3J0IGZ1bmN0aW9uIGlzRmFsc3kodmFsdWU6IGFueSk6IGFueSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSBmYWxzZVxuXHRcdFx0fHwgdmFsdWUgPT09IG51bGxcblx0XHRcdHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogRXh0cmFjdHMgdHJ1dGh5IHZhbHVlKHMpLlxuXHQgKiBAcGFyYW0gdmFsdWVzIFZhbHVlKHMpIHRvIGZpbHRlci5cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBmaWx0ZXIodmFsdWVzOiBKU1guRWxlbWVudENvbGxlY3Rpb24pOiBKU1guRWxlbWVudEJhc2VbXTtcblx0ZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcih2YWx1ZXM6IEpTWC5Ob2RlQ29sbGVjdGlvbik6IEpTWC5UcnV0aHlOb2RlW107XG5cdGV4cG9ydCBmdW5jdGlvbiBmaWx0ZXIodmFsdWVzOiBKU1guTm9kZUNvbGxlY3Rpb24pOiBKU1guVHJ1dGh5Tm9kZVtdIHwgSlNYLkVsZW1lbnRCYXNlW10ge1xuXHRcdGlmICghdmFsdWVzKVxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSlcblx0XHRcdHJldHVybiB2YWx1ZXMuZmlsdGVyKGlzVHJ1dGh5KSBhcyBKU1guVHJ1dGh5Tm9kZVtdO1xuXHRcdGVsc2UgaWYgKGlzVHJ1dGh5KHZhbHVlcykpXG5cdFx0XHRyZXR1cm4gW3ZhbHVlc107XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsYXR0ZW5zIGFuIGFycmF5IG9mIG5vZGUgY29sbGVjdGlvbnMgYW5kIGZpbHRlcnMgaXQgZm9yIHRydXRoeSB2YWx1ZXMgb25seS5cblx0ICogQHBhcmFtIGFycmF5IEFycmF5IG9mIG5vZGVzIGNvbGxlY3Rpb25zIHRvIGZsYXR0ZW4uXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gZmxhdHRlbihhcnJheTogSlNYLk5vZGVDb2xsZWN0aW9uW10pOiBKU1guVHJ1dGh5Tm9kZVtdIHtcblx0XHRjb25zdCBmbGF0dGVuZWQ6IEpTWC5UcnV0aHlOb2RlW10gPSBbXTtcblx0XHRmb3IgKGxldCB2YWx1ZSBvZiBhcnJheSkge1xuXHRcdFx0aWYgKGlzVHJ1dGh5KHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG5cdFx0XHRcdFx0ZmxhdHRlbmVkLnB1c2goLi4udmFsdWUuZmlsdGVyKGlzVHJ1dGh5KSBhcyBKU1guVHJ1dGh5Tm9kZVtdKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGZsYXR0ZW5lZC5wdXNoKHZhbHVlIGFzIEpTWC5UcnV0aHlOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZsYXR0ZW5lZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzc2lnblN0eWxlKGdpdmVuOiBKU1guQ1NTUHJvcGVydGllcywgYWN0dWFsOiBDU1NTdHlsZURlY2xhcmF0aW9uKTogdm9pZCB7XG5cdFx0Zm9yIChsZXQgcHJvcCBpbiBnaXZlbikge1xuXHRcdFx0bGV0IHZhbHVlID0gZ2l2ZW5bcHJvcF07XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIG51bWVyaWNDU1NQcm9wZXJ0aWVzLmluY2x1ZGVzKHByb3ApKVxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlICsgXCJweFwiO1xuXHRcdFx0KGFjdHVhbCBhcyBLZXlWYWx1ZU9iamVjdClbcHJvcF0gPSBnaXZlbltwcm9wXTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVzPFQ+KGF0dHJzOiBKU1guQXR0cnNWYWx1ZTxUPiwgZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcblx0XHRpZiAoIWF0dHJzKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGZvciAobGV0IGF0dHIgaW4gYXR0cnMpIHtcblx0XHRcdGlmIChhdHRyID09PSBcInJlZlwiKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGNvbnN0IHZhbHVlID0gYXR0cnNbYXR0cl0gYXMgYW55O1xuXHRcdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0aWYgKGF0dHIgPT09IFwic3R5bGVcIilcblx0XHRcdFx0YXNzaWduU3R5bGUodmFsdWUsIGVsZW1lbnQuc3R5bGUpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHQoZWxlbWVudCBhcyBhbnkpW2F0dHJdID0gdmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgRE9NIGVsZW1lbnQgZnJvbSBnaXZlbiB0YWcgbmFtZS5cblx0ICogQHBhcmFtIG5hbWUgRE9NIGVsZW1lbnQgdGFnLlxuXHQgKiBAcGFyYW0gYXR0cnMgQXR0cmlidXRlcyB0byBhc3NpZ24uXG5cdCAqIEBwYXJhbSBjaGlsZHJlbiBDaGlsZHJlbiB0byBhcHBlbmQuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gY3JlYXRlSW50cmluc2ljRWxlbWVudDxUIGV4dGVuZHMgSlNYLkF0dHJzVHlwZT4obmFtZTogc3RyaW5nLCBhdHRyczogSlNYLkF0dHJzVmFsdWU8VD4sIGNoaWxkcmVuOiBKU1guTm9kZUNvbGxlY3Rpb25bXSk6IEpTWC5FbGVtZW50IHtcblx0XHRjb25zdCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xuXHRcdGFzc2lnbkF0dHJpYnV0ZXMoYXR0cnMsIGVsdCk7XG5cblx0XHRsZXQgc3RyID0gXCJcIjsgLy8gb3B0aW1pc2F0aW9uXG5cdFx0Zm9yIChjb25zdCBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuKSB7XG5cdFx0XHRjb25zdCBjb2wgPSBBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IFtjb2xsZWN0aW9uXTtcblx0XHRcdGZvciAoY29uc3QgY2hpbGQgb2YgY29sKSB7XG5cdFx0XHRcdGlmIChpc1RydXRoeShjaGlsZCkpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0XHRpZiAoIShjaGlsZCBpbnN0YW5jZW9mIEVsZW1lbnQpKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgSW52YWxpZENoaWxkRWxlbWVudChjaGlsZCk7XG5cdFx0XHRcdFx0XHRpZiAoc3RyKSB7XG5cdFx0XHRcdFx0XHRcdGVsdC5pbnNlcnRBZGphY2VudFRleHQoXCJiZWZvcmVlbmRcIiwgc3RyKTtcblx0XHRcdFx0XHRcdFx0c3RyID0gXCJcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsdC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmVlbmRcIiwgY2hpbGQpO1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0c3RyICs9IGNoaWxkLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHN0cilcblx0XHRcdGVsdC5pbnNlcnRBZGphY2VudFRleHQoXCJiZWZvcmVlbmRcIiwgc3RyKTtcblxuXHRcdGlmIChhdHRycyAmJiBhdHRycy5yZWYpXG5cdFx0XHRhdHRycy5yZWYoZWx0KTtcblxuXHRcdHJldHVybiBlbHQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmVycyBlbGVtZW50IGNvbGxlY3Rpb24gZnJvbSBnaXZlbiBwcm92aWRlci5cblx0ICogQHBhcmFtIHByb3ZpZGVyIFByb3ZpZGVyIHRvIHVzZS5cblx0ICogQHBhcmFtIGF0dHJzIEF0dHJpYnV0ZXMgdG8gYXNzaWduLlxuXHQgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gdG8gYXBwZW5kLlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxFbGVtZW50PFQgZXh0ZW5kcyBKU1guQXR0cnNUeXBlPihwcm92aWRlcjogSlNYLlByb3ZpZGVyPFQ+LCBhdHRyczogSlNYLkF0dHJzVmFsdWU8VD4sIGNoaWxkcmVuOiBKU1guTm9kZUNvbGxlY3Rpb25bXSk6IEpTWC5FbGVtZW50Q29sbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHByb3ZpZGVyKGF0dHJzLCBmbGF0dGVuKGNoaWxkcmVuKSk7XG5cdH1cblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGdpdmVuIGNvbXBvbmVudCBjbGFzcyBhbmQgcmVuZGVycyBpdCdzIGNvbnRlbnQuXG5cdCAqIEBwYXJhbSBjb21wb25lbnRDbGFzcyBDb21wb25lbnQgY2xhc3MgdG8gaW5zdGFudGlhdGUgYW5kIHVzZS5cblx0ICogQHBhcmFtIGF0dHJzIEF0dHJpYnV0ZXMgdG8gYXNzaWduLlxuXHQgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gdG8gYXBwZW5kLlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudENsYXNzRWxlbWVudDxUIGV4dGVuZHMgSlNYLkF0dHJzVHlwZSwgQyBleHRlbmRzIENvbXBvbmVudDxUPiwgRSBleHRlbmRzIEpTWC5FbGVtZW50QmFzZT4oY29tcG9uZW50Q2xhc3M6IElDb21wb25lbnRDbGFzczxULCBFPiwgYXR0cnM6IEpTWC5BdHRyc1ZhbHVlPFQ+LCBjaGlsZHJlbjogSlNYLk5vZGVDb2xsZWN0aW9uW10pOiBKU1guRWxlbWVudENvbGxlY3Rpb24ge1xuXHRcdGNvbnN0IGMgPSBmbGF0dGVuKGNoaWxkcmVuKTtcblx0XHRsZXQgaW5zdGFuY2U6IENvbXBvbmVudDxUPiB8IHVuc2V0O1xuXHRcdGlmIChjb21wb25lbnRDbGFzcy5pbnN0YW5jZVByb3ZpZGVyKVxuXHRcdFx0aW5zdGFuY2UgPSBjb21wb25lbnRDbGFzcy5pbnN0YW5jZVByb3ZpZGVyKGF0dHJzLCBjKTtcblx0XHRpZiAoIWluc3RhbmNlICYmIGNvbXBvbmVudENsYXNzLmluc3RhbmNlKVxuXHRcdFx0aW5zdGFuY2UgPSBjb21wb25lbnRDbGFzcy5pbnN0YW5jZTtcblx0XHRpZiAoIWluc3RhbmNlKSB7XG5cdFx0XHRpbnN0YW5jZSA9IG5ldyAoY29tcG9uZW50Q2xhc3MgYXMgSUNvbXBvbmVudENsYXNzRGVmYXVsdDxUPikoYXR0cnMpO1xuXHRcdFx0aWYgKGNvbXBvbmVudENsYXNzLmluc3RhbmNlQ3JlYXRlZClcblx0XHRcdFx0Y29tcG9uZW50Q2xhc3MuaW5zdGFuY2VDcmVhdGVkKGluc3RhbmNlIGFzIEMpO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5zdGFuY2UucmVuZGVyKGF0dHJzLCBjKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIGNvbnRlbnRzIG9mIGEgSlNYIGNvbXBvbmVudC5cblx0ICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVuZGVyLlxuXHQgKiBAcGFyYW0gYXR0cnMgQXR0cmlidXRlcyB0byBhc3NpZ24uXG5cdCAqIEBwYXJhbSBjaGlsZHJlbiBDaGlsZHJlbiB0byBhcHBlbmQuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VFbGVtZW50PFQ+KGNvbXBvbmVudDogQ29tcG9uZW50PFQ+LCBhdHRyczogVCwgY2hpbGRyZW46IEpTWC5Ob2RlQ29sbGVjdGlvbltdKTogSlNYLkVsZW1lbnRDb2xsZWN0aW9uIHtcblx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxSZWNlaXZlQXR0cnMpXG5cdFx0XHRjb21wb25lbnQuY29tcG9uZW50V2lsbFJlY2VpdmVBdHRycyhhdHRycyk7XG5cdFx0Y29tcG9uZW50LmF0dHJzID0gYXR0cnM7XG5cdFx0cmV0dXJuIGNvbXBvbmVudC5yZW5kZXIoYXR0cnMsIGZsYXR0ZW4oY2hpbGRyZW4pKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIERPTSBlbGVtZW50IGZyb20gZ2l2ZW4gdGFnIG5hbWUuXG5cdCAqIEBwYXJhbSBuYW1lIERPTSBlbGVtZW50IHRhZy5cblx0ICogQHBhcmFtIGF0dHJzIEF0dHJpYnV0ZXMgdG8gYXNzaWduLlxuXHQgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gdG8gYXBwZW5kLlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQ8VCBleHRlbmRzIEpTWC5BdHRyc1R5cGU+KFxuXHRcdG5hbWU6IHN0cmluZyxcblx0XHRhdHRyczogSlNYLkF0dHJzVmFsdWU8VD4sXG5cdFx0Li4uY2hpbGRyZW46IEpTWC5Ob2RlQ29sbGVjdGlvbltdXG5cdCk6IEpTWC5FbGVtZW50O1xuXHQvKipcblx0ICogUmV0cmlldmVycyBlbGVtZW50IGNvbGxlY3Rpb24gZnJvbSBnaXZlbiBwcm92aWRlci5cblx0ICogQHBhcmFtIHByb3ZpZGVyIFByb3ZpZGVyIHRvIHVzZS5cblx0ICogQHBhcmFtIGF0dHJzIEF0dHJpYnV0ZXMgdG8gYXNzaWduLlxuXHQgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gdG8gYXBwZW5kLlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQ8VCBleHRlbmRzIEpTWC5BdHRyc1R5cGU+KFxuXHRcdHByb3ZpZGVyOiBKU1guUHJvdmlkZXI8VD4sXG5cdFx0YXR0cnM6IEpTWC5BdHRyc1ZhbHVlPFQ+LFxuXHRcdC4uLmNoaWxkcmVuOiBKU1guTm9kZUNvbGxlY3Rpb25bXVxuXHQpOiBKU1guRWxlbWVudENvbGxlY3Rpb247XG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgZ2l2ZW4gY29tcG9uZW50IGNsYXNzIGFuZCByZW5kZXJzIGl0J3MgY29udGVudC5cblx0ICogQHBhcmFtIGNvbXBvbmVudENsYXNzIENvbXBvbmVudCBjbGFzcyB0byBpbnN0YW50aWF0ZSBhbmQgdXNlLlxuXHQgKiBAcGFyYW0gYXR0cnMgQXR0cmlidXRlcyB0byBhc3NpZ24uXG5cdCAqIEBwYXJhbSBjaGlsZHJlbiBDaGlsZHJlbiB0byBhcHBlbmQuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudDxUIGV4dGVuZHMgSlNYLkF0dHJzVHlwZSwgQyBleHRlbmRzIENvbXBvbmVudDxUPj4oXG5cdFx0Y29tcG9uZW50Q2xhc3M6IElDb21wb25lbnRDbGFzczxUPixcblx0XHRhdHRyczogSlNYLkF0dHJzVmFsdWU8VD4sXG5cdFx0Li4uY2hpbGRyZW46IEpTWC5Ob2RlQ29sbGVjdGlvbltdXG5cdCk6IEpTWC5FbGVtZW50Q29sbGVjdGlvbjtcblx0ZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQ8VCBleHRlbmRzIEpTWC5BdHRyc1R5cGU+KFxuXHRcdGZhY3Rvcnk6IHN0cmluZyB8IElDb21wb25lbnRDbGFzczxULCBhbnk+IHwgSlNYLlByb3ZpZGVyPFQ+LFxuXHRcdGF0dHJzOiBLZXlWYWx1ZU9iamVjdCB8IG51bGwsXG5cdFx0Li4uY2hpbGRyZW46IEpTWC5Ob2RlQ29sbGVjdGlvbltdXG5cdCk6IEpTWC5FbGVtZW50Q29sbGVjdGlvbiB7XG5cdFx0aWYgKHR5cGVvZiBmYWN0b3J5ID09PSBcInN0cmluZ1wiKVxuXHRcdFx0cmV0dXJuIGNyZWF0ZUludHJpbnNpY0VsZW1lbnQoZmFjdG9yeSwgYXR0cnMsIGNoaWxkcmVuKTtcblx0XHRlbHNlIGlmICh0eXBlb2YgZmFjdG9yeS5wcm90b3R5cGUucmVuZGVyID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHRyZXR1cm4gY3JlYXRlQ29tcG9uZW50Q2xhc3NFbGVtZW50KGZhY3RvcnkgYXMgYW55LCBhdHRycywgY2hpbGRyZW4pO1xuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBjcmVhdGVGdW5jdGlvbmFsRWxlbWVudChmYWN0b3J5IGFzIGFueSwgYXR0cnMsIGNoaWxkcmVuKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGRvY3VtZW50IGZyYWdtZW50IHdoaWNoIGluY2x1ZWRzIGdpdmVuIGVsZW1lbnRzLiBVc2UgdGhpcyB0byBhcHBseSBtdWx0aXBsZSBlbGVtZW50cyB0byB0aGUgRE9NLlxuXHQgKiBAcGFyYW0gZWxlbWVudENvbGxlY3Rpb24gRWxlbWVudHMgdG8gaW5jbHVkZS5cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChlbGVtZW50Q29sbGVjdGlvbjogSlNYLkVsZW1lbnRDb2xsZWN0aW9uKSB7XG5cdFx0Y29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0ZmlsdGVyKGVsZW1lbnRDb2xsZWN0aW9uKS5mb3JFYWNoKGVsdCA9PiBmcmFnbWVudC5hcHBlbmRDaGlsZChlbHQpKTtcblx0XHRyZXR1cm4gZnJhZ21lbnQ7XG5cdH1cblxuXHQvKipcblx0ICogQXBwZW5kcyBlbGVtZW50IHRvIERPTS5cblx0ICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCB0byBhcHBlbmQgdG8uXG5cdCAqIEBwYXJhbSBlbGVtZW50Q29sbGVjdGlvbiBFbGVtZW50cyB0byBhcHBlbmQuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gYXBwZW5kKGVsZW1lbnQ6IEVsZW1lbnQsIGVsZW1lbnRDb2xsZWN0aW9uOiBKU1guRWxlbWVudENvbGxlY3Rpb24pIHtcblx0XHRlbGVtZW50LmFwcGVuZENoaWxkKGNyZWF0ZUZyYWdtZW50KGVsZW1lbnRDb2xsZWN0aW9uKSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBlbGVtZW50J3MgY29udGVudC5cblx0ICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCB3aGljaCdzIGNvbnRlbnQgdG8gY2xlYXIuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gY2xlYXJDb250ZW50KGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHQvKlxuXHRcdCAqIFRoaXMgaXMgbXVjaCBmYXN0ZXIgdGhhbiBlbG1lbnQuaW5uZXJIVE1MID0gXCJcIjtcblx0XHQgKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk1NTIyOS9yZW1vdmUtYWxsLWNoaWxkLWVsZW1lbnRzLW9mLWEtZG9tLW5vZGUtaW4tamF2YXNjcmlwdFxuXHRcdCAqL1xuXHRcdHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHRlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVwbGFjZXMgZWxlbWVudCdzIGNvbnRlbnQgd2l0aCBnaXZlbiBlbGVtZW50cy5cblx0ICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCB3aGljaCdzIGNvbnRlbnQgdG8gcmVwbGFjZS5cblx0ICogQHBhcmFtIGVsZW1lbnRDb2xsZWN0aW9uIEVsZW1lbnRzIHRvIGluc2VydC5cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiByZXBsYWNlQ29udGVudChlbGVtZW50OiBFbGVtZW50LCBlbGVtZW50Q29sbGVjdGlvbjogSlNYLkVsZW1lbnRDb2xsZWN0aW9uKSB7XG5cdFx0Y2xlYXJDb250ZW50KGVsZW1lbnQpO1xuXHRcdGFwcGVuZChlbGVtZW50LCBlbGVtZW50Q29sbGVjdGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogUmVwbGFjZXMgZWxlbWVudCB3aXRoIG90aGVyIGVsZW1lbnRzLlxuXHQgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIHJlbW92ZSBhbmQgcmVwbGFjZS5cblx0ICogQHBhcmFtIGVsZW1lbnRDb2xsZWN0aW9uIEVsZW1lbnRzIHRvIGluc2VydC5cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiByZXBsYWNlKGVsZW1lbnQ6IEVsZW1lbnQsIGVsZW1lbnRDb2xsZWN0aW9uOiBKU1guRWxlbWVudENvbGxlY3Rpb24pIHtcblx0XHRjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0aWYgKCFwYXJlbnQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJObyBwYXJlbnQgZWxlbWVudCBmb3VuZC5cIik7XG5cdFx0cGFyZW50Lmluc2VydEJlZm9yZShjcmVhdGVGcmFnbWVudChlbGVtZW50Q29sbGVjdGlvbiksIGVsZW1lbnQpO1xuXHRcdGVsZW1lbnQucmVtb3ZlKCk7XG5cdH1cblxuXHQvKipcblx0ICogSGlkZXMgYW4gSFRNTCBlbGVtZW50IGJ5IHNldHRpbmcgaXRzIGRpc3BsYXkgQ1NTIHByb3BlcnR5IHRvIFwibm9uZVwiLlxuXHQgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIGhpZGUuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gaGlkZUVsZW1lbnQoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcblx0XHRlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBcdFVuaGlkZXMgYW4gSFRNTCBlbGVtZW5ldCBieSBzZXR0aW5nIGl0cyBkaXNwbGF5IENTUyBwcm9wZXJ0eSB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiBcIm5vbmVcIi5cblx0ICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCB0byB1bmhpZGUuXG5cdCAqIEBwYXJhbSBkaXNwbGF5U3R5bGUgRGlzcGxheSBDU1MgcHJvcGVydHksIGlmIG90aGVyIHRoYW4gXCJibG9ja1wiO1xuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIHNob3dFbGVtZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBkaXNwbGF5U3R5bGU6IHN0cmluZyA9IFwiYmxvY2tcIikge1xuXHRcdGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXlTdHlsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwbGF5IGdpdmVuIGVsZW1lbnRzIGluIHRoZSBkZWZhdWx0IGludGVyZmFjZSBjb250YWluZXIgKHRoZSBgI2FwcGAgZWxlbWVudCkgYW5kIGhpZGVzIHRoZSBkZWZhdWx0IGNhbnZhcyAodGhlIGAjY2FudmFzYCBlbGVtZW50KS5cblx0ICogQHBhcmFtIGVsZW1lbnRDb2xsZWN0aW9uIEVsZW1lbnRzIHRvIGRpc3BsYXkuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gZGlzcGxheURlZmF1bHQoZWxlbWVudENvbGxlY3Rpb246IEpTWC5FbGVtZW50Q29sbGVjdGlvbikge1xuXHRcdGNvbnN0IGFwcCA9IGdldEFwcCgpO1xuXHRcdGNvbnN0IGNoID0gZ2V0Q2FudmFzSG9sZGVyKCk7XG5cdFx0aWYgKGFwcCAmJiBjaCkge1xuXHRcdFx0cmVwbGFjZUNvbnRlbnQoZ2V0QXBwKCksIGVsZW1lbnRDb2xsZWN0aW9uKTtcblx0XHRcdGhpZGVFbGVtZW50KGNoKTtcblx0XHRcdHNob3dFbGVtZW50KGFwcCk7XG5cdFx0fSBlbHNlIHRocm93IG5ldyBET01Db250ZW50Tm90TG9hZGVkKCk7IC8vIHRocm93IGlmIG5vdCBsb2FkZWRcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgYW5kIGhpZGVzIGFwcGxpY2F0aW9uJ3MgZGVmYXVsdCBpbnRlcmZhY2UgY29udGFpbmVyICh0aGUgYCNhcHBgIGVsZW1lbnQpIGFuZCBzaG93cyB0aGUgZGVmYXVsdCBjYW52YXMgKHRoZSBgI2NhbnZhc2AgZWxlbWVudCkuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gY2xlYXJEZWZhdWx0KCkge1xuXHRcdGNvbnN0IGFwcCA9IGdldEFwcCgpO1xuXHRcdGNvbnN0IGNoID0gZ2V0Q2FudmFzSG9sZGVyKCk7XG5cdFx0aWYgKGFwcCAmJiBjaCkge1xuXHRcdFx0Y2xlYXJDb250ZW50KGFwcCk7XG5cdFx0XHRoaWRlRWxlbWVudChhcHApO1xuXHRcdFx0c2hvd0VsZW1lbnQoY2gpO1xuXHRcdH0gZWxzZSB0aHJvdyBuZXcgRE9NQ29udGVudE5vdExvYWRlZCgpOyAvLyB0aHJvdyBpZiBub3QgbG9hZGVkXG5cdH1cblxuXHQvKipcblx0ICogU3Vic2NyaWJlcyBhIGxpc3RlbmVyIHRvIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQuXG5cdCAqIEBwYXJhbSBjYWxsYmFjayBMaXN0ZW5lciB0byBzdWJzY3JpYmUuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gb25ET01Db250ZW50TG9hZGVkKGNhbGxiYWNrOiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KSB7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY2FsbGJhY2spO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIGlzIHJlc29sdmVkIHdoZW4gRE9NIGNvbnRlbnQgZ2V0cyBsb2FkZWQuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gYXdhaXRET01Db250ZW50TG9hZGVkKCkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIHJlc29sdmUpKTtcblx0fVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9JbnRlcmZhY2VCdWlsZGVyLnRzIl0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///15\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar LockLevelCameraStrategy = /** @class */ (function () {\r\n    function LockLevelCameraStrategy(screenBounds, levelBounds) {\r\n        this.minX = levelBounds.left + screenBounds.getWidth() / 2;\r\n        this.maxX = levelBounds.right - screenBounds.getWidth() / 2;\r\n    }\r\n    LockLevelCameraStrategy.prototype.action = function (target, cam, _eng, _delta) {\r\n        this.target = target;\r\n        var newPosition = cam.pos;\r\n        newPosition.x = newPosition.x < this.minX ? this.minX : newPosition.x;\r\n        newPosition.x = newPosition.x > this.maxX ? this.maxX : newPosition.x;\r\n        return newPosition;\r\n    };\r\n    return LockLevelCameraStrategy;\r\n}());\r\nexports.default = LockLevelCameraStrategy;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvQ29tcG9uZW50cy9Mb2NrTGV2ZWxDYW1lcmFTdHJhdGVneS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0lBTUMsaUNBQVksWUFBNEIsRUFBRSxXQUEyQjtRQUNwRSxJQUFJLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLEdBQUcsWUFBWSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMzRCxJQUFJLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQsd0NBQU0sR0FBTixVQUFPLE1BQXdCLEVBQUUsR0FBa0IsRUFBRSxJQUFlLEVBQUUsTUFBYztRQUNuRixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUVyQixJQUFJLFdBQVcsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDO1FBQzFCLFdBQVcsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLFdBQVcsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLE1BQU0sQ0FBQyxXQUFXLENBQUM7SUFDcEIsQ0FBQztJQUVGLDhCQUFDO0FBQUQsQ0FBQyIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGV4IGZyb20gXCJleGNhbGlidXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9ja0xldmVsQ2FtZXJhU3RyYXRlZ3kgaW1wbGVtZW50cyBleC5JQ2FtZXJhU3RyYXRlZ3k8ZXguQWN0b3IgfCB1bnNldD4ge1xuXG5cdHRhcmdldDogZXguQWN0b3IgfCB1bnNldDtcblx0cHJpdmF0ZSBtaW5YOiBudW1iZXI7XG5cdHByaXZhdGUgbWF4WDogbnVtYmVyO1xuXG5cdGNvbnN0cnVjdG9yKHNjcmVlbkJvdW5kczogZXguQm91bmRpbmdCb3gsIGxldmVsQm91bmRzOiBleC5Cb3VuZGluZ0JveCkge1xuXHRcdHRoaXMubWluWCA9IGxldmVsQm91bmRzLmxlZnQgKyBzY3JlZW5Cb3VuZHMuZ2V0V2lkdGgoKSAvIDI7XG5cdFx0dGhpcy5tYXhYID0gbGV2ZWxCb3VuZHMucmlnaHQgLSBzY3JlZW5Cb3VuZHMuZ2V0V2lkdGgoKSAvIDI7XG5cdH1cblxuXHRhY3Rpb24odGFyZ2V0OiBleC5BY3RvciB8IHVuc2V0LCBjYW06IGV4LkJhc2VDYW1lcmEsIF9lbmc6IGV4LkVuZ2luZSwgX2RlbHRhOiBudW1iZXIpOiBleC5WZWN0b3Ige1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXG5cdFx0bGV0IG5ld1Bvc2l0aW9uID0gY2FtLnBvcztcblx0XHRuZXdQb3NpdGlvbi54ID0gbmV3UG9zaXRpb24ueCA8IHRoaXMubWluWCA/IHRoaXMubWluWCA6IG5ld1Bvc2l0aW9uLng7XG5cdFx0bmV3UG9zaXRpb24ueCA9IG5ld1Bvc2l0aW9uLnggPiB0aGlzLm1heFggPyB0aGlzLm1heFggOiBuZXdQb3NpdGlvbi54O1xuXHRcdHJldHVybiBuZXdQb3NpdGlvbjtcblx0fVxuXHRcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL0NvbXBvbmVudHMvTG9ja0xldmVsQ2FtZXJhU3RyYXRlZ3kudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///16\n')},,,,,,,function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar BasePlayer = /** @class */ (function (_super) {\r\n    __extends(BasePlayer, _super);\r\n    function BasePlayer(x, y) {\r\n        var _this = _super.call(this, x, y, BasePlayer.size.w, BasePlayer.size.h, ex.Color.Violet) || this;\r\n        _this.collisionArea.body.useBoxCollision();\r\n        _this.collisionType = ex.CollisionType.Active;\r\n        return _this;\r\n    }\r\n    BasePlayer.size = { w: 15, h: 60 };\r\n    return BasePlayer;\r\n}(ex.Actor));\r\nexports.default = BasePlayer;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvQ29tcG9uZW50cy9CYXNlUGxheWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGdDQUFnQztBQUVoQztJQUFpRCw4QkFBUTtJQUl4RCxvQkFBWSxDQUFTLEVBQUUsQ0FBUztRQUFoQyxZQUNDLGtCQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FHbEU7UUFGQSxLQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUMxQyxLQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDOztJQUM5QyxDQUFDO0lBTmUsZUFBSSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFPekMsaUJBQUM7Q0FBQSxDQVRnRCxFQUFFLENBQUMsS0FBSyxHQVN4RDtrQkFUNkIsVUFBVSIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGV4IGZyb20gXCJleGNhbGlidXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQmFzZVBsYXllciBleHRlbmRzIGV4LkFjdG9yIHtcblxuXHRzdGF0aWMgcmVhZG9ubHkgc2l6ZSA9IHsgdzogMTUsIGg6IDYwIH07XG5cblx0Y29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcblx0XHRzdXBlcih4LCB5LCBCYXNlUGxheWVyLnNpemUudywgQmFzZVBsYXllci5zaXplLmgsIGV4LkNvbG9yLlZpb2xldCk7XG5cdFx0dGhpcy5jb2xsaXNpb25BcmVhLmJvZHkudXNlQm94Q29sbGlzaW9uKCk7XG5cdFx0dGhpcy5jb2xsaXNpb25UeXBlID0gZXguQ29sbGlzaW9uVHlwZS5BY3RpdmU7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL0NvbXBvbmVudHMvQmFzZVBsYXllci50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///23\n')},,,,,,,,,,,,,,,,,,,,,function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Ground = /** @class */ (function (_super) {\r\n    __extends(Ground, _super);\r\n    function Ground(x, y) {\r\n        var _this = _super.call(this, x, y, Ground.width, 50, ex.Color.Gray) || this;\r\n        _this.collisionType = ex.CollisionType.Fixed;\r\n        _this.brickTexture = Ground.resources[0];\r\n        return _this;\r\n    }\r\n    Ground.prototype.draw = function (ctx, delta) {\r\n        var sprite = this.brickTexture.asSprite();\r\n        var offset = 0;\r\n        while (offset < Ground.width) {\r\n            sprite.draw(ctx, this.getLeft() + offset, this.getTop());\r\n            offset += 70;\r\n        }\r\n    };\r\n    Ground.brickTextureUrl = __webpack_require__(69);\r\n    Ground.width = 5000;\r\n    Ground.resources = [new ex.Texture(Ground.brickTextureUrl)];\r\n    return Ground;\r\n}(ex.Actor));\r\nexports.default = Ground;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvQ29tcG9uZW50cy9Hcm91bmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBRWhDO0lBQW9DLDBCQUFRO0lBUTNDLGdCQUFZLENBQVMsRUFBRSxDQUFTO1FBQWhDLFlBQ0Msa0JBQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUc1QztRQUZBLEtBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUM7UUFDNUMsS0FBSSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBZSxDQUFDOztJQUN2RCxDQUFDO0lBRUQscUJBQUksR0FBSixVQUFLLEdBQTZCLEVBQUUsS0FBYTtRQUNoRCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzFDLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztRQUVmLE9BQU8sTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUM5QixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBQ3pELE1BQU0sSUFBSSxFQUFFLENBQUM7UUFDZCxDQUFDO0lBQ0YsQ0FBQztJQXBCTSxzQkFBZSxHQUFXLG1CQUFPLENBQUMsRUFBdUMsQ0FBQyxDQUFDO0lBQ2xFLFlBQUssR0FBVyxJQUFJLENBQUM7SUFDOUIsZ0JBQVMsR0FBbUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7SUFtQjdFLGFBQUM7Q0FBQSxDQXZCbUMsRUFBRSxDQUFDLEtBQUssR0F1QjNDO2tCQXZCb0IsTUFBTSIsImZpbGUiOiI0NC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGV4IGZyb20gXCJleGNhbGlidXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JvdW5kIGV4dGVuZHMgZXguQWN0b3Ige1xuXG5cdHN0YXRpYyBicmlja1RleHR1cmVVcmw6IHN0cmluZyA9IHJlcXVpcmUoXCIuLi9TY2VuZXMvTW92ZW1lbnRUZXN0TGV2ZWwvYnJpY2suanBnXCIpO1xuXHRzdGF0aWMgcmVhZG9ubHkgd2lkdGg6IG51bWJlciA9IDUwMDA7XG5cdHN0YXRpYyByZXNvdXJjZXM6IGV4LklMb2FkYWJsZVtdID0gW25ldyBleC5UZXh0dXJlKEdyb3VuZC5icmlja1RleHR1cmVVcmwpXTtcblxuXHRicmlja1RleHR1cmU6IGV4LlRleHR1cmU7XG5cblx0Y29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcblx0XHRzdXBlcih4LCB5LCBHcm91bmQud2lkdGgsIDUwLCBleC5Db2xvci5HcmF5KTtcblx0XHR0aGlzLmNvbGxpc2lvblR5cGUgPSBleC5Db2xsaXNpb25UeXBlLkZpeGVkO1xuXHRcdHRoaXMuYnJpY2tUZXh0dXJlID0gR3JvdW5kLnJlc291cmNlc1swXSBhcyBleC5UZXh0dXJlO1xuXHR9XG5cblx0ZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZGVsdGE6IG51bWJlcik6IHZvaWQge1xuXHRcdGxldCBzcHJpdGUgPSB0aGlzLmJyaWNrVGV4dHVyZS5hc1Nwcml0ZSgpO1xuXHRcdGxldCBvZmZzZXQgPSAwO1xuXG5cdFx0d2hpbGUgKG9mZnNldCA8IEdyb3VuZC53aWR0aCkge1xuXHRcdFx0c3ByaXRlLmRyYXcoY3R4LCB0aGlzLmdldExlZnQoKSArIG9mZnNldCwgdGhpcy5nZXRUb3AoKSk7XG5cdFx0XHRvZmZzZXQgKz0gNzA7XG5cdFx0fVxuXHR9XG59XG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvQ29tcG9uZW50cy9Hcm91bmQudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///44\n')},,,,,,,,,,,,,function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n// base assets\r\n__webpack_require__(58);\r\n// main application\r\n__webpack_require__(59);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9hcHAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxjQUFjO0FBQ2Qsd0JBQXNCO0FBRXRCLG1CQUFtQjtBQUNuQix3QkFBZSIsImZpbGUiOiI1Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGJhc2UgYXNzZXRzXG5pbXBvcnQgXCIuL3N0eWxlLnNjc3NcIjtcblxuLy8gbWFpbiBhcHBsaWNhdGlvblxuaW1wb3J0IFwiLi9zcmNcIjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvYXBwLnRzIl0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///57\n')},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zdHlsZS5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjU4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvZGUvc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///58\n")},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar GameBootstrap_1 = __webpack_require__(14);\r\nvar InterfaceBuilder_1 = __webpack_require__(15);\r\nfunction init() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var gb;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: \r\n                // wait for the document to load\r\n                return [4 /*yield*/, InterfaceBuilder_1.InterfaceBuilder.awaitDOMContentLoaded()];\r\n                case 1:\r\n                    // wait for the document to load\r\n                    _a.sent();\r\n                    gb = new GameBootstrap_1.GameBootstrap(InterfaceBuilder_1.InterfaceBuilder.canvasId, InterfaceBuilder_1.InterfaceBuilder.getApp());\r\n                    // start the game\r\n                    gb.start();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n// check whether the user is using Internet Explorer\r\nif (navigator.userAgent.match(/MSIE|Trident/))\r\n    // criticise the user\r\n    alert("Internet Explorer is currently not supported.");\r\nelse\r\n    // start everything\r\n    init();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDhDQUFnRDtBQUNoRCxpREFBc0Q7QUFFdEQ7Ozs7OztnQkFDQyxnQ0FBZ0M7Z0JBQ2hDLHFCQUFNLG1DQUFnQixDQUFDLHFCQUFxQixFQUFFOztvQkFEOUMsZ0NBQWdDO29CQUNoQyxTQUE4QyxDQUFDO29CQUV6QyxFQUFFLEdBQUcsSUFBSSw2QkFBYSxDQUFDLG1DQUFnQixDQUFDLFFBQVEsRUFBRSxtQ0FBZ0IsQ0FBQyxNQUFNLEVBQWlCLENBQUMsQ0FBQztvQkFDbEcsaUJBQWlCO29CQUNqQixFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7Ozs7O0NBQ1g7QUFFRCxvREFBb0Q7QUFDcEQsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDN0MscUJBQXFCO0lBQ3JCLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO0FBQ3hELElBQUk7SUFDSCxtQkFBbUI7SUFDbkIsSUFBSSxFQUFFLENBQUMiLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHYW1lQm9vdHN0cmFwIH0gZnJvbSBcIi4vR2FtZUJvb3RzdHJhcFwiO1xuaW1wb3J0IHsgSW50ZXJmYWNlQnVpbGRlciB9IGZyb20gXCIuL0ludGVyZmFjZUJ1aWxkZXJcIjtcblxuYXN5bmMgZnVuY3Rpb24gaW5pdCgpIHtcblx0Ly8gd2FpdCBmb3IgdGhlIGRvY3VtZW50IHRvIGxvYWRcblx0YXdhaXQgSW50ZXJmYWNlQnVpbGRlci5hd2FpdERPTUNvbnRlbnRMb2FkZWQoKTtcblx0Ly8gY3JlYXRlIG5ldyBHYW1lQm9vdHN0cmFwIG9iamVjdFxuXHRjb25zdCBnYiA9IG5ldyBHYW1lQm9vdHN0cmFwKEludGVyZmFjZUJ1aWxkZXIuY2FudmFzSWQsIEludGVyZmFjZUJ1aWxkZXIuZ2V0QXBwKCkgYXMgSFRNTEVsZW1lbnQpO1xuXHQvLyBzdGFydCB0aGUgZ2FtZVxuXHRnYi5zdGFydCgpO1xufVxuXG4vLyBjaGVjayB3aGV0aGVyIHRoZSB1c2VyIGlzIHVzaW5nIEludGVybmV0IEV4cGxvcmVyXG5pZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvTVNJRXxUcmlkZW50LykpXG5cdC8vIGNyaXRpY2lzZSB0aGUgdXNlclxuXHRhbGVydChcIkludGVybmV0IEV4cGxvcmVyIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlwiKTtcbmVsc2Vcblx0Ly8gc3RhcnQgZXZlcnl0aGluZ1xuXHRpbml0KCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9pbmRleC50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///59\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar Class_1 = __webpack_require__(5);\r\nvar GameBootstrap_1 = __webpack_require__(14);\r\nvar InterfaceBuilder_1 = __webpack_require__(15);\r\n__webpack_require__(61);\r\nvar NameEnquiry = /** @class */ (function (_super) {\r\n    __extends(NameEnquiry, _super);\r\n    function NameEnquiry() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Object.defineProperty(NameEnquiry.prototype, "value", {\r\n        get: function () {\r\n            return this.inputElement && this.inputElement.value.trim() || null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NameEnquiry.prototype.init = function (bootstrap) {\r\n        this.gameBoostrap = bootstrap;\r\n    };\r\n    NameEnquiry.prototype.start = function () {\r\n        InterfaceBuilder_1.InterfaceBuilder.displayDefault(this.render());\r\n        if (this.inputElement)\r\n            this.inputElement.select();\r\n    };\r\n    NameEnquiry.prototype.dispose = function () {\r\n        InterfaceBuilder_1.InterfaceBuilder.clearDefault();\r\n    };\r\n    NameEnquiry.prototype.done = function () {\r\n        if (this.gameBoostrap)\r\n            this.gameBoostrap.state.name = this.value;\r\n        this.emit("done", { target: this, type: GameBootstrap_1.GameElementDoneType.Finished });\r\n    };\r\n    NameEnquiry.prototype.onClick = function () {\r\n        if (this.value) {\r\n            this.done();\r\n        }\r\n        else\r\n            alert("Please enter a name.");\r\n    };\r\n    NameEnquiry.prototype.onKeyPress = function (keyCode) {\r\n        if (keyCode === 13)\r\n            this.done();\r\n    };\r\n    NameEnquiry.prototype.render = function () {\r\n        var _this = this;\r\n        return (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "pname-enquiry", className: "content-holder" },\r\n            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "dialog" },\r\n                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "label" }, "Enter your name:"),\r\n                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "form" },\r\n                    InterfaceBuilder_1.InterfaceBuilder.createElement("input", { ref: function (elt) { return _this.inputElement = elt; }, className: "name", type: "text", value: this.value || (this.gameBoostrap && this.gameBoostrap.state.name) || "", onkeyup: function (e) { return _this.onKeyPress(e.keyCode); }, autoFocus: true, maxLength: 32 }),\r\n                    InterfaceBuilder_1.InterfaceBuilder.createElement("button", { className: "submit", onclick: this.onClick.bind(this) }, "Let\'s go!")))));\r\n    };\r\n    return NameEnquiry;\r\n}(Class_1.Class));\r\nexports.NameEnquiry = NameEnquiry;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL05hbWVFbnF1aXJ5L05hbWVFbnF1aXJ5LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxxQ0FBb0M7QUFDcEMsOENBQXVGO0FBQ3ZGLGlEQUEwRDtBQUMxRCxtQkFBTyxDQUFDLEVBQWMsQ0FBQyxDQUFDO0FBRXhCO0lBQWlDLCtCQUFLO0lBQXRDOztJQStEQSxDQUFDO0lBMURBLHNCQUFJLDhCQUFLO2FBQVQ7WUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUM7UUFDcEUsQ0FBQzs7O09BQUE7SUFFRCwwQkFBSSxHQUFKLFVBQUssU0FBd0I7UUFDNUIsSUFBSSxDQUFDLFlBQVksR0FBRyxTQUFTLENBQUM7SUFDL0IsQ0FBQztJQUVELDJCQUFLLEdBQUw7UUFDQyxtQ0FBZ0IsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDL0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztZQUNyQixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRCw2QkFBTyxHQUFQO1FBQ0MsbUNBQWdCLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDakMsQ0FBQztJQUVPLDBCQUFJLEdBQVo7UUFDQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsbUNBQW1CLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRU8sNkJBQU8sR0FBZjtRQUNDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ2hCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNiLENBQUM7UUFBQyxJQUFJO1lBQ0wsS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVPLGdDQUFVLEdBQWxCLFVBQW1CLE9BQWU7UUFDakMsRUFBRSxDQUFDLENBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNsQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDZCxDQUFDO0lBRU8sNEJBQU0sR0FBZDtRQUFBLGlCQW9CQztRQW5CQSxNQUFNLENBQUMsQ0FDTiwyREFBSyxFQUFFLEVBQUMsZUFBZSxFQUFDLFNBQVMsRUFBQyxnQkFBZ0I7WUFDakQsMkRBQUssU0FBUyxFQUFDLFFBQVE7Z0JBQ3RCLDJEQUFLLFNBQVMsRUFBQyxPQUFPLHVCQUF1QjtnQkFDN0MsMkRBQUssU0FBUyxFQUFDLE1BQU07b0JBQ3BCLDZEQUNDLEdBQUcsRUFBRSxhQUFHLElBQUksWUFBSSxDQUFDLFlBQVksR0FBRyxHQUFHLEVBQXZCLENBQXVCLEVBQ25DLFNBQVMsRUFBQyxNQUFNLEVBQ2hCLElBQUksRUFBQyxNQUFNLEVBQ1gsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFDOUUsT0FBTyxFQUFFLFdBQUMsSUFBSSxZQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBMUIsQ0FBMEIsRUFDeEMsU0FBUyxRQUNULFNBQVMsRUFBRSxFQUFFLEdBQ1o7b0JBQ0YsOERBQVEsU0FBUyxFQUFDLFFBQVEsRUFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFvQixDQUMxRSxDQUNELENBQ0QsQ0FDTixDQUFDO0lBQ0gsQ0FBQztJQUVGLGtCQUFDO0FBQUQsQ0FBQyxDQS9EZ0MsYUFBSyxHQStEckM7QUEvRFksa0NBQVciLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbGFzcyB9IGZyb20gXCIuLi8uLi9DbGFzc1wiO1xuaW1wb3J0IHsgSUdhbWVFbGVtZW50LCBHYW1lQm9vdHN0cmFwLCBHYW1lRWxlbWVudERvbmVUeXBlIH0gZnJvbSBcIi4uLy4uL0dhbWVCb290c3RyYXBcIjtcbmltcG9ydCB7IEludGVyZmFjZUJ1aWxkZXIgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlQnVpbGRlclwiO1xucmVxdWlyZShcIi4vc3R5bGUuc2Nzc1wiKTtcblxuZXhwb3J0IGNsYXNzIE5hbWVFbnF1aXJ5IGV4dGVuZHMgQ2xhc3MgaW1wbGVtZW50cyBJR2FtZUVsZW1lbnQge1xuXG5cdHByaXZhdGUgaW5wdXRFbGVtZW50PzogSFRNTElucHV0RWxlbWVudDtcblx0cHJpdmF0ZSBnYW1lQm9vc3RyYXA/OiBHYW1lQm9vdHN0cmFwO1xuXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnB1dEVsZW1lbnQgJiYgdGhpcy5pbnB1dEVsZW1lbnQudmFsdWUudHJpbSgpIHx8IG51bGw7XG5cdH1cblxuXHRpbml0KGJvb3RzdHJhcDogR2FtZUJvb3RzdHJhcCkge1xuXHRcdHRoaXMuZ2FtZUJvb3N0cmFwID0gYm9vdHN0cmFwO1xuXHR9XG5cblx0c3RhcnQoKSB7XG5cdFx0SW50ZXJmYWNlQnVpbGRlci5kaXNwbGF5RGVmYXVsdCh0aGlzLnJlbmRlcigpKTtcblx0XHRpZiAodGhpcy5pbnB1dEVsZW1lbnQpXG5cdFx0XHR0aGlzLmlucHV0RWxlbWVudC5zZWxlY3QoKTtcblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cdFx0SW50ZXJmYWNlQnVpbGRlci5jbGVhckRlZmF1bHQoKTtcblx0fVxuXG5cdHByaXZhdGUgZG9uZSgpIHtcblx0XHRpZiAodGhpcy5nYW1lQm9vc3RyYXApXG5cdFx0XHR0aGlzLmdhbWVCb29zdHJhcC5zdGF0ZS5uYW1lID0gdGhpcy52YWx1ZTtcblx0XHR0aGlzLmVtaXQoXCJkb25lXCIsIHsgdGFyZ2V0OiB0aGlzLCB0eXBlOiBHYW1lRWxlbWVudERvbmVUeXBlLkZpbmlzaGVkIH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBvbkNsaWNrKCkge1xuXHRcdGlmICh0aGlzLnZhbHVlKSB7XG5cdFx0XHR0aGlzLmRvbmUoKTtcblx0XHR9IGVsc2Vcblx0XHRcdGFsZXJ0KFwiUGxlYXNlIGVudGVyIGEgbmFtZS5cIik7XG5cdH1cblxuXHRwcml2YXRlIG9uS2V5UHJlc3Moa2V5Q29kZTogbnVtYmVyKSB7XG5cdFx0aWYgKGtleUNvZGUgPT09IDEzKSAvLyBlbnRlclxuXHRcdFx0dGhpcy5kb25lKCk7XG5cdH1cblxuXHRwcml2YXRlIHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBpZD1cInBuYW1lLWVucXVpcnlcIiBjbGFzc05hbWU9XCJjb250ZW50LWhvbGRlclwiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImRpYWxvZ1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwibGFiZWxcIj5FbnRlciB5b3VyIG5hbWU6PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmb3JtXCI+XG5cdFx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdFx0cmVmPXtlbHQgPT4gdGhpcy5pbnB1dEVsZW1lbnQgPSBlbHR9XG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cIm5hbWVcIlxuXHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRcdHZhbHVlPXt0aGlzLnZhbHVlIHx8ICh0aGlzLmdhbWVCb29zdHJhcCAmJiB0aGlzLmdhbWVCb29zdHJhcC5zdGF0ZS5uYW1lKSB8fCBcIlwifVxuXHRcdFx0XHRcdFx0XHRvbmtleXVwPXtlID0+IHRoaXMub25LZXlQcmVzcyhlLmtleUNvZGUpfVxuXHRcdFx0XHRcdFx0XHRhdXRvRm9jdXNcblx0XHRcdFx0XHRcdFx0bWF4TGVuZ3RoPXszMn1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT1cInN1Ym1pdFwiIG9uY2xpY2s9e3RoaXMub25DbGljay5iaW5kKHRoaXMpfT5MZXQncyBnbyE8L2J1dHRvbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9OYW1lRW5xdWlyeS9OYW1lRW5xdWlyeS50c3giXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///60\n')},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL05hbWVFbnF1aXJ5L3N0eWxlLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29kZS9zcmMvU2NlbmVzL05hbWVFbnF1aXJ5L3N0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///61\n")},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar excalibur_1 = __webpack_require__(1);\r\nvar GameBootstrap_1 = __webpack_require__(14);\r\nvar Class_1 = __webpack_require__(5);\r\nvar ExampleLevel = /** @class */ (function (_super) {\r\n    __extends(ExampleLevel, _super);\r\n    function ExampleLevel(bootstrap) {\r\n        var _this = _super.call(this) || this;\r\n        _this.items = [];\r\n        _this.bricks = [];\r\n        _this.sceneKey = "examplelevel";\r\n        var engine = bootstrap.engine;\r\n        _this.gameBootstrap = bootstrap;\r\n        var scene = _this.scene = new excalibur_1.Scene(engine);\r\n        var bounds = engine.getWorldBounds();\r\n        var paddle = new excalibur_1.Actor(150, bounds.getHeight() - 40, 200, 20);\r\n        paddle.color = excalibur_1.Color.Chartreuse;\r\n        paddle.collisionType = excalibur_1.CollisionType.Fixed;\r\n        scene.add(paddle);\r\n        engine.addScene(_this.sceneKey, scene);\r\n        _this.gameBootstrap.engine.input.pointers.primary.on("move", function (evt) {\r\n            paddle.pos.x = evt.x;\r\n        });\r\n        return _this;\r\n    }\r\n    ExampleLevel.prototype.init = function (bootstrap) {\r\n        //\r\n    };\r\n    ExampleLevel.prototype.start = function () {\r\n        this.createElements();\r\n        this.gameBootstrap.engine.goToScene(this.sceneKey);\r\n    };\r\n    ExampleLevel.prototype.dispose = function () {\r\n        var _a = this.gameBootstrap, engine = _a.engine, rootSceneKey = _a.rootSceneKey;\r\n        this.bricks.forEach(function (t) { return t.kill(); });\r\n        this.bricks = [];\r\n        if (this.ball)\r\n            this.ball.kill();\r\n        engine.goToScene(rootSceneKey);\r\n    };\r\n    ExampleLevel.prototype.win = function () {\r\n        this.emit("done", {\r\n            target: this,\r\n            type: GameBootstrap_1.GameElementDoneType.Finished\r\n        });\r\n    };\r\n    ExampleLevel.prototype.lose = function () {\r\n        this.emit("done", {\r\n            target: this,\r\n            type: GameBootstrap_1.GameElementDoneType.Aborted\r\n        });\r\n    };\r\n    ExampleLevel.prototype.createElements = function () {\r\n        var _this = this;\r\n        // add bricks and a ball\r\n        var _a = this, scene = _a.scene, gameBootstrap = _a.gameBootstrap;\r\n        var brickColor = [excalibur_1.Color.Violet, excalibur_1.Color.Orange, excalibur_1.Color.Yellow];\r\n        var bounds = gameBootstrap.engine.getWorldBounds();\r\n        var padding = 20; // px\r\n        var xoffset = 65; // x-offset\r\n        var yoffset = 20; // y-offset\r\n        var columns = 5;\r\n        var rows = 3;\r\n        var brickWidth = bounds.getWidth() / columns - padding - padding / columns; // px\r\n        var brickHeight = 30; // px\r\n        var bricks = [];\r\n        this.bricks = bricks;\r\n        for (var j = 0; j < rows; j++) {\r\n            for (var i = 0; i < columns; i++) {\r\n                bricks.push(new excalibur_1.Actor(xoffset + i * (brickWidth + padding) + padding, yoffset + j * (brickHeight + padding) + padding, brickWidth, brickHeight, brickColor[j % brickColor.length]));\r\n            }\r\n        }\r\n        bricks.forEach(function (brick) {\r\n            brick.collisionType = excalibur_1.CollisionType.Active;\r\n            scene.add(brick);\r\n        });\r\n        var ball = new excalibur_1.Actor(100, 300, 20, 20);\r\n        this.ball = ball;\r\n        ball.color = excalibur_1.Color.Red;\r\n        ball.vel.setTo(500, 500);\r\n        ball.collisionType = excalibur_1.CollisionType.Passive;\r\n        ball.draw = function (ctx, delta) {\r\n            ctx.fillStyle = this.color.toString();\r\n            ctx.beginPath();\r\n            ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        };\r\n        ball.on("postupdate", function () {\r\n            // @ts-ignore\r\n            var that = this;\r\n            if (that.pos.x < (that.getWidth() / 2))\r\n                that.vel.x *= -1;\r\n            if (that.pos.x + (that.getWidth() / 2) > bounds.getWidth())\r\n                that.vel.x *= -1;\r\n            if (that.pos.y < (that.getHeight() / 2)) {\r\n                that.vel.y *= -1;\r\n            }\r\n        });\r\n        ball.on("precollision", function (ev) {\r\n            var index = bricks.indexOf(ev.other);\r\n            if (index > -1) {\r\n                ev.other.kill();\r\n                bricks.splice(index, 1);\r\n                if (!bricks.length)\r\n                    _this.win();\r\n            }\r\n            var intersection = ev.intersection.normalize();\r\n            if (Math.abs(intersection.x) > Math.abs(intersection.y)) {\r\n                ball.vel.x *= -1;\r\n            }\r\n            else {\r\n                ball.vel.y *= -1;\r\n            }\r\n        });\r\n        ball.on("exitviewport", function () {\r\n            ball.kill();\r\n            _this.lose();\r\n        });\r\n        scene.add(ball);\r\n    };\r\n    return ExampleLevel;\r\n}(Class_1.Class));\r\nexports.default = ExampleLevel;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0V4YW1wbGVMZXZlbC9FeGFtcGxlTGV2ZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEseUNBQStEO0FBQy9ELDhDQUEyRztBQUMzRyxxQ0FBb0M7QUFFcEM7SUFBMEMsZ0NBQXlCO0lBU2xFLHNCQUFZLFNBQXdCO1FBQXBDLFlBQ0MsaUJBQU8sU0FlUDtRQXZCRCxXQUFLLEdBQWEsRUFBRSxDQUFDO1FBSXJCLFlBQU0sR0FBWSxFQUFFLENBQUM7UUFDWixjQUFRLEdBQUcsY0FBYyxDQUFDO1FBSzFCLDZCQUFNLENBQWU7UUFDN0IsS0FBSSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7UUFDL0IsSUFBTSxLQUFLLEdBQUcsS0FBSSxDQUFDLEtBQUssR0FBRyxJQUFJLGlCQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDN0MsSUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBRXZDLElBQU0sTUFBTSxHQUFHLElBQUksaUJBQUssQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDaEUsTUFBTSxDQUFDLEtBQUssR0FBRyxpQkFBSyxDQUFDLFVBQVUsQ0FBQztRQUNoQyxNQUFNLENBQUMsYUFBYSxHQUFHLHlCQUFhLENBQUMsS0FBSyxDQUFDO1FBQzNDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbEIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFJLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3RDLEtBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsVUFBVSxHQUFRO1lBQzdFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQUM7O0lBQ0osQ0FBQztJQUVELDJCQUFJLEdBQUosVUFBSyxTQUF3QjtRQUM1QixFQUFFO0lBQ0gsQ0FBQztJQUVELDRCQUFLLEdBQUw7UUFDQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQsOEJBQU8sR0FBUDtRQUNPLDJCQUE2QyxFQUEzQyxrQkFBTSxFQUFFLDhCQUFZLENBQXdCO1FBQ3BELElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQUMsSUFBSSxRQUFDLENBQUMsSUFBSSxFQUFFLEVBQVIsQ0FBUSxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDakIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDbEIsTUFBTSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQsMEJBQUcsR0FBSDtRQUNDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2pCLE1BQU0sRUFBRSxJQUFJO1lBQ1osSUFBSSxFQUFFLG1DQUFtQixDQUFDLFFBQVE7U0FDbEMsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELDJCQUFJLEdBQUo7UUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNqQixNQUFNLEVBQUUsSUFBSTtZQUNaLElBQUksRUFBRSxtQ0FBbUIsQ0FBQyxPQUFPO1NBQ2pDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCxxQ0FBYyxHQUFkO1FBQUEsaUJBMkVDO1FBMUVBLHdCQUF3QjtRQUNsQixhQUErQixFQUE3QixnQkFBSyxFQUFFLGdDQUFhLENBQVU7UUFDdEMsSUFBTSxVQUFVLEdBQUcsQ0FBQyxpQkFBSyxDQUFDLE1BQU0sRUFBRSxpQkFBSyxDQUFDLE1BQU0sRUFBRSxpQkFBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzlELElBQU0sTUFBTSxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUM7UUFFckQsSUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLENBQUMsS0FBSztRQUN6QixJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsQ0FBQyxXQUFXO1FBQy9CLElBQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQyxDQUFDLFdBQVc7UUFDL0IsSUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ2xCLElBQU0sSUFBSSxHQUFHLENBQUMsQ0FBQztRQUNmLElBQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsR0FBRyxPQUFPLEdBQUcsT0FBTyxHQUFHLE9BQU8sR0FBRyxPQUFPLENBQUMsQ0FBQyxLQUFLO1FBQ25GLElBQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEtBQUs7UUFFN0IsSUFBTSxNQUFNLEdBQVksRUFBRSxDQUFDO1FBQzNCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDL0IsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDbEMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLGlCQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsR0FBRyxPQUFPLEVBQUUsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckwsQ0FBQztRQUNGLENBQUM7UUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsS0FBSztZQUM3QixLQUFLLENBQUMsYUFBYSxHQUFHLHlCQUFhLENBQUMsTUFBTSxDQUFDO1lBQzNDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEIsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFNLElBQUksR0FBRyxJQUFJLGlCQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxpQkFBSyxDQUFDLEdBQUcsQ0FBQztRQUN2QixJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLGFBQWEsR0FBRyx5QkFBYSxDQUFDLE9BQU8sQ0FBQztRQUUzQyxJQUFJLENBQUMsSUFBSSxHQUFHLFVBQVUsR0FBRyxFQUFFLEtBQUs7WUFDL0IsR0FBRyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3RDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNoQixHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNwRCxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDaEIsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ1osQ0FBQyxDQUFDO1FBRUYsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUU7WUFDckIsYUFBYTtZQUNiLElBQU0sSUFBSSxHQUFHLElBQVcsQ0FBQztZQUN6QixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDdEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDbEIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUMxRCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNsQixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLENBQUM7UUFDRixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLFVBQUMsRUFBTztZQUMvQixJQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN2QyxFQUFFLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNoQixNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDeEIsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO29CQUNsQixLQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDYixDQUFDO1lBQ0QsSUFBTSxZQUFZLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNqRCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDUCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNsQixDQUFDO1FBQ0YsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRTtZQUN2QixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDWixLQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDYixDQUFDLENBQUMsQ0FBQztRQUVILEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDakIsQ0FBQztJQUVGLG1CQUFDO0FBQUQsQ0FBQyxDQXhJeUMsYUFBSyxHQXdJOUMiLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY2VuZSwgQWN0b3IsIENvbG9yLCBDb2xsaXNpb25UeXBlIH0gZnJvbSBcImV4Y2FsaWJ1clwiO1xuaW1wb3J0IHsgSUdhbWVFbGVtZW50LCBHYW1lQm9vdHN0cmFwLCBJR2FtZUVsZW1lbnRFdmVudHMsIEdhbWVFbGVtZW50RG9uZVR5cGUgfSBmcm9tIFwiLi4vLi4vR2FtZUJvb3RzdHJhcFwiO1xuaW1wb3J0IHsgQ2xhc3MgfSBmcm9tIFwiLi4vLi4vQ2xhc3NcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhhbXBsZUxldmVsIGV4dGVuZHMgQ2xhc3M8SUdhbWVFbGVtZW50RXZlbnRzPiBpbXBsZW1lbnRzIElHYW1lRWxlbWVudCB7XG5cblx0aXRlbXM6IHN0cmluZ1tdID0gW107XG5cdGdhbWVCb290c3RyYXA6IEdhbWVCb290c3RyYXA7XG5cdHNjZW5lOiBTY2VuZTtcblx0YmFsbD86IEFjdG9yO1xuXHRicmlja3M6IEFjdG9yW10gPSBbXTtcblx0cmVhZG9ubHkgc2NlbmVLZXkgPSBcImV4YW1wbGVsZXZlbFwiO1xuXG5cdGNvbnN0cnVjdG9yKGJvb3RzdHJhcDogR2FtZUJvb3RzdHJhcCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHRjb25zdCB7IGVuZ2luZSB9ID0gYm9vdHN0cmFwO1xuXHRcdHRoaXMuZ2FtZUJvb3RzdHJhcCA9IGJvb3RzdHJhcDtcblx0XHRjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmUgPSBuZXcgU2NlbmUoZW5naW5lKTtcblx0XHRjb25zdCBib3VuZHMgPSBlbmdpbmUuZ2V0V29ybGRCb3VuZHMoKTtcblxuXHRcdGNvbnN0IHBhZGRsZSA9IG5ldyBBY3RvcigxNTAsIGJvdW5kcy5nZXRIZWlnaHQoKSAtIDQwLCAyMDAsIDIwKTtcblx0XHRwYWRkbGUuY29sb3IgPSBDb2xvci5DaGFydHJldXNlO1xuXHRcdHBhZGRsZS5jb2xsaXNpb25UeXBlID0gQ29sbGlzaW9uVHlwZS5GaXhlZDtcblx0XHRzY2VuZS5hZGQocGFkZGxlKTtcblx0XHRlbmdpbmUuYWRkU2NlbmUodGhpcy5zY2VuZUtleSwgc2NlbmUpO1xuXHRcdHRoaXMuZ2FtZUJvb3RzdHJhcC5lbmdpbmUuaW5wdXQucG9pbnRlcnMucHJpbWFyeS5vbihcIm1vdmVcIiwgZnVuY3Rpb24gKGV2dDogYW55KSB7XG5cdFx0XHRwYWRkbGUucG9zLnggPSBldnQueDtcblx0XHR9KTtcblx0fVxuXG5cdGluaXQoYm9vdHN0cmFwOiBHYW1lQm9vdHN0cmFwKTogdm9pZCB7XG5cdFx0Ly9cblx0fVxuXG5cdHN0YXJ0KCk6IHZvaWQge1xuXHRcdHRoaXMuY3JlYXRlRWxlbWVudHMoKTtcblx0XHR0aGlzLmdhbWVCb290c3RyYXAuZW5naW5lLmdvVG9TY2VuZSh0aGlzLnNjZW5lS2V5KTtcblx0fVxuXG5cdGRpc3Bvc2UoKTogdm9pZCB7XG5cdFx0Y29uc3QgeyBlbmdpbmUsIHJvb3RTY2VuZUtleSB9ID0gdGhpcy5nYW1lQm9vdHN0cmFwO1xuXHRcdHRoaXMuYnJpY2tzLmZvckVhY2godCA9PiB0LmtpbGwoKSk7XG5cdFx0dGhpcy5icmlja3MgPSBbXTtcblx0XHRpZiAodGhpcy5iYWxsKVxuXHRcdFx0dGhpcy5iYWxsLmtpbGwoKTtcblx0XHRlbmdpbmUuZ29Ub1NjZW5lKHJvb3RTY2VuZUtleSk7XG5cdH1cblxuXHR3aW4oKSB7XG5cdFx0dGhpcy5lbWl0KFwiZG9uZVwiLCB7XG5cdFx0XHR0YXJnZXQ6IHRoaXMsXG5cdFx0XHR0eXBlOiBHYW1lRWxlbWVudERvbmVUeXBlLkZpbmlzaGVkXG5cdFx0fSk7XG5cdH1cblxuXHRsb3NlKCkge1xuXHRcdHRoaXMuZW1pdChcImRvbmVcIiwge1xuXHRcdFx0dGFyZ2V0OiB0aGlzLFxuXHRcdFx0dHlwZTogR2FtZUVsZW1lbnREb25lVHlwZS5BYm9ydGVkXG5cdFx0fSk7XG5cdH1cblxuXHRjcmVhdGVFbGVtZW50cygpIHtcblx0XHQvLyBhZGQgYnJpY2tzIGFuZCBhIGJhbGxcblx0XHRjb25zdCB7IHNjZW5lLCBnYW1lQm9vdHN0cmFwIH0gPSB0aGlzO1xuXHRcdGNvbnN0IGJyaWNrQ29sb3IgPSBbQ29sb3IuVmlvbGV0LCBDb2xvci5PcmFuZ2UsIENvbG9yLlllbGxvd107XG5cdFx0Y29uc3QgYm91bmRzID0gZ2FtZUJvb3RzdHJhcC5lbmdpbmUuZ2V0V29ybGRCb3VuZHMoKTtcblxuXHRcdGNvbnN0IHBhZGRpbmcgPSAyMDsgLy8gcHhcblx0XHRjb25zdCB4b2Zmc2V0ID0gNjU7IC8vIHgtb2Zmc2V0XG5cdFx0Y29uc3QgeW9mZnNldCA9IDIwOyAvLyB5LW9mZnNldFxuXHRcdGNvbnN0IGNvbHVtbnMgPSA1O1xuXHRcdGNvbnN0IHJvd3MgPSAzO1xuXHRcdGNvbnN0IGJyaWNrV2lkdGggPSBib3VuZHMuZ2V0V2lkdGgoKSAvIGNvbHVtbnMgLSBwYWRkaW5nIC0gcGFkZGluZyAvIGNvbHVtbnM7IC8vIHB4XG5cdFx0Y29uc3QgYnJpY2tIZWlnaHQgPSAzMDsgLy8gcHhcblxuXHRcdGNvbnN0IGJyaWNrczogQWN0b3JbXSA9IFtdO1xuXHRcdHRoaXMuYnJpY2tzID0gYnJpY2tzO1xuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgcm93czsgaisrKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuXHRcdFx0XHRicmlja3MucHVzaChuZXcgQWN0b3IoeG9mZnNldCArIGkgKiAoYnJpY2tXaWR0aCArIHBhZGRpbmcpICsgcGFkZGluZywgeW9mZnNldCArIGogKiAoYnJpY2tIZWlnaHQgKyBwYWRkaW5nKSArIHBhZGRpbmcsIGJyaWNrV2lkdGgsIGJyaWNrSGVpZ2h0LCBicmlja0NvbG9yW2ogJSBicmlja0NvbG9yLmxlbmd0aF0pKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRicmlja3MuZm9yRWFjaChmdW5jdGlvbiAoYnJpY2spIHtcblx0XHRcdGJyaWNrLmNvbGxpc2lvblR5cGUgPSBDb2xsaXNpb25UeXBlLkFjdGl2ZTtcblx0XHRcdHNjZW5lLmFkZChicmljayk7XG5cdFx0fSk7XG5cblx0XHRjb25zdCBiYWxsID0gbmV3IEFjdG9yKDEwMCwgMzAwLCAyMCwgMjApO1xuXHRcdHRoaXMuYmFsbCA9IGJhbGw7XG5cdFx0YmFsbC5jb2xvciA9IENvbG9yLlJlZDtcblx0XHRiYWxsLnZlbC5zZXRUbyg1MDAsIDUwMCk7XG5cdFx0YmFsbC5jb2xsaXNpb25UeXBlID0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlO1xuXG5cdFx0YmFsbC5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHguYXJjKHRoaXMucG9zLngsIHRoaXMucG9zLnksIDEwLCAwLCBNYXRoLlBJICogMik7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHguZmlsbCgpO1xuXHRcdH07XG5cblx0XHRiYWxsLm9uKFwicG9zdHVwZGF0ZVwiLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRjb25zdCB0aGF0ID0gdGhpcyBhcyBhbnk7XG5cdFx0XHRpZiAodGhhdC5wb3MueCA8ICh0aGF0LmdldFdpZHRoKCkgLyAyKSlcblx0XHRcdFx0dGhhdC52ZWwueCAqPSAtMTtcblx0XHRcdGlmICh0aGF0LnBvcy54ICsgKHRoYXQuZ2V0V2lkdGgoKSAvIDIpID4gYm91bmRzLmdldFdpZHRoKCkpXG5cdFx0XHRcdHRoYXQudmVsLnggKj0gLTE7XG5cdFx0XHRpZiAodGhhdC5wb3MueSA8ICh0aGF0LmdldEhlaWdodCgpIC8gMikpIHtcblx0XHRcdFx0dGhhdC52ZWwueSAqPSAtMTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGJhbGwub24oXCJwcmVjb2xsaXNpb25cIiwgKGV2OiBhbnkpID0+IHtcblx0XHRcdGNvbnN0IGluZGV4ID0gYnJpY2tzLmluZGV4T2YoZXYub3RoZXIpO1xuXHRcdFx0aWYgKGluZGV4ID4gLTEpIHtcblx0XHRcdFx0ZXYub3RoZXIua2lsbCgpO1xuXHRcdFx0XHRicmlja3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0aWYgKCFicmlja3MubGVuZ3RoKSAvLyB3ZSBkZXN0cm95ZWQgYWxsIHRoZSBicmlja3Ncblx0XHRcdFx0XHR0aGlzLndpbigpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgaW50ZXJzZWN0aW9uID0gZXYuaW50ZXJzZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXHRcdFx0aWYgKE1hdGguYWJzKGludGVyc2VjdGlvbi54KSA+IE1hdGguYWJzKGludGVyc2VjdGlvbi55KSkge1xuXHRcdFx0XHRiYWxsLnZlbC54ICo9IC0xO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YmFsbC52ZWwueSAqPSAtMTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGJhbGwub24oXCJleGl0dmlld3BvcnRcIiwgKCkgPT4ge1xuXHRcdFx0YmFsbC5raWxsKCk7XG5cdFx0XHR0aGlzLmxvc2UoKTtcblx0XHR9KTtcblxuXHRcdHNjZW5lLmFkZChiYWxsKTtcblx0fVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvRXhhbXBsZUxldmVsL0V4YW1wbGVMZXZlbC50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///62\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar GameBootstrap_1 = __webpack_require__(14);\r\nvar InterfaceBuilder_1 = __webpack_require__(15);\r\nvar Class_1 = __webpack_require__(5);\r\n__webpack_require__(64);\r\nvar Menu = /** @class */ (function (_super) {\r\n    __extends(Menu, _super);\r\n    function Menu() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Menu.prototype.init = function (bootstrap) {\r\n        void (0); // do nothing\r\n    };\r\n    Menu.prototype.itemClick = function (id, name) {\r\n        this.emit("click", {\r\n            target: this,\r\n            id: id,\r\n            name: name\r\n        });\r\n        this.emit("done", {\r\n            target: this,\r\n            type: GameBootstrap_1.GameElementDoneType.Finished\r\n        });\r\n    };\r\n    Menu.prototype.start = function () {\r\n        var _this = this;\r\n        InterfaceBuilder_1.InterfaceBuilder.displayDefault(InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "game-menu" },\r\n            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "dialog" },\r\n                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "items" }, this.items && this.items.map(function (t, i) { return (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "item", onclick: function (e) { return _this.itemClick(i, t); } }, t)); })))));\r\n    };\r\n    Menu.prototype.dispose = function () {\r\n        InterfaceBuilder_1.InterfaceBuilder.clearDefault();\r\n    };\r\n    return Menu;\r\n}(Class_1.Class));\r\nexports.default = Menu;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL01lbnUvTWVudS50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsOENBQTJHO0FBQzNHLGlEQUEwRDtBQUMxRCxxQ0FBb0M7QUFDcEMsbUJBQU8sQ0FBQyxFQUFjLENBQUMsQ0FBQztBQVV4QjtJQUFrQyx3QkFBa0I7SUFBcEQ7O0lBc0NBLENBQUM7SUFsQ0EsbUJBQUksR0FBSixVQUFLLFNBQXdCO1FBQzVCLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWE7SUFDeEIsQ0FBQztJQUVPLHdCQUFTLEdBQWpCLFVBQWtCLEVBQVUsRUFBRSxJQUFZO1FBQ3pDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2xCLE1BQU0sRUFBRSxJQUFJO1lBQ1osRUFBRTtZQUNGLElBQUk7U0FDSixDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNqQixNQUFNLEVBQUUsSUFBSTtZQUNaLElBQUksRUFBRSxtQ0FBbUIsQ0FBQyxRQUFRO1NBQ2xDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCxvQkFBSyxHQUFMO1FBQUEsaUJBWUM7UUFYQSxtQ0FBZ0IsQ0FBQyxjQUFjLENBQzlCLDJEQUFLLEVBQUUsRUFBQyxXQUFXO1lBQ2xCLDJEQUFLLFNBQVMsRUFBQyxRQUFRO2dCQUN0QiwyREFBSyxTQUFTLEVBQUMsT0FBTyxJQUNwQixJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSyxRQUN2QywyREFBSyxTQUFTLEVBQUMsTUFBTSxFQUFDLE9BQU8sRUFBRSxXQUFDLElBQUksWUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQXBCLENBQW9CLElBQUcsQ0FBQyxDQUFPLENBQ25FLEVBRnVDLENBRXZDLENBQUMsQ0FDRyxDQUNELENBQ0QsQ0FDTixDQUFDO0lBQ0gsQ0FBQztJQUVELHNCQUFPLEdBQVA7UUFDQyxtQ0FBZ0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNqQyxDQUFDO0lBRUYsV0FBQztBQUFELENBQUMsQ0F0Q2lDLGFBQUssR0FzQ3RDIiwiZmlsZSI6IjYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUdhbWVFbGVtZW50LCBHYW1lQm9vdHN0cmFwLCBJR2FtZUVsZW1lbnRFdmVudHMsIEdhbWVFbGVtZW50RG9uZVR5cGUgfSBmcm9tIFwiLi4vLi4vR2FtZUJvb3RzdHJhcFwiO1xuaW1wb3J0IHsgSW50ZXJmYWNlQnVpbGRlciB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2VCdWlsZGVyXCI7XG5pbXBvcnQgeyBDbGFzcyB9IGZyb20gXCIuLi8uLi9DbGFzc1wiO1xucmVxdWlyZShcIi4vc3R5bGUuc2Nzc1wiKTtcblxuaW50ZXJmYWNlIElNZW51RXZlbnRzIGV4dGVuZHMgSUdhbWVFbGVtZW50RXZlbnRzIHtcblx0Y2xpY2s6IHtcblx0XHR0YXJnZXQ6IElHYW1lRWxlbWVudDtcblx0XHRpZDogbnVtYmVyO1xuXHRcdG5hbWU6IHN0cmluZztcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVudSBleHRlbmRzIENsYXNzPElNZW51RXZlbnRzPiBpbXBsZW1lbnRzIElHYW1lRWxlbWVudCB7XG5cblx0aXRlbXM/OiBzdHJpbmdbXTtcblxuXHRpbml0KGJvb3RzdHJhcDogR2FtZUJvb3RzdHJhcCk6IHZvaWQge1xuXHRcdHZvaWQgKDApOyAvLyBkbyBub3RoaW5nXG5cdH1cblxuXHRwcml2YXRlIGl0ZW1DbGljayhpZDogbnVtYmVyLCBuYW1lOiBzdHJpbmcpIHtcblx0XHR0aGlzLmVtaXQoXCJjbGlja1wiLCB7XG5cdFx0XHR0YXJnZXQ6IHRoaXMsXG5cdFx0XHRpZCxcblx0XHRcdG5hbWVcblx0XHR9KTtcblx0XHR0aGlzLmVtaXQoXCJkb25lXCIsIHtcblx0XHRcdHRhcmdldDogdGhpcyxcblx0XHRcdHR5cGU6IEdhbWVFbGVtZW50RG9uZVR5cGUuRmluaXNoZWRcblx0XHR9KTtcblx0fVxuXG5cdHN0YXJ0KCk6IHZvaWQge1xuXHRcdEludGVyZmFjZUJ1aWxkZXIuZGlzcGxheURlZmF1bHQoXG5cdFx0XHQ8ZGl2IGlkPVwiZ2FtZS1tZW51XCI+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZGlhbG9nXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJpdGVtc1wiPlxuXHRcdFx0XHRcdFx0e3RoaXMuaXRlbXMgJiYgdGhpcy5pdGVtcy5tYXAoKHQsIGkpID0+IChcblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJpdGVtXCIgb25jbGljaz17ZSA9PiB0aGlzLml0ZW1DbGljayhpLCB0KX0+e3R9PC9kaXY+XG5cdFx0XHRcdFx0XHQpKX1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0ZGlzcG9zZSgpOiB2b2lkIHtcblx0XHRJbnRlcmZhY2VCdWlsZGVyLmNsZWFyRGVmYXVsdCgpO1xuXHR9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9NZW51L01lbnUudHN4Il0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///63\n')},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL01lbnUvc3R5bGUuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI2NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTWVudS9zdHlsZS5zY3NzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///64\n")},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar Class_1 = __webpack_require__(5);\r\nvar GameBootstrap_1 = __webpack_require__(14);\r\nvar InterfaceBuilder_1 = __webpack_require__(15);\r\nvar Story_1 = __webpack_require__(66);\r\n__webpack_require__(67);\r\nvar Intro = /** @class */ (function (_super) {\r\n    __extends(Intro, _super);\r\n    function Intro(bootstrap) {\r\n        var _this = _super.call(this) || this;\r\n        _this.gameBoostrap = bootstrap;\r\n        _this.story = [Story_1.intro, Story_1.level1, Story_1.level2, Story_1.level3, Story_1.level4, Story_1.end, Story_1.death];\r\n        _this.storyPage = 0;\r\n        return _this;\r\n    }\r\n    Intro.prototype.init = function (bootstrap) {\r\n        //\r\n    };\r\n    Intro.prototype.renderStoryPage = function () {\r\n        if (this.storyElement)\r\n            InterfaceBuilder_1.InterfaceBuilder.replaceContent(this.storyElement, this.story[this.storyPage]);\r\n    };\r\n    Intro.prototype.start = function () {\r\n        InterfaceBuilder_1.InterfaceBuilder.displayDefault(this.render());\r\n        this.renderStoryPage();\r\n    };\r\n    Intro.prototype.dispose = function () {\r\n        InterfaceBuilder_1.InterfaceBuilder.clearDefault();\r\n    };\r\n    Intro.prototype.done = function () {\r\n        this.storyPage = 0;\r\n        this.emit("done", { target: this, type: GameBootstrap_1.GameElementDoneType.Finished });\r\n    };\r\n    Intro.prototype.onClick = function () {\r\n        this.storyPage++;\r\n        if (this.storyPage >= this.story.length)\r\n            this.done();\r\n        else\r\n            this.renderStoryPage();\r\n    };\r\n    Intro.prototype.render = function () {\r\n        var _this = this;\r\n        return (InterfaceBuilder_1.InterfaceBuilder.createElement("div", { id: "intro" },\r\n            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "bg" }),\r\n            InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "content-holder" },\r\n                InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "dialog" },\r\n                    InterfaceBuilder_1.InterfaceBuilder.createElement("div", { className: "story" },\r\n                        InterfaceBuilder_1.InterfaceBuilder.createElement("div", { ref: function (elt) { return _this.storyElement = elt; } }),\r\n                        InterfaceBuilder_1.InterfaceBuilder.createElement("button", { className: "submit", onclick: this.onClick.bind(this) }, "Continue to read the story!"))))));\r\n    };\r\n    return Intro;\r\n}(Class_1.Class));\r\nexports.default = Intro;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0ludHJvL0ludHJvLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxxQ0FBb0M7QUFDcEMsOENBQTRIO0FBQzVILGlEQUEwRDtBQUMxRCxzQ0FBb0Y7QUFDcEYsbUJBQU8sQ0FBQyxFQUFjLENBQUMsQ0FBQztBQUV4QjtJQUFtQyx5QkFBSztJQU92QyxlQUFZLFNBQXdCO1FBQXBDLFlBQ0MsaUJBQU8sU0FLUDtRQUhBLEtBQUksQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDO1FBQzlCLEtBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxhQUFLLEVBQUUsY0FBTSxFQUFFLGNBQU0sRUFBRSxjQUFNLEVBQUUsY0FBTSxFQUFFLFdBQUcsRUFBRSxhQUFLLENBQUMsQ0FBQztRQUNqRSxLQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQzs7SUFDcEIsQ0FBQztJQUVELG9CQUFJLEdBQUosVUFBSyxTQUF3QjtRQUM1QixFQUFFO0lBQ0gsQ0FBQztJQUVPLCtCQUFlLEdBQXZCO1FBQ0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztZQUNyQixtQ0FBZ0IsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQ2pGLENBQUM7SUFFRCxxQkFBSyxHQUFMO1FBQ0MsbUNBQWdCLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQsdUJBQU8sR0FBUDtRQUNDLG1DQUFnQixDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ2pDLENBQUM7SUFFTyxvQkFBSSxHQUFaO1FBQ0MsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxtQ0FBbUIsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFTyx1QkFBTyxHQUFmO1FBQ0MsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2pCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7WUFDdkMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2IsSUFBSTtZQUNILElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRU8sc0JBQU0sR0FBZDtRQUFBLGlCQWNDO1FBYkEsTUFBTSxDQUFDLENBQ04sMkRBQUssRUFBRSxFQUFDLE9BQU87WUFDZCwyREFBSyxTQUFTLEVBQUMsSUFBSSxHQUFPO1lBQzFCLDJEQUFLLFNBQVMsRUFBQyxnQkFBZ0I7Z0JBQzlCLDJEQUFLLFNBQVMsRUFBQyxRQUFRO29CQUN0QiwyREFBSyxTQUFTLEVBQUMsT0FBTzt3QkFDckIsMkRBQUssR0FBRyxFQUFFLGFBQUcsSUFBSSxZQUFJLENBQUMsWUFBWSxHQUFHLEdBQUcsRUFBdkIsQ0FBdUIsR0FBUTt3QkFDaEQsOERBQVEsU0FBUyxFQUFDLFFBQVEsRUFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGtDQUFzQyxDQUM1RixDQUNELENBQ0QsQ0FDRCxDQUNOLENBQUM7SUFDSCxDQUFDO0lBRUYsWUFBQztBQUFELENBQUMsQ0E5RGtDLGFBQUssR0E4RHZDIiwiZmlsZSI6IjY1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xhc3MgfSBmcm9tIFwiLi4vLi4vQ2xhc3NcIjtcbmltcG9ydCB7IElHYW1lRWxlbWVudCwgR2FtZUJvb3RzdHJhcCwgSUdhbWVFbGVtZW50RXZlbnRzLCBJR2FtZUV2ZW50VmFsdWUsIEdhbWVFbGVtZW50RG9uZVR5cGUgfSBmcm9tIFwiLi4vLi4vR2FtZUJvb3RzdHJhcFwiO1xuaW1wb3J0IHsgSW50ZXJmYWNlQnVpbGRlciB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2VCdWlsZGVyXCI7XG5pbXBvcnQgeyBJU3RvcnksIGludHJvLCBsZXZlbDEsIGxldmVsMiwgbGV2ZWwzLCBsZXZlbDQsIGVuZCwgZGVhdGggfSBmcm9tIFwiLi9TdG9yeVwiO1xucmVxdWlyZShcIi4vc3R5bGUuc2Nzc1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50cm8gZXh0ZW5kcyBDbGFzcyBpbXBsZW1lbnRzIElHYW1lRWxlbWVudCB7XG5cblx0cHJpdmF0ZSBnYW1lQm9vc3RyYXA6IEdhbWVCb290c3RyYXA7XG5cdHByaXZhdGUgc3RvcnlFbGVtZW50PzogSFRNTEVsZW1lbnQ7XG5cdHByaXZhdGUgc3Rvcnk6IElTdG9yeVtdO1xuXHRwcml2YXRlIHN0b3J5UGFnZTogbnVtYmVyOyAvLyBpbmRleCBvZiBhIHBhZ2Ugb2YgYSBzdG9yeVxuXG5cdGNvbnN0cnVjdG9yKGJvb3RzdHJhcDogR2FtZUJvb3RzdHJhcCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmdhbWVCb29zdHJhcCA9IGJvb3RzdHJhcDtcblx0XHR0aGlzLnN0b3J5ID0gW2ludHJvLCBsZXZlbDEsIGxldmVsMiwgbGV2ZWwzLCBsZXZlbDQsIGVuZCwgZGVhdGhdO1xuXHRcdHRoaXMuc3RvcnlQYWdlID0gMDtcblx0fVxuXG5cdGluaXQoYm9vdHN0cmFwOiBHYW1lQm9vdHN0cmFwKSB7XG5cdFx0Ly9cblx0fVxuXG5cdHByaXZhdGUgcmVuZGVyU3RvcnlQYWdlKCkge1xuXHRcdGlmICh0aGlzLnN0b3J5RWxlbWVudClcblx0XHRcdEludGVyZmFjZUJ1aWxkZXIucmVwbGFjZUNvbnRlbnQodGhpcy5zdG9yeUVsZW1lbnQsIHRoaXMuc3RvcnlbdGhpcy5zdG9yeVBhZ2VdKTtcblx0fVxuXG5cdHN0YXJ0KCkge1xuXHRcdEludGVyZmFjZUJ1aWxkZXIuZGlzcGxheURlZmF1bHQodGhpcy5yZW5kZXIoKSk7XG5cdFx0dGhpcy5yZW5kZXJTdG9yeVBhZ2UoKTtcblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cdFx0SW50ZXJmYWNlQnVpbGRlci5jbGVhckRlZmF1bHQoKTtcblx0fVxuXG5cdHByaXZhdGUgZG9uZSgpIHtcblx0XHR0aGlzLnN0b3J5UGFnZSA9IDA7XG5cdFx0dGhpcy5lbWl0KFwiZG9uZVwiLCB7IHRhcmdldDogdGhpcywgdHlwZTogR2FtZUVsZW1lbnREb25lVHlwZS5GaW5pc2hlZCB9KTtcblx0fVxuXG5cdHByaXZhdGUgb25DbGljaygpIHtcblx0XHR0aGlzLnN0b3J5UGFnZSsrO1xuXHRcdGlmICh0aGlzLnN0b3J5UGFnZSA+PSB0aGlzLnN0b3J5Lmxlbmd0aClcblx0XHRcdHRoaXMuZG9uZSgpO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMucmVuZGVyU3RvcnlQYWdlKCk7XG5cdH1cblxuXHRwcml2YXRlIHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBpZD1cImludHJvXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYmdcIj48L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJjb250ZW50LWhvbGRlclwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZGlhbG9nXCI+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN0b3J5XCI+XG5cdFx0XHRcdFx0XHRcdDxkaXYgcmVmPXtlbHQgPT4gdGhpcy5zdG9yeUVsZW1lbnQgPSBlbHR9PjwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT1cInN1Ym1pdFwiIG9uY2xpY2s9e3RoaXMub25DbGljay5iaW5kKHRoaXMpfT5Db250aW51ZSB0byByZWFkIHRoZSBzdG9yeSE8L2J1dHRvbj5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvU2NlbmVzL0ludHJvL0ludHJvLnRzeCJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///65\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar InterfaceBuilder_1 = __webpack_require__(15);\r\nexports.intro = [\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("h1", null, "SpaceHunt - Episode 1"),\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("h2", null, "Unexpected kidnap"),\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("p", null, "The year 3020 is written, and travel between planets and galaxies is finally becomingcommon, but this fact carries some pitfalls. The technological war between the Earth and theplanet Eslan from a nearby galaxy broke out. During this battle, one of the respectedbiologists, Lucy Mikelson was abducted for unknown reasons. However, the government refusesto take part in any rescue action. Thus, everything remains in the hands of Lucy\'s husbandFreddy Mikelson.")\r\n];\r\nexports.level1 = [\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("h2", null, "Level 1"),\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("p", null, "After a long intergalactic flight, Freddy finally finds himself on the planet Eslan, which, besides the absence of animals, does not any differ from Earth. The landing was not smooth and his first task is to get away from the crown of huge tree in the jungle.")\r\n];\r\nexports.level2 = [\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("h2", null, "Level 2"),\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("p", null, "It seems he has mastered the jungle easily, but the river, which stands in his way now, is full of crocodiles, robotic crocodiles. The kidnapping of Lucy suddenly starts to make sense.")\r\n];\r\nexports.level3 = [\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("h2", null, "Level 3"),\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("p", null, "Local inhabitants detect his presence and they are trying to stop him by rolling and bouncing boulders.")\r\n];\r\nexports.level4 = [\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("h2", null, "Level 4"),\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("p", null, "The exhausted Freddy eventually meets a few Eslans who hold his Lucy and use her knowledge of animals to create their own. However, the Eslans are not very friendly, and Freddy confronts them in the struggle for life and death.")\r\n];\r\nexports.end = [\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("h2", null, "The End!"),\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("p", null, "After long fight, Freddy has handled to save love of his life. Then they have stolen Eslan\'s spaceship to be able to get back to the Earth, where they live happily ever after.")\r\n];\r\nexports.death = [\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("h2", null, "Ooops..."),\r\n    InterfaceBuilder_1.InterfaceBuilder.createElement("p", null, "Such a tragedy! Poor Freddy lost his life within trying to set free love of his life from the hands of the evil Eslans.")\r\n];\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0ludHJvL1N0b3J5LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlEQUEwRDtBQUk3QyxhQUFLLEdBQVc7SUFDNUIsc0ZBQThCO0lBQzlCLGtGQUEwQjtJQUMxQiwyZ0JBQWtkO0NBQ2xkLENBQUM7QUFFVyxjQUFNLEdBQVc7SUFDN0Isd0VBQWdCO0lBQ2hCLG1VQUEwUTtDQUMxUSxDQUFDO0FBRVcsY0FBTSxHQUFXO0lBQzdCLHdFQUFnQjtJQUNoQix3UEFBK0w7Q0FDL0wsQ0FBQztBQUVXLGNBQU0sR0FBVztJQUM3Qix3RUFBZ0I7SUFDaEIsdUtBQThHO0NBQzlHLENBQUM7QUFFVyxjQUFNLEdBQVc7SUFDN0Isd0VBQWdCO0lBQ2hCLG1TQUEwTztDQUMxTyxDQUFDO0FBRVcsV0FBRyxHQUFXO0lBQzFCLHlFQUFpQjtJQUNqQiwrT0FBc0w7Q0FDdEwsQ0FBQztBQUVXLGFBQUssR0FBVztJQUM1Qix5RUFBaUI7SUFDakIsdUxBQThIO0NBQzlILENBQUMiLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlcmZhY2VCdWlsZGVyIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZUJ1aWxkZXJcIjtcblxuZXhwb3J0IHR5cGUgSVN0b3J5ID0gSlNYLkVsZW1lbnRbXTtcblxuZXhwb3J0IGNvbnN0IGludHJvOiBJU3RvcnkgPSBbXG5cdDxoMT5TcGFjZUh1bnQgLSBFcGlzb2RlIDE8L2gxPixcblx0PGgyPlVuZXhwZWN0ZWQga2lkbmFwPC9oMj4sXG5cdDxwPlRoZSB5ZWFyIDMwMjAgaXMgd3JpdHRlbiwgYW5kIHRyYXZlbCBiZXR3ZWVuIHBsYW5ldHMgYW5kIGdhbGF4aWVzIGlzIGZpbmFsbHkgYmVjb21pbmdjb21tb24sIGJ1dCB0aGlzIGZhY3QgY2FycmllcyBzb21lIHBpdGZhbGxzLiBUaGUgdGVjaG5vbG9naWNhbCB3YXIgYmV0d2VlbiB0aGUgRWFydGggYW5kIHRoZXBsYW5ldCBFc2xhbiBmcm9tIGEgbmVhcmJ5IGdhbGF4eSBicm9rZSBvdXQuIER1cmluZyB0aGlzIGJhdHRsZSwgb25lIG9mIHRoZSByZXNwZWN0ZWRiaW9sb2dpc3RzLCBMdWN5IE1pa2Vsc29uIHdhcyBhYmR1Y3RlZCBmb3IgdW5rbm93biByZWFzb25zLiBIb3dldmVyLCB0aGUgZ292ZXJubWVudCByZWZ1c2VzdG8gdGFrZSBwYXJ0IGluIGFueSByZXNjdWUgYWN0aW9uLiBUaHVzLCBldmVyeXRoaW5nIHJlbWFpbnMgaW4gdGhlIGhhbmRzIG9mIEx1Y3kncyBodXNiYW5kRnJlZGR5IE1pa2Vsc29uLjwvcD5cbl07XG5cbmV4cG9ydCBjb25zdCBsZXZlbDE6IElTdG9yeSA9IFtcblx0PGgyPkxldmVsIDE8L2gyPixcblx0PHA+QWZ0ZXIgYSBsb25nIGludGVyZ2FsYWN0aWMgZmxpZ2h0LCBGcmVkZHkgZmluYWxseSBmaW5kcyBoaW1zZWxmIG9uIHRoZSBwbGFuZXQgRXNsYW4sIHdoaWNoLCBiZXNpZGVzIHRoZSBhYnNlbmNlIG9mIGFuaW1hbHMsIGRvZXMgbm90IGFueSBkaWZmZXIgZnJvbSBFYXJ0aC4gVGhlIGxhbmRpbmcgd2FzIG5vdCBzbW9vdGggYW5kIGhpcyBmaXJzdCB0YXNrIGlzIHRvIGdldCBhd2F5IGZyb20gdGhlIGNyb3duIG9mIGh1Z2UgdHJlZSBpbiB0aGUganVuZ2xlLjwvcD5cbl07XG5cbmV4cG9ydCBjb25zdCBsZXZlbDI6IElTdG9yeSA9IFtcblx0PGgyPkxldmVsIDI8L2gyPixcblx0PHA+SXQgc2VlbXMgaGUgaGFzIG1hc3RlcmVkIHRoZSBqdW5nbGUgZWFzaWx5LCBidXQgdGhlIHJpdmVyLCB3aGljaCBzdGFuZHMgaW4gaGlzIHdheSBub3csIGlzIGZ1bGwgb2YgY3JvY29kaWxlcywgcm9ib3RpYyBjcm9jb2RpbGVzLiBUaGUga2lkbmFwcGluZyBvZiBMdWN5IHN1ZGRlbmx5IHN0YXJ0cyB0byBtYWtlIHNlbnNlLjwvcD5cbl07XG5cbmV4cG9ydCBjb25zdCBsZXZlbDM6IElTdG9yeSA9IFtcblx0PGgyPkxldmVsIDM8L2gyPixcblx0PHA+TG9jYWwgaW5oYWJpdGFudHMgZGV0ZWN0IGhpcyBwcmVzZW5jZSBhbmQgdGhleSBhcmUgdHJ5aW5nIHRvIHN0b3AgaGltIGJ5IHJvbGxpbmcgYW5kIGJvdW5jaW5nIGJvdWxkZXJzLjwvcD5cbl07XG5cbmV4cG9ydCBjb25zdCBsZXZlbDQ6IElTdG9yeSA9IFtcblx0PGgyPkxldmVsIDQ8L2gyPixcblx0PHA+VGhlIGV4aGF1c3RlZCBGcmVkZHkgZXZlbnR1YWxseSBtZWV0cyBhIGZldyBFc2xhbnMgd2hvIGhvbGQgaGlzIEx1Y3kgYW5kIHVzZSBoZXIga25vd2xlZGdlIG9mIGFuaW1hbHMgdG8gY3JlYXRlIHRoZWlyIG93bi4gSG93ZXZlciwgdGhlIEVzbGFucyBhcmUgbm90IHZlcnkgZnJpZW5kbHksIGFuZCBGcmVkZHkgY29uZnJvbnRzIHRoZW0gaW4gdGhlIHN0cnVnZ2xlIGZvciBsaWZlIGFuZCBkZWF0aC48L3A+XG5dO1xuXG5leHBvcnQgY29uc3QgZW5kOiBJU3RvcnkgPSBbXG5cdDxoMj5UaGUgRW5kITwvaDI+LFxuXHQ8cD5BZnRlciBsb25nIGZpZ2h0LCBGcmVkZHkgaGFzIGhhbmRsZWQgdG8gc2F2ZSBsb3ZlIG9mIGhpcyBsaWZlLiBUaGVuIHRoZXkgaGF2ZSBzdG9sZW4gRXNsYW4ncyBzcGFjZXNoaXAgdG8gYmUgYWJsZSB0byBnZXQgYmFjayB0byB0aGUgRWFydGgsIHdoZXJlIHRoZXkgbGl2ZSBoYXBwaWx5IGV2ZXIgYWZ0ZXIuPC9wPlxuXTtcblxuZXhwb3J0IGNvbnN0IGRlYXRoOiBJU3RvcnkgPSBbXG5cdDxoMj5Pb29wcy4uLjwvaDI+LFxuXHQ8cD5TdWNoIGEgdHJhZ2VkeSEgUG9vciBGcmVkZHkgbG9zdCBoaXMgbGlmZSB3aXRoaW4gdHJ5aW5nIHRvIHNldCBmcmVlIGxvdmUgb2YgaGlzIGxpZmUgZnJvbSB0aGUgaGFuZHMgb2YgdGhlIGV2aWwgRXNsYW5zLjwvcD5cbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvSW50cm8vU3RvcnkudHN4Il0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///66\n')},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0ludHJvL3N0eWxlLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29kZS9zcmMvU2NlbmVzL0ludHJvL3N0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///67\n")},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Class_1 = __webpack_require__(5);\r\nvar LockLevelCameraStrategy_1 = __webpack_require__(16);\r\nvar Ground_1 = __webpack_require__(44);\r\nvar Player_1 = __webpack_require__(70);\r\nvar MovementTestLevel = /** @class */ (function (_super) {\r\n    __extends(MovementTestLevel, _super);\r\n    function MovementTestLevel(bootstrap) {\r\n        var _this = _super.call(this) || this;\r\n        _this.sceneKey = "movementtestlevel";\r\n        _this.levelBounds = new ex.BoundingBox(0, 0, 5000);\r\n        _this.buildScene = function () {\r\n            _this.scene.add(_this.ground);\r\n            _this.scene.add(_this.player);\r\n            _this.engine.addScene(_this.sceneKey, _this.scene);\r\n            _this.engine.goToScene(_this.sceneKey);\r\n        };\r\n        _this.engine = bootstrap.engine;\r\n        _this.scene = new ex.Scene(_this.engine);\r\n        _this.bounds = _this.engine.getWorldBounds();\r\n        _this.loader = bootstrap.loader;\r\n        _this.ground = new Ground_1.default(_this.bounds.left + 2500, _this.bounds.bottom - 25);\r\n        _this.player = new Player_1.default(_this.bounds.right / 2, _this.bounds.bottom - 100, _this.levelBounds);\r\n        return _this;\r\n    }\r\n    MovementTestLevel.prototype.init = function (bootstrap) {\r\n        this.registerResources();\r\n    };\r\n    MovementTestLevel.prototype.start = function () {\r\n        ex.Physics.acc.setTo(0, 3000);\r\n        this.scene.camera.addStrategy(new ex.LockCameraToActorAxisStrategy(this.player, ex.Axis.X));\r\n        this.scene.camera.addStrategy(new LockLevelCameraStrategy_1.default(this.bounds, this.levelBounds));\r\n        this.buildScene();\r\n    };\r\n    MovementTestLevel.prototype.dispose = function () {\r\n        this.ground.kill();\r\n    };\r\n    MovementTestLevel.prototype.registerResources = function () {\r\n        //\r\n    };\r\n    return MovementTestLevel;\r\n}(Class_1.Class));\r\nexports.default = MovementTestLevel;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL01vdmVtZW50VGVzdExldmVsL01vdmVtZW50VGVzdExldmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGdDQUFnQztBQUNoQyxxQ0FBa0M7QUFDbEMsd0RBQStFO0FBRS9FLHVDQUE2QztBQUM3Qyx1Q0FBOEI7QUFFOUI7SUFBK0MscUNBQXlCO0lBWXZFLDJCQUFZLFNBQXdCO1FBQXBDLFlBQ0MsaUJBQU8sU0FTUDtRQXBCUSxjQUFRLEdBQVcsbUJBQW1CLENBQUM7UUFDdkMsaUJBQVcsR0FBbUIsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUF3QzlELGdCQUFVLEdBQUc7WUFDcEIsS0FBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzVCLEtBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM1QixLQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFJLENBQUMsUUFBUSxFQUFFLEtBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNoRCxLQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdEMsQ0FBQztRQWpDQSxLQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUM7UUFDL0IsS0FBSSxDQUFDLEtBQUssR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3ZDLEtBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUMzQyxLQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUM7UUFFL0IsS0FBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGdCQUFNLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxFQUFFLEtBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQzNFLEtBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxnQkFBTSxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUUsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDOztJQUM3RixDQUFDO0lBRUQsZ0NBQUksR0FBSixVQUFLLFNBQXdCO1FBQzVCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRCxpQ0FBSyxHQUFMO1FBQ0MsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsNkJBQTZCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUYsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksaUNBQXVCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUMxRixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVELG1DQUFPLEdBQVA7UUFDQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3BCLENBQUM7SUFFTyw2Q0FBaUIsR0FBekI7UUFDQyxFQUFFO0lBQ0gsQ0FBQztJQVFGLHdCQUFDO0FBQUQsQ0FBQyxDQWpEOEMsYUFBSyxHQWlEbkQiLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XHJcbmltcG9ydCB7Q2xhc3N9IGZyb20gXCIuLi8uLi9DbGFzc1wiO1xyXG5pbXBvcnQgTG9ja0xldmVsQ2FtZXJhU3RyYXRlZ3kgZnJvbSBcIi4uLy4uL0NvbXBvbmVudHMvTG9ja0xldmVsQ2FtZXJhU3RyYXRlZ3lcIjtcclxuaW1wb3J0IHtHYW1lQm9vdHN0cmFwLCBJR2FtZUVsZW1lbnQsIElHYW1lRWxlbWVudEV2ZW50c30gZnJvbSBcIi4uLy4uL0dhbWVCb290c3RyYXBcIjtcclxuaW1wb3J0IEdyb3VuZCBmcm9tIFwiLi4vLi4vQ29tcG9uZW50cy9Hcm91bmRcIjtcclxuaW1wb3J0IFBsYXllciBmcm9tIFwiLi9QbGF5ZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vdmVtZW50VGVzdExldmVsIGV4dGVuZHMgQ2xhc3M8SUdhbWVFbGVtZW50RXZlbnRzPiBpbXBsZW1lbnRzIElHYW1lRWxlbWVudCB7XHJcblxyXG5cdHJlYWRvbmx5IHNjZW5lS2V5OiBzdHJpbmcgPSBcIm1vdmVtZW50dGVzdGxldmVsXCI7XHJcblx0cmVhZG9ubHkgbGV2ZWxCb3VuZHM6IGV4LkJvdW5kaW5nQm94ID0gbmV3IGV4LkJvdW5kaW5nQm94KDAsIDAsIDUwMDApO1xyXG5cclxuXHRlbmdpbmU6IGV4LkVuZ2luZTtcclxuXHRzY2VuZTogZXguU2NlbmU7XHJcblx0Ym91bmRzOiBleC5Cb3VuZGluZ0JveDtcclxuXHRncm91bmQ6IEdyb3VuZDtcclxuXHRwbGF5ZXI6IFBsYXllcjtcclxuXHRsb2FkZXI6IGV4LkxvYWRlcjtcclxuXHJcblx0Y29uc3RydWN0b3IoYm9vdHN0cmFwOiBHYW1lQm9vdHN0cmFwKSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0XHJcblx0XHR0aGlzLmVuZ2luZSA9IGJvb3RzdHJhcC5lbmdpbmU7XHJcblx0XHR0aGlzLnNjZW5lID0gbmV3IGV4LlNjZW5lKHRoaXMuZW5naW5lKTtcclxuXHRcdHRoaXMuYm91bmRzID0gdGhpcy5lbmdpbmUuZ2V0V29ybGRCb3VuZHMoKTtcclxuXHRcdHRoaXMubG9hZGVyID0gYm9vdHN0cmFwLmxvYWRlcjtcclxuXHJcblx0XHR0aGlzLmdyb3VuZCA9IG5ldyBHcm91bmQodGhpcy5ib3VuZHMubGVmdCArIDI1MDAsIHRoaXMuYm91bmRzLmJvdHRvbSAtIDI1KTtcclxuXHRcdHRoaXMucGxheWVyID0gbmV3IFBsYXllcih0aGlzLmJvdW5kcy5yaWdodCAvIDIsIHRoaXMuYm91bmRzLmJvdHRvbSAtIDEwMCwgdGhpcy5sZXZlbEJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHRpbml0KGJvb3RzdHJhcDogR2FtZUJvb3RzdHJhcCk6IHZvaWQge1xyXG5cdFx0dGhpcy5yZWdpc3RlclJlc291cmNlcygpO1xyXG5cdH1cclxuXHJcblx0c3RhcnQoKTogdm9pZCB7XHJcblx0XHRleC5QaHlzaWNzLmFjYy5zZXRUbygwLCAzMDAwKTtcclxuXHRcdHRoaXMuc2NlbmUuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBleC5Mb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneSh0aGlzLnBsYXllciwgZXguQXhpcy5YKSk7XHJcblx0XHR0aGlzLnNjZW5lLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgTG9ja0xldmVsQ2FtZXJhU3RyYXRlZ3kodGhpcy5ib3VuZHMsIHRoaXMubGV2ZWxCb3VuZHMpKTtcclxuXHRcdHRoaXMuYnVpbGRTY2VuZSgpO1xyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpOiB2b2lkIHtcclxuXHRcdHRoaXMuZ3JvdW5kLmtpbGwoKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVnaXN0ZXJSZXNvdXJjZXMoKSB7XHJcblx0XHQvL1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBidWlsZFNjZW5lID0gKCkgPT4ge1xyXG5cdFx0dGhpcy5zY2VuZS5hZGQodGhpcy5ncm91bmQpO1xyXG5cdFx0dGhpcy5zY2VuZS5hZGQodGhpcy5wbGF5ZXIpO1xyXG5cdFx0dGhpcy5lbmdpbmUuYWRkU2NlbmUodGhpcy5zY2VuZUtleSwgdGhpcy5zY2VuZSk7XHJcblx0XHR0aGlzLmVuZ2luZS5nb1RvU2NlbmUodGhpcy5zY2VuZUtleSk7XHJcblx0fVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9Nb3ZlbWVudFRlc3RMZXZlbC9Nb3ZlbWVudFRlc3RMZXZlbC50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///68\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "assets/2af60af4b4d8ec99f8051ccb1a1f108b.jpg";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL01vdmVtZW50VGVzdExldmVsL2JyaWNrLmpwZyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI2OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy8yYWY2MGFmNGI0ZDhlYzk5ZjgwNTFjY2IxYTFmMTA4Yi5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9Nb3ZlbWVudFRlc3RMZXZlbC9icmljay5qcGdcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///69\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar BasePlayer_1 = __webpack_require__(23);\r\nvar Player = /** @class */ (function (_super) {\r\n    __extends(Player, _super);\r\n    function Player(x, y, levelBounds) {\r\n        var _this = _super.call(this, x, y) || this;\r\n        _this.ducked = false;\r\n        _this.minX = levelBounds.left + Player.size.w / 2;\r\n        _this.maxX = levelBounds.right - Player.size.w / 2;\r\n        _this.anchor.setTo(0.5, 1);\r\n        _this.body.useBoxCollision();\r\n        _this.y += _this.getHeight() / 2;\r\n        return _this;\r\n    }\r\n    Player.prototype.update = function (engine, delta) {\r\n        _super.prototype.update.call(this, engine, delta);\r\n        if (engine.input.keyboard.wasPressed(ex.Input.Keys.Space)) {\r\n            this.jump();\r\n        }\r\n        if (engine.input.keyboard.isHeld(ex.Input.Keys.Left)) {\r\n            this.goLeft();\r\n        }\r\n        if (engine.input.keyboard.isHeld(ex.Input.Keys.Right)) {\r\n            this.goRight();\r\n        }\r\n        if (engine.input.keyboard.wasPressed(ex.Input.Keys.D)) {\r\n            this.duck();\r\n        }\r\n        if (engine.input.keyboard.wasReleased(ex.Input.Keys.D)) {\r\n            this.unDuck();\r\n        }\r\n    };\r\n    Player.prototype.jump = function () {\r\n        var groundLevel = this.scene.engine.getWorldBounds().bottom - 50;\r\n        if (groundLevel - this.getBottom() < 15) {\r\n            this.vel.setTo(this.vel.x, -1000);\r\n            console.log(this.vel);\r\n        }\r\n    };\r\n    Player.prototype.goLeft = function () {\r\n        this.pos.x -= Player.speed;\r\n        this.pos.x = this.pos.x < this.minX ? this.minX : this.pos.x;\r\n    };\r\n    Player.prototype.goRight = function () {\r\n        this.pos.x += Player.speed;\r\n        this.pos.x = this.pos.x > this.maxX ? this.maxX : this.pos.x;\r\n    };\r\n    Player.prototype.duck = function () {\r\n        if (this.ducked)\r\n            return; // already ducked\r\n        this.ducked = true;\r\n        this.setHeight(this.getHeight() / 2);\r\n        this.collisionArea.body.useBoxCollision();\r\n    };\r\n    Player.prototype.unDuck = function () {\r\n        if (!this.ducked)\r\n            return; // already ducked\r\n        this.ducked = false;\r\n        this.setHeight(this.getHeight() * 2);\r\n        this.collisionArea.body.useBoxCollision();\r\n    };\r\n    Player.speed = 8;\r\n    return Player;\r\n}(BasePlayer_1.default));\r\nexports.default = Player;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL01vdmVtZW50VGVzdExldmVsL1BsYXllci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxnQ0FBZ0M7QUFDaEMsMkNBQXFEO0FBR3JEO0lBQW9DLDBCQUFVO0lBTTdDLGdCQUFZLENBQVMsRUFBRSxDQUFTLEVBQUUsV0FBMkI7UUFBN0QsWUFDQyxrQkFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBTVg7UUFUTyxZQUFNLEdBQVksS0FBSyxDQUFDO1FBSS9CLEtBQUksQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakQsS0FBSSxDQUFDLElBQUksR0FBRyxXQUFXLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsRCxLQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDMUIsS0FBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUM1QixLQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7O0lBQ2hDLENBQUM7SUFFRCx1QkFBTSxHQUFOLFVBQU8sTUFBaUIsRUFBRSxLQUFhO1FBQ3RDLGlCQUFNLE1BQU0sWUFBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFNUIsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzRCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDYixDQUFDO1FBRUQsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0RCxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDZixDQUFDO1FBRUQsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2RCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDaEIsQ0FBQztRQUVELEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDeEQsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2YsQ0FBQztJQUNGLENBQUM7SUFFTyxxQkFBSSxHQUFaO1FBQ0MsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUVqRSxFQUFFLENBQUMsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QixDQUFDO0lBQ0YsQ0FBQztJQUVPLHVCQUFNLEdBQWQ7UUFDQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQzNCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFTyx3QkFBTyxHQUFmO1FBQ0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQztRQUMzQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRU8scUJBQUksR0FBWjtRQUNDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDZixNQUFNLENBQUMsQ0FBQyxpQkFBaUI7UUFDMUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDM0MsQ0FBQztJQUVPLHVCQUFNLEdBQWQ7UUFDQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDaEIsTUFBTSxDQUFDLENBQUMsaUJBQWlCO1FBQzFCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQzNDLENBQUM7SUF0RWUsWUFBSyxHQUFXLENBQUMsQ0FBQztJQXdFbkMsYUFBQztDQUFBLENBekVtQyxvQkFBVSxHQXlFN0M7a0JBekVvQixNQUFNIiwiZmlsZSI6IjcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZXggZnJvbSBcImV4Y2FsaWJ1clwiO1xyXG5pbXBvcnQgQmFzZVBsYXllciBmcm9tIFwiLi4vLi4vQ29tcG9uZW50cy9CYXNlUGxheWVyXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyIGV4dGVuZHMgQmFzZVBsYXllciB7XHJcblx0c3RhdGljIHJlYWRvbmx5IHNwZWVkOiBudW1iZXIgPSA4O1xyXG5cdHByaXZhdGUgbWluWDogbnVtYmVyO1xyXG5cdHByaXZhdGUgbWF4WDogbnVtYmVyO1xyXG5cdHByaXZhdGUgZHVja2VkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHg6IG51bWJlciwgeTogbnVtYmVyLCBsZXZlbEJvdW5kczogZXguQm91bmRpbmdCb3gpIHtcclxuXHRcdHN1cGVyKHgsIHkpO1xyXG5cdFx0dGhpcy5taW5YID0gbGV2ZWxCb3VuZHMubGVmdCArIFBsYXllci5zaXplLncgLyAyO1xyXG5cdFx0dGhpcy5tYXhYID0gbGV2ZWxCb3VuZHMucmlnaHQgLSBQbGF5ZXIuc2l6ZS53IC8gMjtcclxuXHRcdHRoaXMuYW5jaG9yLnNldFRvKDAuNSwgMSk7XHJcblx0XHR0aGlzLmJvZHkudXNlQm94Q29sbGlzaW9uKCk7XHJcblx0XHR0aGlzLnkgKz0gdGhpcy5nZXRIZWlnaHQoKSAvIDI7XHJcblx0fVxyXG5cclxuXHR1cGRhdGUoZW5naW5lOiBleC5FbmdpbmUsIGRlbHRhOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuXHJcblx0XHRpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLndhc1ByZXNzZWQoZXguSW5wdXQuS2V5cy5TcGFjZSkpIHtcclxuXHRcdFx0dGhpcy5qdW1wKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGVuZ2luZS5pbnB1dC5rZXlib2FyZC5pc0hlbGQoZXguSW5wdXQuS2V5cy5MZWZ0KSkge1xyXG5cdFx0XHR0aGlzLmdvTGVmdCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQuaXNIZWxkKGV4LklucHV0LktleXMuUmlnaHQpKSB7XHJcblx0XHRcdHRoaXMuZ29SaWdodCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQud2FzUHJlc3NlZChleC5JbnB1dC5LZXlzLkQpKSB7XHJcblx0XHRcdHRoaXMuZHVjaygpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGVuZ2luZS5pbnB1dC5rZXlib2FyZC53YXNSZWxlYXNlZChleC5JbnB1dC5LZXlzLkQpKSB7XHJcblx0XHRcdHRoaXMudW5EdWNrKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGp1bXAoKSB7XHJcblx0XHRsZXQgZ3JvdW5kTGV2ZWwgPSB0aGlzLnNjZW5lLmVuZ2luZS5nZXRXb3JsZEJvdW5kcygpLmJvdHRvbSAtIDUwO1xyXG5cclxuXHRcdGlmIChncm91bmRMZXZlbCAtIHRoaXMuZ2V0Qm90dG9tKCkgPCAxNSkge1xyXG5cdFx0XHR0aGlzLnZlbC5zZXRUbyh0aGlzLnZlbC54LCAtMTAwMCk7XHJcblx0XHRcdGNvbnNvbGUubG9nKHRoaXMudmVsKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgZ29MZWZ0KCkge1xyXG5cdFx0dGhpcy5wb3MueCAtPSBQbGF5ZXIuc3BlZWQ7XHJcblx0XHR0aGlzLnBvcy54ID0gdGhpcy5wb3MueCA8IHRoaXMubWluWCA/IHRoaXMubWluWCA6IHRoaXMucG9zLng7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGdvUmlnaHQoKSB7XHJcblx0XHR0aGlzLnBvcy54ICs9IFBsYXllci5zcGVlZDtcclxuXHRcdHRoaXMucG9zLnggPSB0aGlzLnBvcy54ID4gdGhpcy5tYXhYID8gdGhpcy5tYXhYIDogdGhpcy5wb3MueDtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgZHVjaygpIHtcclxuXHRcdGlmICh0aGlzLmR1Y2tlZClcclxuXHRcdFx0cmV0dXJuOyAvLyBhbHJlYWR5IGR1Y2tlZFxyXG5cdFx0dGhpcy5kdWNrZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5zZXRIZWlnaHQodGhpcy5nZXRIZWlnaHQoKSAvIDIpO1xyXG5cdFx0dGhpcy5jb2xsaXNpb25BcmVhLmJvZHkudXNlQm94Q29sbGlzaW9uKCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHVuRHVjaygpIHtcclxuXHRcdGlmICghdGhpcy5kdWNrZWQpXHJcblx0XHRcdHJldHVybjsgLy8gYWxyZWFkeSBkdWNrZWRcclxuXHRcdHRoaXMuZHVja2VkID0gZmFsc2U7XHJcblx0XHR0aGlzLnNldEhlaWdodCh0aGlzLmdldEhlaWdodCgpICogMik7XHJcblx0XHR0aGlzLmNvbGxpc2lvbkFyZWEuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcclxuXHR9XHJcblxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9Nb3ZlbWVudFRlc3RMZXZlbC9QbGF5ZXIudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///70\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar Class_1 = __webpack_require__(5);\r\nvar StateListener = /** @class */ (function (_super) {\r\n    __extends(StateListener, _super);\r\n    function StateListener(initialState) {\r\n        var _this = _super.call(this) || this;\r\n        _this.internalState = initialState;\r\n        return _this;\r\n    }\r\n    StateListener.prototype.emitEvent = function (e) {\r\n        this.emit(e.key, e);\r\n        this.emit("$all", e);\r\n    };\r\n    StateListener.prototype.createListenableObject = function () {\r\n        var _this = this;\r\n        var state = {};\r\n        Object.keys(this.internalState).forEach(function (t) {\r\n            var key = t;\r\n            Object.defineProperty(state, key, {\r\n                get: function () { return _this.internalState[key]; },\r\n                set: function (newValue) {\r\n                    var oldValue = _this.internalState[key];\r\n                    _this.internalState[key] = newValue;\r\n                    _this.emitEvent({\r\n                        target: state,\r\n                        oldValue: oldValue,\r\n                        newValue: newValue,\r\n                        key: key\r\n                    });\r\n                },\r\n                enumerable: true,\r\n                configurable: false,\r\n            });\r\n        });\r\n        return state;\r\n    };\r\n    return StateListener;\r\n}(Class_1.Class));\r\nexports.default = StateListener;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvQ29tcG9uZW50cy9TdGF0ZUxpc3RlbmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUNBLHFDQUFpQztBQW9CakM7SUFBOEMsaUNBQThCO0lBSTNFLHVCQUFZLFlBQWU7UUFBM0IsWUFDQyxpQkFBTyxTQUVQO1FBREEsS0FBSSxDQUFDLGFBQWEsR0FBRyxZQUFZLENBQUM7O0lBQ25DLENBQUM7SUFFTyxpQ0FBUyxHQUFqQixVQUFrQixDQUF3QjtRQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFVLEVBQUUsQ0FBUSxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVELDhDQUFzQixHQUF0QjtRQUFBLGlCQXFCQztRQXBCQSxJQUFNLEtBQUssR0FBRyxFQUFPLENBQUM7UUFDdEIsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsT0FBTyxDQUFDLFdBQUM7WUFDeEMsSUFBTSxHQUFHLEdBQUcsQ0FBWSxDQUFDO1lBQ3pCLE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRTtnQkFDakMsR0FBRyxFQUFFLGNBQU0sWUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsRUFBdkIsQ0FBdUI7Z0JBQ2xDLEdBQUcsRUFBRSxVQUFDLFFBQW9CO29CQUN6QixJQUFNLFFBQVEsR0FBRyxLQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN6QyxLQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQztvQkFDbkMsS0FBSSxDQUFDLFNBQVMsQ0FBQzt3QkFDZCxNQUFNLEVBQUUsS0FBSzt3QkFDYixRQUFRO3dCQUNSLFFBQVE7d0JBQ1IsR0FBRztxQkFDSCxDQUFDLENBQUM7Z0JBQ0osQ0FBQztnQkFDRCxVQUFVLEVBQUUsSUFBSTtnQkFDaEIsWUFBWSxFQUFFLEtBQUs7YUFDbkIsQ0FBQyxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2QsQ0FBQztJQUVGLG9CQUFDO0FBQUQsQ0FBQyxDQXJDNkMsYUFBSyxHQXFDbEQiLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHYW1lRXZlbnQgfSBmcm9tIFwiZXhjYWxpYnVyXCI7XG5pbXBvcnQgeyBDbGFzcyB9IGZyb20gXCIuLi9DbGFzc1wiO1xuXG5pbnRlcmZhY2UgSVN0YXRpY1N0YXRlQ2hhbmdlZEV2ZW50PFQsIEsgZXh0ZW5kcyBrZXlvZiBUID0ga2V5b2YgVD4gZXh0ZW5kcyBHYW1lRXZlbnQ8VD4ge1xuXHRrZXk6IEs7XG5cdG9sZFZhbHVlOiBUW0tdO1xuXHRuZXdWYWx1ZTogVFtLXTtcbn1cblxudHlwZSBJU3RhdGVDaGFuZ2VkRXZlbnQ8VCwgSyBleHRlbmRzIGtleW9mIElTdGF0ZUxpc3RlbmVyRXZlbnRzPFQ+ID0ga2V5b2YgSVN0YXRlTGlzdGVuZXJFdmVudHM8VD4+ID0gSVN0YXRlTGlzdGVuZXJFdmVudHM8VD5bS107XG5cbnR5cGUgSVN0YXRlRXZlbnRzPFQ+ID0ge1xuXHRbSyBpbiBrZXlvZiBUXTogSVN0YXRpY1N0YXRlQ2hhbmdlZEV2ZW50PFQsIEs+O1xufTtcblxuaW50ZXJmYWNlIElBZGRpdGlvbmFsSGFuZGxlcnM8VD4ge1xuXHRcIiRhbGxcIjogSVN0YXRpY1N0YXRlQ2hhbmdlZEV2ZW50PFQsIGtleW9mIFQ+O1xufVxuXG5leHBvcnQgdHlwZSBJU3RhdGVMaXN0ZW5lckV2ZW50czxUPiA9IElTdGF0ZUV2ZW50czxUPiAmIElBZGRpdGlvbmFsSGFuZGxlcnM8VD47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlTGlzdGVuZXI8VD4gZXh0ZW5kcyBDbGFzczxJU3RhdGVMaXN0ZW5lckV2ZW50czxUPj4ge1xuXG5cdHByaXZhdGUgaW50ZXJuYWxTdGF0ZTogVDtcblxuXHRjb25zdHJ1Y3Rvcihpbml0aWFsU3RhdGU6IFQpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaW50ZXJuYWxTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcblx0fVxuXG5cdHByaXZhdGUgZW1pdEV2ZW50KGU6IElTdGF0ZUNoYW5nZWRFdmVudDxUPikge1xuXHRcdHRoaXMuZW1pdChlLmtleSBhcyBhbnksIGUgYXMgYW55KTtcblx0XHR0aGlzLmVtaXQoXCIkYWxsXCIsIGUgYXMgYW55KTtcblx0fVxuXG5cdGNyZWF0ZUxpc3RlbmFibGVPYmplY3QoKTogVCB7XG5cdFx0Y29uc3Qgc3RhdGUgPSB7fSBhcyBUO1xuXHRcdE9iamVjdC5rZXlzKHRoaXMuaW50ZXJuYWxTdGF0ZSkuZm9yRWFjaCh0ID0+IHtcblx0XHRcdGNvbnN0IGtleSA9IHQgYXMga2V5b2YgVDtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdGF0ZSwga2V5LCB7XG5cdFx0XHRcdGdldDogKCkgPT4gdGhpcy5pbnRlcm5hbFN0YXRlW2tleV0sXG5cdFx0XHRcdHNldDogKG5ld1ZhbHVlOiBUW2tleW9mIFRdKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgb2xkVmFsdWUgPSB0aGlzLmludGVybmFsU3RhdGVba2V5XTtcblx0XHRcdFx0XHR0aGlzLmludGVybmFsU3RhdGVba2V5XSA9IG5ld1ZhbHVlO1xuXHRcdFx0XHRcdHRoaXMuZW1pdEV2ZW50KHtcblx0XHRcdFx0XHRcdHRhcmdldDogc3RhdGUsXG5cdFx0XHRcdFx0XHRvbGRWYWx1ZSxcblx0XHRcdFx0XHRcdG5ld1ZhbHVlLFxuXHRcdFx0XHRcdFx0a2V5XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvQ29tcG9uZW50cy9TdGF0ZUxpc3RlbmVyLnRzIl0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///71\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Class_1 = __webpack_require__(5);\r\nvar GameBootstrap_1 = __webpack_require__(14);\r\nvar LockLevelCameraStrategy_1 = __webpack_require__(16);\r\nvar Arrow_1 = __webpack_require__(73);\r\nvar Ground_1 = __webpack_require__(44);\r\nvar Player_1 = __webpack_require__(75);\r\nvar TreeBranch_1 = __webpack_require__(76);\r\nvar VineCreator_1 = __webpack_require__(77);\r\nvar Level1 = /** @class */ (function (_super) {\r\n    __extends(Level1, _super);\r\n    function Level1(bootstrap) {\r\n        var _this = _super.call(this) || this;\r\n        _this.sceneKey = "level1";\r\n        _this.levelBounds = new ex.BoundingBox(0, 0, 5000);\r\n        _this.player = null;\r\n        _this.win = function () {\r\n            alert("You won!");\r\n            _this.player.off("won");\r\n            _this.emit("done", {\r\n                target: _this,\r\n                type: GameBootstrap_1.GameElementDoneType.Finished\r\n            });\r\n        };\r\n        _this.lose = function () {\r\n            alert("You fell down and died");\r\n            _this.player.off("fell");\r\n            _this.emit("done", {\r\n                target: _this,\r\n                type: GameBootstrap_1.GameElementDoneType.Aborted\r\n            });\r\n        };\r\n        _this.buildScene = function () {\r\n            var vines = _this.vineCreator.createVines();\r\n            for (var _i = 0, vines_1 = vines; _i < vines_1.length; _i++) {\r\n                var vine = vines_1[_i];\r\n                for (var _a = 0, _b = vine.getAllParts(); _a < _b.length; _a++) {\r\n                    var vinePart = _b[_a];\r\n                    _this.scene.add(vinePart);\r\n                }\r\n            }\r\n            _this.scene.add(_this.ground);\r\n            _this.scene.add(_this.treeBranch);\r\n            _this.scene.add(_this.player);\r\n            _this.scene.add(_this.arrow);\r\n            _this.arrow.z = -1;\r\n            _this.engine.addScene(_this.sceneKey, _this.scene);\r\n            _this.engine.goToScene(_this.sceneKey);\r\n        };\r\n        _this.engine = bootstrap.engine;\r\n        _this.scene = new ex.Scene(_this.engine);\r\n        _this.bounds = _this.engine.getWorldBounds();\r\n        _this.loader = bootstrap.loader;\r\n        _this.ground = new Ground_1.default(_this.bounds.left + 2500, _this.bounds.bottom - 25);\r\n        _this.vineCreator = new VineCreator_1.default(_this.levelBounds.right - 400, _this.levelBounds.left + 50);\r\n        _this.treeBranch = new TreeBranch_1.default(_this.levelBounds.right - TreeBranch_1.default.branchLength / 2, _this.levelBounds.top + 250);\r\n        _this.arrow = new Arrow_1.default(_this.levelBounds.left + 200, _this.levelBounds.top + 200);\r\n        return _this;\r\n    }\r\n    Level1.prototype.init = function (bootstrap) {\r\n        this.registerResources();\r\n    };\r\n    Level1.prototype.start = function () {\r\n        this.player = new Player_1.default(this.levelBounds.right - 100, this.levelBounds.top + 199);\r\n        this.player.on("fell", this.lose);\r\n        this.player.on("won", this.win);\r\n        ex.Physics.acc.setTo(0, 2000);\r\n        this.scene.camera.addStrategy(this.player.cameraStrategy);\r\n        this.scene.camera.addStrategy(new LockLevelCameraStrategy_1.default(this.bounds, this.levelBounds));\r\n        this.buildScene();\r\n    };\r\n    Level1.prototype.dispose = function () {\r\n        for (var _i = 0, _a = this.scene.actors; _i < _a.length; _i++) {\r\n            var actor = _a[_i];\r\n            actor.kill();\r\n        }\r\n    };\r\n    Level1.prototype.registerResources = function () {\r\n        this.loader.addResources(Ground_1.default.resources);\r\n        this.loader.addResources(Arrow_1.default.resources);\r\n    };\r\n    return Level1;\r\n}(Class_1.Class));\r\nexports.default = Level1;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9MZXZlbDEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLHFDQUFrQztBQUNsQyw4Q0FBeUc7QUFDekcsd0RBQStFO0FBQy9FLHNDQUE0QjtBQUM1Qix1Q0FBNkM7QUFDN0MsdUNBQW9DO0FBQ3BDLDJDQUFzQztBQUN0Qyw0Q0FBd0M7QUFHeEM7SUFBb0MsMEJBQXlCO0lBZTVELGdCQUFZLFNBQXdCO1FBQXBDLFlBQ0MsaUJBQU8sU0FVUDtRQXhCUSxjQUFRLEdBQVcsUUFBUSxDQUFDO1FBQzVCLGlCQUFXLEdBQW1CLElBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBT3RFLFlBQU0sR0FBdUIsSUFBSSxDQUFDO1FBc0NsQyxTQUFHLEdBQUc7WUFDTCxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbEIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdkIsS0FBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ2pCLE1BQU0sRUFBRSxLQUFJO2dCQUNaLElBQUksRUFBRSxtQ0FBbUIsQ0FBQyxRQUFRO2FBQ2xDLENBQUMsQ0FBQztRQUNKLENBQUM7UUFFRCxVQUFJLEdBQUc7WUFDTixLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQztZQUNoQyxLQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUN4QixLQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDakIsTUFBTSxFQUFFLEtBQUk7Z0JBQ1osSUFBSSxFQUFFLG1DQUFtQixDQUFDLE9BQU87YUFDakMsQ0FBQyxDQUFDO1FBQ0osQ0FBQztRQU9PLGdCQUFVLEdBQUc7WUFDcEIsSUFBSSxLQUFLLEdBQUcsS0FBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUUzQyxHQUFHLEVBQWEsVUFBSyxFQUFMLGVBQUssRUFBTCxtQkFBSyxFQUFMLElBQUs7Z0JBQWpCLElBQUksSUFBSTtnQkFDWCxHQUFHLEVBQWlCLFVBQWtCLEVBQWxCLFNBQUksQ0FBQyxXQUFXLEVBQUUsRUFBbEIsY0FBa0IsRUFBbEIsSUFBa0I7b0JBQWxDLElBQUksUUFBUTtvQkFDZixLQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDekI7YUFDRDtZQUVELEtBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM1QixLQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDaEMsS0FBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzVCLEtBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMzQixLQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUVsQixLQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFJLENBQUMsUUFBUSxFQUFFLEtBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNoRCxLQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdEMsQ0FBQztRQXZFQSxLQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUM7UUFDL0IsS0FBSSxDQUFDLEtBQUssR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3ZDLEtBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUMzQyxLQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUM7UUFDL0IsS0FBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGdCQUFNLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxFQUFFLEtBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQzNFLEtBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxxQkFBVyxDQUFDLEtBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxHQUFHLEdBQUcsRUFBRSxLQUFJLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQztRQUM3RixLQUFJLENBQUMsVUFBVSxHQUFHLElBQUksb0JBQVUsQ0FDL0IsS0FBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEdBQUcsb0JBQVUsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxFQUFFLEtBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ25GLEtBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxlQUFLLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxFQUFFLEtBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDOztJQUNqRixDQUFDO0lBRUQscUJBQUksR0FBSixVQUFLLFNBQXdCO1FBQzVCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRCxzQkFBSyxHQUFMO1FBQ0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGdCQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ3pGLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoQyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzFELElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGlDQUF1QixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFDMUYsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRCx3QkFBTyxHQUFQO1FBQ0MsR0FBRyxFQUFjLFVBQWlCLEVBQWpCLFNBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFqQixjQUFpQixFQUFqQixJQUFpQjtZQUE5QixJQUFJLEtBQUs7WUFDWixLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDYjtJQUNGLENBQUM7SUFvQk8sa0NBQWlCLEdBQXpCO1FBQ0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsZ0JBQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMzQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxlQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQW9CRixhQUFDO0FBQUQsQ0FBQyxDQXpGbUMsYUFBSyxHQXlGeEMiLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XG5pbXBvcnQge0NsYXNzfSBmcm9tIFwiLi4vLi4vQ2xhc3NcIjtcbmltcG9ydCB7R2FtZUJvb3RzdHJhcCwgR2FtZUVsZW1lbnREb25lVHlwZSwgSUdhbWVFbGVtZW50LCBJR2FtZUVsZW1lbnRFdmVudHN9IGZyb20gXCIuLi8uLi9HYW1lQm9vdHN0cmFwXCI7XG5pbXBvcnQgTG9ja0xldmVsQ2FtZXJhU3RyYXRlZ3kgZnJvbSBcIi4uLy4uL0NvbXBvbmVudHMvTG9ja0xldmVsQ2FtZXJhU3RyYXRlZ3lcIjtcbmltcG9ydCBBcnJvdyBmcm9tIFwiLi9BcnJvd1wiO1xuaW1wb3J0IEdyb3VuZCBmcm9tIFwiLi4vLi4vQ29tcG9uZW50cy9Hcm91bmRcIjtcbmltcG9ydCBMZXZlbDFQbGF5ZXIgZnJvbSBcIi4vUGxheWVyXCI7XG5pbXBvcnQgVHJlZUJyYW5jaCBmcm9tIFwiLi9UcmVlQnJhbmNoXCI7XG5pbXBvcnQgVmluZUNyZWF0b3IgZnJvbSBcIi4vVmluZUNyZWF0b3JcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbDEgZXh0ZW5kcyBDbGFzczxJR2FtZUVsZW1lbnRFdmVudHM+IGltcGxlbWVudHMgSUdhbWVFbGVtZW50IHtcblxuXHRyZWFkb25seSBzY2VuZUtleTogc3RyaW5nID0gXCJsZXZlbDFcIjtcblx0cmVhZG9ubHkgbGV2ZWxCb3VuZHM6IGV4LkJvdW5kaW5nQm94ID0gbmV3IGV4LkJvdW5kaW5nQm94KDAsIDAsIDUwMDApO1xuXG5cdGFycm93OiBBcnJvdztcblx0Ym91bmRzOiBleC5Cb3VuZGluZ0JveDtcblx0ZW5naW5lOiBleC5FbmdpbmU7XG5cdGdyb3VuZDogR3JvdW5kO1xuXHRsb2FkZXI6IGV4LkxvYWRlcjtcblx0cGxheWVyOiBMZXZlbDFQbGF5ZXIgfCBhbnkgPSBudWxsO1xuXHRzY2VuZTogZXguU2NlbmU7XG5cdHRyZWVCcmFuY2g6IFRyZWVCcmFuY2g7XG5cdHZpbmVDcmVhdG9yOiBWaW5lQ3JlYXRvcjtcblxuXHRjb25zdHJ1Y3Rvcihib290c3RyYXA6IEdhbWVCb290c3RyYXApIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuZW5naW5lID0gYm9vdHN0cmFwLmVuZ2luZTtcblx0XHR0aGlzLnNjZW5lID0gbmV3IGV4LlNjZW5lKHRoaXMuZW5naW5lKTtcblx0XHR0aGlzLmJvdW5kcyA9IHRoaXMuZW5naW5lLmdldFdvcmxkQm91bmRzKCk7XG5cdFx0dGhpcy5sb2FkZXIgPSBib290c3RyYXAubG9hZGVyO1xuXHRcdHRoaXMuZ3JvdW5kID0gbmV3IEdyb3VuZCh0aGlzLmJvdW5kcy5sZWZ0ICsgMjUwMCwgdGhpcy5ib3VuZHMuYm90dG9tIC0gMjUpO1xuXHRcdHRoaXMudmluZUNyZWF0b3IgPSBuZXcgVmluZUNyZWF0b3IodGhpcy5sZXZlbEJvdW5kcy5yaWdodCAtIDQwMCwgdGhpcy5sZXZlbEJvdW5kcy5sZWZ0ICsgNTApO1xuXHRcdHRoaXMudHJlZUJyYW5jaCA9IG5ldyBUcmVlQnJhbmNoKFxuXHRcdFx0dGhpcy5sZXZlbEJvdW5kcy5yaWdodCAtIFRyZWVCcmFuY2guYnJhbmNoTGVuZ3RoIC8gMiwgdGhpcy5sZXZlbEJvdW5kcy50b3AgKyAyNTApO1xuXHRcdHRoaXMuYXJyb3cgPSBuZXcgQXJyb3codGhpcy5sZXZlbEJvdW5kcy5sZWZ0ICsgMjAwLCB0aGlzLmxldmVsQm91bmRzLnRvcCArIDIwMCk7XG5cdH1cblxuXHRpbml0KGJvb3RzdHJhcDogR2FtZUJvb3RzdHJhcCk6IHZvaWQge1xuXHRcdHRoaXMucmVnaXN0ZXJSZXNvdXJjZXMoKTtcblx0fVxuXG5cdHN0YXJ0KCk6IHZvaWQge1xuXHRcdHRoaXMucGxheWVyID0gbmV3IExldmVsMVBsYXllcih0aGlzLmxldmVsQm91bmRzLnJpZ2h0IC0gMTAwLCB0aGlzLmxldmVsQm91bmRzLnRvcCArIDE5OSk7XG5cdFx0dGhpcy5wbGF5ZXIub24oXCJmZWxsXCIsIHRoaXMubG9zZSk7XG5cdFx0dGhpcy5wbGF5ZXIub24oXCJ3b25cIiwgdGhpcy53aW4pO1xuXHRcdGV4LlBoeXNpY3MuYWNjLnNldFRvKDAsIDIwMDApO1xuXHRcdHRoaXMuc2NlbmUuY2FtZXJhLmFkZFN0cmF0ZWd5KHRoaXMucGxheWVyLmNhbWVyYVN0cmF0ZWd5KTtcblx0XHR0aGlzLnNjZW5lLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgTG9ja0xldmVsQ2FtZXJhU3RyYXRlZ3kodGhpcy5ib3VuZHMsIHRoaXMubGV2ZWxCb3VuZHMpKTtcblx0XHR0aGlzLmJ1aWxkU2NlbmUoKTtcblx0fVxuXG5cdGRpc3Bvc2UoKTogdm9pZCB7XG5cdFx0Zm9yKGxldCBhY3RvciBvZiB0aGlzLnNjZW5lLmFjdG9ycykge1xuXHRcdFx0YWN0b3Iua2lsbCgpO1xuXHRcdH1cblx0fVxuXG5cdHdpbiA9ICgpOiB2b2lkID0+IHtcblx0XHRhbGVydChcIllvdSB3b24hXCIpO1xuXHRcdHRoaXMucGxheWVyLm9mZihcIndvblwiKTtcblx0XHR0aGlzLmVtaXQoXCJkb25lXCIsIHtcblx0XHRcdHRhcmdldDogdGhpcyxcblx0XHRcdHR5cGU6IEdhbWVFbGVtZW50RG9uZVR5cGUuRmluaXNoZWRcblx0XHR9KTtcblx0fVxuXG5cdGxvc2UgPSAoKTogdm9pZCA9PiB7XG5cdFx0YWxlcnQoXCJZb3UgZmVsbCBkb3duIGFuZCBkaWVkXCIpO1xuXHRcdHRoaXMucGxheWVyLm9mZihcImZlbGxcIik7XG5cdFx0dGhpcy5lbWl0KFwiZG9uZVwiLCB7XG5cdFx0XHR0YXJnZXQ6IHRoaXMsXG5cdFx0XHR0eXBlOiBHYW1lRWxlbWVudERvbmVUeXBlLkFib3J0ZWRcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgcmVnaXN0ZXJSZXNvdXJjZXMoKSB7XG5cdFx0dGhpcy5sb2FkZXIuYWRkUmVzb3VyY2VzKEdyb3VuZC5yZXNvdXJjZXMpO1xuXHRcdHRoaXMubG9hZGVyLmFkZFJlc291cmNlcyhBcnJvdy5yZXNvdXJjZXMpO1xuXHR9XG5cblx0cHJpdmF0ZSBidWlsZFNjZW5lID0gKCkgPT4ge1xuXHRcdGxldCB2aW5lcyA9IHRoaXMudmluZUNyZWF0b3IuY3JlYXRlVmluZXMoKTtcblxuXHRcdGZvcihsZXQgdmluZSBvZiB2aW5lcykge1xuXHRcdFx0Zm9yKGxldCB2aW5lUGFydCBvZiB2aW5lLmdldEFsbFBhcnRzKCkpIHtcblx0XHRcdFx0dGhpcy5zY2VuZS5hZGQodmluZVBhcnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuc2NlbmUuYWRkKHRoaXMuZ3JvdW5kKTtcblx0XHR0aGlzLnNjZW5lLmFkZCh0aGlzLnRyZWVCcmFuY2gpO1xuXHRcdHRoaXMuc2NlbmUuYWRkKHRoaXMucGxheWVyKTtcblx0XHR0aGlzLnNjZW5lLmFkZCh0aGlzLmFycm93KTtcblx0XHR0aGlzLmFycm93LnogPSAtMTtcblxuXHRcdHRoaXMuZW5naW5lLmFkZFNjZW5lKHRoaXMuc2NlbmVLZXksIHRoaXMuc2NlbmUpO1xuXHRcdHRoaXMuZW5naW5lLmdvVG9TY2VuZSh0aGlzLnNjZW5lS2V5KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9MZXZlbDEudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///72\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Arrow = /** @class */ (function (_super) {\r\n    __extends(Arrow, _super);\r\n    function Arrow(x, y) {\r\n        var _this = _super.call(this, x, y, Arrow.size.w, Arrow.size.h) || this;\r\n        _this.collisionType = ex.CollisionType.PreventCollision;\r\n        _this.texture = Arrow.resources[0];\r\n        return _this;\r\n    }\r\n    Arrow.prototype.draw = function (ctx, delta) {\r\n        var sprite = this.texture.asSprite();\r\n        sprite.draw(ctx, this.getLeft(), this.getTop());\r\n    };\r\n    Arrow.textureUrl = __webpack_require__(74);\r\n    Arrow.resources = [new ex.Texture(Arrow.textureUrl)];\r\n    Arrow.size = { w: 210, h: 200 };\r\n    return Arrow;\r\n}(ex.Actor));\r\nexports.default = Arrow;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9BcnJvdy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxnQ0FBZ0M7QUFFaEM7SUFBbUMseUJBQVE7SUFRMUMsZUFBWSxDQUFTLEVBQUUsQ0FBUztRQUFoQyxZQUNDLGtCQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FHdkM7UUFGQSxLQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUM7UUFDdkQsS0FBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBZSxDQUFDOztJQUNqRCxDQUFDO0lBRUQsb0JBQUksR0FBSixVQUFLLEdBQTZCLEVBQUUsS0FBYTtRQUNoRCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3JDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBZk0sZ0JBQVUsR0FBVyxtQkFBTyxDQUFDLEVBQWEsQ0FBQyxDQUFDO0lBQzVDLGVBQVMsR0FBbUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFDdEQsVUFBSSxHQUFHLEVBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFDLENBQUM7SUFjekMsWUFBQztDQUFBLENBbEJrQyxFQUFFLENBQUMsS0FBSyxHQWtCMUM7a0JBbEJvQixLQUFLIiwiZmlsZSI6IjczLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZXggZnJvbSBcImV4Y2FsaWJ1clwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcnJvdyBleHRlbmRzIGV4LkFjdG9yIHtcblxuXHRzdGF0aWMgdGV4dHVyZVVybDogc3RyaW5nID0gcmVxdWlyZShcIi4vQXJyb3cucG5nXCIpO1xuXHRzdGF0aWMgcmVzb3VyY2VzOiBleC5JTG9hZGFibGVbXSA9IFtuZXcgZXguVGV4dHVyZShBcnJvdy50ZXh0dXJlVXJsKV07XG5cdHN0YXRpYyByZWFkb25seSBzaXplID0ge3c6IDIxMCwgaDogMjAwfTtcblxuXHR0ZXh0dXJlOiBleC5UZXh0dXJlO1xuXG5cdGNvbnN0cnVjdG9yKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XG5cdFx0c3VwZXIoeCwgeSwgQXJyb3cuc2l6ZS53LCBBcnJvdy5zaXplLmgpO1xuXHRcdHRoaXMuY29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcblx0XHR0aGlzLnRleHR1cmUgPSBBcnJvdy5yZXNvdXJjZXNbMF0gYXMgZXguVGV4dHVyZTtcblx0fVxuXG5cdGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGRlbHRhOiBudW1iZXIpOiB2b2lkIHtcblx0XHRsZXQgc3ByaXRlID0gdGhpcy50ZXh0dXJlLmFzU3ByaXRlKCk7XG5cdFx0c3ByaXRlLmRyYXcoY3R4LCB0aGlzLmdldExlZnQoKSwgdGhpcy5nZXRUb3AoKSk7XG5cdH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9BcnJvdy50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///73\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "assets/717cbcea12687a3f61a4b9f071f259b6.png";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9BcnJvdy5wbmciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvNzE3Y2JjZWExMjY4N2EzZjYxYTRiOWYwNzFmMjU5YjYucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWwxL0Fycm93LnBuZ1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///74\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar BasePlayer_1 = __webpack_require__(23);\r\nvar Level1Player = /** @class */ (function (_super) {\r\n    __extends(Level1Player, _super);\r\n    function Level1Player(x, y) {\r\n        var _this = _super.call(this, x, y) || this;\r\n        _this.inJump = false;\r\n        _this.onVine = false;\r\n        _this.cameraStrategy = new ex.LockCameraToActorAxisStrategy(_this, ex.Axis.X);\r\n        _this.on("precollision", _this.onPrecollision);\r\n        _this.on("postcollision", _this.onPostcollision);\r\n        return _this;\r\n    }\r\n    Level1Player.prototype.update = function (engine, delta) {\r\n        _super.prototype.update.call(this, engine, delta);\r\n        if (engine.input.keyboard.wasPressed(ex.Input.Keys.Space)) {\r\n            this.jump();\r\n        }\r\n        if (this.getWorldPos().x < -10) {\r\n            this.emit("won");\r\n        }\r\n    };\r\n    Level1Player.prototype.jump = function () {\r\n        if (!this.inJump) {\r\n            if (this.onVine) {\r\n                var parent_1 = this.parent;\r\n                this.parent.remove(this);\r\n                this.scene.add(this);\r\n                this.pos.setTo(parent_1.pos.x, parent_1.pos.y);\r\n                this.collisionType = ex.CollisionType.Active;\r\n                this.cameraStrategy.target = this;\r\n            }\r\n            this.vel.setTo(-600, -500);\r\n            this.rotation = -Math.PI / 6;\r\n            this.inJump = true;\r\n            this.onVine = false;\r\n        }\r\n    };\r\n    Level1Player.prototype.onPrecollision = function (e) {\r\n        if (e.other.constructor.name === "Vine" && !this.onVine) {\r\n            this.inJump = false;\r\n            this.attachToVine(e.other);\r\n        }\r\n    };\r\n    Level1Player.prototype.onPostcollision = function (e) {\r\n        if (e.other.constructor.name === "Ground") {\r\n            this.emit("fell");\r\n        }\r\n    };\r\n    Level1Player.prototype.attachToVine = function (vine) {\r\n        this.scene.remove(this);\r\n        vine.add(this);\r\n        var vineRoot = vine.getRoot();\r\n        for (var _i = 0, _a = vineRoot.getAllParts(); _i < _a.length; _i++) {\r\n            var v = _a[_i];\r\n            v.collisionType = ex.CollisionType.PreventCollision;\r\n        }\r\n        this.onVine = true;\r\n        this.pos.x = 0;\r\n        this.pos.y = Level1Player.size.h / 2;\r\n        this.vel.setTo(0, 0);\r\n        this.rotation = 0;\r\n        this.cameraStrategy.target = vine;\r\n    };\r\n    return Level1Player;\r\n}(BasePlayer_1.default));\r\nexports.default = Level1Player;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9QbGF5ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLDJDQUFxRDtBQUdyRDtJQUEwQyxnQ0FBVTtJQU1uRCxzQkFBWSxDQUFTLEVBQUUsQ0FBUztRQUFoQyxZQUNDLGtCQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsU0FJWDtRQVRELFlBQU0sR0FBWSxLQUFLLENBQUM7UUFDeEIsWUFBTSxHQUFZLEtBQUssQ0FBQztRQUt2QixLQUFJLENBQUMsY0FBYyxHQUFHLElBQUksRUFBRSxDQUFDLDZCQUE2QixDQUFDLEtBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVFLEtBQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLEtBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUM3QyxLQUFJLENBQUMsRUFBRSxDQUFDLGVBQWUsRUFBRSxLQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7O0lBQ2hELENBQUM7SUFFRCw2QkFBTSxHQUFOLFVBQU8sTUFBaUIsRUFBRSxLQUFhO1FBQ3RDLGlCQUFNLE1BQU0sWUFBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFNUIsRUFBRSxFQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUQsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2IsQ0FBQztRQUVELEVBQUUsRUFBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xCLENBQUM7SUFDRixDQUFDO0lBRUQsMkJBQUksR0FBSjtRQUNDLEVBQUUsRUFBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLEVBQUUsRUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDaEIsSUFBSSxRQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztnQkFDekIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxRQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxRQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDO2dCQUM3QyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7WUFDbkMsQ0FBQztZQUVELElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1lBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLENBQUM7SUFDRixDQUFDO0lBRUQscUNBQWMsR0FBZCxVQUFlLENBQTZCO1FBQzNDLEVBQUUsRUFBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDeEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7WUFDcEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsS0FBYSxDQUFDLENBQUM7UUFDcEMsQ0FBQztJQUNGLENBQUM7SUFFRCxzQ0FBZSxHQUFmLFVBQWdCLENBQThCO1FBQzdDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkIsQ0FBQztJQUNGLENBQUM7SUFFRCxtQ0FBWSxHQUFaLFVBQWEsSUFBVTtRQUN0QixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2YsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRTlCLEdBQUcsRUFBVSxVQUFzQixFQUF0QixhQUFRLENBQUMsV0FBVyxFQUFFLEVBQXRCLGNBQXNCLEVBQXRCLElBQXNCO1lBQS9CLElBQUksQ0FBQztZQUNSLENBQUMsQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQztTQUNwRDtRQUVELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1FBQ25CLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7UUFDbEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0lBQ25DLENBQUM7SUFDRixtQkFBQztBQUFELENBQUMsQ0F4RXlDLG9CQUFVLEdBd0VuRCIsImZpbGUiOiI3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGV4IGZyb20gXCJleGNhbGlidXJcIjtcclxuaW1wb3J0IEJhc2VQbGF5ZXIgZnJvbSBcIi4uLy4uL0NvbXBvbmVudHMvQmFzZVBsYXllclwiO1xyXG5pbXBvcnQgVmluZSBmcm9tIFwiLi9WaW5lXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbDFQbGF5ZXIgZXh0ZW5kcyBCYXNlUGxheWVyIHtcclxuXHJcblx0aW5KdW1wOiBib29sZWFuID0gZmFsc2U7XHJcblx0b25WaW5lOiBib29sZWFuID0gZmFsc2U7XHJcblx0Y2FtZXJhU3RyYXRlZ3k6IGV4LkxvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5O1xyXG5cclxuXHRjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG5cdFx0c3VwZXIoeCwgeSk7XHJcblx0XHR0aGlzLmNhbWVyYVN0cmF0ZWd5ID0gbmV3IGV4LkxvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5KHRoaXMsIGV4LkF4aXMuWCk7XHJcblx0XHR0aGlzLm9uKFwicHJlY29sbGlzaW9uXCIsIHRoaXMub25QcmVjb2xsaXNpb24pO1xyXG5cdFx0dGhpcy5vbihcInBvc3Rjb2xsaXNpb25cIiwgdGhpcy5vblBvc3Rjb2xsaXNpb24pO1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKGVuZ2luZTogZXguRW5naW5lLCBkZWx0YTogbnVtYmVyKSB7XHJcblx0XHRzdXBlci51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcblxyXG5cdFx0aWYoZW5naW5lLmlucHV0LmtleWJvYXJkLndhc1ByZXNzZWQoZXguSW5wdXQuS2V5cy5TcGFjZSkpIHtcclxuXHRcdFx0dGhpcy5qdW1wKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5nZXRXb3JsZFBvcygpLnggPCAtMTApIHtcclxuXHRcdFx0dGhpcy5lbWl0KFwid29uXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0anVtcCgpIHtcclxuXHRcdGlmKCF0aGlzLmluSnVtcCkge1xyXG5cdFx0XHRpZih0aGlzLm9uVmluZSkge1xyXG5cdFx0XHRcdGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuXHRcdFx0XHR0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XHJcblx0XHRcdFx0dGhpcy5zY2VuZS5hZGQodGhpcyk7XHJcblx0XHRcdFx0dGhpcy5wb3Muc2V0VG8ocGFyZW50LnBvcy54LCBwYXJlbnQucG9zLnkpO1xyXG5cdFx0XHRcdHRoaXMuY29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGUuQWN0aXZlO1xyXG5cdFx0XHRcdHRoaXMuY2FtZXJhU3RyYXRlZ3kudGFyZ2V0ID0gdGhpcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy52ZWwuc2V0VG8oLTYwMCwgLTUwMCk7XHJcblx0XHRcdHRoaXMucm90YXRpb24gPSAtIE1hdGguUEkgLyA2O1xyXG5cdFx0XHR0aGlzLmluSnVtcCA9IHRydWU7XHJcblx0XHRcdHRoaXMub25WaW5lID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRvblByZWNvbGxpc2lvbihlOiBhbnkgfCBleC5QcmVDb2xsaXNpb25FdmVudCkge1xyXG5cdFx0aWYoZS5vdGhlci5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlZpbmVcIiAmJiAhdGhpcy5vblZpbmUpIHtcclxuXHRcdFx0dGhpcy5pbkp1bXAgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5hdHRhY2hUb1ZpbmUoZS5vdGhlciBhcyBWaW5lKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG9uUG9zdGNvbGxpc2lvbihlOiBhbnkgfCBleC5Qb3N0Q29sbGlzaW9uRXZlbnQpIHtcclxuXHRcdGlmIChlLm90aGVyLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiR3JvdW5kXCIpIHtcclxuXHRcdFx0dGhpcy5lbWl0KFwiZmVsbFwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGF0dGFjaFRvVmluZSh2aW5lOiBWaW5lKSB7XHJcblx0XHR0aGlzLnNjZW5lLnJlbW92ZSh0aGlzKTtcclxuXHRcdHZpbmUuYWRkKHRoaXMpO1xyXG5cdFx0bGV0IHZpbmVSb290ID0gdmluZS5nZXRSb290KCk7XHJcblxyXG5cdFx0Zm9yKGxldCB2IG9mIHZpbmVSb290LmdldEFsbFBhcnRzKCkpIHtcclxuXHRcdFx0di5jb2xsaXNpb25UeXBlID0gZXguQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub25WaW5lID0gdHJ1ZTtcclxuXHRcdHRoaXMucG9zLnggPSAwO1xyXG5cdFx0dGhpcy5wb3MueSA9IExldmVsMVBsYXllci5zaXplLmggLyAyO1xyXG5cdFx0dGhpcy52ZWwuc2V0VG8oMCwgMCk7XHJcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcclxuXHRcdHRoaXMuY2FtZXJhU3RyYXRlZ3kudGFyZ2V0ID0gdmluZTtcclxuXHR9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9QbGF5ZXIudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///75\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar TreeBranch = /** @class */ (function (_super) {\r\n    __extends(TreeBranch, _super);\r\n    function TreeBranch(x, y) {\r\n        var _this = _super.call(this, x, y, TreeBranch.branchLength, TreeBranch.branchWidth, ex.Color.Green) || this;\r\n        _this.collisionType = ex.CollisionType.Fixed;\r\n        return _this;\r\n    }\r\n    TreeBranch.branchWidth = 20;\r\n    TreeBranch.branchLength = 170;\r\n    return TreeBranch;\r\n}(ex.Actor));\r\nexports.default = TreeBranch;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9UcmVlQnJhbmNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGdDQUFnQztBQUdoQztJQUF3Qyw4QkFBUTtJQUsvQyxvQkFBWSxDQUFTLEVBQUUsQ0FBUztRQUFoQyxZQUNDLGtCQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsVUFBVSxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBRTVFO1FBREEsS0FBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQzs7SUFDN0MsQ0FBQztJQU5lLHNCQUFXLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLHVCQUFZLEdBQUcsR0FBRyxDQUFDO0lBT3BDLGlCQUFDO0NBQUEsQ0FWdUMsRUFBRSxDQUFDLEtBQUssR0FVL0M7a0JBVm9CLFVBQVUiLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJlZUJyYW5jaCBleHRlbmRzIGV4LkFjdG9yIHtcblxuXHRzdGF0aWMgcmVhZG9ubHkgYnJhbmNoV2lkdGggPSAyMDtcblx0c3RhdGljIHJlYWRvbmx5IGJyYW5jaExlbmd0aCA9IDE3MDtcblxuXHRjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlcikge1xuXHRcdHN1cGVyKHgsIHksIFRyZWVCcmFuY2guYnJhbmNoTGVuZ3RoLCBUcmVlQnJhbmNoLmJyYW5jaFdpZHRoLCBleC5Db2xvci5HcmVlbik7XG5cdFx0dGhpcy5jb2xsaXNpb25UeXBlID0gZXguQ29sbGlzaW9uVHlwZS5GaXhlZDtcblx0fVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWwxL1RyZWVCcmFuY2gudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///76\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar Vine_1 = __webpack_require__(78);\r\nvar VineCreator = /** @class */ (function () {\r\n    function VineCreator(start, end) {\r\n        this.rightToLeft = false;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.rightToLeft = start > end;\r\n    }\r\n    VineCreator.prototype.createVines = function () {\r\n        var vines = [];\r\n        var position = this.start;\r\n        while (true) {\r\n            var distance = VineCreator.randomNumber(VineCreator.distRange.min, VineCreator.distRange.max);\r\n            var vineLength = Math.round(VineCreator.randomNumber(VineCreator.lenRange.min, VineCreator.lenRange.max));\r\n            var speed = VineCreator.randomNumber(VineCreator.speedRange.min, VineCreator.speedRange.max);\r\n            var maxRotation = VineCreator.randomNumber(VineCreator.rotRange.min, VineCreator.rotRange.max);\r\n            var vine = new Vine_1.default(position, 0, vineLength, speed, maxRotation);\r\n            vines.push(vine);\r\n            position = this.rightToLeft ? position - distance : position + distance;\r\n            if (position <= this.end) {\r\n                break;\r\n            }\r\n        }\r\n        return vines;\r\n    };\r\n    VineCreator.randomNumber = function (from, to) {\r\n        var diff = to - from;\r\n        return Math.random() * diff + from;\r\n    };\r\n    VineCreator.distRange = { min: 350, max: 390 };\r\n    VineCreator.lenRange = { min: 12, max: 16 };\r\n    VineCreator.speedRange = { min: 0.8, max: 1.6 };\r\n    VineCreator.rotRange = { min: 0.5, max: 0.9 };\r\n    return VineCreator;\r\n}());\r\nexports.default = VineCreator;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9WaW5lQ3JlYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLHFDQUEwQjtBQUcxQjtJQVVDLHFCQUFZLEtBQWEsRUFBRSxHQUFXO1FBRnRDLGdCQUFXLEdBQVksS0FBSyxDQUFDO1FBRzVCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDO0lBQ2hDLENBQUM7SUFFRCxpQ0FBVyxHQUFYO1FBQ0MsSUFBSSxLQUFLLEdBQVcsRUFBRSxDQUFDO1FBQ3ZCLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFFMUIsT0FBTSxJQUFJLEVBQUUsQ0FBQztZQUNaLElBQUksUUFBUSxHQUFHLFdBQVcsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM5RixJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzFHLElBQUksS0FBSyxHQUFHLFdBQVcsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM3RixJQUFJLFdBQVcsR0FBRyxXQUFXLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFL0YsSUFBSSxJQUFJLEdBQUcsSUFBSSxjQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQ2pFLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDakIsUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7WUFFeEUsRUFBRSxFQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDekIsS0FBSyxDQUFDO1lBQ1AsQ0FBQztRQUNGLENBQUM7UUFFRCxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2QsQ0FBQztJQUVjLHdCQUFZLEdBQTNCLFVBQTRCLElBQVksRUFBRSxFQUFVO1FBQ25ELElBQUksSUFBSSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDckIsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ3BDLENBQUM7SUF4Q2UscUJBQVMsR0FBRyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBQyxDQUFDO0lBQ2pDLG9CQUFRLEdBQUcsRUFBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUMsQ0FBQztJQUM5QixzQkFBVSxHQUFHLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFDLENBQUM7SUFDbEMsb0JBQVEsR0FBRyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBQyxDQUFDO0lBc0NqRCxrQkFBQztDQUFBO2tCQTFDb0IsV0FBVyIsImZpbGUiOiI3Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGV4IGZyb20gXCJleGNhbGlidXJcIjtcbmltcG9ydCBWaW5lIGZyb20gXCIuL1ZpbmVcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaW5lQ3JlYXRvciB7XG5cdHN0YXRpYyByZWFkb25seSBkaXN0UmFuZ2UgPSB7bWluOiAzNTAsIG1heDogMzkwfTtcblx0c3RhdGljIHJlYWRvbmx5IGxlblJhbmdlID0ge21pbjogMTIsIG1heDogMTZ9O1xuXHRzdGF0aWMgcmVhZG9ubHkgc3BlZWRSYW5nZSA9IHttaW46IDAuOCwgbWF4OiAxLjZ9O1xuXHRzdGF0aWMgcmVhZG9ubHkgcm90UmFuZ2UgPSB7bWluOiAwLjUsIG1heDogMC45fTtcblxuXHRzdGFydDogbnVtYmVyO1xuXHRlbmQ6IG51bWJlcjtcblx0cmlnaHRUb0xlZnQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXHRjb25zdHJ1Y3RvcihzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuXHRcdHRoaXMuc3RhcnQgPSBzdGFydDtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnJpZ2h0VG9MZWZ0ID0gc3RhcnQgPiBlbmQ7XG5cdH1cblxuXHRjcmVhdGVWaW5lcygpOiBWaW5lW10ge1xuXHRcdGxldCB2aW5lczogVmluZVtdID0gW107XG5cdFx0bGV0IHBvc2l0aW9uID0gdGhpcy5zdGFydDtcblxuXHRcdHdoaWxlKHRydWUpIHtcblx0XHRcdGxldCBkaXN0YW5jZSA9IFZpbmVDcmVhdG9yLnJhbmRvbU51bWJlcihWaW5lQ3JlYXRvci5kaXN0UmFuZ2UubWluLCBWaW5lQ3JlYXRvci5kaXN0UmFuZ2UubWF4KTtcblx0XHRcdGxldCB2aW5lTGVuZ3RoID0gTWF0aC5yb3VuZChWaW5lQ3JlYXRvci5yYW5kb21OdW1iZXIoVmluZUNyZWF0b3IubGVuUmFuZ2UubWluLCBWaW5lQ3JlYXRvci5sZW5SYW5nZS5tYXgpKTtcblx0XHRcdGxldCBzcGVlZCA9IFZpbmVDcmVhdG9yLnJhbmRvbU51bWJlcihWaW5lQ3JlYXRvci5zcGVlZFJhbmdlLm1pbiwgVmluZUNyZWF0b3Iuc3BlZWRSYW5nZS5tYXgpO1xuXHRcdFx0bGV0IG1heFJvdGF0aW9uID0gVmluZUNyZWF0b3IucmFuZG9tTnVtYmVyKFZpbmVDcmVhdG9yLnJvdFJhbmdlLm1pbiwgVmluZUNyZWF0b3Iucm90UmFuZ2UubWF4KTtcblxuXHRcdFx0bGV0IHZpbmUgPSBuZXcgVmluZShwb3NpdGlvbiwgMCwgdmluZUxlbmd0aCwgc3BlZWQsIG1heFJvdGF0aW9uKTtcblx0XHRcdHZpbmVzLnB1c2godmluZSk7XG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMucmlnaHRUb0xlZnQgPyBwb3NpdGlvbiAtIGRpc3RhbmNlIDogcG9zaXRpb24gKyBkaXN0YW5jZTtcblxuXHRcdFx0aWYocG9zaXRpb24gPD0gdGhpcy5lbmQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpbmVzO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgcmFuZG9tTnVtYmVyKGZyb206IG51bWJlciwgdG86IG51bWJlcik6IG51bWJlciB7XG5cdFx0bGV0IGRpZmYgPSB0byAtIGZyb207XG5cdFx0cmV0dXJuIE1hdGgucmFuZG9tKCkgKiBkaWZmICsgZnJvbTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9WaW5lQ3JlYXRvci50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///77\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Resources_1 = __webpack_require__(7);\r\nvar Vine = /** @class */ (function (_super) {\r\n    __extends(Vine, _super);\r\n    function Vine(x, y, length, speed, maxRotation) {\r\n        var _this = _super.call(this, x, y, Vine.partWidth, Vine.partLength) || this;\r\n        _this.time = 0;\r\n        _this.nextPart = null;\r\n        _this.prevPart = null;\r\n        _this.collisionType = ex.CollisionType.Passive;\r\n        _this.anchor.setTo(1, 0.5);\r\n        _this.body.useCircleCollision(4, new ex.Vector(0, 7));\r\n        _this.speed = speed;\r\n        _this.maxRotation = maxRotation / 10;\r\n        _this.sprite = Vine.sprites[Math.floor(Math.random() * Vine.sprites.length)];\r\n        if (length - 1 > 0) {\r\n            _this.nextPart = new Vine(_this.x, Vine.partLength - 3 + _this.y, length - 1, speed, maxRotation);\r\n            _this.nextPart.prevPart = _this;\r\n        }\r\n        return _this;\r\n    }\r\n    Vine.prototype.update = function (engine, delta) {\r\n        _super.prototype.update.call(this, engine, delta);\r\n        this.rotation = Math.sin(this.time * this.speed) * this.maxRotation;\r\n        this.isOffScreen = this.prevPart ? !(!this.prevPart.isOffScreen || !this.isOffScreen) : this.isOffScreen;\r\n        this.rotation += this.prevPart ? this.prevPart.rotation : 0;\r\n        this.time += delta / 1000;\r\n        if (this.prevPart) {\r\n            var posDiff = new ex.Vector(0, Vine.partLength - 3);\r\n            posDiff = posDiff.rotate(this.prevPart.rotation, new ex.Vector(1, 1));\r\n            this.pos.x = this.prevPart.x + posDiff.x;\r\n            this.pos.y = this.prevPart.y + posDiff.y - 1;\r\n        }\r\n    };\r\n    Vine.prototype.draw = function (ctx, delta) {\r\n        this.sprite.rotation = this.rotation;\r\n        this.sprite.draw(ctx, this.getLeft(), this.getTop());\r\n        _super.prototype.draw.call(this, ctx, delta);\r\n    };\r\n    Vine.prototype.getAllParts = function () {\r\n        var root = this;\r\n        var vineParts = [];\r\n        while (root.nextPart) {\r\n            vineParts.push(root);\r\n            root = root.nextPart;\r\n        }\r\n        return vineParts;\r\n    };\r\n    Vine.prototype.getRoot = function () {\r\n        var root = this;\r\n        while (root.prevPart) {\r\n            root = root.prevPart;\r\n        }\r\n        return root;\r\n    };\r\n    Vine.partLength = 20;\r\n    Vine.partWidth = 10;\r\n    Vine.sprites = [\r\n        new ex.Sprite(Resources_1.default.vine, 0, 0, 10, 20),\r\n        new ex.Sprite(Resources_1.default.vine, 10, 0, 10, 20),\r\n        new ex.Sprite(Resources_1.default.vine, 20, 0, 10, 20),\r\n        new ex.Sprite(Resources_1.default.vine, 30, 0, 10, 20),\r\n    ];\r\n    return Vine;\r\n}(ex.Actor));\r\nexports.default = Vine;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9WaW5lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGdDQUFnQztBQUNoQyx5Q0FBd0M7QUFHeEM7SUFBa0Msd0JBQVE7SUFvQnpDLGNBQVksQ0FBUyxFQUFFLENBQVMsRUFBRSxNQUFjLEVBQUUsS0FBYSxFQUFFLFdBQW1CO1FBQXBGLFlBQ0Msa0JBQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsU0FhNUM7UUE1QkQsVUFBSSxHQUFXLENBQUMsQ0FBQztRQUVqQixjQUFRLEdBQWdCLElBQUksQ0FBQztRQUM3QixjQUFRLEdBQWdCLElBQUksQ0FBQztRQWM1QixLQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDO1FBQzlDLEtBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMxQixLQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckQsS0FBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsS0FBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ3BDLEtBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFFNUUsRUFBRSxFQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuQixLQUFJLENBQUMsUUFBUSxHQUFHLElBQUksSUFBSSxDQUFDLEtBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLEdBQUcsS0FBSSxDQUFDLENBQUMsRUFBRSxNQUFNLEdBQUcsQ0FBQyxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztZQUMvRixLQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsR0FBRyxLQUFJLENBQUM7UUFDL0IsQ0FBQzs7SUFDRixDQUFDO0lBRUQscUJBQU0sR0FBTixVQUFPLE1BQWlCLEVBQUUsS0FBYTtRQUN0QyxpQkFBTSxNQUFNLFlBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBRXBFLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDekcsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVELElBQUksQ0FBQyxJQUFJLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQztRQUUxQixFQUFFLEVBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDbEIsSUFBSSxPQUFPLEdBQUcsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3BELE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0RSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzlDLENBQUM7SUFDRixDQUFDO0lBRUQsbUJBQUksR0FBSixVQUFLLEdBQTZCLEVBQUUsS0FBYTtRQUNoRCxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDckQsaUJBQU0sSUFBSSxZQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQsMEJBQVcsR0FBWDtRQUNDLElBQUksSUFBSSxHQUFTLElBQUksQ0FBQztRQUN0QixJQUFJLFNBQVMsR0FBVyxFQUFFLENBQUM7UUFFM0IsT0FBTSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDckIsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNyQixJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUN0QixDQUFDO1FBRUQsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUNsQixDQUFDO0lBRUQsc0JBQU8sR0FBUDtRQUNDLElBQUksSUFBSSxHQUFTLElBQUksQ0FBQztRQUV0QixPQUFNLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNyQixJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUN0QixDQUFDO1FBRUQsTUFBTSxDQUFDLElBQUksQ0FBQztJQUNiLENBQUM7SUE3RWUsZUFBVSxHQUFHLEVBQUUsQ0FBQztJQUNoQixjQUFTLEdBQUcsRUFBRSxDQUFDO0lBU2YsWUFBTyxHQUFnQjtRQUN0QyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsbUJBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBQzNDLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxtQkFBUyxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7UUFDNUMsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLG1CQUFTLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUM1QyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsbUJBQVMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO0tBQzVDLENBQUM7SUErREgsV0FBQztDQUFBLENBL0VpQyxFQUFFLENBQUMsS0FBSyxHQStFekM7a0JBL0VvQixJQUFJIiwiZmlsZSI6Ijc4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZXggZnJvbSBcImV4Y2FsaWJ1clwiO1xyXG5pbXBvcnQgcmVzb3VyY2VzIGZyb20gXCIuLi8uLi9SZXNvdXJjZXNcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaW5lIGV4dGVuZHMgZXguQWN0b3Ige1xyXG5cdHN0YXRpYyByZWFkb25seSBwYXJ0TGVuZ3RoID0gMjA7XHJcblx0c3RhdGljIHJlYWRvbmx5IHBhcnRXaWR0aCA9IDEwO1xyXG5cclxuXHRzcGVlZDogbnVtYmVyO1xyXG5cdG1heFJvdGF0aW9uOiBudW1iZXI7XHJcblx0dGltZTogbnVtYmVyID0gMDtcclxuXHJcblx0bmV4dFBhcnQ6IFZpbmUgfCBudWxsID0gbnVsbDtcclxuXHRwcmV2UGFydDogVmluZSB8IG51bGwgPSBudWxsO1xyXG5cclxuXHRzdGF0aWMgcmVhZG9ubHkgc3ByaXRlczogZXguU3ByaXRlW10gPSBbXHJcblx0XHRuZXcgZXguU3ByaXRlKHJlc291cmNlcy52aW5lLCAwLCAwLCAxMCwgMjApLFxyXG5cdFx0bmV3IGV4LlNwcml0ZShyZXNvdXJjZXMudmluZSwgMTAsIDAsIDEwLCAyMCksXHJcblx0XHRuZXcgZXguU3ByaXRlKHJlc291cmNlcy52aW5lLCAyMCwgMCwgMTAsIDIwKSxcclxuXHRcdG5ldyBleC5TcHJpdGUocmVzb3VyY2VzLnZpbmUsIDMwLCAwLCAxMCwgMjApLFxyXG5cdF07XHJcblxyXG5cdHNwcml0ZTogZXguU3ByaXRlO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHNwZWVkOiBudW1iZXIsIG1heFJvdGF0aW9uOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKHgsIHksIFZpbmUucGFydFdpZHRoLCBWaW5lLnBhcnRMZW5ndGgpO1xyXG5cclxuXHRcdHRoaXMuY29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGUuUGFzc2l2ZTtcclxuXHRcdHRoaXMuYW5jaG9yLnNldFRvKDEsIDAuNSk7XHJcblx0XHR0aGlzLmJvZHkudXNlQ2lyY2xlQ29sbGlzaW9uKDQsIG5ldyBleC5WZWN0b3IoMCwgNykpO1xyXG5cdFx0dGhpcy5zcGVlZCA9IHNwZWVkO1xyXG5cdFx0dGhpcy5tYXhSb3RhdGlvbiA9IG1heFJvdGF0aW9uIC8gMTA7XHJcblx0XHR0aGlzLnNwcml0ZSA9IFZpbmUuc3ByaXRlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBWaW5lLnNwcml0ZXMubGVuZ3RoKV07XHJcblxyXG5cdFx0aWYobGVuZ3RoIC0gMSA+IDApIHtcclxuXHRcdFx0dGhpcy5uZXh0UGFydCA9IG5ldyBWaW5lKHRoaXMueCwgVmluZS5wYXJ0TGVuZ3RoIC0gMyArIHRoaXMueSwgbGVuZ3RoIC0gMSwgc3BlZWQsIG1heFJvdGF0aW9uKTtcclxuXHRcdFx0dGhpcy5uZXh0UGFydC5wcmV2UGFydCA9IHRoaXM7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR1cGRhdGUoZW5naW5lOiBleC5FbmdpbmUsIGRlbHRhOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuXHRcdHRoaXMucm90YXRpb24gPSBNYXRoLnNpbih0aGlzLnRpbWUgKiB0aGlzLnNwZWVkKSAqIHRoaXMubWF4Um90YXRpb247XHJcblxyXG5cdFx0dGhpcy5pc09mZlNjcmVlbiA9IHRoaXMucHJldlBhcnQgPyAhKCF0aGlzLnByZXZQYXJ0LmlzT2ZmU2NyZWVuIHx8ICF0aGlzLmlzT2ZmU2NyZWVuKSA6IHRoaXMuaXNPZmZTY3JlZW47XHJcblx0XHR0aGlzLnJvdGF0aW9uICs9IHRoaXMucHJldlBhcnQgPyB0aGlzLnByZXZQYXJ0LnJvdGF0aW9uIDogMDtcclxuXHRcdHRoaXMudGltZSArPSBkZWx0YSAvIDEwMDA7XHJcblxyXG5cdFx0aWYodGhpcy5wcmV2UGFydCkge1xyXG5cdFx0XHRsZXQgcG9zRGlmZiA9IG5ldyBleC5WZWN0b3IoMCwgVmluZS5wYXJ0TGVuZ3RoIC0gMyk7XHJcblx0XHRcdHBvc0RpZmYgPSBwb3NEaWZmLnJvdGF0ZSh0aGlzLnByZXZQYXJ0LnJvdGF0aW9uLCBuZXcgZXguVmVjdG9yKDEsIDEpKTtcclxuXHRcdFx0dGhpcy5wb3MueCA9IHRoaXMucHJldlBhcnQueCArIHBvc0RpZmYueDtcclxuXHRcdFx0dGhpcy5wb3MueSA9IHRoaXMucHJldlBhcnQueSArIHBvc0RpZmYueSAtIDE7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBkZWx0YTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLnNwcml0ZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcblx0XHR0aGlzLnNwcml0ZS5kcmF3KGN0eCwgdGhpcy5nZXRMZWZ0KCksIHRoaXMuZ2V0VG9wKCkpO1xyXG5cdFx0c3VwZXIuZHJhdyhjdHgsIGRlbHRhKTtcclxuXHR9XHJcblxyXG5cdGdldEFsbFBhcnRzKCk6IFZpbmVbXSB7XHJcblx0XHRsZXQgcm9vdDogVmluZSA9IHRoaXM7XHJcblx0XHRsZXQgdmluZVBhcnRzOiBWaW5lW10gPSBbXTtcclxuXHJcblx0XHR3aGlsZShyb290Lm5leHRQYXJ0KSB7XHJcblx0XHRcdHZpbmVQYXJ0cy5wdXNoKHJvb3QpO1xyXG5cdFx0XHRyb290ID0gcm9vdC5uZXh0UGFydDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmluZVBhcnRzO1xyXG5cdH1cclxuXHJcblx0Z2V0Um9vdCgpOiBWaW5lIHtcclxuXHRcdGxldCByb290OiBWaW5lID0gdGhpcztcclxuXHJcblx0XHR3aGlsZShyb290LnByZXZQYXJ0KSB7XHJcblx0XHRcdHJvb3QgPSByb290LnByZXZQYXJ0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByb290O1xyXG5cdH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWwxL1ZpbmUudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///78\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "assets/b1af393cf814f70d9e5917d79ed61809.png";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9jcm9jb2RpbGUtc3ByaXRlLnBuZyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI3OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9iMWFmMzkzY2Y4MTRmNzBkOWU1OTE3ZDc5ZWQ2MTgwOS5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9MZXZlbDIvY3JvY29kaWxlLXNwcml0ZS5wbmdcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///79\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "assets/3e08ac19633622f3ab350e3436fd8882.jpg";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9zZWFiZWQuanBnIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjgwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXNzZXRzLzNlMDhhYzE5NjMzNjIyZjNhYjM1MGUzNDM2ZmQ4ODgyLmpwZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9zZWFiZWQuanBnXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///80\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "assets/725b5b012daf0e35df52db422b55a301.jpg";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9jbG91ZC5qcGciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiODEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvNzI1YjViMDEyZGFmMGUzNWRmNTJkYjQyMmI1NWEzMDEuanBnXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWwyL2Nsb3VkLmpwZ1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///81\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "assets/d7c94c6941a8bc38329178482db8f022.png";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9idWJibGUucG5nIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjgyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXNzZXRzL2Q3Yzk0YzY5NDFhOGJjMzgzMjkxNzg0ODJkYjhmMDIyLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9idWJibGUucG5nXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///82\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "assets/6c097bf454a5dc86f25c327acc980679.png";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMS9WaW5lLnBuZyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI4My5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy82YzA5N2JmNDU0YTVkYzg2ZjI1YzMyN2FjYzk4MDY3OS5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9MZXZlbDEvVmluZS5wbmdcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///83\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "assets/d5adaf8bfeff5c4d467f4902c0f07a53.png";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMy9zbWFsbFJvY2sucG5nIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ijg0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXNzZXRzL2Q1YWRhZjhiZmVmZjVjNGQ0NjdmNDkwMmMwZjA3YTUzLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsMy9zbWFsbFJvY2sucG5nXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///84\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "assets/bd2bdb7d029f922473bca2567252b93f.png";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMy9iaWdSb2NrLnBuZyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI4NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9iZDJiZGI3ZDAyOWY5MjI0NzNiY2EyNTY3MjUyYjkzZi5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9MZXZlbDMvYmlnUm9jay5wbmdcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///85\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Class_1 = __webpack_require__(5);\r\nvar LockLevelCameraStrategy_1 = __webpack_require__(16);\r\nvar Ground_1 = __webpack_require__(87);\r\nvar Sky_1 = __webpack_require__(88);\r\nvar Player_1 = __webpack_require__(89);\r\nvar BubbleCreator_1 = __webpack_require__(90);\r\nvar CrocodileCreator_1 = __webpack_require__(92);\r\nvar Level2 = /** @class */ (function (_super) {\r\n    __extends(Level2, _super);\r\n    function Level2(bootstrap) {\r\n        var _this = _super.call(this) || this;\r\n        _this.sceneKey = "level2";\r\n        _this.levelBounds = new ex.BoundingBox(0, 0, 5000, 600);\r\n        _this.sceneBackgroundColor = ex.Color.Azure;\r\n        _this.buildScene = function () {\r\n            // add actors\r\n            _this.scene.add(_this.ground);\r\n            _this.scene.add(_this.sky);\r\n            _this.scene.add(_this.player);\r\n            _this.scene.addUIActor(_this.oxygenMeter);\r\n            // start bubbleCreator and crocodileCreator\r\n            _this.bubbleCreator.start();\r\n            _this.crocodileCreator.start();\r\n            _this.engine.addScene(_this.sceneKey, _this.scene);\r\n            _this.engine.goToScene(_this.sceneKey);\r\n        };\r\n        _this.engine = bootstrap.engine;\r\n        _this.scene = new ex.Scene(_this.engine);\r\n        _this.bounds = _this.engine.getWorldBounds();\r\n        _this.loader = bootstrap.loader;\r\n        // Actor creation\r\n        _this.ground = new Ground_1.default(_this.bounds.left + 2500, _this.bounds.bottom - 25);\r\n        _this.sky = new Sky_1.default(_this.bounds.left + 2500, _this.bounds.top + 25);\r\n        _this.oxygenMeter = new ex.Label("Oxygen Level: 100/100", _this.bounds.left + 30, _this.bounds.top + 50);\r\n        _this.oxygenMeter.fontSize = 30;\r\n        _this.player = new Player_1.default(0, _this.bounds.bottom / 2, _this.levelBounds, _this.oxygenMeter);\r\n        _this.bubbles = [];\r\n        _this.crocodiles = [];\r\n        // BubbleCreator for cyclic generation of new bubbles\r\n        _this.bubbleCreator = new BubbleCreator_1.default(_this.engine, _this.scene, _this.bounds, _this.player, _this.bubbles);\r\n        // CrocodileCreator for generation of new crocodiles\r\n        _this.crocodileCreator = new CrocodileCreator_1.default(bootstrap, _this.scene, _this.bounds, _this.player, _this.crocodiles);\r\n        return _this;\r\n    }\r\n    Level2.prototype.start = function () {\r\n        this.engine.backgroundColor = this.sceneBackgroundColor; // set background color\r\n        ex.Physics.acc.setTo(0, 0);\r\n        this.scene.camera.addStrategy(new ex.LockCameraToActorAxisStrategy(this.player, ex.Axis.X));\r\n        this.scene.camera.addStrategy(new LockLevelCameraStrategy_1.default(this.bounds, this.levelBounds));\r\n        this.buildScene();\r\n    };\r\n    Level2.prototype.dispose = function () {\r\n        this.ground.kill();\r\n        this.sky.kill();\r\n        this.oxygenMeter.kill();\r\n        this.bubbleCreator.stop();\r\n        this.bubbles.forEach(function (b) {\r\n            if (!b.isKilled) {\r\n                b.kill();\r\n            }\r\n        });\r\n        this.crocodileCreator.stop();\r\n        this.crocodiles.forEach(function (b) {\r\n            if (!b.isKilled) {\r\n                b.kill();\r\n            }\r\n        });\r\n    };\r\n    return Level2;\r\n}(Class_1.Class));\r\nexports.default = Level2;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9MZXZlbDIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLHFDQUFvQztBQUNwQyx3REFBK0U7QUFFL0UsdUNBQThCO0FBQzlCLG9DQUF3QjtBQUN4Qix1Q0FBOEI7QUFFOUIsOENBQTRDO0FBRTVDLGlEQUFrRDtBQUVsRDtJQUFvQywwQkFBeUI7SUEwQjVELGdCQUFZLFNBQXdCO1FBQXBDLFlBQ0MsaUJBQU8sU0FxQlA7UUE5Q1EsY0FBUSxHQUFXLFFBQVEsQ0FBQztRQUM1QixpQkFBVyxHQUFtQixJQUFJLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDbEUsMEJBQW9CLEdBQWEsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7UUFzRWpELGdCQUFVLEdBQUc7WUFFcEIsYUFBYTtZQUNiLEtBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM1QixLQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDekIsS0FBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTVCLEtBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUV4QywyQ0FBMkM7WUFDM0MsS0FBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUMzQixLQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLENBQUM7WUFFOUIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSSxDQUFDLFFBQVEsRUFBRSxLQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDaEQsS0FBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3RDLENBQUM7UUE1REEsS0FBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQy9CLEtBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN2QyxLQUFJLENBQUMsTUFBTSxHQUFHLEtBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDM0MsS0FBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBRS9CLGlCQUFpQjtRQUNqQixLQUFJLENBQUMsTUFBTSxHQUFHLElBQUksZ0JBQU0sQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLEVBQUUsS0FBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDM0UsS0FBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLGFBQUcsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLEVBQUUsS0FBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDbEUsS0FBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsdUJBQXVCLEVBQUUsS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsRUFBRSxFQUFFLEtBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3RHLEtBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUMvQixLQUFJLENBQUMsTUFBTSxHQUFHLElBQUksZ0JBQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLEtBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3hGLEtBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ2xCLEtBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO1FBRXJCLHFEQUFxRDtRQUNyRCxLQUFJLENBQUMsYUFBYSxHQUFHLElBQUksdUJBQWEsQ0FBQyxLQUFJLENBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSSxDQUFDLE1BQU0sRUFBRSxLQUFJLENBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV4RyxvREFBb0Q7UUFDcEQsS0FBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksMEJBQWdCLENBQUMsU0FBUyxFQUFFLEtBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSSxDQUFDLE1BQU0sRUFBRSxLQUFJLENBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzs7SUFDaEgsQ0FBQztJQUVELHNCQUFLLEdBQUw7UUFDQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyx1QkFBdUI7UUFDaEYsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsNkJBQTZCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUYsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksaUNBQXVCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUMxRixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVELHdCQUFPLEdBQVA7UUFDQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ25CLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDaEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUV4QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQztZQUMvQixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUFDLENBQUM7UUFDL0IsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDN0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDO1lBQ2xDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQUMsQ0FBQztRQUMvQixDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFtQkYsYUFBQztBQUFELENBQUMsQ0EzRm1DLGFBQUssR0EyRnhDIiwiZmlsZSI6Ijg2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZXggZnJvbSBcImV4Y2FsaWJ1clwiO1xuaW1wb3J0IHsgQ2xhc3MgfSBmcm9tIFwiLi4vLi4vQ2xhc3NcIjtcbmltcG9ydCBMb2NrTGV2ZWxDYW1lcmFTdHJhdGVneSBmcm9tIFwiLi4vLi4vQ29tcG9uZW50cy9Mb2NrTGV2ZWxDYW1lcmFTdHJhdGVneVwiO1xuaW1wb3J0IHsgR2FtZUJvb3RzdHJhcCwgSUdhbWVFbGVtZW50LCBJR2FtZUVsZW1lbnRFdmVudHMgfSBmcm9tIFwiLi4vLi4vR2FtZUJvb3RzdHJhcFwiO1xuaW1wb3J0IEdyb3VuZCBmcm9tIFwiLi9Hcm91bmRcIjtcbmltcG9ydCBTa3kgZnJvbSBcIi4vU2t5XCI7XG5pbXBvcnQgUGxheWVyIGZyb20gXCIuL1BsYXllclwiO1xuaW1wb3J0IEJ1YmJsZSBmcm9tIFwiLi9CdWJibGVcIjtcbmltcG9ydCBCdWJibGVDcmVhdG9yIGZyb20gXCIuL0J1YmJsZUNyZWF0b3JcIjtcbmltcG9ydCBDcm9jb2RpbGUgZnJvbSBcIi4vQ3JvY29kaWxlXCI7XG5pbXBvcnQgQ3JvY29kaWxlQ3JlYXRvciBmcm9tIFwiLi9Dcm9jb2RpbGVDcmVhdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsMiBleHRlbmRzIENsYXNzPElHYW1lRWxlbWVudEV2ZW50cz4gaW1wbGVtZW50cyBJR2FtZUVsZW1lbnQge1xuXG5cdHJlYWRvbmx5IHNjZW5lS2V5OiBzdHJpbmcgPSBcImxldmVsMlwiO1xuXHRyZWFkb25seSBsZXZlbEJvdW5kczogZXguQm91bmRpbmdCb3ggPSBuZXcgZXguQm91bmRpbmdCb3goMCwgMCwgNTAwMCwgNjAwKTtcblx0cmVhZG9ubHkgc2NlbmVCYWNrZ3JvdW5kQ29sb3I6IGV4LkNvbG9yID0gZXguQ29sb3IuQXp1cmU7XG5cblx0ZW5naW5lOiBleC5FbmdpbmU7XG5cdHNjZW5lOiBleC5TY2VuZTtcblx0Ym91bmRzOiBleC5Cb3VuZGluZ0JveDtcblxuXHQvLyBhY3RvcnNcblx0Z3JvdW5kOiBHcm91bmQ7XG5cdHNreTogU2t5O1xuXHRwbGF5ZXI6IFBsYXllcjtcblx0b3h5Z2VuTWV0ZXI6IGV4LkxhYmVsO1xuXG5cdC8vIGJ1YmJsZXNcblx0YnViYmxlczogQnViYmxlW107XG5cdGJ1YmJsZUNyZWF0b3I6IEJ1YmJsZUNyZWF0b3I7XG5cblx0Ly8gQ3JvY29kaWxlc1xuXHRjcm9jb2RpbGVzOiBDcm9jb2RpbGVbXTtcblx0Y3JvY29kaWxlQ3JlYXRvcjogQ3JvY29kaWxlQ3JlYXRvcjtcblxuXHRsb2FkZXI6IGV4LkxvYWRlcjtcblxuXHRjb25zdHJ1Y3Rvcihib290c3RyYXA6IEdhbWVCb290c3RyYXApIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5lbmdpbmUgPSBib290c3RyYXAuZW5naW5lO1xuXHRcdHRoaXMuc2NlbmUgPSBuZXcgZXguU2NlbmUodGhpcy5lbmdpbmUpO1xuXHRcdHRoaXMuYm91bmRzID0gdGhpcy5lbmdpbmUuZ2V0V29ybGRCb3VuZHMoKTtcblx0XHR0aGlzLmxvYWRlciA9IGJvb3RzdHJhcC5sb2FkZXI7XG5cblx0XHQvLyBBY3RvciBjcmVhdGlvblxuXHRcdHRoaXMuZ3JvdW5kID0gbmV3IEdyb3VuZCh0aGlzLmJvdW5kcy5sZWZ0ICsgMjUwMCwgdGhpcy5ib3VuZHMuYm90dG9tIC0gMjUpO1xuXHRcdHRoaXMuc2t5ID0gbmV3IFNreSh0aGlzLmJvdW5kcy5sZWZ0ICsgMjUwMCwgdGhpcy5ib3VuZHMudG9wICsgMjUpO1xuXHRcdHRoaXMub3h5Z2VuTWV0ZXIgPSBuZXcgZXguTGFiZWwoXCJPeHlnZW4gTGV2ZWw6IDEwMC8xMDBcIiwgdGhpcy5ib3VuZHMubGVmdCArIDMwLCB0aGlzLmJvdW5kcy50b3AgKyA1MCk7XG5cdFx0dGhpcy5veHlnZW5NZXRlci5mb250U2l6ZSA9IDMwO1xuXHRcdHRoaXMucGxheWVyID0gbmV3IFBsYXllcigwLCB0aGlzLmJvdW5kcy5ib3R0b20gLyAyLCB0aGlzLmxldmVsQm91bmRzLCB0aGlzLm94eWdlbk1ldGVyKTtcblx0XHR0aGlzLmJ1YmJsZXMgPSBbXTtcblx0XHR0aGlzLmNyb2NvZGlsZXMgPSBbXTtcblxuXHRcdC8vIEJ1YmJsZUNyZWF0b3IgZm9yIGN5Y2xpYyBnZW5lcmF0aW9uIG9mIG5ldyBidWJibGVzXG5cdFx0dGhpcy5idWJibGVDcmVhdG9yID0gbmV3IEJ1YmJsZUNyZWF0b3IodGhpcy5lbmdpbmUsIHRoaXMuc2NlbmUsIHRoaXMuYm91bmRzLCB0aGlzLnBsYXllciwgdGhpcy5idWJibGVzKTtcblxuXHRcdC8vIENyb2NvZGlsZUNyZWF0b3IgZm9yIGdlbmVyYXRpb24gb2YgbmV3IGNyb2NvZGlsZXNcblx0XHR0aGlzLmNyb2NvZGlsZUNyZWF0b3IgPSBuZXcgQ3JvY29kaWxlQ3JlYXRvcihib290c3RyYXAsIHRoaXMuc2NlbmUsIHRoaXMuYm91bmRzLCB0aGlzLnBsYXllciwgdGhpcy5jcm9jb2RpbGVzKTtcblx0fVxuXG5cdHN0YXJ0KCk6IHZvaWQge1xuXHRcdHRoaXMuZW5naW5lLmJhY2tncm91bmRDb2xvciA9IHRoaXMuc2NlbmVCYWNrZ3JvdW5kQ29sb3I7IC8vIHNldCBiYWNrZ3JvdW5kIGNvbG9yXG5cdFx0ZXguUGh5c2ljcy5hY2Muc2V0VG8oMCwgMCk7XG5cdFx0dGhpcy5zY2VuZS5jYW1lcmEuYWRkU3RyYXRlZ3kobmV3IGV4LkxvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5KHRoaXMucGxheWVyLCBleC5BeGlzLlgpKTtcblx0XHR0aGlzLnNjZW5lLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgTG9ja0xldmVsQ2FtZXJhU3RyYXRlZ3kodGhpcy5ib3VuZHMsIHRoaXMubGV2ZWxCb3VuZHMpKTtcblx0XHR0aGlzLmJ1aWxkU2NlbmUoKTtcblx0fVxuXG5cdGRpc3Bvc2UoKTogdm9pZCB7XG5cdFx0dGhpcy5ncm91bmQua2lsbCgpO1xuXHRcdHRoaXMuc2t5LmtpbGwoKTtcblx0XHR0aGlzLm94eWdlbk1ldGVyLmtpbGwoKTtcblxuXHRcdHRoaXMuYnViYmxlQ3JlYXRvci5zdG9wKCk7XG5cdFx0dGhpcy5idWJibGVzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcblx0XHRcdGlmICghYi5pc0tpbGxlZCkgeyBiLmtpbGwoKTsgfVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5jcm9jb2RpbGVDcmVhdG9yLnN0b3AoKTtcblx0XHR0aGlzLmNyb2NvZGlsZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuXHRcdFx0aWYgKCFiLmlzS2lsbGVkKSB7IGIua2lsbCgpOyB9XG5cdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIGJ1aWxkU2NlbmUgPSAoKSA9PiB7XG5cblx0XHQvLyBhZGQgYWN0b3JzXG5cdFx0dGhpcy5zY2VuZS5hZGQodGhpcy5ncm91bmQpO1xuXHRcdHRoaXMuc2NlbmUuYWRkKHRoaXMuc2t5KTtcblx0XHR0aGlzLnNjZW5lLmFkZCh0aGlzLnBsYXllcik7XG5cblx0XHR0aGlzLnNjZW5lLmFkZFVJQWN0b3IodGhpcy5veHlnZW5NZXRlcik7XG5cblx0XHQvLyBzdGFydCBidWJibGVDcmVhdG9yIGFuZCBjcm9jb2RpbGVDcmVhdG9yXG5cdFx0dGhpcy5idWJibGVDcmVhdG9yLnN0YXJ0KCk7XG5cdFx0dGhpcy5jcm9jb2RpbGVDcmVhdG9yLnN0YXJ0KCk7XG5cblx0XHR0aGlzLmVuZ2luZS5hZGRTY2VuZSh0aGlzLnNjZW5lS2V5LCB0aGlzLnNjZW5lKTtcblx0XHR0aGlzLmVuZ2luZS5nb1RvU2NlbmUodGhpcy5zY2VuZUtleSk7XG5cdH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9MZXZlbDIudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///86\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Resources_1 = __webpack_require__(7);\r\nvar Ground = /** @class */ (function (_super) {\r\n    __extends(Ground, _super);\r\n    function Ground(x, y) {\r\n        var _this = _super.call(this, x, y, Ground.width, 50, ex.Color.Gray) || this;\r\n        _this.collisionType = ex.CollisionType.Fixed;\r\n        return _this;\r\n    }\r\n    Ground.prototype.draw = function (ctx, delta) {\r\n        var sprite = Resources_1.default.seaBed.asSprite();\r\n        var offset = 0;\r\n        while (offset < Ground.width) {\r\n            sprite.draw(ctx, this.getLeft() + offset, this.getTop());\r\n            offset += 70;\r\n        }\r\n    };\r\n    Ground.width = 5000;\r\n    return Ground;\r\n}(ex.Actor));\r\nexports.default = Ground;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9Hcm91bmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLHlDQUF3QztBQUV4QztJQUFvQywwQkFBUTtJQUkzQyxnQkFBWSxDQUFTLEVBQUUsQ0FBUztRQUFoQyxZQUNDLGtCQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FFNUM7UUFEQSxLQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDOztJQUM3QyxDQUFDO0lBRUQscUJBQUksR0FBSixVQUFLLEdBQTZCLEVBQUUsS0FBYTtRQUNoRCxJQUFNLE1BQU0sR0FBRyxtQkFBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMzQyxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFFZixPQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztZQUN6RCxNQUFNLElBQUksRUFBRSxDQUFDO1FBQ2QsQ0FBQztJQUNGLENBQUM7SUFmZSxZQUFLLEdBQVcsSUFBSSxDQUFDO0lBZ0J0QyxhQUFDO0NBQUEsQ0FsQm1DLEVBQUUsQ0FBQyxLQUFLLEdBa0IzQztrQkFsQm9CLE1BQU0iLCJmaWxlIjoiODcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XHJcbmltcG9ydCBSZXNvdXJjZXMgZnJvbSBcIi4uLy4uL1Jlc291cmNlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JvdW5kIGV4dGVuZHMgZXguQWN0b3Ige1xyXG5cclxuXHRzdGF0aWMgcmVhZG9ubHkgd2lkdGg6IG51bWJlciA9IDUwMDA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XHJcblx0XHRzdXBlcih4LCB5LCBHcm91bmQud2lkdGgsIDUwLCBleC5Db2xvci5HcmF5KTtcclxuXHRcdHRoaXMuY29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGUuRml4ZWQ7XHJcblx0fVxyXG5cclxuXHRkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBkZWx0YTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCBzcHJpdGUgPSBSZXNvdXJjZXMuc2VhQmVkLmFzU3ByaXRlKCk7XHJcblx0XHRsZXQgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR3aGlsZShvZmZzZXQgPCBHcm91bmQud2lkdGgpIHtcclxuXHRcdFx0c3ByaXRlLmRyYXcoY3R4LCB0aGlzLmdldExlZnQoKSArIG9mZnNldCwgdGhpcy5nZXRUb3AoKSk7XHJcblx0XHRcdG9mZnNldCArPSA3MDtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9Hcm91bmQudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///87\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Resources_1 = __webpack_require__(7);\r\nvar Sky = /** @class */ (function (_super) {\r\n    __extends(Sky, _super);\r\n    function Sky(x, y) {\r\n        var _this = _super.call(this, x, y, Sky.width, 50, ex.Color.Gray) || this;\r\n        _this.collisionType = ex.CollisionType.Passive;\r\n        _this.color = ex.Color.fromHex("#59C9FF");\r\n        return _this;\r\n    }\r\n    Sky.prototype.draw = function (ctx, delta) {\r\n        _super.prototype.draw.call(this, ctx, delta);\r\n        var sprite = Resources_1.default.sky.asSprite();\r\n        var offset = 0;\r\n        var rndm = new ex.Random(47);\r\n        while (offset < Sky.width) {\r\n            sprite.draw(ctx, this.getLeft() + offset, this.getTop());\r\n            offset += rndm.integer(43, 250); // 70;\r\n        }\r\n    };\r\n    Sky.width = 5000;\r\n    return Sky;\r\n}(ex.Actor));\r\nexports.default = Sky;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9Ta3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLHlDQUF3QztBQUV4QztJQUFpQyx1QkFBUTtJQUl4QyxhQUFZLENBQVMsRUFBRSxDQUFTO1FBQWhDLFlBQ0Msa0JBQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUd6QztRQUZBLEtBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUM7UUFDOUMsS0FBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7SUFDMUMsQ0FBQztJQUVELGtCQUFJLEdBQUosVUFBSyxHQUE2QixFQUFFLEtBQWE7UUFDaEQsaUJBQU0sSUFBSSxZQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2QixJQUFJLE1BQU0sR0FBRyxtQkFBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUN0QyxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDZixJQUFJLElBQUksR0FBRyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFN0IsT0FBTyxNQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQzNCLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDekQsTUFBTSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU07UUFDdkMsQ0FBQztJQUNGLENBQUM7SUFsQmUsU0FBSyxHQUFXLElBQUksQ0FBQztJQW9CdEMsVUFBQztDQUFBLENBdEJnQyxFQUFFLENBQUMsS0FBSyxHQXNCeEM7a0JBdEJvQixHQUFHIiwiZmlsZSI6Ijg4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZXggZnJvbSBcImV4Y2FsaWJ1clwiO1xuaW1wb3J0IHJlc291cmNlcyBmcm9tIFwiLi4vLi4vUmVzb3VyY2VzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNreSBleHRlbmRzIGV4LkFjdG9yIHtcblxuXHRzdGF0aWMgcmVhZG9ubHkgd2lkdGg6IG51bWJlciA9IDUwMDA7XG5cblx0Y29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcblx0XHRzdXBlcih4LCB5LCBTa3kud2lkdGgsIDUwLCBleC5Db2xvci5HcmF5KTtcblx0XHR0aGlzLmNvbGxpc2lvblR5cGUgPSBleC5Db2xsaXNpb25UeXBlLlBhc3NpdmU7XG5cdFx0dGhpcy5jb2xvciA9IGV4LkNvbG9yLmZyb21IZXgoXCIjNTlDOUZGXCIpO1xuXHR9XG5cblx0ZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZGVsdGE6IG51bWJlcik6IHZvaWQge1xuXHRcdHN1cGVyLmRyYXcoY3R4LCBkZWx0YSk7XG5cdFx0bGV0IHNwcml0ZSA9IHJlc291cmNlcy5za3kuYXNTcHJpdGUoKTtcblx0XHRsZXQgb2Zmc2V0ID0gMDtcblx0XHRsZXQgcm5kbSA9IG5ldyBleC5SYW5kb20oNDcpO1xuXG5cdFx0d2hpbGUgKG9mZnNldCA8IFNreS53aWR0aCkge1xuXHRcdFx0c3ByaXRlLmRyYXcoY3R4LCB0aGlzLmdldExlZnQoKSArIG9mZnNldCwgdGhpcy5nZXRUb3AoKSk7XG5cdFx0XHRvZmZzZXQgKz0gcm5kbS5pbnRlZ2VyKDQzLCAyNTApOy8vIDcwO1xuXHRcdH1cblx0fVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWwyL1NreS50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///88\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Player = /** @class */ (function (_super) {\r\n    __extends(Player, _super);\r\n    function Player(x, y, levelBounds, oxygenMeter) {\r\n        var _this = _super.call(this, x, y, Player.size.w, Player.size.h, ex.Color.DarkGray) || this;\r\n        _this.speedX = Player.speedNormal;\r\n        _this.trapped = false; // for disabling controls in case of being trapped by a bubble\r\n        _this.dead = false;\r\n        _this.oxygenLevel = 100;\r\n        _this.minX = levelBounds.left + Player.size.w / 2;\r\n        _this.maxX = levelBounds.right - Player.size.w / 2;\r\n        _this.minY = levelBounds.top + Player.size.h / 2;\r\n        _this.maxY = levelBounds.bottom - Player.size.h / 2;\r\n        _this.oxygenMeter = oxygenMeter;\r\n        // Anchor\r\n        _this.anchor.setTo(0.5, 0.5); // set anchor to the center of the right edge (?)\r\n        // this.y += this.getHeight() / 2;\r\n        _this.collisionArea.body.useBoxCollision();\r\n        _this.collisionType = ex.CollisionType.Active;\r\n        _this.on("precollision", _this.onPrecollision);\r\n        return _this;\r\n    }\r\n    Player.prototype.onPrecollision = function (ev) {\r\n        // Reset Oxygen Level to 100\r\n        if (ev.other.constructor.name === "Sky") {\r\n            this.oxygenLevel = 100;\r\n        }\r\n        else if (ev.other.constructor.name === "Bubble" && !this.trapped) {\r\n            this.oxygenLevel = (this.oxygenLevel + 20) < 100 ? this.oxygenLevel + 20 : 100;\r\n        }\r\n    };\r\n    Player.prototype.update = function (engine, delta) {\r\n        _super.prototype.update.call(this, engine, delta);\r\n        // Decrease Oxygen Level and drown if no oxygen is left\r\n        this.oxygenLevel -= 0.12;\r\n        this.oxygenMeter.text = "Oxygen Level: " + Math.round(this.oxygenLevel) + "/100";\r\n        if (this.oxygenLevel <= 0) {\r\n            this.die("You drowned!");\r\n        }\r\n        if (!this.trapped) {\r\n            // X movement\r\n            if (engine.input.keyboard.wasPressed(ex.Input.Keys.Left)) {\r\n                this.speedX = Player.speedDec;\r\n            }\r\n            if (engine.input.keyboard.wasPressed(ex.Input.Keys.Right)) {\r\n                this.speedX = Player.speedAcc;\r\n            }\r\n            if (engine.input.keyboard.wasReleased(ex.Input.Keys.Left)) {\r\n                if (engine.input.keyboard.isHeld(ex.Input.Keys.Right)) {\r\n                    this.speedX = Player.speedAcc;\r\n                }\r\n                else {\r\n                    this.speedX = Player.speedNormal;\r\n                }\r\n            }\r\n            if (engine.input.keyboard.wasReleased(ex.Input.Keys.Right)) {\r\n                if (engine.input.keyboard.isHeld(ex.Input.Keys.Left)) {\r\n                    this.speedX = Player.speedDec;\r\n                }\r\n                else {\r\n                    this.speedX = Player.speedNormal;\r\n                }\r\n            }\r\n            if (engine.input.keyboard.isHeld(ex.Input.Keys.Left) && engine.input.keyboard.isHeld(ex.Input.Keys.Right)) {\r\n                this.speedX = Player.speedNormal;\r\n            }\r\n            this.vel.x = this.speedX;\r\n            // check for Level ending -> better raise event in case of collision with level ending?\r\n            // Y movement\r\n            if (engine.input.keyboard.isHeld(ex.Input.Keys.Up)) {\r\n                this.moveUp();\r\n            }\r\n            if (engine.input.keyboard.isHeld(ex.Input.Keys.Down)) {\r\n                this.moveDown();\r\n            }\r\n        }\r\n    };\r\n    Player.prototype.die = function (info) {\r\n        if (!this.dead) {\r\n            this.dead = true;\r\n            this.kill();\r\n            alert(info);\r\n            var restartLabel = new ex.Label("Game Over.", (this.minX + this.maxX) / 2, (this.minY + this.maxY) / 2);\r\n            restartLabel.fontSize = 30;\r\n            this.scene.addUIActor(restartLabel);\r\n        }\r\n    };\r\n    Player.prototype.moveUp = function () {\r\n        // to not move too far into the sky\r\n        if (this.pos.y > (this.minY + 25)) {\r\n            this.pos.y -= Player.speedY;\r\n        }\r\n    };\r\n    Player.prototype.moveDown = function () {\r\n        if (this.pos.y < this.maxY) {\r\n            this.pos.y += Player.speedY;\r\n        }\r\n    };\r\n    Player.size = { w: 100, h: 50 }; // changed for swimming movement\r\n    // static speed: number = 8; //to be changed for normal/slower/faster swimming movement\r\n    Player.speedY = 2;\r\n    Player.speedAcc = 200;\r\n    Player.speedNormal = 100;\r\n    Player.speedDec = 50;\r\n    return Player;\r\n}(ex.Actor));\r\nexports.default = Player;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9QbGF5ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBSWhDO0lBQW9DLDBCQUFRO0lBdUIzQyxnQkFBWSxDQUFTLEVBQUUsQ0FBUyxFQUFFLFdBQTJCLEVBQUUsV0FBcUI7UUFBcEYsWUFDQyxrQkFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBZTVEO1FBeEJPLFlBQU0sR0FBVyxNQUFNLENBQUMsV0FBVyxDQUFDO1FBRXJDLGFBQU8sR0FBWSxLQUFLLENBQUMsQ0FBQyw4REFBOEQ7UUFDeEYsVUFBSSxHQUFZLEtBQUssQ0FBQztRQUd0QixpQkFBVyxHQUFXLEdBQUcsQ0FBQztRQUloQyxLQUFJLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pELEtBQUksQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEQsS0FBSSxDQUFDLElBQUksR0FBRyxXQUFXLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoRCxLQUFJLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRW5ELEtBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBRS9CLFNBQVM7UUFDVCxLQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxpREFBaUQ7UUFDOUUsa0NBQWtDO1FBRWxDLEtBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQzFDLEtBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUM7UUFDN0MsS0FBSSxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsS0FBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDOztJQUM5QyxDQUFDO0lBRUQsK0JBQWMsR0FBZCxVQUFlLEVBQU87UUFDckIsNEJBQTRCO1FBQzVCLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxXQUFXLEdBQUcsR0FBRyxDQUFDO1FBQ3hCLENBQUM7UUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3BFLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUNoRixDQUFDO0lBQ0YsQ0FBQztJQUVELHVCQUFNLEdBQU4sVUFBTyxNQUFpQixFQUFFLEtBQWE7UUFDdEMsaUJBQU0sTUFBTSxZQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUU1Qix1REFBdUQ7UUFDdkQsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUM7UUFDekIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsTUFBTSxDQUFDO1FBQ2pGLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzQixJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzFCLENBQUM7UUFFRCxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ25CLGFBQWE7WUFDYixFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMxRCxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUM7WUFDL0IsQ0FBQztZQUVELEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzNELElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztZQUMvQixDQUFDO1lBRUQsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDM0QsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDdkQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDO2dCQUMvQixDQUFDO2dCQUFDLElBQUksQ0FBQyxDQUFDO29CQUNQLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQztnQkFDbEMsQ0FBQztZQUNGLENBQUM7WUFFRCxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM1RCxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN0RCxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUM7Z0JBQy9CLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ1AsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO2dCQUNsQyxDQUFDO1lBQ0YsQ0FBQztZQUVELEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzRyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7WUFDbEMsQ0FBQztZQUVELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDekIsdUZBQXVGO1lBRXZGLGFBQWE7WUFDYixFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNwRCxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDZixDQUFDO1lBRUQsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdEQsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2pCLENBQUM7UUFDRixDQUFDO0lBR0YsQ0FBQztJQUVNLG9CQUFHLEdBQVYsVUFBVyxJQUFZO1FBQ3RCLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDaEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7WUFDakIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1osS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ1osSUFBSSxZQUFZLEdBQUcsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3hHLFlBQVksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO1lBQzNCLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3JDLENBQUM7SUFDRixDQUFDO0lBR08sdUJBQU0sR0FBZDtRQUNDLG1DQUFtQztRQUNuQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDN0IsQ0FBQztJQUNGLENBQUM7SUFFTyx5QkFBUSxHQUFoQjtRQUNDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzVCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDN0IsQ0FBQztJQUNGLENBQUM7SUEvSGUsV0FBSSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxnQ0FBZ0M7SUFFMUUsdUZBQXVGO0lBQ3ZFLGFBQU0sR0FBVyxDQUFDLENBQUM7SUFDbkIsZUFBUSxHQUFXLEdBQUcsQ0FBQztJQUN2QixrQkFBVyxHQUFXLEdBQUcsQ0FBQztJQUMxQixlQUFRLEdBQVcsRUFBRSxDQUFDO0lBMEh2QyxhQUFDO0NBQUEsQ0FsSW1DLEVBQUUsQ0FBQyxLQUFLLEdBa0kzQztrQkFsSW9CLE1BQU0iLCJmaWxlIjoiODkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XHJcbmltcG9ydCBTa3kgZnJvbSBcIi4vU2t5XCI7XHJcbmltcG9ydCBMZXZlbDIgZnJvbSBcIi4vTGV2ZWwyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXIgZXh0ZW5kcyBleC5BY3RvciB7XHJcblxyXG5cdHN0YXRpYyByZWFkb25seSBzaXplID0geyB3OiAxMDAsIGg6IDUwIH07IC8vIGNoYW5nZWQgZm9yIHN3aW1taW5nIG1vdmVtZW50XHJcblxyXG5cdC8vIHN0YXRpYyBzcGVlZDogbnVtYmVyID0gODsgLy90byBiZSBjaGFuZ2VkIGZvciBub3JtYWwvc2xvd2VyL2Zhc3RlciBzd2ltbWluZyBtb3ZlbWVudFxyXG5cdHN0YXRpYyByZWFkb25seSBzcGVlZFk6IG51bWJlciA9IDI7XHJcblx0c3RhdGljIHJlYWRvbmx5IHNwZWVkQWNjOiBudW1iZXIgPSAyMDA7XHJcblx0c3RhdGljIHJlYWRvbmx5IHNwZWVkTm9ybWFsOiBudW1iZXIgPSAxMDA7XHJcblx0c3RhdGljIHJlYWRvbmx5IHNwZWVkRGVjOiBudW1iZXIgPSA1MDtcclxuXHJcblx0cHJpdmF0ZSBtaW5YOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBtYXhYOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBtaW5ZOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBtYXhZOiBudW1iZXI7XHJcblxyXG5cdHByaXZhdGUgc3BlZWRYOiBudW1iZXIgPSBQbGF5ZXIuc3BlZWROb3JtYWw7XHJcblxyXG5cdHB1YmxpYyB0cmFwcGVkOiBib29sZWFuID0gZmFsc2U7IC8vIGZvciBkaXNhYmxpbmcgY29udHJvbHMgaW4gY2FzZSBvZiBiZWluZyB0cmFwcGVkIGJ5IGEgYnViYmxlXHJcblx0cHVibGljIGRlYWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0cHVibGljIG94eWdlbk1ldGVyOiBleC5MYWJlbDtcclxuXHRwdWJsaWMgb3h5Z2VuTGV2ZWw6IG51bWJlciA9IDEwMDtcclxuXHJcblx0Y29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIsIGxldmVsQm91bmRzOiBleC5Cb3VuZGluZ0JveCwgb3h5Z2VuTWV0ZXI6IGV4LkxhYmVsKSB7XHJcblx0XHRzdXBlcih4LCB5LCBQbGF5ZXIuc2l6ZS53LCBQbGF5ZXIuc2l6ZS5oLCBleC5Db2xvci5EYXJrR3JheSk7XHJcblx0XHR0aGlzLm1pblggPSBsZXZlbEJvdW5kcy5sZWZ0ICsgUGxheWVyLnNpemUudyAvIDI7XHJcblx0XHR0aGlzLm1heFggPSBsZXZlbEJvdW5kcy5yaWdodCAtIFBsYXllci5zaXplLncgLyAyO1xyXG5cdFx0dGhpcy5taW5ZID0gbGV2ZWxCb3VuZHMudG9wICsgUGxheWVyLnNpemUuaCAvIDI7XHJcblx0XHR0aGlzLm1heFkgPSBsZXZlbEJvdW5kcy5ib3R0b20gLSBQbGF5ZXIuc2l6ZS5oIC8gMjtcclxuXHJcblx0XHR0aGlzLm94eWdlbk1ldGVyID0gb3h5Z2VuTWV0ZXI7XHJcblxyXG5cdFx0Ly8gQW5jaG9yXHJcblx0XHR0aGlzLmFuY2hvci5zZXRUbygwLjUsIDAuNSk7IC8vIHNldCBhbmNob3IgdG8gdGhlIGNlbnRlciBvZiB0aGUgcmlnaHQgZWRnZSAoPylcclxuXHRcdC8vIHRoaXMueSArPSB0aGlzLmdldEhlaWdodCgpIC8gMjtcclxuXHJcblx0XHR0aGlzLmNvbGxpc2lvbkFyZWEuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcclxuXHRcdHRoaXMuY29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGUuQWN0aXZlO1xyXG5cdFx0dGhpcy5vbihcInByZWNvbGxpc2lvblwiLCB0aGlzLm9uUHJlY29sbGlzaW9uKTtcclxuXHR9XHJcblxyXG5cdG9uUHJlY29sbGlzaW9uKGV2OiBhbnkpIHtcclxuXHRcdC8vIFJlc2V0IE94eWdlbiBMZXZlbCB0byAxMDBcclxuXHRcdGlmIChldi5vdGhlci5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlNreVwiKSB7XHJcblx0XHRcdHRoaXMub3h5Z2VuTGV2ZWwgPSAxMDA7XHJcblx0XHR9IGVsc2UgaWYgKGV2Lm90aGVyLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiQnViYmxlXCIgJiYgIXRoaXMudHJhcHBlZCkgeyAvLyBCdWJibGVzIGFkZCAyMCBveHlnZW4gcG9pbnRzXHJcblx0XHRcdHRoaXMub3h5Z2VuTGV2ZWwgPSAodGhpcy5veHlnZW5MZXZlbCArIDIwKSA8IDEwMCA/IHRoaXMub3h5Z2VuTGV2ZWwgKyAyMCA6IDEwMDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHVwZGF0ZShlbmdpbmU6IGV4LkVuZ2luZSwgZGVsdGE6IG51bWJlcikge1xyXG5cdFx0c3VwZXIudXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG5cclxuXHRcdC8vIERlY3JlYXNlIE94eWdlbiBMZXZlbCBhbmQgZHJvd24gaWYgbm8gb3h5Z2VuIGlzIGxlZnRcclxuXHRcdHRoaXMub3h5Z2VuTGV2ZWwgLT0gMC4xMjtcclxuXHRcdHRoaXMub3h5Z2VuTWV0ZXIudGV4dCA9IFwiT3h5Z2VuIExldmVsOiBcIiArIE1hdGgucm91bmQodGhpcy5veHlnZW5MZXZlbCkgKyBcIi8xMDBcIjtcclxuXHRcdGlmICh0aGlzLm94eWdlbkxldmVsIDw9IDApIHtcclxuXHRcdFx0dGhpcy5kaWUoXCJZb3UgZHJvd25lZCFcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLnRyYXBwZWQpIHtcclxuXHRcdFx0Ly8gWCBtb3ZlbWVudFxyXG5cdFx0XHRpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLndhc1ByZXNzZWQoZXguSW5wdXQuS2V5cy5MZWZ0KSkge1xyXG5cdFx0XHRcdHRoaXMuc3BlZWRYID0gUGxheWVyLnNwZWVkRGVjO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLndhc1ByZXNzZWQoZXguSW5wdXQuS2V5cy5SaWdodCkpIHtcclxuXHRcdFx0XHR0aGlzLnNwZWVkWCA9IFBsYXllci5zcGVlZEFjYztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGVuZ2luZS5pbnB1dC5rZXlib2FyZC53YXNSZWxlYXNlZChleC5JbnB1dC5LZXlzLkxlZnQpKSB7XHJcblx0XHRcdFx0aWYgKGVuZ2luZS5pbnB1dC5rZXlib2FyZC5pc0hlbGQoZXguSW5wdXQuS2V5cy5SaWdodCkpIHtcclxuXHRcdFx0XHRcdHRoaXMuc3BlZWRYID0gUGxheWVyLnNwZWVkQWNjO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLnNwZWVkWCA9IFBsYXllci5zcGVlZE5vcm1hbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQud2FzUmVsZWFzZWQoZXguSW5wdXQuS2V5cy5SaWdodCkpIHtcclxuXHRcdFx0XHRpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLmlzSGVsZChleC5JbnB1dC5LZXlzLkxlZnQpKSB7XHJcblx0XHRcdFx0XHR0aGlzLnNwZWVkWCA9IFBsYXllci5zcGVlZERlYztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5zcGVlZFggPSBQbGF5ZXIuc3BlZWROb3JtYWw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLmlzSGVsZChleC5JbnB1dC5LZXlzLkxlZnQpICYmIGVuZ2luZS5pbnB1dC5rZXlib2FyZC5pc0hlbGQoZXguSW5wdXQuS2V5cy5SaWdodCkpIHtcclxuXHRcdFx0XHR0aGlzLnNwZWVkWCA9IFBsYXllci5zcGVlZE5vcm1hbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy52ZWwueCA9IHRoaXMuc3BlZWRYO1xyXG5cdFx0XHQvLyBjaGVjayBmb3IgTGV2ZWwgZW5kaW5nIC0+IGJldHRlciByYWlzZSBldmVudCBpbiBjYXNlIG9mIGNvbGxpc2lvbiB3aXRoIGxldmVsIGVuZGluZz9cclxuXHJcblx0XHRcdC8vIFkgbW92ZW1lbnRcclxuXHRcdFx0aWYgKGVuZ2luZS5pbnB1dC5rZXlib2FyZC5pc0hlbGQoZXguSW5wdXQuS2V5cy5VcCkpIHtcclxuXHRcdFx0XHR0aGlzLm1vdmVVcCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLmlzSGVsZChleC5JbnB1dC5LZXlzLkRvd24pKSB7XHJcblx0XHRcdFx0dGhpcy5tb3ZlRG93bigpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBkaWUoaW5mbzogc3RyaW5nKSB7XHJcblx0XHRpZiAoIXRoaXMuZGVhZCkge1xyXG5cdFx0XHR0aGlzLmRlYWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmtpbGwoKTtcclxuXHRcdFx0YWxlcnQoaW5mbyk7XHJcblx0XHRcdGxldCByZXN0YXJ0TGFiZWwgPSBuZXcgZXguTGFiZWwoXCJHYW1lIE92ZXIuXCIsICh0aGlzLm1pblggKyB0aGlzLm1heFgpIC8gMiwgKHRoaXMubWluWSArIHRoaXMubWF4WSkgLyAyKTtcclxuXHRcdFx0cmVzdGFydExhYmVsLmZvbnRTaXplID0gMzA7XHJcblx0XHRcdHRoaXMuc2NlbmUuYWRkVUlBY3RvcihyZXN0YXJ0TGFiZWwpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cdHByaXZhdGUgbW92ZVVwKCkge1xyXG5cdFx0Ly8gdG8gbm90IG1vdmUgdG9vIGZhciBpbnRvIHRoZSBza3lcclxuXHRcdGlmICh0aGlzLnBvcy55ID4gKHRoaXMubWluWSArIDI1KSkge1xyXG5cdFx0XHR0aGlzLnBvcy55IC09IFBsYXllci5zcGVlZFk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIG1vdmVEb3duKCkge1xyXG5cdFx0aWYgKHRoaXMucG9zLnkgPCB0aGlzLm1heFkpIHtcclxuXHRcdFx0dGhpcy5wb3MueSArPSBQbGF5ZXIuc3BlZWRZO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWwyL1BsYXllci50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///89\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar Bubble_1 = __webpack_require__(91);\r\n// class for cyclically creating new bubbles and adding them to the scene, in front of the player\r\nvar BubbleCreator = /** @class */ (function () {\r\n    function BubbleCreator(engine, scene, bounds, player, bubbles) {\r\n        this.timer = [-1]; // to be passed by reference\r\n        this.engine = engine;\r\n        this.scene = scene;\r\n        this.bounds = bounds;\r\n        this.player = player;\r\n        this.bubbles = bubbles;\r\n    }\r\n    BubbleCreator.prototype.start = function () {\r\n        console.log("bubbleCreator started! (Level2 - BubbleCreator - start())");\r\n        // start timer scheduling new bubble creations\r\n        var that = this;\r\n        this.timer[0] = setTimeout(function () {\r\n            that.createNewBubbleRT(that.scene, that.bounds, that.player, that.bubbles, that.timer);\r\n        }, 3000);\r\n    };\r\n    BubbleCreator.prototype.stop = function () {\r\n        // cancel timer // kill bubbles ? \r\n        console.log("bubbleCreator stopped! (Level2 - BubbleCreator - stop())");\r\n        if (this.timer[0] !== -1) {\r\n            clearInterval(this.timer[0]);\r\n        }\r\n    };\r\n    // TODO: random position(hitting the player based on it\'s current speed and y-distance?) & intervals\r\n    BubbleCreator.prototype.createNewBubbleRT = function (scene, bounds, player, bubbles, timer) {\r\n        console.log("creating new bubble... (Level2 - BubbleCreator - createNewBubbleRT()");\r\n        // determining speed of the next bubble\r\n        var speedXB = this.randomIntFromInterval(20, 100);\r\n        var speedYB = this.randomIntFromInterval(-100, -200);\r\n        // time until collision = y distance of bubble starting point (at the bottom) and player / y-speed of the bubble\r\n        var t = -1 * (bounds.bottom - player.y) / speedYB;\r\n        // console.log("t =    " + t);\r\n        // x of possible collision point = x position of player in t seconds\r\n        var xC = player.x + (t * player.vel.x);\r\n        // starting x of the bubble = collision x - x distance travelled by the bubble until collision\r\n        var xBStart = xC - speedXB * t;\r\n        // create new bubble in front of the player\r\n        // let x = player.x + 300;\r\n        var x = xBStart;\r\n        var newBubbleIndex = bubbles.push(new Bubble_1.default(x, bounds.bottom, speedXB, speedYB)) - 1;\r\n        scene.add(bubbles[newBubbleIndex]);\r\n        // create new timeout for next bubble\r\n        var nextBubbleInMS = this.randomIntFromInterval(1000, 3000);\r\n        var that = this;\r\n        timer[0] = setTimeout(function () {\r\n            that.createNewBubbleRT(scene, bounds, player, bubbles, timer);\r\n        }, nextBubbleInMS);\r\n    };\r\n    BubbleCreator.prototype.randomIntFromInterval = function (min, max) {\r\n        var t = Math.floor(Math.random() * (max - min + 1) + min);\r\n        return t;\r\n    };\r\n    return BubbleCreator;\r\n}());\r\nexports.default = BubbleCreator;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9CdWJibGVDcmVhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsdUNBQThCO0FBRzlCLGlHQUFpRztBQUVqRztJQVVDLHVCQUFZLE1BQWlCLEVBQUUsS0FBZSxFQUFFLE1BQXNCLEVBQUUsTUFBYyxFQUFFLE9BQWlCO1FBRnpHLFVBQUssR0FBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyw0QkFBNEI7UUFHbkQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDeEIsQ0FBQztJQUVELDZCQUFLLEdBQUw7UUFDQyxPQUFPLENBQUMsR0FBRyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7UUFFekUsOENBQThDO1FBQzlDLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztZQUMxQixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEYsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ1YsQ0FBQztJQUVELDRCQUFJLEdBQUo7UUFDQyxrQ0FBa0M7UUFDbEMsT0FBTyxDQUFDLEdBQUcsQ0FBQywwREFBMEQsQ0FBQyxDQUFDO1FBQ3hFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTFCLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUIsQ0FBQztJQUNGLENBQUM7SUFFRCxvR0FBb0c7SUFDcEcseUNBQWlCLEdBQWpCLFVBQWtCLEtBQWUsRUFBRSxNQUFzQixFQUFFLE1BQWMsRUFBRSxPQUFpQixFQUFFLEtBQWU7UUFDNUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzRUFBc0UsQ0FBQyxDQUFDO1FBRXBGLHVDQUF1QztRQUN2QyxJQUFJLE9BQU8sR0FBVyxJQUFJLENBQUMscUJBQXFCLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzFELElBQUksT0FBTyxHQUFXLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRTdELGdIQUFnSDtRQUNoSCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQztRQUNsRCw4QkFBOEI7UUFFOUIsb0VBQW9FO1FBQ3BFLElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV2Qyw4RkFBOEY7UUFDOUYsSUFBSSxPQUFPLEdBQUcsRUFBRSxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFFL0IsMkNBQTJDO1FBQzNDLDBCQUEwQjtRQUMxQixJQUFJLENBQUMsR0FBRyxPQUFPLENBQUM7UUFDaEIsSUFBSSxjQUFjLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLGdCQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RGLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFFbkMscUNBQXFDO1FBQ3JDLElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDNUQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2hCLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUM7WUFDckIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMvRCxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUVELDZDQUFxQixHQUFyQixVQUFzQixHQUFXLEVBQUUsR0FBVztRQUM3QyxJQUFJLENBQUMsR0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDbEUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRixvQkFBQztBQUFELENBQUMiLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XG5pbXBvcnQgQnViYmxlIGZyb20gXCIuL0J1YmJsZVwiO1xuaW1wb3J0IFBsYXllciBmcm9tIFwiLi9QbGF5ZXJcIjtcblxuLy8gY2xhc3MgZm9yIGN5Y2xpY2FsbHkgY3JlYXRpbmcgbmV3IGJ1YmJsZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBzY2VuZSwgaW4gZnJvbnQgb2YgdGhlIHBsYXllclxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWJibGVDcmVhdG9yIHtcblxuXHRlbmdpbmU6IGV4LkVuZ2luZTtcblx0c2NlbmU6IGV4LlNjZW5lO1xuXHRwbGF5ZXI6IFBsYXllcjtcblx0YnViYmxlczogQnViYmxlW107XG5cdGJvdW5kczogZXguQm91bmRpbmdCb3g7XG5cblx0dGltZXI6IG51bWJlcltdID0gWy0xXTsgLy8gdG8gYmUgcGFzc2VkIGJ5IHJlZmVyZW5jZVxuXG5cdGNvbnN0cnVjdG9yKGVuZ2luZTogZXguRW5naW5lLCBzY2VuZTogZXguU2NlbmUsIGJvdW5kczogZXguQm91bmRpbmdCb3gsIHBsYXllcjogUGxheWVyLCBidWJibGVzOiBCdWJibGVbXSkge1xuXHRcdHRoaXMuZW5naW5lID0gZW5naW5lO1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0XHR0aGlzLmJvdW5kcyA9IGJvdW5kcztcblx0XHR0aGlzLnBsYXllciA9IHBsYXllcjtcblx0XHR0aGlzLmJ1YmJsZXMgPSBidWJibGVzO1xuXHR9XG5cblx0c3RhcnQoKSB7XG5cdFx0Y29uc29sZS5sb2coXCJidWJibGVDcmVhdG9yIHN0YXJ0ZWQhIChMZXZlbDIgLSBCdWJibGVDcmVhdG9yIC0gc3RhcnQoKSlcIik7XG5cblx0XHQvLyBzdGFydCB0aW1lciBzY2hlZHVsaW5nIG5ldyBidWJibGUgY3JlYXRpb25zXG5cdFx0bGV0IHRoYXQgPSB0aGlzO1xuXHRcdHRoaXMudGltZXJbMF0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQuY3JlYXRlTmV3QnViYmxlUlQodGhhdC5zY2VuZSwgdGhhdC5ib3VuZHMsIHRoYXQucGxheWVyLCB0aGF0LmJ1YmJsZXMsIHRoYXQudGltZXIpO1xuXHRcdH0sIDMwMDApO1xuXHR9XG5cblx0c3RvcCgpIHtcblx0XHQvLyBjYW5jZWwgdGltZXIgLy8ga2lsbCBidWJibGVzID8gXG5cdFx0Y29uc29sZS5sb2coXCJidWJibGVDcmVhdG9yIHN0b3BwZWQhIChMZXZlbDIgLSBCdWJibGVDcmVhdG9yIC0gc3RvcCgpKVwiKTtcblx0XHRpZiAodGhpcy50aW1lclswXSAhPT0gLTEpIHtcblxuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyWzBdKTtcblx0XHR9XG5cdH1cblxuXHQvLyBUT0RPOiByYW5kb20gcG9zaXRpb24oaGl0dGluZyB0aGUgcGxheWVyIGJhc2VkIG9uIGl0J3MgY3VycmVudCBzcGVlZCBhbmQgeS1kaXN0YW5jZT8pICYgaW50ZXJ2YWxzXG5cdGNyZWF0ZU5ld0J1YmJsZVJUKHNjZW5lOiBleC5TY2VuZSwgYm91bmRzOiBleC5Cb3VuZGluZ0JveCwgcGxheWVyOiBQbGF5ZXIsIGJ1YmJsZXM6IEJ1YmJsZVtdLCB0aW1lcjogbnVtYmVyW10pIHtcblx0XHRjb25zb2xlLmxvZyhcImNyZWF0aW5nIG5ldyBidWJibGUuLi4gKExldmVsMiAtIEJ1YmJsZUNyZWF0b3IgLSBjcmVhdGVOZXdCdWJibGVSVCgpXCIpO1xuXG5cdFx0Ly8gZGV0ZXJtaW5pbmcgc3BlZWQgb2YgdGhlIG5leHQgYnViYmxlXG5cdFx0bGV0IHNwZWVkWEI6IG51bWJlciA9IHRoaXMucmFuZG9tSW50RnJvbUludGVydmFsKDIwLCAxMDApO1xuXHRcdGxldCBzcGVlZFlCOiBudW1iZXIgPSB0aGlzLnJhbmRvbUludEZyb21JbnRlcnZhbCgtMTAwLCAtMjAwKTtcblxuXHRcdC8vIHRpbWUgdW50aWwgY29sbGlzaW9uID0geSBkaXN0YW5jZSBvZiBidWJibGUgc3RhcnRpbmcgcG9pbnQgKGF0IHRoZSBib3R0b20pIGFuZCBwbGF5ZXIgLyB5LXNwZWVkIG9mIHRoZSBidWJibGVcblx0XHRsZXQgdCA9IC0xICogKGJvdW5kcy5ib3R0b20gLSBwbGF5ZXIueSkgLyBzcGVlZFlCO1xuXHRcdC8vIGNvbnNvbGUubG9nKFwidCA9ICAgIFwiICsgdCk7XG5cblx0XHQvLyB4IG9mIHBvc3NpYmxlIGNvbGxpc2lvbiBwb2ludCA9IHggcG9zaXRpb24gb2YgcGxheWVyIGluIHQgc2Vjb25kc1xuXHRcdGxldCB4QyA9IHBsYXllci54ICsgKHQgKiBwbGF5ZXIudmVsLngpO1xuXG5cdFx0Ly8gc3RhcnRpbmcgeCBvZiB0aGUgYnViYmxlID0gY29sbGlzaW9uIHggLSB4IGRpc3RhbmNlIHRyYXZlbGxlZCBieSB0aGUgYnViYmxlIHVudGlsIGNvbGxpc2lvblxuXHRcdGxldCB4QlN0YXJ0ID0geEMgLSBzcGVlZFhCICogdDtcblxuXHRcdC8vIGNyZWF0ZSBuZXcgYnViYmxlIGluIGZyb250IG9mIHRoZSBwbGF5ZXJcblx0XHQvLyBsZXQgeCA9IHBsYXllci54ICsgMzAwO1xuXHRcdGxldCB4ID0geEJTdGFydDtcblx0XHRsZXQgbmV3QnViYmxlSW5kZXggPSBidWJibGVzLnB1c2gobmV3IEJ1YmJsZSh4LCBib3VuZHMuYm90dG9tLCBzcGVlZFhCLCBzcGVlZFlCKSkgLSAxO1xuXHRcdHNjZW5lLmFkZChidWJibGVzW25ld0J1YmJsZUluZGV4XSk7XG5cblx0XHQvLyBjcmVhdGUgbmV3IHRpbWVvdXQgZm9yIG5leHQgYnViYmxlXG5cdFx0bGV0IG5leHRCdWJibGVJbk1TID0gdGhpcy5yYW5kb21JbnRGcm9tSW50ZXJ2YWwoMTAwMCwgMzAwMCk7XG5cdFx0bGV0IHRoYXQgPSB0aGlzO1xuXHRcdHRpbWVyWzBdID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0LmNyZWF0ZU5ld0J1YmJsZVJUKHNjZW5lLCBib3VuZHMsIHBsYXllciwgYnViYmxlcywgdGltZXIpO1xuXHRcdH0sIG5leHRCdWJibGVJbk1TKTtcblx0fVxuXG5cdHJhbmRvbUludEZyb21JbnRlcnZhbChtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdGxldCB0OiBudW1iZXIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pO1xuXHRcdHJldHVybiB0O1xuXHR9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9MZXZlbDIvQnViYmxlQ3JlYXRvci50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///90\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Resources_1 = __webpack_require__(7);\r\nvar Bubble = /** @class */ (function (_super) {\r\n    __extends(Bubble, _super);\r\n    function Bubble(x, y, speedX, speedY) {\r\n        var _this = _super.call(this, x, y, Bubble.size.w, Bubble.size.h, ex.Color.White) || this;\r\n        _this.playerCollision = false;\r\n        _this.playerTrapped = false;\r\n        _this.timer = -1;\r\n        // Anchor\r\n        _this.anchor.setTo(0.5, 0.5); // set anchor to the center\r\n        _this.collisionArea.body.useBoxCollision();\r\n        _this.collisionType = ex.CollisionType.Passive;\r\n        _this.vel = new ex.Vector(speedX, speedY);\r\n        // On collision check if Player and trap if true\r\n        _this.on("precollision", _this.onPrecollision);\r\n        return _this;\r\n    }\r\n    // raised every frame while colliding\r\n    Bubble.prototype.onPrecollision = function (ev) {\r\n        // console.log("precollision event raised");\r\n        // trap player if collided\r\n        // only if player not already in the sky\r\n        if (!this.playerCollision && ev.other.constructor.name === "Player" && !ev.other.trapped && this.y > Bubble.MINCOLLISIONY) {\r\n            console.log("1st-time PLAYER precollision event raised (Level2 - Bubble - onPrecollision())");\r\n            this.playerCollision = true;\r\n            this.playerTrapped = true;\r\n            this.collidedPlayer = ev.other;\r\n            if (this.collidedPlayer) {\r\n                this.collidedPlayer.trapped = true;\r\n                this.collidedPlayer.vel = this.vel;\r\n                // player position: to be moved towards the center of the bubble within tImbibe seconds\r\n                // extra velocity for tImbibe seconds\r\n                var dX = (this.x - this.collidedPlayer.x);\r\n                var dY = (this.y - this.collidedPlayer.y);\r\n                this.collidedPlayer.vel.x = this.collidedPlayer.vel.x + dX / Bubble.tImbibe;\r\n                this.collidedPlayer.vel.y = this.collidedPlayer.vel.y + dY / Bubble.tImbibe;\r\n                var that_1 = this;\r\n                this.timer = setTimeout(function () {\r\n                    if (that_1.collidedPlayer /*&& !that.isKilled()*/) {\r\n                        that_1.collidedPlayer.vel = that_1.vel;\r\n                    }\r\n                    that_1.timer = -1;\r\n                }, Bubble.tImbibe * 1000);\r\n            }\r\n        }\r\n        // kill bubble when reaching sky\r\n        if (ev.other.constructor.name === "Sky") {\r\n            this.kill();\r\n        }\r\n    };\r\n    Bubble.prototype.draw = function (ctx, delta) {\r\n        // Optionally call original \'base\' method\r\n        // ex.Actor.prototype.draw.call(this, ctx, delta)\r\n        // super.draw(ctx, delta);\r\n        // Custom draw code\r\n        /*\r\n        ctx.fillStyle = this.color.toString();\r\n        ctx.beginPath();\r\n        ctx.arc(this.pos.x, this.pos.y, 35, 0, Math.PI * 2);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        */\r\n        var sprite = Resources_1.default.bubble.asSprite();\r\n        sprite.draw(ctx, this.getCenter().x - 32, this.getCenter().y - 35);\r\n    };\r\n    Bubble.prototype.update = function (engine, delta) {\r\n        _super.prototype.update.call(this, engine, delta);\r\n    };\r\n    Bubble.prototype.kill = function () {\r\n        // clear timeout if necessary and free player\r\n        if (this.timer !== -1) {\r\n            clearTimeout(this.timer);\r\n        }\r\n        this.playerTrapped = false;\r\n        if (this.collidedPlayer) {\r\n            this.collidedPlayer.trapped = false;\r\n            this.collidedPlayer.vel = new ex.Vector(0, 0);\r\n        }\r\n        _super.prototype.kill.call(this);\r\n    };\r\n    Bubble.size = { w: 20, h: 20 };\r\n    // no influence on player if over a certain height -> depending on sky height and own size\r\n    Bubble.MINCOLLISIONY = Bubble.size.h / 2 + 50 + 1;\r\n    Bubble.speedY = -100;\r\n    Bubble.speedX = 50;\r\n    Bubble.tImbibe = 0.5;\r\n    return Bubble;\r\n}(ex.Actor));\r\nexports.default = Bubble;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9CdWJibGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBRWhDLHlDQUF3QztBQUV4QztJQUFvQywwQkFBUTtJQWdCM0MsZ0JBQVksQ0FBUyxFQUFFLENBQVMsRUFBRSxNQUFjLEVBQUUsTUFBYztRQUFoRSxZQUNDLGtCQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FZekQ7UUFsQkQscUJBQWUsR0FBWSxLQUFLLENBQUM7UUFDakMsbUJBQWEsR0FBWSxLQUFLLENBQUM7UUFFL0IsV0FBSyxHQUFXLENBQUMsQ0FBQyxDQUFDO1FBS2xCLFNBQVM7UUFDVCxLQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQywyQkFBMkI7UUFFeEQsS0FBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDMUMsS0FBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQztRQUU5QyxLQUFJLENBQUMsR0FBRyxHQUFHLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFekMsZ0RBQWdEO1FBQ2hELEtBQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLEtBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQzs7SUFDOUMsQ0FBQztJQUVELHFDQUFxQztJQUNyQywrQkFBYyxHQUFkLFVBQWUsRUFBTztRQUNyQiw0Q0FBNEM7UUFDNUMsMEJBQTBCO1FBQzFCLHdDQUF3QztRQUN4QyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLGFBQWMsQ0FBQyxDQUFDLENBQUM7WUFDNUgsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnRkFBZ0YsQ0FBQyxDQUFDO1lBQzlGLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO1lBQzVCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO1lBQzFCLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQztZQUMvQixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztnQkFDekIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO2dCQUNuQyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO2dCQUVuQyx1RkFBdUY7Z0JBQ3ZGLHFDQUFxQztnQkFDckMsSUFBSSxFQUFFLEdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xELElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsRCxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO2dCQUM1RSxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO2dCQUc1RSxJQUFJLE1BQUksR0FBVyxJQUFJLENBQUM7Z0JBQ3hCLElBQUksQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDO29CQUN2QixFQUFFLENBQUMsQ0FBQyxNQUFJLENBQUMsY0FBYyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQzt3QkFBQSxNQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsR0FBRyxNQUFJLENBQUMsR0FBRyxDQUFDO29CQUFBLENBQUM7b0JBQ3RGLE1BQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pCLENBQUMsRUFBRSxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDO1lBRTNCLENBQUM7UUFDRixDQUFDO1FBQ0QsZ0NBQWdDO1FBQ2hDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNiLENBQUM7SUFDRixDQUFDO0lBRUQscUJBQUksR0FBSixVQUFLLEdBQVEsRUFBRSxLQUFVO1FBQ3hCLHlDQUF5QztRQUN6QyxpREFBaUQ7UUFDakQsMEJBQTBCO1FBRTFCLG1CQUFtQjtRQUNuQjs7Ozs7O1VBTUU7UUFFRixJQUFJLE1BQU0sR0FBRyxtQkFBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUN6QyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRCx1QkFBTSxHQUFOLFVBQU8sTUFBaUIsRUFBRSxLQUFhO1FBQ3RDLGlCQUFNLE1BQU0sWUFBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVELHFCQUFJLEdBQUo7UUFDQyw2Q0FBNkM7UUFDN0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkIsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQixDQUFDO1FBRUQsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7UUFDM0IsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDekIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ3BDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxHQUFHLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDL0MsQ0FBQztRQUVELGlCQUFNLElBQUksV0FBRSxDQUFDO0lBQ2QsQ0FBQztJQXBHZSxXQUFJLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQztJQUV4QywwRkFBMEY7SUFDMUUsb0JBQWEsR0FBVyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUVuRCxhQUFNLEdBQVcsQ0FBQyxHQUFHLENBQUM7SUFDdEIsYUFBTSxHQUFXLEVBQUUsQ0FBQztJQUNwQixjQUFPLEdBQVcsR0FBRyxDQUFDO0lBK0Z2QyxhQUFDO0NBQUEsQ0F4R21DLEVBQUUsQ0FBQyxLQUFLLEdBd0czQztrQkF4R29CLE1BQU0iLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XHJcbmltcG9ydCBQbGF5ZXIgZnJvbSBcIi4vUGxheWVyXCI7XHJcbmltcG9ydCByZXNvdXJjZXMgZnJvbSBcIi4uLy4uL1Jlc291cmNlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnViYmxlIGV4dGVuZHMgZXguQWN0b3Ige1xyXG5cclxuXHRzdGF0aWMgcmVhZG9ubHkgc2l6ZSA9IHsgdzogMjAsIGg6IDIwIH07XHJcblxyXG5cdC8vIG5vIGluZmx1ZW5jZSBvbiBwbGF5ZXIgaWYgb3ZlciBhIGNlcnRhaW4gaGVpZ2h0IC0+IGRlcGVuZGluZyBvbiBza3kgaGVpZ2h0IGFuZCBvd24gc2l6ZVxyXG5cdHN0YXRpYyByZWFkb25seSBNSU5DT0xMSVNJT05ZOiBudW1iZXIgPSBCdWJibGUuc2l6ZS5oIC8gMiArIDUwICsgMTtcclxuXHJcblx0c3RhdGljIHJlYWRvbmx5IHNwZWVkWTogbnVtYmVyID0gLTEwMDtcclxuXHRzdGF0aWMgcmVhZG9ubHkgc3BlZWRYOiBudW1iZXIgPSA1MDtcclxuXHRzdGF0aWMgcmVhZG9ubHkgdEltYmliZTogbnVtYmVyID0gMC41O1xyXG5cclxuXHRwbGF5ZXJDb2xsaXNpb246IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwbGF5ZXJUcmFwcGVkOiBib29sZWFuID0gZmFsc2U7XHJcblx0Y29sbGlkZWRQbGF5ZXI6IFBsYXllciB8IHVuc2V0O1xyXG5cdHRpbWVyOiBudW1iZXIgPSAtMTtcclxuXHJcblx0Y29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIsIHNwZWVkWDogbnVtYmVyLCBzcGVlZFk6IG51bWJlcikge1xyXG5cdFx0c3VwZXIoeCwgeSwgQnViYmxlLnNpemUudywgQnViYmxlLnNpemUuaCwgZXguQ29sb3IuV2hpdGUpO1xyXG5cclxuXHRcdC8vIEFuY2hvclxyXG5cdFx0dGhpcy5hbmNob3Iuc2V0VG8oMC41LCAwLjUpOyAvLyBzZXQgYW5jaG9yIHRvIHRoZSBjZW50ZXJcclxuXHJcblx0XHR0aGlzLmNvbGxpc2lvbkFyZWEuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcclxuXHRcdHRoaXMuY29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGUuUGFzc2l2ZTtcclxuXHJcblx0XHR0aGlzLnZlbCA9IG5ldyBleC5WZWN0b3Ioc3BlZWRYLCBzcGVlZFkpO1xyXG5cclxuXHRcdC8vIE9uIGNvbGxpc2lvbiBjaGVjayBpZiBQbGF5ZXIgYW5kIHRyYXAgaWYgdHJ1ZVxyXG5cdFx0dGhpcy5vbihcInByZWNvbGxpc2lvblwiLCB0aGlzLm9uUHJlY29sbGlzaW9uKTtcclxuXHR9XHJcblxyXG5cdC8vIHJhaXNlZCBldmVyeSBmcmFtZSB3aGlsZSBjb2xsaWRpbmdcclxuXHRvblByZWNvbGxpc2lvbihldjogYW55KSB7XHJcblx0XHQvLyBjb25zb2xlLmxvZyhcInByZWNvbGxpc2lvbiBldmVudCByYWlzZWRcIik7XHJcblx0XHQvLyB0cmFwIHBsYXllciBpZiBjb2xsaWRlZFxyXG5cdFx0Ly8gb25seSBpZiBwbGF5ZXIgbm90IGFscmVhZHkgaW4gdGhlIHNreVxyXG5cdFx0aWYgKCF0aGlzLnBsYXllckNvbGxpc2lvbiAmJiBldi5vdGhlci5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlBsYXllclwiICYmICFldi5vdGhlci50cmFwcGVkICYmIHRoaXMueSA+IEJ1YmJsZS5NSU5DT0xMSVNJT05ZICkge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIjFzdC10aW1lIFBMQVlFUiBwcmVjb2xsaXNpb24gZXZlbnQgcmFpc2VkIChMZXZlbDIgLSBCdWJibGUgLSBvblByZWNvbGxpc2lvbigpKVwiKTtcclxuXHRcdFx0dGhpcy5wbGF5ZXJDb2xsaXNpb24gPSB0cnVlO1xyXG5cdFx0XHR0aGlzLnBsYXllclRyYXBwZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmNvbGxpZGVkUGxheWVyID0gZXYub3RoZXI7XHJcblx0XHRcdGlmICh0aGlzLmNvbGxpZGVkUGxheWVyKSB7XHJcblx0XHRcdFx0dGhpcy5jb2xsaWRlZFBsYXllci50cmFwcGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR0aGlzLmNvbGxpZGVkUGxheWVyLnZlbCA9IHRoaXMudmVsO1xyXG5cclxuXHRcdFx0XHQvLyBwbGF5ZXIgcG9zaXRpb246IHRvIGJlIG1vdmVkIHRvd2FyZHMgdGhlIGNlbnRlciBvZiB0aGUgYnViYmxlIHdpdGhpbiB0SW1iaWJlIHNlY29uZHNcclxuXHRcdFx0XHQvLyBleHRyYSB2ZWxvY2l0eSBmb3IgdEltYmliZSBzZWNvbmRzXHJcblx0XHRcdFx0bGV0IGRYOiBudW1iZXIgPSAodGhpcy54IC0gdGhpcy5jb2xsaWRlZFBsYXllci54KTtcclxuXHRcdFx0XHRsZXQgZFk6IG51bWJlciA9ICh0aGlzLnkgLSB0aGlzLmNvbGxpZGVkUGxheWVyLnkpO1xyXG5cdFx0XHRcdHRoaXMuY29sbGlkZWRQbGF5ZXIudmVsLnggPSB0aGlzLmNvbGxpZGVkUGxheWVyLnZlbC54ICsgZFggLyBCdWJibGUudEltYmliZTtcclxuXHRcdFx0XHR0aGlzLmNvbGxpZGVkUGxheWVyLnZlbC55ID0gdGhpcy5jb2xsaWRlZFBsYXllci52ZWwueSArIGRZIC8gQnViYmxlLnRJbWJpYmU7XHJcblxyXG5cclxuXHRcdFx0XHRsZXQgdGhhdDogQnViYmxlID0gdGhpcztcclxuXHRcdFx0XHR0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRpZiAodGhhdC5jb2xsaWRlZFBsYXllciAvKiYmICF0aGF0LmlzS2lsbGVkKCkqLykge3RoYXQuY29sbGlkZWRQbGF5ZXIudmVsID0gdGhhdC52ZWw7fVxyXG5cdFx0XHRcdFx0dGhhdC50aW1lciA9IC0xO1xyXG5cdFx0XHRcdH0sIEJ1YmJsZS50SW1iaWJlICogMTAwMCk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBraWxsIGJ1YmJsZSB3aGVuIHJlYWNoaW5nIHNreVxyXG5cdFx0aWYgKGV2Lm90aGVyLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiU2t5XCIpIHtcclxuXHRcdFx0dGhpcy5raWxsKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkcmF3KGN0eDogYW55LCBkZWx0YTogYW55KSB7XHJcblx0XHQvLyBPcHRpb25hbGx5IGNhbGwgb3JpZ2luYWwgJ2Jhc2UnIG1ldGhvZFxyXG5cdFx0Ly8gZXguQWN0b3IucHJvdG90eXBlLmRyYXcuY2FsbCh0aGlzLCBjdHgsIGRlbHRhKVxyXG5cdFx0Ly8gc3VwZXIuZHJhdyhjdHgsIGRlbHRhKTtcclxuXHJcblx0XHQvLyBDdXN0b20gZHJhdyBjb2RlXHJcblx0XHQvKlxyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3IudG9TdHJpbmcoKTtcclxuXHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdGN0eC5hcmModGhpcy5wb3MueCwgdGhpcy5wb3MueSwgMzUsIDAsIE1hdGguUEkgKiAyKTtcclxuXHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdGN0eC5maWxsKCk7XHJcblx0XHQqL1xyXG5cclxuXHRcdGxldCBzcHJpdGUgPSByZXNvdXJjZXMuYnViYmxlLmFzU3ByaXRlKCk7XHJcblx0XHRzcHJpdGUuZHJhdyhjdHgsIHRoaXMuZ2V0Q2VudGVyKCkueCAtIDMyLCB0aGlzLmdldENlbnRlcigpLnkgLSAzNSk7XHJcblx0fVxyXG5cclxuXHR1cGRhdGUoZW5naW5lOiBleC5FbmdpbmUsIGRlbHRhOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuXHR9XHJcblxyXG5cdGtpbGwoKSB7XHJcblx0XHQvLyBjbGVhciB0aW1lb3V0IGlmIG5lY2Vzc2FyeSBhbmQgZnJlZSBwbGF5ZXJcclxuXHRcdGlmICh0aGlzLnRpbWVyICE9PSAtMSkge1xyXG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5wbGF5ZXJUcmFwcGVkID0gZmFsc2U7XHJcblx0XHRpZiAodGhpcy5jb2xsaWRlZFBsYXllcikge1xyXG5cdFx0XHR0aGlzLmNvbGxpZGVkUGxheWVyLnRyYXBwZWQgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5jb2xsaWRlZFBsYXllci52ZWwgPSBuZXcgZXguVmVjdG9yKDAsIDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN1cGVyLmtpbGwoKTtcclxuXHR9XHJcblxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9MZXZlbDIvQnViYmxlLnRzIl0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///91\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar Crocodile_1 = __webpack_require__(93);\r\n// class for cyclically creating new bubbles and adding them to the scene, in front of the player\r\nvar CrocodileCreator = /** @class */ (function () {\r\n    function CrocodileCreator(bootstrap, scene, bounds, player, crocodiles) {\r\n        this.timer = [-1]; // to be passed by reference\r\n        this.engine = bootstrap.engine;\r\n        this.scene = scene;\r\n        this.bounds = bounds;\r\n        this.player = player;\r\n        this.crocodiles = crocodiles;\r\n        this.bootstrap = bootstrap;\r\n    }\r\n    CrocodileCreator.prototype.start = function () {\r\n        var _this = this;\r\n        console.log("crocodileCreator started! (Level2 - CrocodileCreator - start())");\r\n        // start timer scheduling new crocodile creations\r\n        this.timer[0] = setTimeout(function () {\r\n            _this.createNewCrocodileRT(_this.scene, _this.bounds, _this.player, _this.crocodiles, _this.timer);\r\n        }, 1500);\r\n    };\r\n    CrocodileCreator.prototype.stop = function () {\r\n        // cancel timer // kill bubbles ?\r\n        console.log("crocodileCreator stopped! (Level2 - CrocodileCreator - stop())");\r\n        if (this.timer[0] !== -1) {\r\n            clearInterval(this.timer[0]);\r\n        }\r\n    };\r\n    CrocodileCreator.prototype.createNewCrocodileRT = function (scene, bounds, player, crocodiles, timer) {\r\n        console.log("creating new bubble... (Level2 - CrocodileCreator - createNewCrocodileRT()");\r\n        // determining speed of the next bubble\r\n        var speedXB = this.randomIntFromInterval(-20, -100);\r\n        var speedYB = this.randomIntFromInterval(0, 0);\r\n        // time until collision = y distance of bubble starting point (at the bottom) and player / y-speed of the bubble\r\n        var t = -1 * (bounds.bottom - player.y) / speedYB;\r\n        // console.log("t =    " + t);\r\n        // x of possible collision point = x position of player in t seconds\r\n        var xC = player.x + (t * player.vel.x);\r\n        // starting x of the bubble = collision x - x distance travelled by the bubble until collision\r\n        var xBStart = xC - speedXB * t;\r\n        // create new bubble in front of the player\r\n        var x = player.x + 1000;\r\n        // let x = xBStart;\r\n        var newCrocodileIndex = crocodiles.push(new Crocodile_1.default(this.bootstrap, x, this.randomIntFromInterval(40, bounds.bottom - 60), speedXB, speedYB)) - 1;\r\n        scene.add(crocodiles[newCrocodileIndex]);\r\n        // create new timeout for next bubble\r\n        var nextCrocodileInMS = this.randomIntFromInterval(1500, 3000);\r\n        var that = this;\r\n        timer[0] = setTimeout(function () {\r\n            that.createNewCrocodileRT(scene, bounds, player, crocodiles, timer);\r\n        }, nextCrocodileInMS);\r\n    };\r\n    CrocodileCreator.prototype.randomIntFromInterval = function (min, max) {\r\n        var t = Math.floor(Math.random() * (max - min + 1) + min);\r\n        return t;\r\n    };\r\n    return CrocodileCreator;\r\n}());\r\nexports.default = CrocodileCreator;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9Dcm9jb2RpbGVDcmVhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsMENBQW9DO0FBSXBDLGlHQUFpRztBQUNqRztJQVdDLDBCQUFZLFNBQXdCLEVBQUUsS0FBZSxFQUFFLE1BQXNCLEVBQUUsTUFBYyxFQUFFLFVBQXVCO1FBRnRILFVBQUssR0FBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyw0QkFBNEI7UUFHbkQsSUFBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQy9CLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBQzdCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0lBQzVCLENBQUM7SUFFRCxnQ0FBSyxHQUFMO1FBQUEsaUJBT0M7UUFOQSxPQUFPLENBQUMsR0FBRyxDQUFDLGlFQUFpRSxDQUFDLENBQUM7UUFFL0UsaURBQWlEO1FBQ2pELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO1lBQzFCLEtBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFJLENBQUMsS0FBSyxFQUFFLEtBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSSxDQUFDLE1BQU0sRUFBRSxLQUFJLENBQUMsVUFBVSxFQUFFLEtBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5RixDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDVixDQUFDO0lBRUQsK0JBQUksR0FBSjtRQUNDLGlDQUFpQztRQUNqQyxPQUFPLENBQUMsR0FBRyxDQUFDLGdFQUFnRSxDQUFDLENBQUM7UUFDOUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUIsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5QixDQUFDO0lBQ0YsQ0FBQztJQUVELCtDQUFvQixHQUFwQixVQUFxQixLQUFlLEVBQUUsTUFBc0IsRUFBRSxNQUFjLEVBQUUsVUFBdUIsRUFBRSxLQUFlO1FBQ3JILE9BQU8sQ0FBQyxHQUFHLENBQUMsNEVBQTRFLENBQUMsQ0FBQztRQUUxRix1Q0FBdUM7UUFDdkMsSUFBSSxPQUFPLEdBQVcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUQsSUFBSSxPQUFPLEdBQVcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUV2RCxnSEFBZ0g7UUFDaEgsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUM7UUFDbEQsOEJBQThCO1FBRTlCLG9FQUFvRTtRQUNwRSxJQUFJLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFdkMsOEZBQThGO1FBQzlGLElBQUksT0FBTyxHQUFHLEVBQUUsR0FBRyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBRS9CLDJDQUEyQztRQUMzQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN4QixtQkFBbUI7UUFDbkIsSUFBSSxpQkFBaUIsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksbUJBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMscUJBQXFCLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3BKLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztRQUV6QyxxQ0FBcUM7UUFDckMsSUFBSSxpQkFBaUIsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQy9ELElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUNoQixLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDckUsQ0FBQyxFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVELGdEQUFxQixHQUFyQixVQUFzQixHQUFXLEVBQUUsR0FBVztRQUM3QyxJQUFJLENBQUMsR0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDbEUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRix1QkFBQztBQUFELENBQUMiLCJmaWxlIjoiOTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XG5pbXBvcnQgQ3JvY29kaWxlIGZyb20gXCIuL0Nyb2NvZGlsZVwiO1xuaW1wb3J0IFBsYXllciBmcm9tIFwiLi9QbGF5ZXJcIjtcbmltcG9ydCB7IEdhbWVCb290c3RyYXAgfSBmcm9tIFwiLi4vLi4vR2FtZUJvb3RzdHJhcFwiO1xuXG4vLyBjbGFzcyBmb3IgY3ljbGljYWxseSBjcmVhdGluZyBuZXcgYnViYmxlcyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlIHNjZW5lLCBpbiBmcm9udCBvZiB0aGUgcGxheWVyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDcm9jb2RpbGVDcmVhdG9yIHtcblxuXHRlbmdpbmU6IGV4LkVuZ2luZTtcblx0c2NlbmU6IGV4LlNjZW5lO1xuXHRwbGF5ZXI6IFBsYXllcjtcblx0Y3JvY29kaWxlczogQ3JvY29kaWxlW107XG5cdGJvdW5kczogZXguQm91bmRpbmdCb3g7XG5cdGJvb3RzdHJhcDogR2FtZUJvb3RzdHJhcDtcblxuXHR0aW1lcjogbnVtYmVyW10gPSBbLTFdOyAvLyB0byBiZSBwYXNzZWQgYnkgcmVmZXJlbmNlXG5cblx0Y29uc3RydWN0b3IoYm9vdHN0cmFwOiBHYW1lQm9vdHN0cmFwLCBzY2VuZTogZXguU2NlbmUsIGJvdW5kczogZXguQm91bmRpbmdCb3gsIHBsYXllcjogUGxheWVyLCBjcm9jb2RpbGVzOiBDcm9jb2RpbGVbXSkge1xuXHRcdHRoaXMuZW5naW5lID0gYm9vdHN0cmFwLmVuZ2luZTtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdFx0dGhpcy5ib3VuZHMgPSBib3VuZHM7XG5cdFx0dGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG5cdFx0dGhpcy5jcm9jb2RpbGVzID0gY3JvY29kaWxlcztcblx0XHR0aGlzLmJvb3RzdHJhcCA9IGJvb3RzdHJhcDtcblx0fVxuXG5cdHN0YXJ0KCkge1xuXHRcdGNvbnNvbGUubG9nKFwiY3JvY29kaWxlQ3JlYXRvciBzdGFydGVkISAoTGV2ZWwyIC0gQ3JvY29kaWxlQ3JlYXRvciAtIHN0YXJ0KCkpXCIpO1xuXG5cdFx0Ly8gc3RhcnQgdGltZXIgc2NoZWR1bGluZyBuZXcgY3JvY29kaWxlIGNyZWF0aW9uc1xuXHRcdHRoaXMudGltZXJbMF0gPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHRoaXMuY3JlYXRlTmV3Q3JvY29kaWxlUlQodGhpcy5zY2VuZSwgdGhpcy5ib3VuZHMsIHRoaXMucGxheWVyLCB0aGlzLmNyb2NvZGlsZXMsIHRoaXMudGltZXIpO1xuXHRcdH0sIDE1MDApO1xuXHR9XG5cblx0c3RvcCgpIHtcblx0XHQvLyBjYW5jZWwgdGltZXIgLy8ga2lsbCBidWJibGVzID9cblx0XHRjb25zb2xlLmxvZyhcImNyb2NvZGlsZUNyZWF0b3Igc3RvcHBlZCEgKExldmVsMiAtIENyb2NvZGlsZUNyZWF0b3IgLSBzdG9wKCkpXCIpO1xuXHRcdGlmICh0aGlzLnRpbWVyWzBdICE9PSAtMSkge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyWzBdKTtcblx0XHR9XG5cdH1cblxuXHRjcmVhdGVOZXdDcm9jb2RpbGVSVChzY2VuZTogZXguU2NlbmUsIGJvdW5kczogZXguQm91bmRpbmdCb3gsIHBsYXllcjogUGxheWVyLCBjcm9jb2RpbGVzOiBDcm9jb2RpbGVbXSwgdGltZXI6IG51bWJlcltdKSB7XG5cdFx0Y29uc29sZS5sb2coXCJjcmVhdGluZyBuZXcgYnViYmxlLi4uIChMZXZlbDIgLSBDcm9jb2RpbGVDcmVhdG9yIC0gY3JlYXRlTmV3Q3JvY29kaWxlUlQoKVwiKTtcblxuXHRcdC8vIGRldGVybWluaW5nIHNwZWVkIG9mIHRoZSBuZXh0IGJ1YmJsZVxuXHRcdGxldCBzcGVlZFhCOiBudW1iZXIgPSB0aGlzLnJhbmRvbUludEZyb21JbnRlcnZhbCgtMjAsIC0xMDApO1xuXHRcdGxldCBzcGVlZFlCOiBudW1iZXIgPSB0aGlzLnJhbmRvbUludEZyb21JbnRlcnZhbCgwLCAwKTtcblxuXHRcdC8vIHRpbWUgdW50aWwgY29sbGlzaW9uID0geSBkaXN0YW5jZSBvZiBidWJibGUgc3RhcnRpbmcgcG9pbnQgKGF0IHRoZSBib3R0b20pIGFuZCBwbGF5ZXIgLyB5LXNwZWVkIG9mIHRoZSBidWJibGVcblx0XHRsZXQgdCA9IC0xICogKGJvdW5kcy5ib3R0b20gLSBwbGF5ZXIueSkgLyBzcGVlZFlCO1xuXHRcdC8vIGNvbnNvbGUubG9nKFwidCA9ICAgIFwiICsgdCk7XG5cblx0XHQvLyB4IG9mIHBvc3NpYmxlIGNvbGxpc2lvbiBwb2ludCA9IHggcG9zaXRpb24gb2YgcGxheWVyIGluIHQgc2Vjb25kc1xuXHRcdGxldCB4QyA9IHBsYXllci54ICsgKHQgKiBwbGF5ZXIudmVsLngpO1xuXG5cdFx0Ly8gc3RhcnRpbmcgeCBvZiB0aGUgYnViYmxlID0gY29sbGlzaW9uIHggLSB4IGRpc3RhbmNlIHRyYXZlbGxlZCBieSB0aGUgYnViYmxlIHVudGlsIGNvbGxpc2lvblxuXHRcdGxldCB4QlN0YXJ0ID0geEMgLSBzcGVlZFhCICogdDtcblxuXHRcdC8vIGNyZWF0ZSBuZXcgYnViYmxlIGluIGZyb250IG9mIHRoZSBwbGF5ZXJcblx0XHRsZXQgeCA9IHBsYXllci54ICsgMTAwMDtcblx0XHQvLyBsZXQgeCA9IHhCU3RhcnQ7XG5cdFx0bGV0IG5ld0Nyb2NvZGlsZUluZGV4ID0gY3JvY29kaWxlcy5wdXNoKG5ldyBDcm9jb2RpbGUodGhpcy5ib290c3RyYXAsIHgsIHRoaXMucmFuZG9tSW50RnJvbUludGVydmFsKDQwLCBib3VuZHMuYm90dG9tIC0gNjApLCBzcGVlZFhCLCBzcGVlZFlCKSkgLSAxO1xuXHRcdHNjZW5lLmFkZChjcm9jb2RpbGVzW25ld0Nyb2NvZGlsZUluZGV4XSk7XG5cblx0XHQvLyBjcmVhdGUgbmV3IHRpbWVvdXQgZm9yIG5leHQgYnViYmxlXG5cdFx0bGV0IG5leHRDcm9jb2RpbGVJbk1TID0gdGhpcy5yYW5kb21JbnRGcm9tSW50ZXJ2YWwoMTUwMCwgMzAwMCk7XG5cdFx0bGV0IHRoYXQgPSB0aGlzO1xuXHRcdHRpbWVyWzBdID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0LmNyZWF0ZU5ld0Nyb2NvZGlsZVJUKHNjZW5lLCBib3VuZHMsIHBsYXllciwgY3JvY29kaWxlcywgdGltZXIpO1xuXHRcdH0sIG5leHRDcm9jb2RpbGVJbk1TKTtcblx0fVxuXG5cdHJhbmRvbUludEZyb21JbnRlcnZhbChtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdGxldCB0OiBudW1iZXIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pO1xuXHRcdHJldHVybiB0O1xuXHR9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9MZXZlbDIvQ3JvY29kaWxlQ3JlYXRvci50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///92\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Resources_1 = __webpack_require__(7);\r\nvar Crocodile = /** @class */ (function (_super) {\r\n    __extends(Crocodile, _super);\r\n    function Crocodile(bootstrap, x, y, speedX, speedY) {\r\n        var _this = _super.call(this, x, y, Crocodile.size.w, Crocodile.size.h, ex.Color.Green) || this;\r\n        _this.bootstrap = bootstrap;\r\n        // Anchor\r\n        _this.anchor.setTo(0.5, 0.5); // set anchor to the center of the right edge (?)\r\n        _this.collisionArea.body.useBoxCollision();\r\n        _this.collisionType = ex.CollisionType.Active;\r\n        _this.vel = new ex.Vector(speedX, speedY);\r\n        // On collision check if Player and trapp if true\r\n        _this.on("precollision", _this.onPrecollision);\r\n        // Sprite drawings\r\n        var spriteSheet = new ex.SpriteSheet(Resources_1.default.crocodile, 1, 8, Crocodile.size.w, Crocodile.size.h);\r\n        var animation = spriteSheet.getAnimationForAll(bootstrap.engine, 100);\r\n        _this.addDrawing("idle", animation);\r\n        return _this;\r\n    }\r\n    // raised every frame while colliding\r\n    Crocodile.prototype.onPrecollision = function (ev) {\r\n        // Trap player if collided\r\n        if (ev.other.constructor.name === "Player") {\r\n            var player = ev.other;\r\n            console.log("1st-time PLAYER precollision event raised (Level2 - Crocodile - onPrecollision())");\r\n            player.die("You got eaten by a crocodile!");\r\n        }\r\n    };\r\n    Crocodile.prototype.draw = function (ctx, delta) {\r\n        _super.prototype.draw.call(this, ctx, delta);\r\n        // Drawing asset\r\n        // let sprite = this.crocodileTexture.asSprite();\r\n        // sprite.draw(ctx, this.getRight(), this.getCenter().y);\r\n    };\r\n    Crocodile.prototype.update = function (engine, delta) {\r\n        _super.prototype.update.call(this, engine, delta);\r\n    };\r\n    Crocodile.size = { w: 202, h: 50 };\r\n    Crocodile.speedY = -30;\r\n    Crocodile.speedX = 10;\r\n    return Crocodile;\r\n}(ex.Actor));\r\nexports.default = Crocodile;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9Dcm9jb2RpbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBRWhDLHlDQUF3QztBQUd4QztJQUF1Qyw2QkFBUTtJQU85QyxtQkFBWSxTQUF3QixFQUFFLENBQVMsRUFBRSxDQUFTLEVBQUUsTUFBYyxFQUFFLE1BQWM7UUFBMUYsWUFDQyxrQkFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBbUIvRDtRQWpCQSxLQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUUzQixTQUFTO1FBQ1QsS0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsaURBQWlEO1FBRTlFLEtBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQzFDLEtBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUM7UUFFN0MsS0FBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRXpDLGlEQUFpRDtRQUNqRCxLQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxLQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFN0Msa0JBQWtCO1FBQ2xCLElBQU0sV0FBVyxHQUFHLElBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxtQkFBUyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEcsSUFBTSxTQUFTLEdBQUcsV0FBVyxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDeEUsS0FBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsU0FBZ0IsQ0FBQyxDQUFDOztJQUMzQyxDQUFDO0lBRUQscUNBQXFDO0lBQ3JDLGtDQUFjLEdBQWQsVUFBZSxFQUFPO1FBQ3JCLDBCQUEwQjtRQUMxQixFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJLE1BQU0sR0FBVyxFQUFFLENBQUMsS0FBSyxDQUFDO1lBQzlCLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUZBQW1GLENBQUMsQ0FBQztZQUNqRyxNQUFNLENBQUMsR0FBRyxDQUFDLCtCQUErQixDQUFDLENBQUM7UUFDN0MsQ0FBQztJQUNGLENBQUM7SUFFRCx3QkFBSSxHQUFKLFVBQUssR0FBNkIsRUFBRSxLQUFhO1FBQ2hELGlCQUFNLElBQUksWUFBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDdkIsZ0JBQWdCO1FBQ2hCLGlEQUFpRDtRQUNqRCx5REFBeUQ7SUFDMUQsQ0FBQztJQUVELDBCQUFNLEdBQU4sVUFBTyxNQUFpQixFQUFFLEtBQWE7UUFDdEMsaUJBQU0sTUFBTSxZQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBOUNlLGNBQUksR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDO0lBQ3pCLGdCQUFNLEdBQVcsQ0FBQyxFQUFFLENBQUM7SUFDckIsZ0JBQU0sR0FBVyxFQUFFLENBQUM7SUE4Q3JDLGdCQUFDO0NBQUEsQ0FsRHNDLEVBQUUsQ0FBQyxLQUFLLEdBa0Q5QztrQkFsRG9CLFNBQVMiLCJmaWxlIjoiOTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XG5pbXBvcnQgUGxheWVyIGZyb20gXCIuL1BsYXllclwiO1xuaW1wb3J0IHJlc291cmNlcyBmcm9tIFwiLi4vLi4vUmVzb3VyY2VzXCI7XG5pbXBvcnQgeyBHYW1lQm9vdHN0cmFwIH0gZnJvbSBcIi4uLy4uL0dhbWVCb290c3RyYXBcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3JvY29kaWxlIGV4dGVuZHMgZXguQWN0b3Ige1xuXG5cdHN0YXRpYyByZWFkb25seSBzaXplID0geyB3OiAyMDIsIGg6IDUwIH07XG5cdHN0YXRpYyByZWFkb25seSBzcGVlZFk6IG51bWJlciA9IC0zMDtcblx0c3RhdGljIHJlYWRvbmx5IHNwZWVkWDogbnVtYmVyID0gMTA7XG5cdHByaXZhdGUgcmVhZG9ubHkgYm9vdHN0cmFwOiBHYW1lQm9vdHN0cmFwO1xuXG5cdGNvbnN0cnVjdG9yKGJvb3RzdHJhcDogR2FtZUJvb3RzdHJhcCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIHNwZWVkWDogbnVtYmVyLCBzcGVlZFk6IG51bWJlcikge1xuXHRcdHN1cGVyKHgsIHksIENyb2NvZGlsZS5zaXplLncsIENyb2NvZGlsZS5zaXplLmgsIGV4LkNvbG9yLkdyZWVuKTtcblxuXHRcdHRoaXMuYm9vdHN0cmFwID0gYm9vdHN0cmFwO1xuXG5cdFx0Ly8gQW5jaG9yXG5cdFx0dGhpcy5hbmNob3Iuc2V0VG8oMC41LCAwLjUpOyAvLyBzZXQgYW5jaG9yIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHJpZ2h0IGVkZ2UgKD8pXG5cblx0XHR0aGlzLmNvbGxpc2lvbkFyZWEuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcblx0XHR0aGlzLmNvbGxpc2lvblR5cGUgPSBleC5Db2xsaXNpb25UeXBlLkFjdGl2ZTtcblxuXHRcdHRoaXMudmVsID0gbmV3IGV4LlZlY3RvcihzcGVlZFgsIHNwZWVkWSk7XG5cblx0XHQvLyBPbiBjb2xsaXNpb24gY2hlY2sgaWYgUGxheWVyIGFuZCB0cmFwcCBpZiB0cnVlXG5cdFx0dGhpcy5vbihcInByZWNvbGxpc2lvblwiLCB0aGlzLm9uUHJlY29sbGlzaW9uKTtcblxuXHRcdC8vIFNwcml0ZSBkcmF3aW5nc1xuXHRcdGNvbnN0IHNwcml0ZVNoZWV0ID0gbmV3IGV4LlNwcml0ZVNoZWV0KHJlc291cmNlcy5jcm9jb2RpbGUsIDEsIDgsIENyb2NvZGlsZS5zaXplLncsIENyb2NvZGlsZS5zaXplLmgpO1xuXHRcdGNvbnN0IGFuaW1hdGlvbiA9IHNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbkZvckFsbChib290c3RyYXAuZW5naW5lLCAxMDApO1xuXHRcdHRoaXMuYWRkRHJhd2luZyhcImlkbGVcIiwgYW5pbWF0aW9uIGFzIGFueSk7XG5cdH1cblxuXHQvLyByYWlzZWQgZXZlcnkgZnJhbWUgd2hpbGUgY29sbGlkaW5nXG5cdG9uUHJlY29sbGlzaW9uKGV2OiBhbnkpIHtcblx0XHQvLyBUcmFwIHBsYXllciBpZiBjb2xsaWRlZFxuXHRcdGlmIChldi5vdGhlci5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlBsYXllclwiKSB7XG5cdFx0XHRsZXQgcGxheWVyOiBQbGF5ZXIgPSBldi5vdGhlcjtcblx0XHRcdGNvbnNvbGUubG9nKFwiMXN0LXRpbWUgUExBWUVSIHByZWNvbGxpc2lvbiBldmVudCByYWlzZWQgKExldmVsMiAtIENyb2NvZGlsZSAtIG9uUHJlY29sbGlzaW9uKCkpXCIpO1xuXHRcdFx0cGxheWVyLmRpZShcIllvdSBnb3QgZWF0ZW4gYnkgYSBjcm9jb2RpbGUhXCIpO1xuXHRcdH1cblx0fVxuXG5cdGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGRlbHRhOiBudW1iZXIpIHtcblx0XHRzdXBlci5kcmF3KGN0eCwgZGVsdGEpO1xuXHRcdC8vIERyYXdpbmcgYXNzZXRcblx0XHQvLyBsZXQgc3ByaXRlID0gdGhpcy5jcm9jb2RpbGVUZXh0dXJlLmFzU3ByaXRlKCk7XG5cdFx0Ly8gc3ByaXRlLmRyYXcoY3R4LCB0aGlzLmdldFJpZ2h0KCksIHRoaXMuZ2V0Q2VudGVyKCkueSk7XG5cdH1cblxuXHR1cGRhdGUoZW5naW5lOiBleC5FbmdpbmUsIGRlbHRhOiBudW1iZXIpIHtcblx0XHRzdXBlci51cGRhdGUoZW5naW5lLCBkZWx0YSk7XG5cdH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsMi9Dcm9jb2RpbGUudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///93\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Class_1 = __webpack_require__(5);\r\nvar LockLevelCameraStrategy_1 = __webpack_require__(16);\r\nvar Ground_1 = __webpack_require__(95);\r\nvar Player_1 = __webpack_require__(96);\r\nvar RockCreator_1 = __webpack_require__(97);\r\nvar Level3 = /** @class */ (function (_super) {\r\n    __extends(Level3, _super);\r\n    function Level3(bootstrap) {\r\n        var _this = _super.call(this) || this;\r\n        _this.sceneKey = "level3";\r\n        _this.levelBounds = new ex.BoundingBox(0, 0, 5000, 600);\r\n        _this.sceneBackgroundColor = ex.Color.DarkGray;\r\n        _this.buildScene = function () {\r\n            // add actors\r\n            _this.scene.add(_this.ground);\r\n            _this.scene.add(_this.player);\r\n            // start rockCreator\r\n            _this.rockCreator.start();\r\n            _this.engine.addScene(_this.sceneKey, _this.scene);\r\n            _this.engine.goToScene(_this.sceneKey);\r\n        };\r\n        _this.engine = bootstrap.engine;\r\n        _this.scene = new ex.Scene(_this.engine);\r\n        _this.bounds = _this.engine.getWorldBounds();\r\n        _this.loader = bootstrap.loader;\r\n        // Actor creation\r\n        _this.ground = new Ground_1.default(_this.bounds.left + 2500, _this.bounds.bottom - 25);\r\n        // this.ground = new Ground(this.bounds.left, this.bounds.bottom - 25);\r\n        /* this.ground.anchor.setTo(0, 0.5);\r\n        this.ground.body.useBoxCollision();\r\n        this.ground.rotation = -Math.PI / 360 * 5; */\r\n        _this.player = new Player_1.default(100, 300, _this.levelBounds);\r\n        // RockCreator for cyclic generation of new rocks\r\n        _this.rocks = [];\r\n        _this.rockCreator = new RockCreator_1.default(_this.engine, _this.scene, _this.bounds, _this.player, _this.rocks);\r\n        return _this;\r\n    }\r\n    Level3.prototype.start = function () {\r\n        this.engine.backgroundColor = this.sceneBackgroundColor; // set background color\r\n        ex.Physics.acc.setTo(0, 2000);\r\n        this.scene.camera.addStrategy(this.player.cameraStrategy);\r\n        this.scene.camera.addStrategy(new LockLevelCameraStrategy_1.default(this.bounds, this.levelBounds));\r\n        this.buildScene();\r\n        // camera rotation ?!\r\n        this.scene.camera.rotation += 0.47;\r\n        console.log("cam rot:   " + this.scene.camera.rotation + "   (level3 - start())");\r\n    };\r\n    Level3.prototype.dispose = function () {\r\n        this.ground.kill();\r\n        this.rockCreator.stop();\r\n        this.rocks.forEach(function (b) {\r\n            if (!b.isKilled) {\r\n                b.kill();\r\n            }\r\n        });\r\n    };\r\n    return Level3;\r\n}(Class_1.Class));\r\nexports.default = Level3;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMy9MZXZlbDMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLHFDQUFvQztBQUNwQyx3REFBK0U7QUFFL0UsdUNBQThCO0FBQzlCLHVDQUE4QjtBQUU5Qiw0Q0FBd0M7QUFFeEM7SUFBb0MsMEJBQXlCO0lBb0I1RCxnQkFBWSxTQUF3QjtRQUFwQyxZQUNDLGlCQUFPLFNBb0JQO1FBdkNRLGNBQVEsR0FBVyxRQUFRLENBQUM7UUFDNUIsaUJBQVcsR0FBbUIsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2xFLDBCQUFvQixHQUFhLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO1FBNERwRCxnQkFBVSxHQUFHO1lBRXBCLGFBQWE7WUFDYixLQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDNUIsS0FBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTVCLG9CQUFvQjtZQUNwQixLQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBRXpCLEtBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2hELEtBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN0QyxDQUFDO1FBcERBLEtBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUMvQixLQUFJLENBQUMsS0FBSyxHQUFHLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkMsS0FBSSxDQUFDLE1BQU0sR0FBRyxLQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQzNDLEtBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUUvQixpQkFBaUI7UUFDakIsS0FBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGdCQUFNLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxFQUFFLEtBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQzNFLHVFQUF1RTtRQUN2RTs7cURBRTZDO1FBRTdDLEtBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxnQkFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXJELGlEQUFpRDtRQUNqRCxLQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUNoQixLQUFJLENBQUMsV0FBVyxHQUFHLElBQUkscUJBQVcsQ0FBQyxLQUFJLENBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSSxDQUFDLE1BQU0sRUFBRSxLQUFJLENBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzs7SUFFbkcsQ0FBQztJQUVELHNCQUFLLEdBQUw7UUFDQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyx1QkFBdUI7UUFDaEYsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUMxRCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxpQ0FBdUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQzFGLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUVsQixxQkFBcUI7UUFDckIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQztRQUNuQyxPQUFPLENBQUMsR0FBRyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsdUJBQXVCLENBQUMsQ0FBQztJQUNuRixDQUFDO0lBRUQsd0JBQU8sR0FBUDtRQUNDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFbkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN4QixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7WUFDN0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7WUFBQyxDQUFDO1FBQy9CLENBQUMsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQWVGLGFBQUM7QUFBRCxDQUFDLENBN0VtQyxhQUFLLEdBNkV4QyIsImZpbGUiOiI5NC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGV4IGZyb20gXCJleGNhbGlidXJcIjtcclxuaW1wb3J0IHsgQ2xhc3MgfSBmcm9tIFwiLi4vLi4vQ2xhc3NcIjtcclxuaW1wb3J0IExvY2tMZXZlbENhbWVyYVN0cmF0ZWd5IGZyb20gXCIuLi8uLi9Db21wb25lbnRzL0xvY2tMZXZlbENhbWVyYVN0cmF0ZWd5XCI7XHJcbmltcG9ydCB7IEdhbWVCb290c3RyYXAsIElHYW1lRWxlbWVudCwgSUdhbWVFbGVtZW50RXZlbnRzIH0gZnJvbSBcIi4uLy4uL0dhbWVCb290c3RyYXBcIjtcclxuaW1wb3J0IEdyb3VuZCBmcm9tIFwiLi9Hcm91bmRcIjtcclxuaW1wb3J0IFBsYXllciBmcm9tIFwiLi9QbGF5ZXJcIjtcclxuaW1wb3J0IFJvY2sgZnJvbSBcIi4vUm9ja1wiO1xyXG5pbXBvcnQgUm9ja0NyZWF0b3IgZnJvbSBcIi4vUm9ja0NyZWF0b3JcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsMyBleHRlbmRzIENsYXNzPElHYW1lRWxlbWVudEV2ZW50cz4gaW1wbGVtZW50cyBJR2FtZUVsZW1lbnQge1xyXG5cclxuXHRyZWFkb25seSBzY2VuZUtleTogc3RyaW5nID0gXCJsZXZlbDNcIjtcclxuXHRyZWFkb25seSBsZXZlbEJvdW5kczogZXguQm91bmRpbmdCb3ggPSBuZXcgZXguQm91bmRpbmdCb3goMCwgMCwgNTAwMCwgNjAwKTtcclxuXHRyZWFkb25seSBzY2VuZUJhY2tncm91bmRDb2xvcjogZXguQ29sb3IgPSBleC5Db2xvci5EYXJrR3JheTtcclxuXHJcblx0ZW5naW5lOiBleC5FbmdpbmU7XHJcblx0c2NlbmU6IGV4LlNjZW5lO1xyXG5cdGJvdW5kczogZXguQm91bmRpbmdCb3g7XHJcblxyXG5cdC8vIGFjdG9yc1xyXG5cdGdyb3VuZDogR3JvdW5kO1xyXG5cdHBsYXllcjogUGxheWVyO1xyXG5cclxuXHQvLyByb2Nrc1xyXG5cdHJvY2tzOiBSb2NrW107XHJcblx0cm9ja0NyZWF0b3I6IFJvY2tDcmVhdG9yO1xyXG5cclxuXHRsb2FkZXI6IGV4LkxvYWRlcjtcclxuXHJcblx0Y29uc3RydWN0b3IoYm9vdHN0cmFwOiBHYW1lQm9vdHN0cmFwKSB7XHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuZW5naW5lID0gYm9vdHN0cmFwLmVuZ2luZTtcclxuXHRcdHRoaXMuc2NlbmUgPSBuZXcgZXguU2NlbmUodGhpcy5lbmdpbmUpO1xyXG5cdFx0dGhpcy5ib3VuZHMgPSB0aGlzLmVuZ2luZS5nZXRXb3JsZEJvdW5kcygpO1xyXG5cdFx0dGhpcy5sb2FkZXIgPSBib290c3RyYXAubG9hZGVyO1xyXG5cclxuXHRcdC8vIEFjdG9yIGNyZWF0aW9uXHJcblx0XHR0aGlzLmdyb3VuZCA9IG5ldyBHcm91bmQodGhpcy5ib3VuZHMubGVmdCArIDI1MDAsIHRoaXMuYm91bmRzLmJvdHRvbSAtIDI1KTtcclxuXHRcdC8vIHRoaXMuZ3JvdW5kID0gbmV3IEdyb3VuZCh0aGlzLmJvdW5kcy5sZWZ0LCB0aGlzLmJvdW5kcy5ib3R0b20gLSAyNSk7XHJcblx0XHQvKiB0aGlzLmdyb3VuZC5hbmNob3Iuc2V0VG8oMCwgMC41KTtcclxuXHRcdHRoaXMuZ3JvdW5kLmJvZHkudXNlQm94Q29sbGlzaW9uKCk7XHJcblx0XHR0aGlzLmdyb3VuZC5yb3RhdGlvbiA9IC1NYXRoLlBJIC8gMzYwICogNTsgKi9cclxuXHJcblx0XHR0aGlzLnBsYXllciA9IG5ldyBQbGF5ZXIoMTAwLCAzMDAsIHRoaXMubGV2ZWxCb3VuZHMpO1xyXG5cclxuXHRcdC8vIFJvY2tDcmVhdG9yIGZvciBjeWNsaWMgZ2VuZXJhdGlvbiBvZiBuZXcgcm9ja3NcclxuXHRcdHRoaXMucm9ja3MgPSBbXTtcclxuXHRcdHRoaXMucm9ja0NyZWF0b3IgPSBuZXcgUm9ja0NyZWF0b3IodGhpcy5lbmdpbmUsIHRoaXMuc2NlbmUsIHRoaXMuYm91bmRzLCB0aGlzLnBsYXllciwgdGhpcy5yb2Nrcyk7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhcnQoKTogdm9pZCB7XHJcblx0XHR0aGlzLmVuZ2luZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnNjZW5lQmFja2dyb3VuZENvbG9yOyAvLyBzZXQgYmFja2dyb3VuZCBjb2xvclxyXG5cdFx0ZXguUGh5c2ljcy5hY2Muc2V0VG8oMCwgMjAwMCk7XHJcblx0XHR0aGlzLnNjZW5lLmNhbWVyYS5hZGRTdHJhdGVneSh0aGlzLnBsYXllci5jYW1lcmFTdHJhdGVneSk7XHJcblx0XHR0aGlzLnNjZW5lLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgTG9ja0xldmVsQ2FtZXJhU3RyYXRlZ3kodGhpcy5ib3VuZHMsIHRoaXMubGV2ZWxCb3VuZHMpKTtcclxuXHRcdHRoaXMuYnVpbGRTY2VuZSgpO1xyXG5cclxuXHRcdC8vIGNhbWVyYSByb3RhdGlvbiA/IVxyXG5cdFx0dGhpcy5zY2VuZS5jYW1lcmEucm90YXRpb24gKz0gMC40NztcclxuXHRcdGNvbnNvbGUubG9nKFwiY2FtIHJvdDogICBcIiArIHRoaXMuc2NlbmUuY2FtZXJhLnJvdGF0aW9uICsgXCIgICAobGV2ZWwzIC0gc3RhcnQoKSlcIik7XHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5ncm91bmQua2lsbCgpO1xyXG5cclxuXHRcdHRoaXMucm9ja0NyZWF0b3Iuc3RvcCgpO1xyXG5cdFx0dGhpcy5yb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XHJcblx0XHRcdGlmICghYi5pc0tpbGxlZCkgeyBiLmtpbGwoKTsgfVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGJ1aWxkU2NlbmUgPSAoKSA9PiB7XHJcblxyXG5cdFx0Ly8gYWRkIGFjdG9yc1xyXG5cdFx0dGhpcy5zY2VuZS5hZGQodGhpcy5ncm91bmQpO1xyXG5cdFx0dGhpcy5zY2VuZS5hZGQodGhpcy5wbGF5ZXIpO1xyXG5cclxuXHRcdC8vIHN0YXJ0IHJvY2tDcmVhdG9yXHJcblx0XHR0aGlzLnJvY2tDcmVhdG9yLnN0YXJ0KCk7XHJcblxyXG5cdFx0dGhpcy5lbmdpbmUuYWRkU2NlbmUodGhpcy5zY2VuZUtleSwgdGhpcy5zY2VuZSk7XHJcblx0XHR0aGlzLmVuZ2luZS5nb1RvU2NlbmUodGhpcy5zY2VuZUtleSk7XHJcblx0fVxyXG5cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWwzL0xldmVsMy50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///94\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Resources_1 = __webpack_require__(7);\r\nvar Ground = /** @class */ (function (_super) {\r\n    __extends(Ground, _super);\r\n    function Ground(x, y) {\r\n        var _this = _super.call(this, x, y, Ground.width, 50, ex.Color.Gray) || this;\r\n        _this.collisionType = ex.CollisionType.Fixed;\r\n        return _this;\r\n    }\r\n    Ground.prototype.draw = function (ctx, delta) {\r\n        _super.prototype.draw.call(this, ctx, delta);\r\n        var sprite = Resources_1.default.seaBed.asSprite();\r\n        var offset = 0;\r\n        while (offset < Ground.width) {\r\n            sprite.draw(ctx, this.getLeft() + offset, this.getTop());\r\n            offset += 70;\r\n        }\r\n    };\r\n    Ground.width = 5100;\r\n    return Ground;\r\n}(ex.Actor));\r\nexports.default = Ground;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMy9Hcm91bmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLHlDQUF3QztBQUV4QztJQUFvQywwQkFBUTtJQUkzQyxnQkFBWSxDQUFTLEVBQUUsQ0FBUztRQUFoQyxZQUNDLGtCQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FFNUM7UUFEQSxLQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDOztJQUM3QyxDQUFDO0lBRUQscUJBQUksR0FBSixVQUFLLEdBQTZCLEVBQUUsS0FBYTtRQUNoRCxpQkFBTSxJQUFJLFlBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3ZCLElBQU0sTUFBTSxHQUFHLG1CQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzNDLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztRQUdmLE9BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUM3QixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBQ3pELE1BQU0sSUFBSSxFQUFFLENBQUM7UUFDZCxDQUFDO0lBRUYsQ0FBQztJQWxCZSxZQUFLLEdBQVcsSUFBSSxDQUFDO0lBbUJ0QyxhQUFDO0NBQUEsQ0FyQm1DLEVBQUUsQ0FBQyxLQUFLLEdBcUIzQztrQkFyQm9CLE1BQU0iLCJmaWxlIjoiOTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XHJcbmltcG9ydCBSZXNvdXJjZXMgZnJvbSBcIi4uLy4uL1Jlc291cmNlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JvdW5kIGV4dGVuZHMgZXguQWN0b3Ige1xyXG5cclxuXHRzdGF0aWMgcmVhZG9ubHkgd2lkdGg6IG51bWJlciA9IDUxMDA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XHJcblx0XHRzdXBlcih4LCB5LCBHcm91bmQud2lkdGgsIDUwLCBleC5Db2xvci5HcmF5KTtcclxuXHRcdHRoaXMuY29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGUuRml4ZWQ7XHJcblx0fVxyXG5cclxuXHRkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBkZWx0YTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRzdXBlci5kcmF3KGN0eCwgZGVsdGEpO1xyXG5cdFx0Y29uc3Qgc3ByaXRlID0gUmVzb3VyY2VzLnNlYUJlZC5hc1Nwcml0ZSgpO1xyXG5cdFx0bGV0IG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHJcblx0XHR3aGlsZShvZmZzZXQgPCBHcm91bmQud2lkdGgpIHtcclxuXHRcdFx0c3ByaXRlLmRyYXcoY3R4LCB0aGlzLmdldExlZnQoKSArIG9mZnNldCwgdGhpcy5nZXRUb3AoKSk7XHJcblx0XHRcdG9mZnNldCArPSA3MDtcclxuXHRcdH1cclxuXHRcdFxyXG5cdH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWwzL0dyb3VuZC50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///95\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar BasePlayer_1 = __webpack_require__(23);\r\nvar Player = /** @class */ (function (_super) {\r\n    __extends(Player, _super);\r\n    function Player(x, y, levelBounds) {\r\n        var _this = _super.call(this, x, y) || this;\r\n        _this.dead = false;\r\n        _this.ducked = false;\r\n        _this.speedAcc = 300;\r\n        _this.speedNormal = 200;\r\n        _this.speedDec = 100;\r\n        _this.speedDucked = 50;\r\n        _this.anchor.setTo(0.5, 1); // set anchor to the center of the bottom edge\r\n        _this.y += _this.getHeight();\r\n        _this.collisionArea.body.useBoxCollision();\r\n        _this.cameraStrategy = new ex.LockCameraToActorAxisStrategy(_this, ex.Axis.X);\r\n        // this.cameraStrategy = new ex.LockCameraToActorStrategy(this);\r\n        _this.minX = levelBounds.left + Player.size.w / 2;\r\n        _this.maxX = levelBounds.right - Player.size.w / 2;\r\n        _this.speed = _this.speedNormal;\r\n        return _this;\r\n    }\r\n    Player.prototype.update = function (engine, delta) {\r\n        _super.prototype.update.call(this, engine, delta);\r\n        if (engine.input.keyboard.wasPressed(ex.Input.Keys.Space)) {\r\n            this.jump();\r\n        }\r\n        // X movement\r\n        if (engine.input.keyboard.wasPressed(ex.Input.Keys.Left)) {\r\n            this.speed = this.speedDec;\r\n        }\r\n        if (engine.input.keyboard.wasPressed(ex.Input.Keys.Right)) {\r\n            this.speed = this.speedAcc;\r\n        }\r\n        if (engine.input.keyboard.wasReleased(ex.Input.Keys.Left)) {\r\n            if (engine.input.keyboard.isHeld(ex.Input.Keys.Right)) {\r\n                this.speed = this.speedAcc;\r\n            }\r\n            else {\r\n                this.speed = this.speedNormal;\r\n            }\r\n        }\r\n        if (engine.input.keyboard.wasReleased(ex.Input.Keys.Right)) {\r\n            if (engine.input.keyboard.isHeld(ex.Input.Keys.Left)) {\r\n                this.speed = this.speedDec;\r\n            }\r\n            else {\r\n                this.speed = this.speedNormal;\r\n            }\r\n        }\r\n        if (engine.input.keyboard.isHeld(ex.Input.Keys.Left) && engine.input.keyboard.isHeld(ex.Input.Keys.Right)) {\r\n            this.speed = this.speedNormal;\r\n        }\r\n        if (engine.input.keyboard.wasPressed(ex.Input.Keys.D)) {\r\n            this.duck();\r\n        }\r\n        if (engine.input.keyboard.wasReleased(ex.Input.Keys.D)) {\r\n            this.unDuck();\r\n        }\r\n        if (!this.ducked) {\r\n            this.pos.x += this.speed * delta / 1000;\r\n        }\r\n        else {\r\n            this.pos.x += this.speedDucked * delta / 1000;\r\n        }\r\n    };\r\n    Player.prototype.jump = function () {\r\n        var groundLevel = this.scene.engine.getWorldBounds().bottom - 50;\r\n        if (groundLevel - this.getBottom() < 15) {\r\n            this.vel.y = -450;\r\n        }\r\n    };\r\n    Player.prototype.duck = function () {\r\n        if (this.ducked)\r\n            return; // already ducked\r\n        this.ducked = true;\r\n        this.setHeight(this.getHeight() / 2);\r\n        this.collisionArea.body.useBoxCollision();\r\n    };\r\n    Player.prototype.unDuck = function () {\r\n        if (!this.ducked)\r\n            return; // already ducked\r\n        this.ducked = false;\r\n        this.setHeight(this.getHeight() * 2);\r\n        this.collisionArea.body.useBoxCollision();\r\n    };\r\n    Player.prototype.die = function (info) {\r\n        if (!this.dead) {\r\n            // console.log("cam rot: "+this.scene.camera.rotation + "   (level3 - player - die)"); // proof that rotation is not influenced by anything else\r\n            this.dead = true;\r\n            // this.rotation = Math.PI / 2;\r\n            this.setHeight(this.getHeight() / 4);\r\n            this.collisionArea.body.useBoxCollision();\r\n            this.scene.camera.shake(50, 50, 500);\r\n            var player_1 = this;\r\n            setTimeout(function () {\r\n                player_1.kill();\r\n                alert(info);\r\n            }, 550);\r\n        }\r\n    };\r\n    return Player;\r\n}(BasePlayer_1.default));\r\nexports.default = Player;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMy9QbGF5ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLDJDQUFxRDtBQUVyRDtJQUFvQywwQkFBVTtJQWU3QyxnQkFBWSxDQUFTLEVBQUUsQ0FBUyxFQUFFLFdBQTJCO1FBQTdELFlBQ0Msa0JBQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQVdYO1FBeEJELFVBQUksR0FBWSxLQUFLLENBQUM7UUFDdEIsWUFBTSxHQUFZLEtBQUssQ0FBQztRQUd4QixjQUFRLEdBQVcsR0FBRyxDQUFDO1FBQ3ZCLGlCQUFXLEdBQVcsR0FBRyxDQUFDO1FBQzFCLGNBQVEsR0FBVyxHQUFHLENBQUM7UUFDdkIsaUJBQVcsR0FBVyxFQUFFLENBQUM7UUFReEIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsOENBQThDO1FBQ3pFLEtBQUksQ0FBQyxDQUFDLElBQUksS0FBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzNCLEtBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRTFDLEtBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxFQUFFLENBQUMsNkJBQTZCLENBQUMsS0FBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUUsZ0VBQWdFO1FBQ2hFLEtBQUksQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakQsS0FBSSxDQUFDLElBQUksR0FBRyxXQUFXLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsRCxLQUFJLENBQUMsS0FBSyxHQUFHLEtBQUksQ0FBQyxXQUFXLENBQUM7O0lBQy9CLENBQUM7SUFHRCx1QkFBTSxHQUFOLFVBQU8sTUFBaUIsRUFBRSxLQUFhO1FBQ3RDLGlCQUFNLE1BQU0sWUFBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFNUIsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzRCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDYixDQUFDO1FBRUQsYUFBYTtRQUNiLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUQsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzVCLENBQUM7UUFFRCxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNELElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUM1QixDQUFDO1FBRUQsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzRCxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN2RCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDNUIsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNQLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUMvQixDQUFDO1FBQ0YsQ0FBQztRQUVELEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDNUQsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdEQsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQzVCLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDUCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7WUFDL0IsQ0FBQztRQUNGLENBQUM7UUFFRCxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzRyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDL0IsQ0FBQztRQUdELEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2IsQ0FBQztRQUVELEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDeEQsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2YsQ0FBQztRQUVELEVBQUUsRUFBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQztRQUN6QyxDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDUCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDL0MsQ0FBQztJQUNGLENBQUM7SUFHTyxxQkFBSSxHQUFaO1FBQ0MsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUVqRSxFQUFFLENBQUMsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7UUFDbkIsQ0FBQztJQUNGLENBQUM7SUFJTyxxQkFBSSxHQUFaO1FBQ0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUNmLE1BQU0sQ0FBQyxDQUFDLGlCQUFpQjtRQUMxQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztRQUNuQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUMzQyxDQUFDO0lBRU8sdUJBQU0sR0FBZDtRQUNDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUNoQixNQUFNLENBQUMsQ0FBQyxpQkFBaUI7UUFDMUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDM0MsQ0FBQztJQUVNLG9CQUFHLEdBQVYsVUFBVyxJQUFZO1FBQ3RCLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFFaEIsZ0pBQWdKO1lBRWhKLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1lBRWpCLCtCQUErQjtZQUMvQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUUxQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUVyQyxJQUFJLFFBQU0sR0FBVyxJQUFJLENBQUM7WUFDMUIsVUFBVSxDQUFDO2dCQUVWLFFBQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDZCxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDVCxDQUFDO0lBQ0YsQ0FBQztJQUNGLGFBQUM7QUFBRCxDQUFDLENBbkltQyxvQkFBVSxHQW1JN0MiLCJmaWxlIjoiOTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XHJcbmltcG9ydCBCYXNlUGxheWVyIGZyb20gXCIuLi8uLi9Db21wb25lbnRzL0Jhc2VQbGF5ZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsYXllciBleHRlbmRzIEJhc2VQbGF5ZXIge1xyXG5cclxuXHRjYW1lcmFTdHJhdGVneTogZXguTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneTtcclxuXHRkZWFkOiBib29sZWFuID0gZmFsc2U7XHJcblx0ZHVja2VkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdHNwZWVkOiBudW1iZXI7XHJcblx0c3BlZWRBY2M6IG51bWJlciA9IDMwMDtcclxuXHRzcGVlZE5vcm1hbDogbnVtYmVyID0gMjAwO1xyXG5cdHNwZWVkRGVjOiBudW1iZXIgPSAxMDA7XHJcblx0c3BlZWREdWNrZWQ6IG51bWJlciA9IDUwO1xyXG5cclxuXHRtaW5YOiBudW1iZXI7XHJcblx0bWF4WDogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlciwgbGV2ZWxCb3VuZHM6IGV4LkJvdW5kaW5nQm94KSB7XHJcblx0XHRzdXBlcih4LCB5KTtcclxuXHRcdFxyXG5cdFx0dGhpcy5hbmNob3Iuc2V0VG8oMC41LCAxKTsgLy8gc2V0IGFuY2hvciB0byB0aGUgY2VudGVyIG9mIHRoZSBib3R0b20gZWRnZVxyXG5cdFx0dGhpcy55ICs9IHRoaXMuZ2V0SGVpZ2h0KCk7XHJcblx0XHR0aGlzLmNvbGxpc2lvbkFyZWEuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcclxuXHRcdFxyXG5cdFx0dGhpcy5jYW1lcmFTdHJhdGVneSA9IG5ldyBleC5Mb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneSh0aGlzLCBleC5BeGlzLlgpO1xyXG5cdFx0Ly8gdGhpcy5jYW1lcmFTdHJhdGVneSA9IG5ldyBleC5Mb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5KHRoaXMpO1xyXG5cdFx0dGhpcy5taW5YID0gbGV2ZWxCb3VuZHMubGVmdCArIFBsYXllci5zaXplLncgLyAyO1xyXG5cdFx0dGhpcy5tYXhYID0gbGV2ZWxCb3VuZHMucmlnaHQgLSBQbGF5ZXIuc2l6ZS53IC8gMjtcclxuXHRcdHRoaXMuc3BlZWQgPSB0aGlzLnNwZWVkTm9ybWFsO1xyXG5cdH1cclxuXHJcblxyXG5cdHVwZGF0ZShlbmdpbmU6IGV4LkVuZ2luZSwgZGVsdGE6IG51bWJlcikge1xyXG5cdFx0c3VwZXIudXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG5cclxuXHRcdGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQud2FzUHJlc3NlZChleC5JbnB1dC5LZXlzLlNwYWNlKSkge1xyXG5cdFx0XHR0aGlzLmp1bXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBYIG1vdmVtZW50XHJcblx0XHRpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLndhc1ByZXNzZWQoZXguSW5wdXQuS2V5cy5MZWZ0KSkge1xyXG5cdFx0XHR0aGlzLnNwZWVkID0gdGhpcy5zcGVlZERlYztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLndhc1ByZXNzZWQoZXguSW5wdXQuS2V5cy5SaWdodCkpIHtcclxuXHRcdFx0dGhpcy5zcGVlZCA9IHRoaXMuc3BlZWRBY2M7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGVuZ2luZS5pbnB1dC5rZXlib2FyZC53YXNSZWxlYXNlZChleC5JbnB1dC5LZXlzLkxlZnQpKSB7XHJcblx0XHRcdGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQuaXNIZWxkKGV4LklucHV0LktleXMuUmlnaHQpKSB7XHJcblx0XHRcdFx0dGhpcy5zcGVlZCA9IHRoaXMuc3BlZWRBY2M7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5zcGVlZCA9IHRoaXMuc3BlZWROb3JtYWw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLndhc1JlbGVhc2VkKGV4LklucHV0LktleXMuUmlnaHQpKSB7XHJcblx0XHRcdGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQuaXNIZWxkKGV4LklucHV0LktleXMuTGVmdCkpIHtcclxuXHRcdFx0XHR0aGlzLnNwZWVkID0gdGhpcy5zcGVlZERlYztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnNwZWVkID0gdGhpcy5zcGVlZE5vcm1hbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQuaXNIZWxkKGV4LklucHV0LktleXMuTGVmdCkgJiYgZW5naW5lLmlucHV0LmtleWJvYXJkLmlzSGVsZChleC5JbnB1dC5LZXlzLlJpZ2h0KSkge1xyXG5cdFx0XHR0aGlzLnNwZWVkID0gdGhpcy5zcGVlZE5vcm1hbDtcclxuXHRcdH1cclxuXHJcblx0XHRcclxuXHRcdGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQud2FzUHJlc3NlZChleC5JbnB1dC5LZXlzLkQpKSB7XHJcblx0XHRcdHRoaXMuZHVjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQud2FzUmVsZWFzZWQoZXguSW5wdXQuS2V5cy5EKSkge1xyXG5cdFx0XHR0aGlzLnVuRHVjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCF0aGlzLmR1Y2tlZCkge1xyXG5cdFx0XHR0aGlzLnBvcy54ICs9IHRoaXMuc3BlZWQgKiBkZWx0YSAvIDEwMDA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnBvcy54ICs9IHRoaXMuc3BlZWREdWNrZWQgKiBkZWx0YSAvIDEwMDA7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblx0cHJpdmF0ZSBqdW1wKCkge1xyXG5cdFx0bGV0IGdyb3VuZExldmVsID0gdGhpcy5zY2VuZS5lbmdpbmUuZ2V0V29ybGRCb3VuZHMoKS5ib3R0b20gLSA1MDtcclxuXHJcblx0XHRpZiAoZ3JvdW5kTGV2ZWwgLSB0aGlzLmdldEJvdHRvbSgpIDwgMTUpIHtcclxuXHRcdFx0dGhpcy52ZWwueSA9IC00NTA7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdHByaXZhdGUgZHVjaygpIHtcclxuXHRcdGlmICh0aGlzLmR1Y2tlZClcclxuXHRcdFx0cmV0dXJuOyAvLyBhbHJlYWR5IGR1Y2tlZFxyXG5cdFx0dGhpcy5kdWNrZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5zZXRIZWlnaHQodGhpcy5nZXRIZWlnaHQoKSAvIDIpO1xyXG5cdFx0dGhpcy5jb2xsaXNpb25BcmVhLmJvZHkudXNlQm94Q29sbGlzaW9uKCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHVuRHVjaygpIHtcclxuXHRcdGlmICghdGhpcy5kdWNrZWQpXHJcblx0XHRcdHJldHVybjsgLy8gYWxyZWFkeSBkdWNrZWRcclxuXHRcdHRoaXMuZHVja2VkID0gZmFsc2U7XHJcblx0XHR0aGlzLnNldEhlaWdodCh0aGlzLmdldEhlaWdodCgpICogMik7XHJcblx0XHR0aGlzLmNvbGxpc2lvbkFyZWEuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBkaWUoaW5mbzogc3RyaW5nKSB7XHJcblx0XHRpZiAoIXRoaXMuZGVhZCkge1xyXG5cclxuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJjYW0gcm90OiBcIit0aGlzLnNjZW5lLmNhbWVyYS5yb3RhdGlvbiArIFwiICAgKGxldmVsMyAtIHBsYXllciAtIGRpZSlcIik7IC8vIHByb29mIHRoYXQgcm90YXRpb24gaXMgbm90IGluZmx1ZW5jZWQgYnkgYW55dGhpbmcgZWxzZVxyXG5cclxuXHRcdFx0dGhpcy5kZWFkID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHRoaXMucm90YXRpb24gPSBNYXRoLlBJIC8gMjtcclxuXHRcdFx0dGhpcy5zZXRIZWlnaHQodGhpcy5nZXRIZWlnaHQoKSAvIDQpO1xyXG5cdFx0XHR0aGlzLmNvbGxpc2lvbkFyZWEuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcclxuXHJcblx0XHRcdHRoaXMuc2NlbmUuY2FtZXJhLnNoYWtlKDUwLCA1MCwgNTAwKTtcdFx0XHRcclxuXHJcblx0XHRcdGxldCBwbGF5ZXI6IFBsYXllciA9IHRoaXM7XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRcdHBsYXllci5raWxsKCk7XHJcblx0XHRcdFx0YWxlcnQoaW5mbyk7XHJcblxyXG5cdFx0XHR9LCA1NTApO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWwzL1BsYXllci50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///96\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar Rock_1 = __webpack_require__(98);\r\n// class for cyclically creating new rocks and adding them to the scene, in front of the player\r\nvar RockCreator = /** @class */ (function () {\r\n    function RockCreator(engine, scene, bounds, player, rocks) {\r\n        this.timer = [-1]; // to be passed by reference\r\n        this.engine = engine;\r\n        this.scene = scene;\r\n        this.bounds = bounds;\r\n        this.player = player;\r\n        this.rocks = rocks;\r\n    }\r\n    RockCreator.prototype.start = function () {\r\n        console.log("rockCreator started! (Level2 - RockCreator - start())");\r\n        // start timer scheduling new rock creations\r\n        var that = this;\r\n        this.timer[0] = setTimeout(function () {\r\n            that.createNewRockRT(that.scene, that.bounds, that.player, that.rocks, that.timer);\r\n        }, 1500);\r\n    };\r\n    RockCreator.prototype.stop = function () {\r\n        // cancel timer // kill rocks ? \r\n        console.log("rockCreator stopped! (Level2 - RockCreator - stop())");\r\n        if (this.timer[0] !== -1) {\r\n            clearInterval(this.timer[0]);\r\n        }\r\n    };\r\n    RockCreator.prototype.createNewRockRT = function (scene, bounds, player, rocks, timer) {\r\n        console.log("creating new rock... (Level2 - RockCreator - createNewRockRT()");\r\n        // determining type of the next rock\r\n        var rock;\r\n        if (this.randomIntFromInterval(1, 2) > 1) {\r\n            // big rock\r\n            rock = new Rock_1.default(player.x + 800, 500, 50, -200, 1000, -400, Rock_1.Rocktypes.big); // big rock bouncing towards the player\t\t\r\n        }\r\n        else {\r\n            // small rock\r\n            rock = new Rock_1.default(player.x + 800, 500, 20, -200, 1000, -150, Rock_1.Rocktypes.small); // small rock "rolling" on the ground\r\n        }\r\n        // create new rock\r\n        var newRockIndex = rocks.push(rock) - 1;\r\n        scene.add(rocks[newRockIndex]);\r\n        // create new timeout for next rock\r\n        var nextRockInMS = this.randomIntFromInterval(1000, 1500);\r\n        var that = this;\r\n        timer[0] = setTimeout(function () {\r\n            that.createNewRockRT(scene, bounds, player, rocks, timer);\r\n        }, nextRockInMS);\r\n    };\r\n    RockCreator.prototype.randomIntFromInterval = function (min, max) {\r\n        var t = Math.floor(Math.random() * (max - min + 1) + min);\r\n        return t;\r\n    };\r\n    return RockCreator;\r\n}());\r\nexports.default = RockCreator;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMy9Sb2NrQ3JlYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLHFDQUF5QztBQUd6QywrRkFBK0Y7QUFFL0Y7SUFVQyxxQkFBWSxNQUFpQixFQUFFLEtBQWUsRUFBRSxNQUFzQixFQUFFLE1BQWMsRUFBRSxLQUFhO1FBRnJHLFVBQUssR0FBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyw0QkFBNEI7UUFHbkQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUVELDJCQUFLLEdBQUw7UUFDQyxPQUFPLENBQUMsR0FBRyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7UUFFckUsNENBQTRDO1FBQzVDLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztZQUMxQixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BGLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRCwwQkFBSSxHQUFKO1FBQ0MsZ0NBQWdDO1FBQ2hDLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0RBQXNELENBQUMsQ0FBQztRQUNwRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUUxQixhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlCLENBQUM7SUFDRixDQUFDO0lBRUQscUNBQWUsR0FBZixVQUFnQixLQUFlLEVBQUUsTUFBc0IsRUFBRSxNQUFjLEVBQUUsS0FBYSxFQUFFLEtBQWU7UUFDdEcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnRUFBZ0UsQ0FBQyxDQUFDO1FBRTlFLG9DQUFvQztRQUNwQyxJQUFJLElBQVUsQ0FBQztRQUNmLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxQyxXQUFXO1lBQ1gsSUFBSSxHQUFHLElBQUksY0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUFFLGdCQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyx5Q0FBeUM7UUFDckgsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ1AsYUFBYTtZQUNiLElBQUksR0FBRyxJQUFJLGNBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxnQkFBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMscUNBQXFDO1FBQ25ILENBQUM7UUFFRCxrQkFBa0I7UUFDbEIsSUFBSSxZQUFZLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztRQUUvQixtQ0FBbUM7UUFDbkMsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMxRCxJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7UUFDaEIsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztZQUNyQixJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMzRCxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDbEIsQ0FBQztJQUVELDJDQUFxQixHQUFyQixVQUFzQixHQUFXLEVBQUUsR0FBVztRQUM3QyxJQUFJLENBQUMsR0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDbEUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRixrQkFBQztBQUFELENBQUMiLCJmaWxlIjoiOTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XHJcbmltcG9ydCBSb2NrLCB7IFJvY2t0eXBlcyB9IGZyb20gXCIuL1JvY2tcIjtcclxuaW1wb3J0IFBsYXllciBmcm9tIFwiLi9QbGF5ZXJcIjtcclxuXHJcbi8vIGNsYXNzIGZvciBjeWNsaWNhbGx5IGNyZWF0aW5nIG5ldyByb2NrcyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlIHNjZW5lLCBpbiBmcm9udCBvZiB0aGUgcGxheWVyXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb2NrQ3JlYXRvciB7XHJcblxyXG5cdGVuZ2luZTogZXguRW5naW5lO1xyXG5cdHNjZW5lOiBleC5TY2VuZTtcclxuXHRwbGF5ZXI6IFBsYXllcjtcclxuXHRyb2NrczogUm9ja1tdO1xyXG5cdGJvdW5kczogZXguQm91bmRpbmdCb3g7XHJcblxyXG5cdHRpbWVyOiBudW1iZXJbXSA9IFstMV07IC8vIHRvIGJlIHBhc3NlZCBieSByZWZlcmVuY2VcclxuXHJcblx0Y29uc3RydWN0b3IoZW5naW5lOiBleC5FbmdpbmUsIHNjZW5lOiBleC5TY2VuZSwgYm91bmRzOiBleC5Cb3VuZGluZ0JveCwgcGxheWVyOiBQbGF5ZXIsIHJvY2tzOiBSb2NrW10pIHtcclxuXHRcdHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cdFx0dGhpcy5ib3VuZHMgPSBib3VuZHM7XHJcblx0XHR0aGlzLnBsYXllciA9IHBsYXllcjtcclxuXHRcdHRoaXMucm9ja3MgPSByb2NrcztcclxuXHR9XHJcblxyXG5cdHN0YXJ0KCkge1xyXG5cdFx0Y29uc29sZS5sb2coXCJyb2NrQ3JlYXRvciBzdGFydGVkISAoTGV2ZWwyIC0gUm9ja0NyZWF0b3IgLSBzdGFydCgpKVwiKTtcclxuXHJcblx0XHQvLyBzdGFydCB0aW1lciBzY2hlZHVsaW5nIG5ldyByb2NrIGNyZWF0aW9uc1xyXG5cdFx0bGV0IHRoYXQgPSB0aGlzO1xyXG5cdFx0dGhpcy50aW1lclswXSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGF0LmNyZWF0ZU5ld1JvY2tSVCh0aGF0LnNjZW5lLCB0aGF0LmJvdW5kcywgdGhhdC5wbGF5ZXIsIHRoYXQucm9ja3MsIHRoYXQudGltZXIpO1xyXG5cdFx0fSwgMTUwMCk7XHJcblx0fVxyXG5cclxuXHRzdG9wKCkge1xyXG5cdFx0Ly8gY2FuY2VsIHRpbWVyIC8vIGtpbGwgcm9ja3MgPyBcclxuXHRcdGNvbnNvbGUubG9nKFwicm9ja0NyZWF0b3Igc3RvcHBlZCEgKExldmVsMiAtIFJvY2tDcmVhdG9yIC0gc3RvcCgpKVwiKTtcclxuXHRcdGlmICh0aGlzLnRpbWVyWzBdICE9PSAtMSkge1xyXG5cclxuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyWzBdKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGNyZWF0ZU5ld1JvY2tSVChzY2VuZTogZXguU2NlbmUsIGJvdW5kczogZXguQm91bmRpbmdCb3gsIHBsYXllcjogUGxheWVyLCByb2NrczogUm9ja1tdLCB0aW1lcjogbnVtYmVyW10pIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiY3JlYXRpbmcgbmV3IHJvY2suLi4gKExldmVsMiAtIFJvY2tDcmVhdG9yIC0gY3JlYXRlTmV3Um9ja1JUKClcIik7XHJcblx0XHRcclxuXHRcdC8vIGRldGVybWluaW5nIHR5cGUgb2YgdGhlIG5leHQgcm9ja1xyXG5cdFx0bGV0IHJvY2s6IFJvY2s7XHJcblx0XHRpZiAodGhpcy5yYW5kb21JbnRGcm9tSW50ZXJ2YWwoMSwgMikgPiAxKSB7XHJcblx0XHRcdC8vIGJpZyByb2NrXHJcblx0XHRcdHJvY2sgPSBuZXcgUm9jayhwbGF5ZXIueCArIDgwMCwgNTAwLCA1MCwgLTIwMCwgMTAwMCwgLTQwMCwgUm9ja3R5cGVzLmJpZyk7IC8vIGJpZyByb2NrIGJvdW5jaW5nIHRvd2FyZHMgdGhlIHBsYXllclx0XHRcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHNtYWxsIHJvY2tcclxuXHRcdFx0cm9jayA9IG5ldyBSb2NrKHBsYXllci54ICsgODAwLCA1MDAsIDIwLCAtMjAwLCAxMDAwLCAtMTUwLCBSb2NrdHlwZXMuc21hbGwpOyAvLyBzbWFsbCByb2NrIFwicm9sbGluZ1wiIG9uIHRoZSBncm91bmRcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjcmVhdGUgbmV3IHJvY2tcclxuXHRcdGxldCBuZXdSb2NrSW5kZXggPSByb2Nrcy5wdXNoKHJvY2spIC0gMTtcclxuXHRcdHNjZW5lLmFkZChyb2Nrc1tuZXdSb2NrSW5kZXhdKTtcclxuXHJcblx0XHQvLyBjcmVhdGUgbmV3IHRpbWVvdXQgZm9yIG5leHQgcm9ja1xyXG5cdFx0bGV0IG5leHRSb2NrSW5NUyA9IHRoaXMucmFuZG9tSW50RnJvbUludGVydmFsKDEwMDAsIDE1MDApO1xyXG5cdFx0bGV0IHRoYXQgPSB0aGlzO1xyXG5cdFx0dGltZXJbMF0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhhdC5jcmVhdGVOZXdSb2NrUlQoc2NlbmUsIGJvdW5kcywgcGxheWVyLCByb2NrcywgdGltZXIpO1xyXG5cdFx0fSwgbmV4dFJvY2tJbk1TKTtcclxuXHR9XHJcblxyXG5cdHJhbmRvbUludEZyb21JbnRlcnZhbChtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0bGV0IHQ6IG51bWJlciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pbik7XHJcblx0XHRyZXR1cm4gdDtcclxuXHR9XHJcblxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9MZXZlbDMvUm9ja0NyZWF0b3IudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///97\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Resources_1 = __webpack_require__(7);\r\nexports.Rocktypes = { "small": 1, "big": 2 };\r\nvar Rock = /** @class */ (function (_super) {\r\n    __extends(Rock, _super);\r\n    function Rock(x, y, d, speedX, accY, yVelBounce, typ) {\r\n        var _this = _super.call(this, x, y, d, d, ex.Color.White) || this;\r\n        _this.rotationTime = 0;\r\n        _this.d = d;\r\n        // Anchor\r\n        _this.anchor.setTo(0.5, 0.5); // set anchor to the center\r\n        _this.collisionArea.body.useBoxCollision();\r\n        _this.collisionType = ex.CollisionType.Passive;\r\n        _this.acc.y = accY;\r\n        _this.vel.x = speedX;\r\n        _this.numberOfRotationsPerSecond = speedX / (2 * Math.PI * d / Math.sqrt(2));\r\n        _this.yVelBounce = yVelBounce;\r\n        _this.typ = typ;\r\n        if (typ === exports.Rocktypes.small) {\r\n            _this.sprite = Resources_1.default.smallRock.asSprite();\r\n        }\r\n        else {\r\n            _this.sprite = Resources_1.default.bigRock.asSprite();\r\n        }\r\n        _this.sprite.anchor.setTo(0.5, 0.5);\r\n        // On collision check if Player and trap if true\r\n        _this.on("precollision", _this.onPrecollision);\r\n        return _this;\r\n    }\r\n    // raised every frame while colliding\r\n    Rock.prototype.onPrecollision = function (ev) {\r\n        // console.log("precollision event raised");\r\n        if (ev.other.constructor.name === "Ground") {\r\n            this.vel.y = this.yVelBounce;\r\n        }\r\n        else if (ev.other.constructor.name === "Player") {\r\n            console.log("onPrecollision event of Rock colliding with player");\r\n            var player = ev.other;\r\n            player.die("You got hit by a rock!");\r\n        }\r\n    };\r\n    Rock.prototype.draw = function (ctx, delta) {\r\n        // Optionally call original \'base\' method\r\n        ex.Actor.prototype.draw.call(this, ctx, delta);\r\n        // Custom draw code\r\n        /*\r\n        ctx.fillStyle = this.color.toString();\r\n        ctx.beginPath();\r\n        ctx.arc(this.pos.x, this.pos.y, Math.trunc(Math.sqrt((this.d * this.d)/4.0))+1, 0, Math.PI * 2);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        */\r\n        // TODO: calculate rotation\r\n        this.rotationTime += delta / 1000;\r\n        this.rotation = ((this.rotationTime * this.numberOfRotationsPerSecond) % 1) * 2 * Math.PI;\r\n        this.sprite.rotation = this.rotation;\r\n        this.sprite.draw(ctx, this.getCenter().x, this.getCenter().y);\r\n    };\r\n    Rock.prototype.update = function (engine, delta) {\r\n        _super.prototype.update.call(this, engine, delta);\r\n        // TODO: kill when far behind player\r\n    };\r\n    Rock.prototype.kill = function () {\r\n        _super.prototype.kill.call(this);\r\n    };\r\n    return Rock;\r\n}(ex.Actor));\r\nexports.default = Rock;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsMy9Sb2NrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGdDQUFnQztBQUVoQyx5Q0FBd0M7QUFFM0IsaUJBQVMsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBRWxEO0lBQWtDLHdCQUFRO0lBV3pDLGNBQVksQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTLEVBQUUsTUFBYyxFQUFFLElBQVksRUFBRSxVQUFrQixFQUFFLEdBQVc7UUFBMUcsWUFDQyxrQkFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsU0E2QmpDO1FBbkNELGtCQUFZLEdBQVcsQ0FBQyxDQUFDO1FBUXhCLEtBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRVgsU0FBUztRQUNULEtBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLDJCQUEyQjtRQUV4RCxLQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUMxQyxLQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDO1FBRTlDLEtBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUVsQixLQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7UUFFcEIsS0FBSSxDQUFDLDBCQUEwQixHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFHNUUsS0FBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7UUFFN0IsS0FBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixFQUFFLENBQUMsQ0FBQyxHQUFHLEtBQUssaUJBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzdCLEtBQUksQ0FBQyxNQUFNLEdBQUcsbUJBQVMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDOUMsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ1AsS0FBSSxDQUFDLE1BQU0sR0FBRyxtQkFBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUM1QyxDQUFDO1FBQ0QsS0FBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUVuQyxnREFBZ0Q7UUFDaEQsS0FBSSxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsS0FBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDOztJQUM5QyxDQUFDO0lBRUQscUNBQXFDO0lBQ3JDLDZCQUFjLEdBQWQsVUFBZSxFQUFPO1FBQ3JCLDRDQUE0QztRQUM1QyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQzlCLENBQUM7UUFBQyxJQUFJLENBQ0wsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDNUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO1lBQ2xFLElBQUksTUFBTSxHQUFXLEVBQUUsQ0FBQyxLQUFLLENBQUM7WUFDOUIsTUFBTSxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1FBQ3RDLENBQUM7SUFFSCxDQUFDO0lBRUQsbUJBQUksR0FBSixVQUFLLEdBQVEsRUFBRSxLQUFVO1FBQ3hCLHlDQUF5QztRQUN6QyxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFL0MsbUJBQW1CO1FBQ25COzs7Ozs7VUFNRTtRQUNGLDJCQUEyQjtRQUMzQixJQUFJLENBQUMsWUFBWSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUM7UUFFbEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsMEJBQTBCLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUUxRixJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBRXJDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUvRCxDQUFDO0lBRUQscUJBQU0sR0FBTixVQUFPLE1BQWlCLEVBQUUsS0FBYTtRQUN0QyxpQkFBTSxNQUFNLFlBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTVCLG9DQUFvQztJQUVyQyxDQUFDO0lBRUQsbUJBQUksR0FBSjtRQUNDLGlCQUFNLElBQUksV0FBRSxDQUFDO0lBQ2QsQ0FBQztJQUVGLFdBQUM7QUFBRCxDQUFDLENBM0ZpQyxFQUFFLENBQUMsS0FBSyxHQTJGekMiLCJmaWxlIjoiOTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XHJcbmltcG9ydCBQbGF5ZXIgZnJvbSBcIi4vUGxheWVyXCI7XHJcbmltcG9ydCByZXNvdXJjZXMgZnJvbSBcIi4uLy4uL1Jlc291cmNlc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFJvY2t0eXBlcyA9IHsgXCJzbWFsbFwiOiAxLCBcImJpZ1wiOiAyIH07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb2NrIGV4dGVuZHMgZXguQWN0b3Ige1xyXG5cclxuXHRkOiBudW1iZXI7XHJcblx0eVZlbEJvdW5jZTogbnVtYmVyO1xyXG5cdHR5cDogbnVtYmVyO1xyXG5cdHNwcml0ZTogZXguU3ByaXRlO1xyXG5cdHJvdGF0aW9uVGltZTogbnVtYmVyID0gMDtcclxuXHRudW1iZXJPZlJvdGF0aW9uc1BlclNlY29uZDogbnVtYmVyO1xyXG5cclxuXHRzdGF0aWMgcmVhZG9ubHkgdHlwZXM6IHsgXCJzbWFsbFwiOiAxLCBcImJpZ1wiOiAyIH07XHJcblxyXG5cdGNvbnN0cnVjdG9yKHg6IG51bWJlciwgeTogbnVtYmVyLCBkOiBudW1iZXIsIHNwZWVkWDogbnVtYmVyLCBhY2NZOiBudW1iZXIsIHlWZWxCb3VuY2U6IG51bWJlciwgdHlwOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKHgsIHksIGQsIGQsIGV4LkNvbG9yLldoaXRlKTtcclxuXHJcblx0XHR0aGlzLmQgPSBkO1xyXG5cclxuXHRcdC8vIEFuY2hvclxyXG5cdFx0dGhpcy5hbmNob3Iuc2V0VG8oMC41LCAwLjUpOyAvLyBzZXQgYW5jaG9yIHRvIHRoZSBjZW50ZXJcclxuXHJcblx0XHR0aGlzLmNvbGxpc2lvbkFyZWEuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcclxuXHRcdHRoaXMuY29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGUuUGFzc2l2ZTtcclxuXHJcblx0XHR0aGlzLmFjYy55ID0gYWNjWTtcclxuXHJcblx0XHR0aGlzLnZlbC54ID0gc3BlZWRYO1xyXG5cclxuXHRcdHRoaXMubnVtYmVyT2ZSb3RhdGlvbnNQZXJTZWNvbmQgPSBzcGVlZFggLyAoMiAqIE1hdGguUEkgKiBkIC8gTWF0aC5zcXJ0KDIpKTtcclxuXHJcblxyXG5cdFx0dGhpcy55VmVsQm91bmNlID0geVZlbEJvdW5jZTtcclxuXHJcblx0XHR0aGlzLnR5cCA9IHR5cDtcclxuXHRcdGlmICh0eXAgPT09IFJvY2t0eXBlcy5zbWFsbCkge1xyXG5cdFx0XHR0aGlzLnNwcml0ZSA9IHJlc291cmNlcy5zbWFsbFJvY2suYXNTcHJpdGUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuc3ByaXRlID0gcmVzb3VyY2VzLmJpZ1JvY2suYXNTcHJpdGUoKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuc3ByaXRlLmFuY2hvci5zZXRUbygwLjUsIDAuNSk7XHJcblxyXG5cdFx0Ly8gT24gY29sbGlzaW9uIGNoZWNrIGlmIFBsYXllciBhbmQgdHJhcCBpZiB0cnVlXHJcblx0XHR0aGlzLm9uKFwicHJlY29sbGlzaW9uXCIsIHRoaXMub25QcmVjb2xsaXNpb24pO1xyXG5cdH1cclxuXHJcblx0Ly8gcmFpc2VkIGV2ZXJ5IGZyYW1lIHdoaWxlIGNvbGxpZGluZ1xyXG5cdG9uUHJlY29sbGlzaW9uKGV2OiBhbnkpIHtcclxuXHRcdC8vIGNvbnNvbGUubG9nKFwicHJlY29sbGlzaW9uIGV2ZW50IHJhaXNlZFwiKTtcclxuXHRcdGlmIChldi5vdGhlci5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkdyb3VuZFwiKSB7XHJcblx0XHRcdHRoaXMudmVsLnkgPSB0aGlzLnlWZWxCb3VuY2U7XHJcblx0XHR9IGVsc2VcclxuXHRcdFx0aWYgKGV2Lm90aGVyLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiUGxheWVyXCIpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIm9uUHJlY29sbGlzaW9uIGV2ZW50IG9mIFJvY2sgY29sbGlkaW5nIHdpdGggcGxheWVyXCIpO1xyXG5cdFx0XHRcdGxldCBwbGF5ZXI6IFBsYXllciA9IGV2Lm90aGVyO1xyXG5cdFx0XHRcdHBsYXllci5kaWUoXCJZb3UgZ290IGhpdCBieSBhIHJvY2shXCIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZHJhdyhjdHg6IGFueSwgZGVsdGE6IGFueSkge1xyXG5cdFx0Ly8gT3B0aW9uYWxseSBjYWxsIG9yaWdpbmFsICdiYXNlJyBtZXRob2RcclxuXHRcdGV4LkFjdG9yLnByb3RvdHlwZS5kcmF3LmNhbGwodGhpcywgY3R4LCBkZWx0YSk7XHJcblxyXG5cdFx0Ly8gQ3VzdG9tIGRyYXcgY29kZVxyXG5cdFx0LypcclxuXHRcdGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yLnRvU3RyaW5nKCk7XHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRjdHguYXJjKHRoaXMucG9zLngsIHRoaXMucG9zLnksIE1hdGgudHJ1bmMoTWF0aC5zcXJ0KCh0aGlzLmQgKiB0aGlzLmQpLzQuMCkpKzEsIDAsIE1hdGguUEkgKiAyKTtcclxuXHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdGN0eC5maWxsKCk7XHJcblx0XHQqL1xyXG5cdFx0Ly8gVE9ETzogY2FsY3VsYXRlIHJvdGF0aW9uXHJcblx0XHR0aGlzLnJvdGF0aW9uVGltZSArPSBkZWx0YSAvIDEwMDA7XHJcblx0XHRcclxuXHRcdHRoaXMucm90YXRpb24gPSAoKHRoaXMucm90YXRpb25UaW1lICogdGhpcy5udW1iZXJPZlJvdGF0aW9uc1BlclNlY29uZCkgJSAxKSAqIDIgKiBNYXRoLlBJO1xyXG5cclxuXHRcdHRoaXMuc3ByaXRlLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuXHJcblx0XHR0aGlzLnNwcml0ZS5kcmF3KGN0eCwgdGhpcy5nZXRDZW50ZXIoKS54LCB0aGlzLmdldENlbnRlcigpLnkpO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZShlbmdpbmU6IGV4LkVuZ2luZSwgZGVsdGE6IG51bWJlcikge1xyXG5cdFx0c3VwZXIudXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG5cclxuXHRcdC8vIFRPRE86IGtpbGwgd2hlbiBmYXIgYmVoaW5kIHBsYXllclxyXG5cclxuXHR9XHJcblxyXG5cdGtpbGwoKSB7XHJcblx0XHRzdXBlci5raWxsKCk7XHJcblx0fVxyXG5cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWwzL1JvY2sudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///98\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Class_1 = __webpack_require__(5);\r\nvar LockLevelCameraStrategy_1 = __webpack_require__(16);\r\nvar Ground_1 = __webpack_require__(100);\r\nvar Player_1 = __webpack_require__(101);\r\nvar Cannibale_1 = __webpack_require__(102);\r\nvar Level4 = /** @class */ (function (_super) {\r\n    __extends(Level4, _super);\r\n    function Level4(bootstrap) {\r\n        var _this = _super.call(this) || this;\r\n        _this.sceneKey = "level4";\r\n        _this.levelBounds = new ex.BoundingBox(0, 0, 5000, 600);\r\n        _this.sceneBackgroundColor = ex.Color.Gray;\r\n        _this.cannibales = [];\r\n        _this.buildScene = function () {\r\n            // add actors\r\n            _this.scene.add(_this.ground);\r\n            _this.scene.add(_this.player);\r\n            var that = _this;\r\n            _this.cannibales.forEach(function (b) {\r\n                that.scene.add(b);\r\n            });\r\n            _this.engine.addScene(_this.sceneKey, _this.scene);\r\n            _this.engine.goToScene(_this.sceneKey);\r\n        };\r\n        _this.engine = bootstrap.engine;\r\n        _this.scene = new ex.Scene(_this.engine);\r\n        _this.bounds = _this.engine.getWorldBounds();\r\n        _this.loader = bootstrap.loader;\r\n        // Actor creation\r\n        _this.ground = new Ground_1.default(_this.bounds.left + 2500, _this.bounds.bottom - 25);\r\n        _this.player = new Player_1.default(100, 400, _this.levelBounds);\r\n        var i = 0;\r\n        var numCannibales = 10;\r\n        for (i; i < numCannibales; i++) {\r\n            var xStart = _this.randomIntFromInterval(500, 4500);\r\n            var speedX = _this.randomIntFromInterval(100, 200);\r\n            _this.cannibales.push(new Cannibale_1.default(xStart, 525, 50, speedX, 400, 4600));\r\n        }\r\n        return _this;\r\n    }\r\n    Level4.prototype.start = function () {\r\n        this.engine.backgroundColor = this.sceneBackgroundColor; // set background color\r\n        ex.Physics.acc.setTo(0, 2000);\r\n        this.scene.camera.addStrategy(new ex.LockCameraToActorAxisStrategy(this.player, ex.Axis.X));\r\n        this.scene.camera.addStrategy(new LockLevelCameraStrategy_1.default(this.bounds, this.levelBounds));\r\n        this.buildScene();\r\n    };\r\n    Level4.prototype.dispose = function () {\r\n        this.ground.kill();\r\n    };\r\n    Level4.prototype.randomIntFromInterval = function (min, max) {\r\n        var t = Math.floor(Math.random() * (max - min + 1) + min);\r\n        return t;\r\n    };\r\n    return Level4;\r\n}(Class_1.Class));\r\nexports.default = Level4;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsNC9MZXZlbDQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLHFDQUFvQztBQUNwQyx3REFBK0U7QUFFL0Usd0NBQThCO0FBQzlCLHdDQUE4QjtBQUM5QiwyQ0FBb0M7QUFFcEM7SUFBb0MsMEJBQXlCO0lBdUI1RCxnQkFBWSxTQUF3QjtRQUFwQyxZQUNDLGlCQUFPLFNBbUJQO1FBekNRLGNBQVEsR0FBVyxRQUFRLENBQUM7UUFDNUIsaUJBQVcsR0FBbUIsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2xFLDBCQUFvQixHQUFhLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO1FBU3hELGdCQUFVLEdBQWdCLEVBQUUsQ0FBQztRQTRDckIsZ0JBQVUsR0FBRztZQUVwQixhQUFhO1lBQ2IsS0FBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzVCLEtBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM1QixJQUFJLElBQUksR0FBRyxLQUFJLENBQUM7WUFDaEIsS0FBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDO2dCQUNsQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuQixDQUFDLENBQUMsQ0FBQztZQUVILEtBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2hELEtBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN0QyxDQUFDO1FBM0NBLEtBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUMvQixLQUFJLENBQUMsS0FBSyxHQUFHLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkMsS0FBSSxDQUFDLE1BQU0sR0FBRyxLQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQzNDLEtBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUUvQixpQkFBaUI7UUFDakIsS0FBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGdCQUFNLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxFQUFFLEtBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQzNFLEtBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxnQkFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXJELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNWLElBQUksYUFBYSxHQUFHLEVBQUUsQ0FBQztRQUN2QixHQUFHLEVBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxhQUFhLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUMvQixJQUFJLE1BQU0sR0FBRyxLQUFJLENBQUMscUJBQXFCLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ25ELElBQUksTUFBTSxHQUFHLEtBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDbEQsS0FBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxtQkFBUyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUN6RSxDQUFDOztJQUVGLENBQUM7SUFFRCxzQkFBSyxHQUFMO1FBQ0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsdUJBQXVCO1FBQ2hGLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDOUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLDZCQUE2QixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVGLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGlDQUF1QixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFDMUYsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRCx3QkFBTyxHQUFQO1FBQ0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNwQixDQUFDO0lBZ0JELHNDQUFxQixHQUFyQixVQUFzQixHQUFXLEVBQUUsR0FBVztRQUM3QyxJQUFJLENBQUMsR0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDbEUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRixhQUFDO0FBQUQsQ0FBQyxDQTVFbUMsYUFBSyxHQTRFeEMiLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBleCBmcm9tIFwiZXhjYWxpYnVyXCI7XHJcbmltcG9ydCB7IENsYXNzIH0gZnJvbSBcIi4uLy4uL0NsYXNzXCI7XHJcbmltcG9ydCBMb2NrTGV2ZWxDYW1lcmFTdHJhdGVneSBmcm9tIFwiLi4vLi4vQ29tcG9uZW50cy9Mb2NrTGV2ZWxDYW1lcmFTdHJhdGVneVwiO1xyXG5pbXBvcnQgeyBHYW1lQm9vdHN0cmFwLCBJR2FtZUVsZW1lbnQsIElHYW1lRWxlbWVudEV2ZW50cyB9IGZyb20gXCIuLi8uLi9HYW1lQm9vdHN0cmFwXCI7XHJcbmltcG9ydCBHcm91bmQgZnJvbSBcIi4vR3JvdW5kXCI7XHJcbmltcG9ydCBQbGF5ZXIgZnJvbSBcIi4vUGxheWVyXCI7XHJcbmltcG9ydCBDYW5uaWJhbGUgZnJvbSBcIi4vQ2FubmliYWxlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbDQgZXh0ZW5kcyBDbGFzczxJR2FtZUVsZW1lbnRFdmVudHM+IGltcGxlbWVudHMgSUdhbWVFbGVtZW50IHtcclxuXHJcblx0cmVhZG9ubHkgc2NlbmVLZXk6IHN0cmluZyA9IFwibGV2ZWw0XCI7XHJcblx0cmVhZG9ubHkgbGV2ZWxCb3VuZHM6IGV4LkJvdW5kaW5nQm94ID0gbmV3IGV4LkJvdW5kaW5nQm94KDAsIDAsIDUwMDAsIDYwMCk7XHJcblx0cmVhZG9ubHkgc2NlbmVCYWNrZ3JvdW5kQ29sb3I6IGV4LkNvbG9yID0gZXguQ29sb3IuR3JheTtcclxuXHJcblx0ZW5naW5lOiBleC5FbmdpbmU7XHJcblx0c2NlbmU6IGV4LlNjZW5lO1xyXG5cdGJvdW5kczogZXguQm91bmRpbmdCb3g7XHJcblxyXG5cdC8vIGFjdG9yc1xyXG5cdGdyb3VuZDogR3JvdW5kO1xyXG5cdHBsYXllcjogUGxheWVyO1xyXG5cdGNhbm5pYmFsZXM6IENhbm5pYmFsZVtdID0gW107XHJcblxyXG5cdC8qXHJcblx0Ly8gYnViYmxlc1xyXG5cdGJ1YmJsZXM6IEJ1YmJsZVtdO1xyXG4gICAgYnViYmxlQ3JlYXRvcjogQnViYmxlQ3JlYXRvcjtcclxuICAgICovXHJcblxyXG5cdGxvYWRlcjogZXguTG9hZGVyO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihib290c3RyYXA6IEdhbWVCb290c3RyYXApIHtcclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5lbmdpbmUgPSBib290c3RyYXAuZW5naW5lO1xyXG5cdFx0dGhpcy5zY2VuZSA9IG5ldyBleC5TY2VuZSh0aGlzLmVuZ2luZSk7XHJcblx0XHR0aGlzLmJvdW5kcyA9IHRoaXMuZW5naW5lLmdldFdvcmxkQm91bmRzKCk7XHJcblx0XHR0aGlzLmxvYWRlciA9IGJvb3RzdHJhcC5sb2FkZXI7XHJcblxyXG5cdFx0Ly8gQWN0b3IgY3JlYXRpb25cclxuXHRcdHRoaXMuZ3JvdW5kID0gbmV3IEdyb3VuZCh0aGlzLmJvdW5kcy5sZWZ0ICsgMjUwMCwgdGhpcy5ib3VuZHMuYm90dG9tIC0gMjUpO1xyXG5cdFx0dGhpcy5wbGF5ZXIgPSBuZXcgUGxheWVyKDEwMCwgNDAwLCB0aGlzLmxldmVsQm91bmRzKTtcclxuXHJcblx0XHRsZXQgaSA9IDA7XHJcblx0XHRsZXQgbnVtQ2FubmliYWxlcyA9IDEwO1xyXG5cdFx0Zm9yKGk7IGkgPCBudW1DYW5uaWJhbGVzOyBpKyspIHtcclxuXHRcdFx0bGV0IHhTdGFydCA9IHRoaXMucmFuZG9tSW50RnJvbUludGVydmFsKDUwMCwgNDUwMCk7XHJcblx0XHRcdGxldCBzcGVlZFggPSB0aGlzLnJhbmRvbUludEZyb21JbnRlcnZhbCgxMDAsIDIwMCk7XHJcblx0XHRcdHRoaXMuY2FubmliYWxlcy5wdXNoKG5ldyBDYW5uaWJhbGUoeFN0YXJ0LCA1MjUsIDUwLCBzcGVlZFgsIDQwMCwgNDYwMCkpO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHN0YXJ0KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5lbmdpbmUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5zY2VuZUJhY2tncm91bmRDb2xvcjsgLy8gc2V0IGJhY2tncm91bmQgY29sb3JcclxuXHRcdGV4LlBoeXNpY3MuYWNjLnNldFRvKDAsIDIwMDApO1xyXG5cdFx0dGhpcy5zY2VuZS5jYW1lcmEuYWRkU3RyYXRlZ3kobmV3IGV4LkxvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5KHRoaXMucGxheWVyLCBleC5BeGlzLlgpKTtcclxuXHRcdHRoaXMuc2NlbmUuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBMb2NrTGV2ZWxDYW1lcmFTdHJhdGVneSh0aGlzLmJvdW5kcywgdGhpcy5sZXZlbEJvdW5kcykpO1xyXG5cdFx0dGhpcy5idWlsZFNjZW5lKCk7XHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5ncm91bmQua2lsbCgpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBidWlsZFNjZW5lID0gKCkgPT4ge1xyXG5cclxuXHRcdC8vIGFkZCBhY3RvcnNcclxuXHRcdHRoaXMuc2NlbmUuYWRkKHRoaXMuZ3JvdW5kKTtcclxuXHRcdHRoaXMuc2NlbmUuYWRkKHRoaXMucGxheWVyKTtcclxuXHRcdGxldCB0aGF0ID0gdGhpcztcclxuXHRcdHRoaXMuY2FubmliYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XHJcblx0XHRcdHRoYXQuc2NlbmUuYWRkKGIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5lbmdpbmUuYWRkU2NlbmUodGhpcy5zY2VuZUtleSwgdGhpcy5zY2VuZSk7XHJcblx0XHR0aGlzLmVuZ2luZS5nb1RvU2NlbmUodGhpcy5zY2VuZUtleSk7XHJcblx0fVxyXG5cclxuXHRyYW5kb21JbnRGcm9tSW50ZXJ2YWwobWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGxldCB0OiBudW1iZXIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pO1xyXG5cdFx0cmV0dXJuIHQ7XHJcblx0fVxyXG5cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWw0L0xldmVsNC50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///99\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Resources_1 = __webpack_require__(7);\r\nvar Ground = /** @class */ (function (_super) {\r\n    __extends(Ground, _super);\r\n    function Ground(x, y) {\r\n        var _this = _super.call(this, x, y, Ground.width, 50, ex.Color.Gray) || this;\r\n        _this.collisionType = ex.CollisionType.Fixed;\r\n        return _this;\r\n    }\r\n    Ground.prototype.draw = function (ctx, delta) {\r\n        var sprite = Resources_1.default.seaBed.asSprite();\r\n        var offset = 0;\r\n        while (offset < Ground.width) {\r\n            sprite.draw(ctx, this.getLeft() + offset, this.getTop());\r\n            offset += 70;\r\n        }\r\n    };\r\n    Ground.width = 5000;\r\n    return Ground;\r\n}(ex.Actor));\r\nexports.default = Ground;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsNC9Hcm91bmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLHlDQUF3QztBQUV4QztJQUFvQywwQkFBUTtJQUkzQyxnQkFBWSxDQUFTLEVBQUUsQ0FBUztRQUFoQyxZQUNDLGtCQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FFNUM7UUFEQSxLQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDOztJQUM3QyxDQUFDO0lBRUQscUJBQUksR0FBSixVQUFLLEdBQTZCLEVBQUUsS0FBYTtRQUNoRCxJQUFNLE1BQU0sR0FBRyxtQkFBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMzQyxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFFZixPQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztZQUN6RCxNQUFNLElBQUksRUFBRSxDQUFDO1FBQ2QsQ0FBQztJQUNGLENBQUM7SUFmZSxZQUFLLEdBQVcsSUFBSSxDQUFDO0lBZ0J0QyxhQUFDO0NBQUEsQ0FsQm1DLEVBQUUsQ0FBQyxLQUFLLEdBa0IzQztrQkFsQm9CLE1BQU0iLCJmaWxlIjoiMTAwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZXggZnJvbSBcImV4Y2FsaWJ1clwiO1xyXG5pbXBvcnQgUmVzb3VyY2VzIGZyb20gXCIuLi8uLi9SZXNvdXJjZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyb3VuZCBleHRlbmRzIGV4LkFjdG9yIHtcclxuXHJcblx0c3RhdGljIHJlYWRvbmx5IHdpZHRoOiBudW1iZXIgPSA1MDAwO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG5cdFx0c3VwZXIoeCwgeSwgR3JvdW5kLndpZHRoLCA1MCwgZXguQ29sb3IuR3JheSk7XHJcblx0XHR0aGlzLmNvbGxpc2lvblR5cGUgPSBleC5Db2xsaXNpb25UeXBlLkZpeGVkO1xyXG5cdH1cclxuXHJcblx0ZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZGVsdGE6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3Qgc3ByaXRlID0gUmVzb3VyY2VzLnNlYUJlZC5hc1Nwcml0ZSgpO1xyXG5cdFx0bGV0IG9mZnNldCA9IDA7XHJcblxyXG5cdFx0d2hpbGUob2Zmc2V0IDwgR3JvdW5kLndpZHRoKSB7XHJcblx0XHRcdHNwcml0ZS5kcmF3KGN0eCwgdGhpcy5nZXRMZWZ0KCkgKyBvZmZzZXQsIHRoaXMuZ2V0VG9wKCkpO1xyXG5cdFx0XHRvZmZzZXQgKz0gNzA7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvZGUvc3JjL1NjZW5lcy9MZXZlbDQvR3JvdW5kLnRzIl0sInNvdXJjZVJvb3QiOiJzb3VyY2U6Ly8vIn0=\n//# sourceURL=webpack-internal:///100\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar BasePlayer_1 = __webpack_require__(23);\r\nvar Player = /** @class */ (function (_super) {\r\n    __extends(Player, _super);\r\n    function Player(x, y, levelBounds) {\r\n        var _this = _super.call(this, x, y) || this;\r\n        _this.dead = false;\r\n        _this.minX = levelBounds.left + Player.size.w / 2;\r\n        _this.maxX = levelBounds.right - Player.size.w / 2;\r\n        _this.anchor.setTo(0.5, 1);\r\n        _this.body.useBoxCollision();\r\n        _this.y += _this.getHeight() / 2;\r\n        _this.color = ex.Color.Orange;\r\n        return _this;\r\n    }\r\n    Player.prototype.update = function (engine, delta) {\r\n        _super.prototype.update.call(this, engine, delta);\r\n        if (engine.input.keyboard.wasPressed(ex.Input.Keys.Space)) {\r\n            this.jump();\r\n        }\r\n        if (engine.input.keyboard.isHeld(ex.Input.Keys.Left)) {\r\n            this.goLeft();\r\n        }\r\n        if (engine.input.keyboard.isHeld(ex.Input.Keys.Right)) {\r\n            this.goRight();\r\n        }\r\n    };\r\n    Player.prototype.jump = function () {\r\n        var groundLevel = this.scene.engine.getWorldBounds().bottom - 50;\r\n        if (groundLevel - this.getBottom() < 15) {\r\n            this.vel.setTo(this.vel.x, -700);\r\n            // console.log(this.vel);\r\n        }\r\n    };\r\n    Player.prototype.goLeft = function () {\r\n        this.pos.x -= Player.speed;\r\n        this.pos.x = this.pos.x < this.minX ? this.minX : this.pos.x;\r\n    };\r\n    Player.prototype.goRight = function () {\r\n        this.pos.x += Player.speed;\r\n        this.pos.x = this.pos.x > this.maxX ? this.maxX : this.pos.x;\r\n    };\r\n    Player.prototype.die = function (info) {\r\n        if (!this.dead) {\r\n            // console.log("cam rot: "+this.scene.camera.rotation + "   (level3 - player - die)"); // proof that rotation is not influenced by anything else\r\n            this.dead = true;\r\n            // this.setHeight(this.getHeight() / 4);\r\n            this.collisionArea.body.useBoxCollision();\r\n            this.scene.camera.shake(50, 50, 500);\r\n            var player_1 = this;\r\n            setTimeout(function () {\r\n                player_1.kill();\r\n                alert(info);\r\n            }, 550);\r\n        }\r\n    };\r\n    Player.speed = 8;\r\n    return Player;\r\n}(BasePlayer_1.default));\r\nexports.default = Player;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsNC9QbGF5ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBQ2hDLDJDQUFxRDtBQUdyRDtJQUFvQywwQkFBVTtJQU03QyxnQkFBWSxDQUFTLEVBQUUsQ0FBUyxFQUFFLFdBQTJCO1FBQTdELFlBQ0Msa0JBQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQU9YO1FBVkQsVUFBSSxHQUFZLEtBQUssQ0FBQztRQUlyQixLQUFJLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pELEtBQUksQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEQsS0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzFCLEtBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDNUIsS0FBSSxDQUFDLENBQUMsSUFBSSxLQUFJLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQy9CLEtBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7O0lBQzlCLENBQUM7SUFFRCx1QkFBTSxHQUFOLFVBQU8sTUFBaUIsRUFBRSxLQUFhO1FBQ3RDLGlCQUFNLE1BQU0sWUFBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFNUIsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzRCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDYixDQUFDO1FBRUQsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0RCxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDZixDQUFDO1FBRUQsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2RCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDaEIsQ0FBQztJQUVGLENBQUM7SUFFTyxxQkFBSSxHQUFaO1FBQ0MsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUVqRSxFQUFFLENBQUMsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyx5QkFBeUI7UUFDMUIsQ0FBQztJQUNGLENBQUM7SUFFTyx1QkFBTSxHQUFkO1FBQ0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQztRQUMzQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRU8sd0JBQU8sR0FBZjtRQUNDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDM0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVNLG9CQUFHLEdBQVYsVUFBVyxJQUFZO1FBQ3RCLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFFaEIsZ0pBQWdKO1lBRWhKLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1lBRWpCLHdDQUF3QztZQUN4QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUUxQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUVyQyxJQUFJLFFBQU0sR0FBVyxJQUFJLENBQUM7WUFDMUIsVUFBVSxDQUFDO2dCQUVWLFFBQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDZCxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDVCxDQUFDO0lBQ0YsQ0FBQztJQXZFZSxZQUFLLEdBQVcsQ0FBQyxDQUFDO0lBeUVuQyxhQUFDO0NBQUEsQ0ExRW1DLG9CQUFVLEdBMEU3QztrQkExRW9CLE1BQU0iLCJmaWxlIjoiMTAxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZXggZnJvbSBcImV4Y2FsaWJ1clwiO1xyXG5pbXBvcnQgQmFzZVBsYXllciBmcm9tIFwiLi4vLi4vQ29tcG9uZW50cy9CYXNlUGxheWVyXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyIGV4dGVuZHMgQmFzZVBsYXllciB7XHJcblx0c3RhdGljIHJlYWRvbmx5IHNwZWVkOiBudW1iZXIgPSA4O1xyXG5cdHByaXZhdGUgbWluWDogbnVtYmVyO1xyXG5cdHByaXZhdGUgbWF4WDogbnVtYmVyO1xyXG5cdGRlYWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0Y29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIsIGxldmVsQm91bmRzOiBleC5Cb3VuZGluZ0JveCkge1xyXG5cdFx0c3VwZXIoeCwgeSk7XHJcblx0XHR0aGlzLm1pblggPSBsZXZlbEJvdW5kcy5sZWZ0ICsgUGxheWVyLnNpemUudyAvIDI7XHJcblx0XHR0aGlzLm1heFggPSBsZXZlbEJvdW5kcy5yaWdodCAtIFBsYXllci5zaXplLncgLyAyO1xyXG5cdFx0dGhpcy5hbmNob3Iuc2V0VG8oMC41LCAxKTtcclxuXHRcdHRoaXMuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcclxuXHRcdHRoaXMueSArPSB0aGlzLmdldEhlaWdodCgpIC8gMjtcclxuXHRcdHRoaXMuY29sb3IgPSBleC5Db2xvci5PcmFuZ2U7XHJcblx0fVxyXG5cclxuXHR1cGRhdGUoZW5naW5lOiBleC5FbmdpbmUsIGRlbHRhOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuXHJcblx0XHRpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLndhc1ByZXNzZWQoZXguSW5wdXQuS2V5cy5TcGFjZSkpIHtcclxuXHRcdFx0dGhpcy5qdW1wKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGVuZ2luZS5pbnB1dC5rZXlib2FyZC5pc0hlbGQoZXguSW5wdXQuS2V5cy5MZWZ0KSkge1xyXG5cdFx0XHR0aGlzLmdvTGVmdCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQuaXNIZWxkKGV4LklucHV0LktleXMuUmlnaHQpKSB7XHJcblx0XHRcdHRoaXMuZ29SaWdodCgpO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHByaXZhdGUganVtcCgpIHtcclxuXHRcdGxldCBncm91bmRMZXZlbCA9IHRoaXMuc2NlbmUuZW5naW5lLmdldFdvcmxkQm91bmRzKCkuYm90dG9tIC0gNTA7XHJcblxyXG5cdFx0aWYgKGdyb3VuZExldmVsIC0gdGhpcy5nZXRCb3R0b20oKSA8IDE1KSB7XHJcblx0XHRcdHRoaXMudmVsLnNldFRvKHRoaXMudmVsLngsIC03MDApO1xyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyh0aGlzLnZlbCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGdvTGVmdCgpIHtcclxuXHRcdHRoaXMucG9zLnggLT0gUGxheWVyLnNwZWVkO1xyXG5cdFx0dGhpcy5wb3MueCA9IHRoaXMucG9zLnggPCB0aGlzLm1pblggPyB0aGlzLm1pblggOiB0aGlzLnBvcy54O1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBnb1JpZ2h0KCkge1xyXG5cdFx0dGhpcy5wb3MueCArPSBQbGF5ZXIuc3BlZWQ7XHJcblx0XHR0aGlzLnBvcy54ID0gdGhpcy5wb3MueCA+IHRoaXMubWF4WCA/IHRoaXMubWF4WCA6IHRoaXMucG9zLng7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZGllKGluZm86IHN0cmluZykge1xyXG5cdFx0aWYgKCF0aGlzLmRlYWQpIHtcclxuXHJcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwiY2FtIHJvdDogXCIrdGhpcy5zY2VuZS5jYW1lcmEucm90YXRpb24gKyBcIiAgIChsZXZlbDMgLSBwbGF5ZXIgLSBkaWUpXCIpOyAvLyBwcm9vZiB0aGF0IHJvdGF0aW9uIGlzIG5vdCBpbmZsdWVuY2VkIGJ5IGFueXRoaW5nIGVsc2VcclxuXHJcblx0XHRcdHRoaXMuZGVhZCA9IHRydWU7XHJcblxyXG5cdFx0XHQvLyB0aGlzLnNldEhlaWdodCh0aGlzLmdldEhlaWdodCgpIC8gNCk7XHJcblx0XHRcdHRoaXMuY29sbGlzaW9uQXJlYS5ib2R5LnVzZUJveENvbGxpc2lvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5zY2VuZS5jYW1lcmEuc2hha2UoNTAsIDUwLCA1MDApO1x0XHRcdFxyXG5cclxuXHRcdFx0bGV0IHBsYXllcjogUGxheWVyID0gdGhpcztcclxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0cGxheWVyLmtpbGwoKTtcclxuXHRcdFx0XHRhbGVydChpbmZvKTtcclxuXHJcblx0XHRcdH0sIDU1MCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb2RlL3NyYy9TY2VuZXMvTGV2ZWw0L1BsYXllci50cyJdLCJzb3VyY2VSb290Ijoic291cmNlOi8vLyJ9\n//# sourceURL=webpack-internal:///101\n')},function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ex = __webpack_require__(1);\r\nvar Cannibale = /** @class */ (function (_super) {\r\n    __extends(Cannibale, _super);\r\n    function Cannibale(x, y, d, speedX, minX, maxX) {\r\n        var _this = _super.call(this, x, y, d, d, ex.Color.White) || this;\r\n        _this.minX = minX;\r\n        _this.maxX = maxX;\r\n        _this.speedX = speedX;\r\n        // Anchor\r\n        _this.anchor.setTo(0.5, 0.5); // set anchor to the center\r\n        _this.collisionArea.body.useBoxCollision();\r\n        _this.collisionType = ex.CollisionType.Passive;\r\n        if (_this.randomIntFromInterval(1, 2) > 1) {\r\n            _this.vel.x = speedX;\r\n        }\r\n        else {\r\n            _this.vel.x = -speedX;\r\n        }\r\n        // On collision check if Player and trap if true\r\n        _this.on("precollision", _this.onPrecollision);\r\n        return _this;\r\n    }\r\n    // raised every frame while colliding\r\n    Cannibale.prototype.onPrecollision = function (ev) {\r\n        // console.log("precollision event raised");\r\n        if (ev.other.constructor.name === "Player") {\r\n            console.log("onPrecollision event of cannibale colliding with player");\r\n            var player = ev.other;\r\n            player.die("You got hit by a cannibale!");\r\n        }\r\n    };\r\n    Cannibale.prototype.draw = function (ctx, delta) {\r\n        // Optionally call original \'base\' method\r\n        ex.Actor.prototype.draw.call(this, ctx, delta);\r\n        // this.sprite.draw(ctx, this.getCenter().x, this.getCenter().y);\r\n    };\r\n    Cannibale.prototype.update = function (engine, delta) {\r\n        _super.prototype.update.call(this, engine, delta);\r\n        // check for minX/maxX\r\n        if (this.pos.x - this.getWidth() < this.minX) {\r\n            this.vel.x = this.speedX;\r\n        }\r\n        if (this.pos.x + this.getWidth() > this.maxX) {\r\n            this.vel.x = -this.speedX;\r\n        }\r\n    };\r\n    Cannibale.prototype.kill = function () {\r\n        _super.prototype.kill.call(this);\r\n    };\r\n    Cannibale.prototype.randomIntFromInterval = function (min, max) {\r\n        var t = Math.floor(Math.random() * (max - min + 1) + min);\r\n        return t;\r\n    };\r\n    return Cannibale;\r\n}(ex.Actor));\r\nexports.default = Cannibale;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vY29kZS9zcmMvU2NlbmVzL0xldmVsNC9DYW5uaWJhbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0NBQWdDO0FBSWhDO0lBQXVDLDZCQUFRO0lBTzlDLG1CQUFZLENBQVMsRUFBRSxDQUFTLEVBQUUsQ0FBUyxFQUFFLE1BQWMsRUFBRSxJQUFZLEVBQUUsSUFBVztRQUF0RixZQUNDLGtCQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQW9CakM7UUFsQkEsS0FBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsS0FBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsS0FBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFFckIsU0FBUztRQUNULEtBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLDJCQUEyQjtRQUV4RCxLQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUMxQyxLQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDO1FBRTlDLEVBQUUsRUFBQyxLQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsS0FBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNQLEtBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDO1FBQ3RCLENBQUM7UUFFRCxnREFBZ0Q7UUFDaEQsS0FBSSxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsS0FBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDOztJQUM5QyxDQUFDO0lBRUQscUNBQXFDO0lBQ3JDLGtDQUFjLEdBQWQsVUFBZSxFQUFPO1FBQ3JCLDRDQUE0QztRQUM1QyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQztZQUM1QyxPQUFPLENBQUMsR0FBRyxDQUFDLHlEQUF5RCxDQUFDLENBQUM7WUFDdkUsSUFBSSxNQUFNLEdBQVcsRUFBRSxDQUFDLEtBQUssQ0FBQztZQUM5QixNQUFNLENBQUMsR0FBRyxDQUFDLDZCQUE2QixDQUFDLENBQUM7UUFDM0MsQ0FBQztJQUVGLENBQUM7SUFFRCx3QkFBSSxHQUFKLFVBQUssR0FBUSxFQUFFLEtBQVU7UUFDeEIseUNBQXlDO1FBQ3pDLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUUvQyxpRUFBaUU7SUFFbEUsQ0FBQztJQUVELDBCQUFNLEdBQU4sVUFBTyxNQUFpQixFQUFFLEtBQWE7UUFDdEMsaUJBQU0sTUFBTSxZQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUU1QixzQkFBc0I7UUFDdEIsRUFBRSxFQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM3QyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQzFCLENBQUM7UUFDRCxFQUFFLEVBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzdDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFJLENBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUM3QixDQUFDO0lBRUYsQ0FBQztJQUVELHdCQUFJLEdBQUo7UUFDQyxpQkFBTSxJQUFJLFdBQUUsQ0FBQztJQUNkLENBQUM7SUFFRCx5Q0FBcUIsR0FBckIsVUFBc0IsR0FBVyxFQUFFLEdBQVc7UUFDN0MsSUFBSSxDQUFDLEdBQVcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ2xFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDVixDQUFDO0lBRUYsZ0JBQUM7QUFBRCxDQUFDLENBdkVzQyxFQUFFLENBQUMsS0FBSyxHQXVFOUMiLCJmaWxlIjoiMTAyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZXggZnJvbSBcImV4Y2FsaWJ1clwiO1xyXG5pbXBvcnQgUGxheWVyIGZyb20gXCIuL1BsYXllclwiO1xyXG5pbXBvcnQgcmVzb3VyY2VzIGZyb20gXCIuLi8uLi9SZXNvdXJjZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbm5pYmFsZSBleHRlbmRzIGV4LkFjdG9yIHtcclxuXHJcblx0Ly8gc3ByaXRlOiBleC5TcHJpdGU7XHJcblx0bWluWDogbnVtYmVyO1xyXG5cdG1heFg6IG51bWJlcjtcclxuXHRzcGVlZFg6IG51bWJlcjtcclxuXHJcblx0Y29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIsIGQ6IG51bWJlciwgc3BlZWRYOiBudW1iZXIsIG1pblg6IG51bWJlciwgbWF4WDpudW1iZXIpIHtcclxuXHRcdHN1cGVyKHgsIHksIGQsIGQsIGV4LkNvbG9yLldoaXRlKTtcclxuXHJcblx0XHR0aGlzLm1pblggPSBtaW5YO1xyXG5cdFx0dGhpcy5tYXhYID0gbWF4WDtcclxuXHRcdHRoaXMuc3BlZWRYID0gc3BlZWRYO1xyXG5cclxuXHRcdC8vIEFuY2hvclxyXG5cdFx0dGhpcy5hbmNob3Iuc2V0VG8oMC41LCAwLjUpOyAvLyBzZXQgYW5jaG9yIHRvIHRoZSBjZW50ZXJcclxuXHJcblx0XHR0aGlzLmNvbGxpc2lvbkFyZWEuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcclxuXHRcdHRoaXMuY29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGUuUGFzc2l2ZTtcclxuXHJcblx0XHRpZih0aGlzLnJhbmRvbUludEZyb21JbnRlcnZhbCgxLDIpPjEpIHtcclxuXHRcdFx0dGhpcy52ZWwueCA9IHNwZWVkWDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMudmVsLnggPSAtc3BlZWRYO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE9uIGNvbGxpc2lvbiBjaGVjayBpZiBQbGF5ZXIgYW5kIHRyYXAgaWYgdHJ1ZVxyXG5cdFx0dGhpcy5vbihcInByZWNvbGxpc2lvblwiLCB0aGlzLm9uUHJlY29sbGlzaW9uKTtcclxuXHR9XHJcblxyXG5cdC8vIHJhaXNlZCBldmVyeSBmcmFtZSB3aGlsZSBjb2xsaWRpbmdcclxuXHRvblByZWNvbGxpc2lvbihldjogYW55KSB7XHJcblx0XHQvLyBjb25zb2xlLmxvZyhcInByZWNvbGxpc2lvbiBldmVudCByYWlzZWRcIik7XHJcblx0XHRpZiAoZXYub3RoZXIuY29uc3RydWN0b3IubmFtZSA9PT0gXCJQbGF5ZXJcIikge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIm9uUHJlY29sbGlzaW9uIGV2ZW50IG9mIGNhbm5pYmFsZSBjb2xsaWRpbmcgd2l0aCBwbGF5ZXJcIik7XHJcblx0XHRcdGxldCBwbGF5ZXI6IFBsYXllciA9IGV2Lm90aGVyO1xyXG5cdFx0XHRwbGF5ZXIuZGllKFwiWW91IGdvdCBoaXQgYnkgYSBjYW5uaWJhbGUhXCIpO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGRyYXcoY3R4OiBhbnksIGRlbHRhOiBhbnkpIHtcclxuXHRcdC8vIE9wdGlvbmFsbHkgY2FsbCBvcmlnaW5hbCAnYmFzZScgbWV0aG9kXHJcblx0XHRleC5BY3Rvci5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMsIGN0eCwgZGVsdGEpO1xyXG5cclxuXHRcdC8vIHRoaXMuc3ByaXRlLmRyYXcoY3R4LCB0aGlzLmdldENlbnRlcigpLngsIHRoaXMuZ2V0Q2VudGVyKCkueSk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKGVuZ2luZTogZXguRW5naW5lLCBkZWx0YTogbnVtYmVyKSB7XHJcblx0XHRzdXBlci51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcblxyXG5cdFx0Ly8gY2hlY2sgZm9yIG1pblgvbWF4WFxyXG5cdFx0aWYodGhpcy5wb3MueCAtIHRoaXMuZ2V0V2lkdGgoKSA8IHRoaXMubWluWCkge1xyXG5cdFx0XHR0aGlzLnZlbC54ID0gdGhpcy5zcGVlZFg7XHJcblx0XHR9XHJcblx0XHRpZih0aGlzLnBvcy54ICsgdGhpcy5nZXRXaWR0aCgpID4gdGhpcy5tYXhYKSB7XHJcblx0XHRcdHRoaXMudmVsLnggPSAgLSB0aGlzLnNwZWVkWDtcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRraWxsKCkge1xyXG5cdFx0c3VwZXIua2lsbCgpO1xyXG5cdH1cclxuXHJcblx0cmFuZG9tSW50RnJvbUludGVydmFsKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRsZXQgdDogbnVtYmVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluKTtcclxuXHRcdHJldHVybiB0O1xyXG5cdH1cclxuXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29kZS9zcmMvU2NlbmVzL0xldmVsNC9DYW5uaWJhbGUudHMiXSwic291cmNlUm9vdCI6InNvdXJjZTovLy8ifQ==\n//# sourceURL=webpack-internal:///102\n')}]);
//# sourceMappingURL=app.js.map